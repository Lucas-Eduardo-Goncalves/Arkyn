import * as He from "react";
import Ae, { createContext as qe, useContext as Te, memo as Ie, Children as at, isValidElement as ci, cloneElement as pi, useState as k, useRef as it, useEffect as m, PureComponent as Ee, createRef as Rr, useMemo as Zn, useId as w2, forwardRef as Ba, Component as Nu, useCallback as hn, useReducer as C2, useLayoutEffect as x2 } from "react";
import { Info as $_, AlertTriangle as E2, XCircle as W_, CheckCircle2 as H_, MapPinned as L2, Loader2 as Ui, Check as V_, RefreshCw as k2, Heading1 as O2, Heading2 as M2, Quote as S2, Bold as D2, Italic as P2, Underline as T2, Code as _2, AlignLeft as A2, AlignRight as B2, AlignCenter as I2, AlignJustify as j2, Search as R2, ChevronDown as N2, ChevronRight as vv, ChevronLeft as F2, Ellipsis as Cw, X as Z_ } from "lucide-react";
import * as di from "react-dom";
import qa, { createPortal as Nr } from "react-dom";
import { useActionData as v0, useNavigation as q_, useFetchers as G_, useLocation as y0, Link as z2, useNavigate as X_ } from "@remix-run/react";
import { InputMask as U2 } from "@react-input/mask";
import { AnimatePresence as Y_, motion as cu } from "framer-motion";
var Sn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function tf(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var yv = { exports: {} }, ol = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xw;
function $2() {
  if (xw) return ol;
  xw = 1;
  var e = Ae, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, h = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: h, props: p, _owner: o.current };
  }
  return ol.Fragment = n, ol.jsx = s, ol.jsxs = s, ol;
}
var il = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ew;
function W2() {
  return Ew || (Ew = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ae, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), y = Symbol.iterator, f = "@@iterator";
    function g(v) {
      if (v === null || typeof v != "object")
        return null;
      var B = y && v[y] || v[f];
      return typeof B == "function" ? B : null;
    }
    var x = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function L(v) {
      {
        for (var B = arguments.length, G = new Array(B > 1 ? B - 1 : 0), oe = 1; oe < B; oe++)
          G[oe - 1] = arguments[oe];
        E("error", v, G);
      }
    }
    function E(v, B, G) {
      {
        var oe = x.ReactDebugCurrentFrame, me = oe.getStackAddendum();
        me !== "" && (B += "%s", G = G.concat([me]));
        var ye = G.map(function(fe) {
          return String(fe);
        });
        ye.unshift("Warning: " + B), Function.prototype.apply.call(console[v], console, ye);
      }
    }
    var T = !1, b = !1, C = !1, M = !1, S = !1, F;
    F = Symbol.for("react.module.reference");
    function D(v) {
      return !!(typeof v == "string" || typeof v == "function" || v === r || v === i || S || v === o || v === u || v === c || M || v === h || T || b || C || typeof v == "object" && v !== null && (v.$$typeof === d || v.$$typeof === p || v.$$typeof === s || v.$$typeof === a || v.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      v.$$typeof === F || v.getModuleId !== void 0));
    }
    function Z(v, B, G) {
      var oe = v.displayName;
      if (oe)
        return oe;
      var me = B.displayName || B.name || "";
      return me !== "" ? G + "(" + me + ")" : G;
    }
    function U(v) {
      return v.displayName || "Context";
    }
    function $(v) {
      if (v == null)
        return null;
      if (typeof v.tag == "number" && L("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof v == "function")
        return v.displayName || v.name || null;
      if (typeof v == "string")
        return v;
      switch (v) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof v == "object")
        switch (v.$$typeof) {
          case a:
            var B = v;
            return U(B) + ".Consumer";
          case s:
            var G = v;
            return U(G._context) + ".Provider";
          case l:
            return Z(v, v.render, "ForwardRef");
          case p:
            var oe = v.displayName || null;
            return oe !== null ? oe : $(v.type) || "Memo";
          case d: {
            var me = v, ye = me._payload, fe = me._init;
            try {
              return $(fe(ye));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var N = Object.assign, V = 0, J, j, K, te, O, P, H;
    function I() {
    }
    I.__reactDisabledLog = !0;
    function W() {
      {
        if (V === 0) {
          J = console.log, j = console.info, K = console.warn, te = console.error, O = console.group, P = console.groupCollapsed, H = console.groupEnd;
          var v = {
            configurable: !0,
            enumerable: !0,
            value: I,
            writable: !0
          };
          Object.defineProperties(console, {
            info: v,
            log: v,
            warn: v,
            error: v,
            group: v,
            groupCollapsed: v,
            groupEnd: v
          });
        }
        V++;
      }
    }
    function X() {
      {
        if (V--, V === 0) {
          var v = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: N({}, v, {
              value: J
            }),
            info: N({}, v, {
              value: j
            }),
            warn: N({}, v, {
              value: K
            }),
            error: N({}, v, {
              value: te
            }),
            group: N({}, v, {
              value: O
            }),
            groupCollapsed: N({}, v, {
              value: P
            }),
            groupEnd: N({}, v, {
              value: H
            })
          });
        }
        V < 0 && L("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var w = x.ReactCurrentDispatcher, R;
    function z(v, B, G) {
      {
        if (R === void 0)
          try {
            throw Error();
          } catch (me) {
            var oe = me.stack.trim().match(/\n( *(at )?)/);
            R = oe && oe[1] || "";
          }
        return `
` + R + v;
      }
    }
    var _ = !1, Y;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      Y = new Q();
    }
    function A(v, B) {
      if (!v || _)
        return "";
      {
        var G = Y.get(v);
        if (G !== void 0)
          return G;
      }
      var oe;
      _ = !0;
      var me = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ye;
      ye = w.current, w.current = null, W();
      try {
        if (B) {
          var fe = function() {
            throw Error();
          };
          if (Object.defineProperty(fe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fe, []);
            } catch (Pe) {
              oe = Pe;
            }
            Reflect.construct(v, [], fe);
          } else {
            try {
              fe.call();
            } catch (Pe) {
              oe = Pe;
            }
            v.call(fe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Pe) {
            oe = Pe;
          }
          v();
        }
      } catch (Pe) {
        if (Pe && oe && typeof Pe.stack == "string") {
          for (var pe = Pe.stack.split(`
`), De = oe.stack.split(`
`), Le = pe.length - 1, Oe = De.length - 1; Le >= 1 && Oe >= 0 && pe[Le] !== De[Oe]; )
            Oe--;
          for (; Le >= 1 && Oe >= 0; Le--, Oe--)
            if (pe[Le] !== De[Oe]) {
              if (Le !== 1 || Oe !== 1)
                do
                  if (Le--, Oe--, Oe < 0 || pe[Le] !== De[Oe]) {
                    var ze = `
` + pe[Le].replace(" at new ", " at ");
                    return v.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", v.displayName)), typeof v == "function" && Y.set(v, ze), ze;
                  }
                while (Le >= 1 && Oe >= 0);
              break;
            }
        }
      } finally {
        _ = !1, w.current = ye, X(), Error.prepareStackTrace = me;
      }
      var nt = v ? v.displayName || v.name : "", rt = nt ? z(nt) : "";
      return typeof v == "function" && Y.set(v, rt), rt;
    }
    function ae(v, B, G) {
      return A(v, !1);
    }
    function ce(v) {
      var B = v.prototype;
      return !!(B && B.isReactComponent);
    }
    function ue(v, B, G) {
      if (v == null)
        return "";
      if (typeof v == "function")
        return A(v, ce(v));
      if (typeof v == "string")
        return z(v);
      switch (v) {
        case u:
          return z("Suspense");
        case c:
          return z("SuspenseList");
      }
      if (typeof v == "object")
        switch (v.$$typeof) {
          case l:
            return ae(v.render);
          case p:
            return ue(v.type, B, G);
          case d: {
            var oe = v, me = oe._payload, ye = oe._init;
            try {
              return ue(ye(me), B, G);
            } catch {
            }
          }
        }
      return "";
    }
    var de = Object.prototype.hasOwnProperty, be = {}, ve = x.ReactDebugCurrentFrame;
    function ge(v) {
      if (v) {
        var B = v._owner, G = ue(v.type, v._source, B ? B.type : null);
        ve.setExtraStackFrame(G);
      } else
        ve.setExtraStackFrame(null);
    }
    function se(v, B, G, oe, me) {
      {
        var ye = Function.call.bind(de);
        for (var fe in v)
          if (ye(v, fe)) {
            var pe = void 0;
            try {
              if (typeof v[fe] != "function") {
                var De = Error((oe || "React class") + ": " + G + " type `" + fe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof v[fe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw De.name = "Invariant Violation", De;
              }
              pe = v[fe](B, fe, oe, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Le) {
              pe = Le;
            }
            pe && !(pe instanceof Error) && (ge(me), L("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", oe || "React class", G, fe, typeof pe), ge(null)), pe instanceof Error && !(pe.message in be) && (be[pe.message] = !0, ge(me), L("Failed %s type: %s", G, pe.message), ge(null));
          }
      }
    }
    var xe = Array.isArray;
    function ne(v) {
      return xe(v);
    }
    function Me(v) {
      {
        var B = typeof Symbol == "function" && Symbol.toStringTag, G = B && v[Symbol.toStringTag] || v.constructor.name || "Object";
        return G;
      }
    }
    function ee(v) {
      try {
        return Ce(v), !1;
      } catch {
        return !0;
      }
    }
    function Ce(v) {
      return "" + v;
    }
    function Be(v) {
      if (ee(v))
        return L("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Me(v)), Ce(v);
    }
    var _e = x.ReactCurrentOwner, $e = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, he, Ge, We;
    We = {};
    function Ut(v) {
      if (de.call(v, "ref")) {
        var B = Object.getOwnPropertyDescriptor(v, "ref").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return v.ref !== void 0;
    }
    function ot(v) {
      if (de.call(v, "key")) {
        var B = Object.getOwnPropertyDescriptor(v, "key").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return v.key !== void 0;
    }
    function st(v, B) {
      if (typeof v.ref == "string" && _e.current && B && _e.current.stateNode !== B) {
        var G = $(_e.current.type);
        We[G] || (L('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(_e.current.type), v.ref), We[G] = !0);
      }
    }
    function Zt(v, B) {
      {
        var G = function() {
          he || (he = !0, L("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(v, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function qt(v, B) {
      {
        var G = function() {
          Ge || (Ge = !0, L("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(v, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Gt = function(v, B, G, oe, me, ye, fe) {
      var pe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: v,
        key: B,
        ref: G,
        props: fe,
        // Record the component responsible for creating this element.
        _owner: ye
      };
      return pe._store = {}, Object.defineProperty(pe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(pe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: oe
      }), Object.defineProperty(pe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: me
      }), Object.freeze && (Object.freeze(pe.props), Object.freeze(pe)), pe;
    };
    function Xt(v, B, G, oe, me) {
      {
        var ye, fe = {}, pe = null, De = null;
        G !== void 0 && (Be(G), pe = "" + G), ot(B) && (Be(B.key), pe = "" + B.key), Ut(B) && (De = B.ref, st(B, me));
        for (ye in B)
          de.call(B, ye) && !$e.hasOwnProperty(ye) && (fe[ye] = B[ye]);
        if (v && v.defaultProps) {
          var Le = v.defaultProps;
          for (ye in Le)
            fe[ye] === void 0 && (fe[ye] = Le[ye]);
        }
        if (pe || De) {
          var Oe = typeof v == "function" ? v.displayName || v.name || "Unknown" : v;
          pe && Zt(fe, Oe), De && qt(fe, Oe);
        }
        return Gt(v, pe, De, me, oe, _e.current, fe);
      }
    }
    var et = x.ReactCurrentOwner, bt = x.ReactDebugCurrentFrame;
    function tt(v) {
      if (v) {
        var B = v._owner, G = ue(v.type, v._source, B ? B.type : null);
        bt.setExtraStackFrame(G);
      } else
        bt.setExtraStackFrame(null);
    }
    var ut;
    ut = !1;
    function Yt(v) {
      return typeof v == "object" && v !== null && v.$$typeof === t;
    }
    function gn() {
      {
        if (et.current) {
          var v = $(et.current.type);
          if (v)
            return `

Check the render method of \`` + v + "`.";
        }
        return "";
      }
    }
    function Jt(v) {
      {
        if (v !== void 0) {
          var B = v.fileName.replace(/^.*[\\\/]/, ""), G = v.lineNumber;
          return `

Check your code at ` + B + ":" + G + ".";
        }
        return "";
      }
    }
    var mn = {};
    function qn(v) {
      {
        var B = gn();
        if (!B) {
          var G = typeof v == "string" ? v : v.displayName || v.name;
          G && (B = `

Check the top-level render call using <` + G + ">.");
        }
        return B;
      }
    }
    function wt(v, B) {
      {
        if (!v._store || v._store.validated || v.key != null)
          return;
        v._store.validated = !0;
        var G = qn(B);
        if (mn[G])
          return;
        mn[G] = !0;
        var oe = "";
        v && v._owner && v._owner !== et.current && (oe = " It was passed a child from " + $(v._owner.type) + "."), tt(v), L('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, oe), tt(null);
      }
    }
    function vn(v, B) {
      {
        if (typeof v != "object")
          return;
        if (ne(v))
          for (var G = 0; G < v.length; G++) {
            var oe = v[G];
            Yt(oe) && wt(oe, B);
          }
        else if (Yt(v))
          v._store && (v._store.validated = !0);
        else if (v) {
          var me = g(v);
          if (typeof me == "function" && me !== v.entries)
            for (var ye = me.call(v), fe; !(fe = ye.next()).done; )
              Yt(fe.value) && wt(fe.value, B);
        }
      }
    }
    function Gn(v) {
      {
        var B = v.type;
        if (B == null || typeof B == "string")
          return;
        var G;
        if (typeof B == "function")
          G = B.propTypes;
        else if (typeof B == "object" && (B.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        B.$$typeof === p))
          G = B.propTypes;
        else
          return;
        if (G) {
          var oe = $(B);
          se(G, v.props, "prop", oe, v);
        } else if (B.PropTypes !== void 0 && !ut) {
          ut = !0;
          var me = $(B);
          L("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", me || "Unknown");
        }
        typeof B.getDefaultProps == "function" && !B.getDefaultProps.isReactClassApproved && L("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Kt(v) {
      {
        for (var B = Object.keys(v.props), G = 0; G < B.length; G++) {
          var oe = B[G];
          if (oe !== "children" && oe !== "key") {
            tt(v), L("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", oe), tt(null);
            break;
          }
        }
        v.ref !== null && (tt(v), L("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var yn = {};
    function bn(v, B, G, oe, me, ye) {
      {
        var fe = D(v);
        if (!fe) {
          var pe = "";
          (v === void 0 || typeof v == "object" && v !== null && Object.keys(v).length === 0) && (pe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var De = Jt(me);
          De ? pe += De : pe += gn();
          var Le;
          v === null ? Le = "null" : ne(v) ? Le = "array" : v !== void 0 && v.$$typeof === t ? (Le = "<" + ($(v.type) || "Unknown") + " />", pe = " Did you accidentally export a JSX literal instead of a component?") : Le = typeof v, L("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Le, pe);
        }
        var Oe = Xt(v, B, G, me, ye);
        if (Oe == null)
          return Oe;
        if (fe) {
          var ze = B.children;
          if (ze !== void 0)
            if (oe)
              if (ne(ze)) {
                for (var nt = 0; nt < ze.length; nt++)
                  vn(ze[nt], v);
                Object.freeze && Object.freeze(ze);
              } else
                L("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              vn(ze, v);
        }
        if (de.call(B, "key")) {
          var rt = $(v), Pe = Object.keys(B).filter(function(bi) {
            return bi !== "key";
          }), ie = Pe.length > 0 ? "{key: someKey, " + Pe.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!yn[rt + ie]) {
            var yi = Pe.length > 0 ? "{" + Pe.join(": ..., ") + ": ...}" : "{}";
            L(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ie, rt, yi, rt), yn[rt + ie] = !0;
          }
        }
        return v === r ? Kt(Oe) : Gn(Oe), Oe;
      }
    }
    function Qt(v, B, G) {
      return bn(v, B, G, !0);
    }
    function Xn(v, B, G) {
      return bn(v, B, G, !1);
    }
    var Yn = Xn, en = Qt;
    il.Fragment = r, il.jsx = Yn, il.jsxs = en;
  }()), il;
}
process.env.NODE_ENV === "production" ? yv.exports = $2() : yv.exports = W2();
var re = yv.exports;
function H2(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ re.jsx("div", { className: r.trim(), ...n });
}
const J_ = qe({});
function V2() {
  return Te(J_);
}
function Lme(e) {
  const { schema: t, children: n, className: r, ...o } = e, a = !((u) => {
    let c = !1;
    const p = (d) => {
      Array.isArray(d) ? d.forEach(p) : d && typeof d == "object" && "type" in d && (d.type === H2 ? c = !0 : d.props && d.props.children && p(d.props.children));
    };
    return p(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${a} ${r}`;
  return /* @__PURE__ */ re.jsx(J_.Provider, { value: e, children: /* @__PURE__ */ re.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function kme(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ re.jsx("div", { className: r.trim(), ...n });
}
function Ome(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ re.jsx("div", { className: r.trim(), ...n });
}
function Mme(e) {
  const { className: t, ...n } = e, { schema: r } = V2(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ re.jsx(H_, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ re.jsx(W_, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ re.jsx(E2, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ re.jsx($_, { className: o, ...n });
  }
}
function dd(e, t) {
  return t ? /* @__PURE__ */ re.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ re.jsx(re.Fragment, {});
}
function K_(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function Z2(e, t, n) {
  return e >= n ? [] : K_(e, e + t);
}
function q2(e, t) {
  return e <= 1 ? [] : K_(e - 1 - t, e - 1);
}
function G2(e, t, n) {
  if (!e) return /* @__PURE__ */ re.jsx(re.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ re.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ re.jsx("p", { className: n, children: /* @__PURE__ */ re.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function Sme(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: s = "",
    children: a,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], p = `arkynBadge ${t} ${n} ${r} ${s}`;
  return /* @__PURE__ */ re.jsxs("div", { className: p.trim(), ...l, children: [
    dd(c, o),
    a,
    dd(c, o)
  ] });
}
function Dme(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ re.jsx("div", { className: r.trim(), ...n });
}
function Pme(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ re.jsx("div", { className: o.trim(), ...r });
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var bv = function(e, t) {
  return bv = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
  }, bv(e, t);
};
function An(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  bv(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Xe = function() {
  return Xe = Object.assign || function(t) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, Xe.apply(this, arguments);
};
function b0(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function X2(e, t, n, r) {
  function o(i) {
    return i instanceof n ? i : new n(function(s) {
      s(i);
    });
  }
  return new (n || (n = Promise))(function(i, s) {
    function a(c) {
      try {
        u(r.next(c));
      } catch (p) {
        s(p);
      }
    }
    function l(c) {
      try {
        u(r.throw(c));
      } catch (p) {
        s(p);
      }
    }
    function u(c) {
      c.done ? i(c.value) : o(c.value).then(a, l);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function Y2(e, t) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, o, i, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(c) {
      return l([u, c]);
    };
  }
  function l(u) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, o && (i = u[0] & 2 ? o.return : u[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, u[1])).done) return i;
      switch (o = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
        case 0:
        case 1:
          i = u;
          break;
        case 4:
          return n.label++, { value: u[1], done: !1 };
        case 5:
          n.label++, o = u[1], u = [0];
          continue;
        case 7:
          u = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            n = 0;
            continue;
          }
          if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
            n.label = u[1];
            break;
          }
          if (u[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = u;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(u);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      u = t.call(e, n);
    } catch (c) {
      u = [6, c], o = 0;
    } finally {
      r = i = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function Q_(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var J2 = process.env.NODE_ENV, K2 = function(e, t, n, r, o, i, s, a) {
  if (J2 !== "production" && t === void 0)
    throw new Error("invariant requires an error message argument");
  if (!e) {
    var l;
    if (t === void 0)
      l = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var u = [n, r, o, i, s, a], c = 0;
      l = new Error(
        t.replace(/%s/g, function() {
          return u[c++];
        })
      ), l.name = "Invariant Violation";
    }
    throw l.framesToPop = 1, l;
  }
}, Q2 = K2, _r = /* @__PURE__ */ Q_(Q2), ht = qe(null);
function ez() {
  _r(!!Te, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Te(ht);
  return _r(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function tz(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function nz(e, t) {
  Object.keys(e).forEach(function(n) {
    return t(e[n], n);
  });
}
function rz(e, t, n, r) {
  var o = {}, i = function(s, a) {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return nz(e, i), o;
}
function oz(e, t, n) {
  var r = tz(n, function(i, s, a) {
    return typeof e[a] == "function" && i.push(google.maps.event.addListener(t, s, e[a])), i;
  }, []);
  return r;
}
function iz(e) {
  google.maps.event.removeListener(e);
}
function jt(e) {
  e === void 0 && (e = []), e.forEach(iz);
}
function Ot(e) {
  var t = e.updaterMap, n = e.eventMap, r = e.prevProps, o = e.nextProps, i = e.instance, s = oz(o, i, n);
  return rz(t, r, o, i), s;
}
var Lw = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, kw = {
  extraMapTypes: function(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center: function(e, t) {
    e.setCenter(t);
  },
  clickableIcons: function(e, t) {
    e.setClickableIcons(t);
  },
  heading: function(e, t) {
    e.setHeading(t);
  },
  mapTypeId: function(e, t) {
    e.setMapTypeId(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  streetView: function(e, t) {
    e.setStreetView(t);
  },
  tilt: function(e, t) {
    e.setTilt(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
function sz(e) {
  var t = e.children, n = e.options, r = e.id, o = e.mapContainerStyle, i = e.mapContainerClassName, s = e.center, a = e.onClick, l = e.onDblClick, u = e.onDrag, c = e.onDragEnd, p = e.onDragStart, d = e.onMouseMove, h = e.onMouseOut, y = e.onMouseOver, f = e.onMouseDown, g = e.onMouseUp, x = e.onRightClick, L = e.onCenterChanged, E = e.onLoad, T = e.onUnmount, b = k(null), C = b[0], M = b[1], S = it(null), F = k(null), D = F[0], Z = F[1], U = k(null), $ = U[0], N = U[1], V = k(null), J = V[0], j = V[1], K = k(null), te = K[0], O = K[1], P = k(null), H = P[0], I = P[1], W = k(null), X = W[0], w = W[1], R = k(null), z = R[0], _ = R[1], Y = k(null), Q = Y[0], A = Y[1], ae = k(null), ce = ae[0], ue = ae[1], de = k(null), be = de[0], ve = de[1], ge = k(null), se = ge[0], xe = ge[1], ne = k(null), Me = ne[0], ee = ne[1];
  return m(function() {
    n && C !== null && C.setOptions(n);
  }, [C, n]), m(function() {
    C !== null && typeof s < "u" && C.setCenter(s);
  }, [C, s]), m(function() {
    C && l && ($ !== null && google.maps.event.removeListener($), N(google.maps.event.addListener(C, "dblclick", l)));
  }, [l]), m(function() {
    C && c && (J !== null && google.maps.event.removeListener(J), j(google.maps.event.addListener(C, "dragend", c)));
  }, [c]), m(function() {
    C && p && (te !== null && google.maps.event.removeListener(te), O(google.maps.event.addListener(C, "dragstart", p)));
  }, [p]), m(function() {
    C && f && (H !== null && google.maps.event.removeListener(H), I(google.maps.event.addListener(C, "mousedown", f)));
  }, [f]), m(function() {
    C && d && (X !== null && google.maps.event.removeListener(X), w(google.maps.event.addListener(C, "mousemove", d)));
  }, [d]), m(function() {
    C && h && (z !== null && google.maps.event.removeListener(z), _(google.maps.event.addListener(C, "mouseout", h)));
  }, [h]), m(function() {
    C && y && (Q !== null && google.maps.event.removeListener(Q), A(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), m(function() {
    C && g && (ce !== null && google.maps.event.removeListener(ce), ue(google.maps.event.addListener(C, "mouseup", g)));
  }, [g]), m(function() {
    C && x && (be !== null && google.maps.event.removeListener(be), ve(google.maps.event.addListener(C, "rightclick", x)));
  }, [x]), m(function() {
    C && a && (se !== null && google.maps.event.removeListener(se), xe(google.maps.event.addListener(C, "click", a)));
  }, [a]), m(function() {
    C && u && (Me !== null && google.maps.event.removeListener(Me), ee(google.maps.event.addListener(C, "drag", u)));
  }, [u]), m(function() {
    C && L && (D !== null && google.maps.event.removeListener(D), Z(google.maps.event.addListener(C, "center_changed", L)));
  }, [a]), m(function() {
    var Ce = S.current === null ? null : new google.maps.Map(S.current, n);
    return M(Ce), Ce !== null && E && E(Ce), function() {
      Ce !== null && T && T(Ce);
    };
  }, []), re.jsx("div", { id: r, ref: S, style: o, className: i, children: re.jsx(ht.Provider, { value: C, children: C !== null ? t : null }) });
}
Ie(sz);
var az = (
  /** @class */
  function(e) {
    An(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.state = {
        map: null
      }, n.registeredEvents = [], n.mapRef = null, n.getInstance = function() {
        return n.mapRef === null ? null : new google.maps.Map(n.mapRef, n.props.options);
      }, n.panTo = function(r) {
        var o = n.getInstance();
        o && o.panTo(r);
      }, n.setMapCallback = function() {
        n.state.map !== null && n.props.onLoad && n.props.onLoad(n.state.map);
      }, n.getRef = function(r) {
        n.mapRef = r;
      }, n;
    }
    return t.prototype.componentDidMount = function() {
      var n = this.getInstance();
      this.registeredEvents = Ot({
        updaterMap: kw,
        eventMap: Lw,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          map: n
        };
      }, this.setMapCallback);
    }, t.prototype.componentDidUpdate = function(n) {
      this.state.map !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
        updaterMap: kw,
        eventMap: Lw,
        prevProps: n,
        nextProps: this.props,
        instance: this.state.map
      }));
    }, t.prototype.componentWillUnmount = function() {
      this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), jt(this.registeredEvents));
    }, t.prototype.render = function() {
      return re.jsx("div", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName, children: re.jsx(ht.Provider, { value: this.state.map, children: this.state.map !== null ? this.props.children : null }) });
    }, t;
  }(Ee)
), ua = typeof document < "u";
function eA(e) {
  var t = e.url, n = e.id, r = e.nonce;
  return ua ? new Promise(function(i, s) {
    var a = document.getElementById(n), l = window;
    if (a) {
      var u = a.getAttribute("data-state");
      if (a.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, p = a.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, a.onerror = function(h) {
          p && p(h), s(h);
        };
        return;
      } else
        a.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(y) {
      d.setAttribute("data-state", "error"), s(y);
    }, l.initMap = function() {
      d.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(d);
  }).catch(function(o) {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function Ow(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function tA() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return Ow(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return Ow(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
function nA(e) {
  var t = e.googleMapsApiKey, n = e.googleMapsClientId, r = e.version, o = r === void 0 ? "weekly" : r, i = e.language, s = e.region, a = e.libraries, l = e.channel, u = e.mapIds, c = e.authReferrerPolicy, p = [];
  return _r(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? p.push("key=".concat(t)) : n && p.push("client=".concat(n)), o && p.push("v=".concat(o)), i && p.push("language=".concat(i)), s && p.push("region=".concat(s)), a && a.length && p.push("libraries=".concat(a.sort().join(","))), l && p.push("channel=".concat(l)), u && u.length && p.push("map_ids=".concat(u.join(","))), c && p.push("auth_referrer_policy=".concat(c)), p.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(p.join("&"));
}
var sl = !1;
function rA() {
  return re.jsx("div", { children: "Loading..." });
}
var wv = {
  id: "script-loader",
  version: "weekly"
}, lz = (
  /** @class */
  function(e) {
    An(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.check = Rr(), n.state = {
        loaded: !1
      }, n.cleanupCallback = function() {
        delete window.google.maps, n.injectScript();
      }, n.isCleaningUp = function() {
        return X2(n, void 0, void 0, function() {
          function r(o) {
            if (!sl)
              o();
            else if (ua)
              var i = window.setInterval(function() {
                sl || (window.clearInterval(i), o());
              }, 1);
          }
          return Y2(this, function(o) {
            return [2, new Promise(r)];
          });
        });
      }, n.cleanup = function() {
        sl = !0;
        var r = document.getElementById(n.props.id);
        r && r.parentNode && r.parentNode.removeChild(r), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(i) {
          return typeof i.src == "string" && i.src.includes("maps.googleapis");
        }).forEach(function(i) {
          i.parentNode && i.parentNode.removeChild(i);
        }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(i) {
          return i.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
        }).forEach(function(i) {
          i.parentNode && i.parentNode.removeChild(i);
        }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(i) {
          return i.innerText !== void 0 && i.innerText.length > 0 && i.innerText.includes(".gm-");
        }).forEach(function(i) {
          i.parentNode && i.parentNode.removeChild(i);
        });
      }, n.injectScript = function() {
        n.props.preventGoogleFontsLoading && tA(), _r(!!n.props.id, 'LoadScript requires "id" prop to be a string: %s', n.props.id);
        var r = {
          id: n.props.id,
          nonce: n.props.nonce,
          url: nA(n.props)
        };
        eA(r).then(function() {
          n.props.onLoad && n.props.onLoad(), n.setState(function() {
            return {
              loaded: !0
            };
          });
        }).catch(function(o) {
          n.props.onError && n.props.onError(o), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(n.props.googleMapsApiKey || "-", ") or Client ID (").concat(n.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
        });
      }, n;
    }
    return t.prototype.componentDidMount = function() {
      if (ua) {
        if (window.google && window.google.maps && !sl) {
          console.error("google api is already presented");
          return;
        }
        this.isCleaningUp().then(this.injectScript).catch(function(r) {
          console.error("Error at injecting script after cleaning up: ", r);
        });
      }
    }, t.prototype.componentDidUpdate = function(n) {
      this.props.libraries !== n.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), ua && n.language !== this.props.language && (this.cleanup(), this.setState(function() {
        return {
          loaded: !1
        };
      }, this.cleanupCallback));
    }, t.prototype.componentWillUnmount = function() {
      var n = this;
      if (ua) {
        this.cleanup();
        var r = function() {
          n.check.current || (delete window.google, sl = !1);
        };
        window.setTimeout(r, 1), this.props.onUnmount && this.props.onUnmount();
      }
    }, t.prototype.render = function() {
      return re.jsxs(re.Fragment, { children: [re.jsx("div", { ref: this.check }), this.state.loaded ? this.props.children : this.props.loadingElement || re.jsx(rA, {})] });
    }, t.defaultProps = wv, t;
  }(Ee)
), Mw;
function uz(e) {
  var t = e.id, n = t === void 0 ? wv.id : t, r = e.version, o = r === void 0 ? wv.version : r, i = e.nonce, s = e.googleMapsApiKey, a = e.googleMapsClientId, l = e.language, u = e.region, c = e.libraries, p = e.preventGoogleFontsLoading, d = e.channel, h = e.mapIds, y = e.authReferrerPolicy, f = it(!1), g = k(!1), x = g[0], L = g[1], E = k(void 0), T = E[0], b = E[1];
  m(function() {
    return f.current = !0, function() {
      f.current = !1;
    };
  }, []), m(function() {
    ua && p && tA();
  }, [p]), m(function() {
    x && _r(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [x]);
  var C = nA({
    version: o,
    googleMapsApiKey: s,
    googleMapsClientId: a,
    language: l,
    region: u,
    libraries: c,
    channel: d,
    mapIds: h,
    authReferrerPolicy: y
  });
  m(function() {
    if (!ua)
      return;
    function F() {
      f.current && (L(!0), Mw = C);
    }
    if (window.google && window.google.maps && Mw === C) {
      F();
      return;
    }
    eA({ id: n, url: C, nonce: i }).then(F).catch(function(Z) {
      f.current && b(Z), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(s || "-", ") or Client ID (").concat(a || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(Z);
    });
  }, [n, C, i]);
  var M = it();
  return m(function() {
    M.current && c !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = c;
  }, [c]), { isLoaded: x, loadError: T, url: C };
}
var cz = re.jsx(rA, {});
function pz(e) {
  var t = e.loadingElement, n = e.onLoad, r = e.onError, o = e.onUnmount, i = e.children, s = b0(e, ["loadingElement", "onLoad", "onError", "onUnmount", "children"]), a = uz(s), l = a.isLoaded, u = a.loadError;
  return m(function() {
    l && typeof n == "function" && n();
  }, [l, n]), m(function() {
    u && typeof r == "function" && r(u);
  }, [u, r]), m(function() {
    return function() {
      o && o();
    };
  }, [o]), l ? i : t || cz;
}
Ie(pz);
var Sw;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Sw || (Sw = {}));
var Dw = {}, Pw = {
  options: function(e, t) {
    e.setOptions(t);
  }
};
function dz(e) {
  var t = e.options, n = e.onLoad, r = e.onUnmount, o = Te(ht), i = k(null), s = i[0], a = i[1];
  return m(function() {
    s !== null && s.setMap(o);
  }, [o]), m(function() {
    t && s !== null && s.setOptions(t);
  }, [s, t]), m(function() {
    var l = new google.maps.TrafficLayer(Xe(Xe({}, t || {}), { map: o }));
    return a(l), n && n(l), function() {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Ie(dz);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      trafficLayer: null
    }, n.setTrafficLayerCallback = function() {
      n.state.trafficLayer !== null && n.props.onLoad && n.props.onLoad(n.state.trafficLayer);
    }, n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TrafficLayer(Xe(Xe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ot({
      updaterMap: Pw,
      eventMap: Dw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        trafficLayer: n
      };
    }, this.setTrafficLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.trafficLayer !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: Pw,
      eventMap: Dw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), jt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ht, t;
})(Ee);
function fz(e) {
  var t = e.onLoad, n = e.onUnmount, r = Te(ht), o = k(null), i = o[0], s = o[1];
  return m(function() {
    i !== null && i.setMap(r);
  }, [r]), m(function() {
    var a = new google.maps.BicyclingLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Ie(fz);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      bicyclingLayer: null
    }, n.setBicyclingLayerCallback = function() {
      n.state.bicyclingLayer !== null && (n.state.bicyclingLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.bicyclingLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.BicyclingLayer();
    this.setState(function() {
      return {
        bicyclingLayer: n
      };
    }, this.setBicyclingLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ht, t;
})(Ee);
function hz(e) {
  var t = e.onLoad, n = e.onUnmount, r = Te(ht), o = k(null), i = o[0], s = o[1];
  return m(function() {
    i !== null && i.setMap(r);
  }, [r]), m(function() {
    var a = new google.maps.TransitLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      i !== null && (n && n(i), i.setMap(null));
    };
  }, []), null;
}
Ie(hz);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      transitLayer: null
    }, n.setTransitLayerCallback = function() {
      n.state.transitLayer !== null && (n.state.transitLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.transitLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: n
      };
    }, this.setTransitLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ht, t;
})(Ee);
var Tw = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, _w = {
  drawingMode: function(e, t) {
    e.setDrawingMode(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function gz(e) {
  var t = e.options, n = e.drawingMode, r = e.onCircleComplete, o = e.onMarkerComplete, i = e.onOverlayComplete, s = e.onPolygonComplete, a = e.onPolylineComplete, l = e.onRectangleComplete, u = e.onLoad, c = e.onUnmount, p = Te(ht), d = k(null), h = d[0], y = d[1], f = k(null), g = f[0], x = f[1], L = k(null), E = L[0], T = L[1], b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1];
  return m(function() {
    h !== null && h.setMap(p);
  }, [p]), m(function() {
    t && h !== null && h.setOptions(t);
  }, [h, t]), m(function() {
    h !== null && h.setDrawingMode(n ?? null);
  }, [h, n]), m(function() {
    h && r && (g !== null && google.maps.event.removeListener(g), x(google.maps.event.addListener(h, "circlecomplete", r)));
  }, [h, r]), m(function() {
    h && o && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(h, "markercomplete", o)));
  }, [h, o]), m(function() {
    h && i && (C !== null && google.maps.event.removeListener(C), M(google.maps.event.addListener(h, "overlaycomplete", i)));
  }, [h, i]), m(function() {
    h && s && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(h, "polygoncomplete", s)));
  }, [h, s]), m(function() {
    h && a && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(h, "polylinecomplete", a)));
  }, [h, a]), m(function() {
    h && l && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(h, "rectanglecomplete", l)));
  }, [h, l]), m(function() {
    _r(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var j = new google.maps.drawing.DrawingManager(Xe(Xe({}, t || {}), { map: p }));
    return n && j.setDrawingMode(n), r && x(google.maps.event.addListener(j, "circlecomplete", r)), o && T(google.maps.event.addListener(j, "markercomplete", o)), i && M(google.maps.event.addListener(j, "overlaycomplete", i)), s && D(google.maps.event.addListener(j, "polygoncomplete", s)), a && $(google.maps.event.addListener(j, "polylinecomplete", a)), l && J(google.maps.event.addListener(j, "rectanglecomplete", l)), y(j), u && u(j), function() {
      h !== null && (g && google.maps.event.removeListener(g), E && google.maps.event.removeListener(E), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), U && google.maps.event.removeListener(U), V && google.maps.event.removeListener(V), c && c(h), h.setMap(null));
    };
  }, []), null;
}
Ie(gz);
(function(e) {
  An(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    return r.registeredEvents = [], r.state = {
      drawingManager: null
    }, r.setDrawingManagerCallback = function() {
      r.state.drawingManager !== null && r.props.onLoad && r.props.onLoad(r.state.drawingManager);
    }, _r(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing), r;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.drawing.DrawingManager(Xe(Xe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ot({
      updaterMap: _w,
      eventMap: Tw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        drawingManager: n
      };
    }, this.setDrawingManagerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.drawingManager !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: _w,
      eventMap: Tw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), jt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ht, t;
})(Ee);
var Aw = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, Bw = {
  animation: function(e, t) {
    e.setAnimation(t);
  },
  clickable: function(e, t) {
    e.setClickable(t);
  },
  cursor: function(e, t) {
    e.setCursor(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  icon: function(e, t) {
    e.setIcon(t);
  },
  label: function(e, t) {
    e.setLabel(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  opacity: function(e, t) {
    e.setOpacity(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  shape: function(e, t) {
    e.setShape(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, fd = {};
function mz(e) {
  var t = e.position, n = e.options, r = e.clusterer, o = e.noClustererRedraw, i = e.children, s = e.draggable, a = e.visible, l = e.animation, u = e.clickable, c = e.cursor, p = e.icon, d = e.label, h = e.opacity, y = e.shape, f = e.title, g = e.zIndex, x = e.onClick, L = e.onDblClick, E = e.onDrag, T = e.onDragEnd, b = e.onDragStart, C = e.onMouseOut, M = e.onMouseOver, S = e.onMouseUp, F = e.onMouseDown, D = e.onRightClick, Z = e.onClickableChanged, U = e.onCursorChanged, $ = e.onAnimationChanged, N = e.onDraggableChanged, V = e.onFlatChanged, J = e.onIconChanged, j = e.onPositionChanged, K = e.onShapeChanged, te = e.onTitleChanged, O = e.onVisibleChanged, P = e.onZindexChanged, H = e.onLoad, I = e.onUnmount, W = Te(ht), X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1], se = k(null), xe = se[0], ne = se[1], Me = k(null), ee = Me[0], Ce = Me[1], Be = k(null), _e = Be[0], $e = Be[1], he = k(null), Ge = he[0], We = he[1], Ut = k(null), ot = Ut[0], st = Ut[1], Zt = k(null), qt = Zt[0], Gt = Zt[1], Xt = k(null), et = Xt[0], bt = Xt[1], tt = k(null), ut = tt[0], Yt = tt[1], gn = k(null), Jt = gn[0], mn = gn[1], qn = k(null), wt = qn[0], vn = qn[1], Gn = k(null), Kt = Gn[0], yn = Gn[1], bn = k(null), Qt = bn[0], Xn = bn[1], Yn = k(null), en = Yn[0], v = Yn[1], B = k(null), G = B[0], oe = B[1], me = k(null), ye = me[0], fe = me[1], pe = k(null), De = pe[0], Le = pe[1], Oe = k(null), ze = Oe[0], nt = Oe[1];
  m(function() {
    w !== null && w.setMap(W);
  }, [W]), m(function() {
    typeof n < "u" && w !== null && w.setOptions(n);
  }, [w, n]), m(function() {
    typeof s < "u" && w !== null && w.setDraggable(s);
  }, [w, s]), m(function() {
    t && w !== null && w.setPosition(t);
  }, [w, t]), m(function() {
    typeof a < "u" && w !== null && w.setVisible(a);
  }, [w, a]), m(function() {
    w == null || w.setAnimation(l);
  }, [w, l]), m(function() {
    w && u !== void 0 && w.setClickable(u);
  }, [w, u]), m(function() {
    w && c !== void 0 && w.setCursor(c);
  }, [w, c]), m(function() {
    w && p !== void 0 && w.setIcon(p);
  }, [w, p]), m(function() {
    w && d !== void 0 && w.setLabel(d);
  }, [w, d]), m(function() {
    w && h !== void 0 && w.setOpacity(h);
  }, [w, h]), m(function() {
    w && y !== void 0 && w.setShape(y);
  }, [w, y]), m(function() {
    w && f !== void 0 && w.setTitle(f);
  }, [w, f]), m(function() {
    w && g !== void 0 && w.setZIndex(g);
  }, [w, g]), m(function() {
    w && L && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(w, "dblclick", L)));
  }, [L]), m(function() {
    w && T && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(w, "dragend", T)));
  }, [T]), m(function() {
    w && b && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(w, "dragstart", b)));
  }, [b]), m(function() {
    w && F && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(w, "mousedown", F)));
  }, [F]), m(function() {
    w && C && (xe !== null && google.maps.event.removeListener(xe), ne(google.maps.event.addListener(w, "mouseout", C)));
  }, [C]), m(function() {
    w && M && (ee !== null && google.maps.event.removeListener(ee), Ce(google.maps.event.addListener(w, "mouseover", M)));
  }, [M]), m(function() {
    w && S && (_e !== null && google.maps.event.removeListener(_e), $e(google.maps.event.addListener(w, "mouseup", S)));
  }, [S]), m(function() {
    w && D && (Ge !== null && google.maps.event.removeListener(Ge), We(google.maps.event.addListener(w, "rightclick", D)));
  }, [D]), m(function() {
    w && x && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(w, "click", x)));
  }, [x]), m(function() {
    w && E && (qt !== null && google.maps.event.removeListener(qt), Gt(google.maps.event.addListener(w, "drag", E)));
  }, [E]), m(function() {
    w && Z && (et !== null && google.maps.event.removeListener(et), bt(google.maps.event.addListener(w, "clickable_changed", Z)));
  }, [Z]), m(function() {
    w && U && (ut !== null && google.maps.event.removeListener(ut), Yt(google.maps.event.addListener(w, "cursor_changed", U)));
  }, [U]), m(function() {
    w && $ && (Jt !== null && google.maps.event.removeListener(Jt), mn(google.maps.event.addListener(w, "animation_changed", $)));
  }, [$]), m(function() {
    w && N && (wt !== null && google.maps.event.removeListener(wt), vn(google.maps.event.addListener(w, "draggable_changed", N)));
  }, [N]), m(function() {
    w && V && (Kt !== null && google.maps.event.removeListener(Kt), yn(google.maps.event.addListener(w, "flat_changed", V)));
  }, [V]), m(function() {
    w && J && (Qt !== null && google.maps.event.removeListener(Qt), Xn(google.maps.event.addListener(w, "icon_changed", J)));
  }, [J]), m(function() {
    w && j && (en !== null && google.maps.event.removeListener(en), v(google.maps.event.addListener(w, "position_changed", j)));
  }, [j]), m(function() {
    w && K && (G !== null && google.maps.event.removeListener(G), oe(google.maps.event.addListener(w, "shape_changed", K)));
  }, [K]), m(function() {
    w && te && (ye !== null && google.maps.event.removeListener(ye), fe(google.maps.event.addListener(w, "title_changed", te)));
  }, [te]), m(function() {
    w && O && (De !== null && google.maps.event.removeListener(De), Le(google.maps.event.addListener(w, "visible_changed", O)));
  }, [O]), m(function() {
    w && P && (ze !== null && google.maps.event.removeListener(ze), nt(google.maps.event.addListener(w, "zindex_changed", P)));
  }, [P]), m(function() {
    var Pe = Xe(Xe(Xe({}, n || fd), r ? fd : { map: W }), { position: t }), ie = new google.maps.Marker(Pe);
    return r ? r.addMarker(ie, !!o) : ie.setMap(W), t && ie.setPosition(t), typeof a < "u" && ie.setVisible(a), typeof s < "u" && ie.setDraggable(s), typeof u < "u" && ie.setClickable(u), typeof c == "string" && ie.setCursor(c), p && ie.setIcon(p), typeof d < "u" && ie.setLabel(d), typeof h < "u" && ie.setOpacity(h), y && ie.setShape(y), typeof f == "string" && ie.setTitle(f), typeof g == "number" && ie.setZIndex(g), L && Y(google.maps.event.addListener(ie, "dblclick", L)), T && ae(google.maps.event.addListener(ie, "dragend", T)), b && de(google.maps.event.addListener(ie, "dragstart", b)), F && ge(google.maps.event.addListener(ie, "mousedown", F)), C && ne(google.maps.event.addListener(ie, "mouseout", C)), M && Ce(google.maps.event.addListener(ie, "mouseover", M)), S && $e(google.maps.event.addListener(ie, "mouseup", S)), D && We(google.maps.event.addListener(ie, "rightclick", D)), x && st(google.maps.event.addListener(ie, "click", x)), E && Gt(google.maps.event.addListener(ie, "drag", E)), Z && bt(google.maps.event.addListener(ie, "clickable_changed", Z)), U && Yt(google.maps.event.addListener(ie, "cursor_changed", U)), $ && mn(google.maps.event.addListener(ie, "animation_changed", $)), N && vn(google.maps.event.addListener(ie, "draggable_changed", N)), V && yn(google.maps.event.addListener(ie, "flat_changed", V)), J && Xn(google.maps.event.addListener(ie, "icon_changed", J)), j && v(google.maps.event.addListener(ie, "position_changed", j)), K && oe(google.maps.event.addListener(ie, "shape_changed", K)), te && fe(google.maps.event.addListener(ie, "title_changed", te)), O && Le(google.maps.event.addListener(ie, "visible_changed", O)), P && nt(google.maps.event.addListener(ie, "zindex_changed", P)), R(ie), H && H(ie), function() {
      _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), ve !== null && google.maps.event.removeListener(ve), xe !== null && google.maps.event.removeListener(xe), ee !== null && google.maps.event.removeListener(ee), _e !== null && google.maps.event.removeListener(_e), Ge !== null && google.maps.event.removeListener(Ge), ot !== null && google.maps.event.removeListener(ot), et !== null && google.maps.event.removeListener(et), ut !== null && google.maps.event.removeListener(ut), Jt !== null && google.maps.event.removeListener(Jt), wt !== null && google.maps.event.removeListener(wt), Kt !== null && google.maps.event.removeListener(Kt), Qt !== null && google.maps.event.removeListener(Qt), en !== null && google.maps.event.removeListener(en), ye !== null && google.maps.event.removeListener(ye), De !== null && google.maps.event.removeListener(De), ze !== null && google.maps.event.removeListener(ze), I && I(ie), r ? r.removeMarker(ie, !!o) : ie && ie.setMap(null);
    };
  }, []);
  var rt = Zn(function() {
    return i ? at.map(i, function(Pe) {
      if (!ci(Pe))
        return Pe;
      var ie = Pe;
      return pi(ie, { anchor: w });
    }) : null;
  }, [i, w]);
  return re.jsx(re.Fragment, { children: rt }) || null;
}
Ie(mz);
var vz = (
  /** @class */
  function(e) {
    An(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.registeredEvents = [], n;
    }
    return t.prototype.componentDidMount = function() {
      var n = Xe(Xe(Xe({}, this.props.options || fd), this.props.clusterer ? fd : { map: this.context }), { position: this.props.position });
      this.marker = new google.maps.Marker(n), this.props.clusterer ? this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw) : this.marker.setMap(this.context), this.registeredEvents = Ot({
        updaterMap: Bw,
        eventMap: Aw,
        prevProps: {},
        nextProps: this.props,
        instance: this.marker
      }), this.props.onLoad && this.props.onLoad(this.marker);
    }, t.prototype.componentDidUpdate = function(n) {
      this.marker && (jt(this.registeredEvents), this.registeredEvents = Ot({
        updaterMap: Bw,
        eventMap: Aw,
        prevProps: n,
        nextProps: this.props,
        instance: this.marker
      }));
    }, t.prototype.componentWillUnmount = function() {
      this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), jt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
    }, t.prototype.render = function() {
      var n = this, r = null;
      return this.props.children && (r = at.map(this.props.children, function(o) {
        if (!ci(o))
          return o;
        var i = o;
        return pi(i, { anchor: n.marker });
      })), r || null;
    }, t.contextType = ht, t;
  }(Ee)
), yz = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var h = document.createElement("div");
        h.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (h.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (h.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(h), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), bz = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new yz(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function wz(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Cz = 2e3, xz = 500, Ez = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Lz = "png", kz = [53, 56, 66, 78, 90], Oz = "cluster", oA = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Ez, this.imageExtension = r.imageExtension || Lz, this.imageSizes = r.imageSizes || kz, this.calculator = r.calculator || wz, this.batchSize = r.batchSize || Cz, this.batchSizeIE = r.batchSizeIE || xz, this.clusterClass = r.clusterClass || Oz, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [
        google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged),
        google.maps.event.addListener(t, "idle", this.onIdle)
      ]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new bz(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var h = d[p];
            h.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var s = i;
          this.prototype[s] = o.prototype[s];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), zo = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, tn = {
  averageCenter: function(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE: function(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator: function(e, t) {
    e.setCalculator(t);
  },
  clusterClass: function(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons: function(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize: function(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden: function(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension: function(e, t) {
    e.setImageExtension(t);
  },
  imagePath: function(e, t) {
    e.setImagePath(t);
  },
  imageSizes: function(e, t) {
    e.setImageSizes(t);
  },
  maxZoom: function(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize: function(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles: function(e, t) {
    e.setStyles(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  zoomOnClick: function(e, t) {
    e.setZoomOnClick(t);
  }
}, Mz = {};
function Sz(e) {
  var t = e.children, n = e.options, r = e.averageCenter, o = e.batchSizeIE, i = e.calculator, s = e.clusterClass, a = e.enableRetinaIcons, l = e.gridSize, u = e.ignoreHidden, c = e.imageExtension, p = e.imagePath, d = e.imageSizes, h = e.maxZoom, y = e.minimumClusterSize, f = e.styles, g = e.title, x = e.zoomOnClick, L = e.onClick, E = e.onClusteringBegin, T = e.onClusteringEnd, b = e.onMouseOver, C = e.onMouseOut, M = e.onLoad, S = e.onUnmount, F = k(null), D = F[0], Z = F[1], U = Te(ht), $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1];
  return m(function() {
    D && C && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(D, zo.onMouseOut, C)));
  }, [C]), m(function() {
    D && b && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(D, zo.onMouseOver, b)));
  }, [b]), m(function() {
    D && L && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(D, zo.onClick, L)));
  }, [L]), m(function() {
    D && E && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(D, zo.onClusteringBegin, E)));
  }, [E]), m(function() {
    D && T && (O !== null && google.maps.event.removeListener(O), K(google.maps.event.addListener(D, zo.onClusteringEnd, T)));
  }, [T]), m(function() {
    typeof r < "u" && D !== null && tn.averageCenter(D, r);
  }, [D, r]), m(function() {
    typeof o < "u" && D !== null && tn.batchSizeIE(D, o);
  }, [D, o]), m(function() {
    typeof i < "u" && D !== null && tn.calculator(D, i);
  }, [D, i]), m(function() {
    typeof s < "u" && D !== null && tn.clusterClass(D, s);
  }, [D, s]), m(function() {
    typeof a < "u" && D !== null && tn.enableRetinaIcons(D, a);
  }, [D, a]), m(function() {
    typeof l < "u" && D !== null && tn.gridSize(D, l);
  }, [D, l]), m(function() {
    typeof u < "u" && D !== null && tn.ignoreHidden(D, u);
  }, [D, u]), m(function() {
    typeof c < "u" && D !== null && tn.imageExtension(D, c);
  }, [D, c]), m(function() {
    typeof p < "u" && D !== null && tn.imagePath(D, p);
  }, [D, p]), m(function() {
    typeof d < "u" && D !== null && tn.imageSizes(D, d);
  }, [D, d]), m(function() {
    typeof h < "u" && D !== null && tn.maxZoom(D, h);
  }, [D, h]), m(function() {
    typeof y < "u" && D !== null && tn.minimumClusterSize(D, y);
  }, [D, y]), m(function() {
    typeof f < "u" && D !== null && tn.styles(D, f);
  }, [D, f]), m(function() {
    typeof g < "u" && D !== null && tn.title(D, g);
  }, [D, g]), m(function() {
    typeof x < "u" && D !== null && tn.zoomOnClick(D, x);
  }, [D, x]), m(function() {
    if (U) {
      var z = Xe({}, n || Mz), _ = new oA(U, [], z);
      return r && tn.averageCenter(_, r), o && tn.batchSizeIE(_, o), i && tn.calculator(_, i), s && tn.clusterClass(_, s), a && tn.enableRetinaIcons(_, a), l && tn.gridSize(_, l), u && tn.ignoreHidden(_, u), c && tn.imageExtension(_, c), p && tn.imagePath(_, p), d && tn.imageSizes(_, d), h && tn.maxZoom(_, h), y && tn.minimumClusterSize(_, y), f && tn.styles(_, f), g && tn.title(_, g), x && tn.zoomOnClick(_, x), C && W(google.maps.event.addListener(_, zo.onMouseOut, C)), b && R(google.maps.event.addListener(_, zo.onMouseOver, b)), L && V(google.maps.event.addListener(_, zo.onClick, L)), E && K(google.maps.event.addListener(_, zo.onClusteringBegin, E)), T && P(google.maps.event.addListener(_, zo.onClusteringEnd, T)), Z(_), M && M(_), function() {
        I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), S && S(_);
      };
    }
  }, []), D !== null && t(D) || null;
}
Ie(Sz);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      markerClusterer: null
    }, n.setClustererCallback = function() {
      n.state.markerClusterer !== null && n.props.onLoad && n.props.onLoad(n.state.markerClusterer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context) {
      var n = new oA(this.context, [], this.props.options);
      this.registeredEvents = Ot({
        updaterMap: tn,
        eventMap: zo,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          markerClusterer: n
        };
      }, this.setClustererCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.markerClusterer && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: tn,
      eventMap: zo,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), jt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }, t.prototype.render = function() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }, t.contextType = ht, t;
})(Ee);
function Iw(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var iA = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || Iw(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = [
            "mousedown",
            "mouseover",
            "mouseout",
            "mouseup",
            "click",
            "dblclick",
            "touchstart",
            "touchend",
            "touchmove"
          ], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, Iw));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, h = this.infoBoxClearance.width, y = this.infoBoxClearance.height, f = this.getProjection(), g = f.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + h ? r = g.x + u - h : g.x + p + u + h > a && (r = g.x + p + u + h - a), this.alignBottom ? g.y < -c + y + d ? o = g.y + c - y - d : g.y + c + y > l && (o = g.y + c + y - l) : g.y < -c + y ? o = g.y + c - y : g.y + d + c + y > l && (o = g.y + d + c + y - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = { top: 0, bottom: 0, left: 0, right: 0 };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), jw = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Rw = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, Dz = {};
function Pz(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, h = Te(ht), y = k(null), f = y[0], g = y[1], x = k(null), L = x[0], E = x[1], T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = it(null);
  return m(function() {
    h && f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), m(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), m(function() {
    if (o && f !== null) {
      var j = o instanceof google.maps.LatLng ? o : new google.maps.LatLng(o.lat, o.lng);
      f.setPosition(j);
    }
  }, [o]), m(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), m(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), E(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), m(function() {
    f && a && (b !== null && google.maps.event.removeListener(b), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), m(function() {
    f && l && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), m(function() {
    f && u && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), m(function() {
    f && c && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), m(function() {
    if (h) {
      var j = r || Dz, K = j.position, te = b0(j, ["position"]), O = void 0;
      K && !(K instanceof google.maps.LatLng) && (O = new google.maps.LatLng(K.lat, K.lng));
      var P = new iA(Xe(Xe({}, te), O ? { position: O } : {}));
      J.current = document.createElement("div"), g(P), s && E(google.maps.event.addListener(P, "closeclick", s)), a && C(google.maps.event.addListener(P, "domready", a)), l && F(google.maps.event.addListener(P, "content_changed", l)), u && U(google.maps.event.addListener(P, "position_changed", u)), c && V(google.maps.event.addListener(P, "zindex_changed", c)), P.setContent(J.current), n ? P.open(h, n) : P.getPosition() ? P.open(h) : _r(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(P);
    }
    return function() {
      f !== null && (L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), Z && google.maps.event.removeListener(Z), N && google.maps.event.removeListener(N), d && d(f), f.close());
    };
  }, []), J.current ? Nr(at.only(t), J.current) : null;
}
Ie(Pz);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoBox: null
    }, n.open = function(r, o) {
      o ? n.context !== null && r.open(n.context, o) : r.getPosition() ? n.context !== null && r.open(n.context) : _r(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }, n.setInfoBoxCallback = function() {
      n.state.infoBox !== null && n.containerElement !== null && (n.state.infoBox.setContent(n.containerElement), n.open(n.state.infoBox, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoBox));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.props.options || {}, r = n.position, o = b0(n, ["position"]), i;
    r && !(r instanceof google.maps.LatLng) && (i = new google.maps.LatLng(r.lat, r.lng));
    var s = new iA(Xe(Xe({}, o), i ? { position: i } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Ot({
      updaterMap: Rw,
      eventMap: jw,
      prevProps: {},
      nextProps: this.props,
      instance: s
    }), this.setState({ infoBox: s }, this.setInfoBoxCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = this.state.infoBox;
    r !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: Rw,
      eventMap: jw,
      prevProps: n,
      nextProps: this.props,
      instance: r
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n = this.props.onUnmount, r = this.state.infoBox;
    r !== null && (n && n(r), jt(this.registeredEvents), r.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Nr(at.only(this.props.children), this.containerElement) : null;
  }, t.contextType = ht, t;
})(Ee);
var Tz = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, o, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
    for (o = r; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
    for (o = r; o-- !== 0; ) {
      var s = i[o];
      if (!e(t[s], n[s])) return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
}, Nw = /* @__PURE__ */ Q_(Tz);
const Fw = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], tg = 1, al = 8;
class w0 {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const o = r >> 4;
    if (o !== tg)
      throw new Error(`Got v${o} data when expected v${tg}.`);
    const i = Fw[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new w0(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, o) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = Fw.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, al, t), this.coords = new this.ArrayType(this.data, al + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(al + s + a + l), this.ids = new this.IndexArrayType(this.data, al, t), this.coords = new this.ArrayType(this.data, al + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (tg << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return Cv(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: s, nodeSize: a } = this, l = [0, i.length - 1, 0], u = [];
    for (; l.length; ) {
      const c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (let g = d; g <= p; g++) {
          const x = s[2 * g], L = s[2 * g + 1];
          x >= t && x <= r && L >= n && L <= o && u.push(i[g]);
        }
        continue;
      }
      const h = d + p >> 1, y = s[2 * h], f = s[2 * h + 1];
      y >= t && y <= r && f >= n && f <= o && u.push(i[h]), (c === 0 ? t <= y : n <= f) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= y : o >= f) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: o, coords: i, nodeSize: s } = this, a = [0, o.length - 1, 0], l = [], u = r * r;
    for (; a.length; ) {
      const c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (let g = d; g <= p; g++)
          zw(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      const h = d + p >> 1, y = i[2 * h], f = i[2 * h + 1];
      zw(y, f, t, n) <= u && l.push(o[h]), (c === 0 ? t - r <= y : n - r <= f) && (a.push(d), a.push(h - 1), a.push(1 - c)), (c === 0 ? t + r >= y : n + r >= f) && (a.push(h + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function Cv(e, t, n, r, o, i) {
  if (o - r <= n) return;
  const s = r + o >> 1;
  sA(e, t, s, r, o, i), Cv(e, t, n, r, s - 1, 1 - i), Cv(e, t, n, s + 1, o, 1 - i);
}
function sA(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      const u = o - r + 1, c = n - r + 1, p = Math.log(u), d = 0.5 * Math.exp(2 * p / 3), h = 0.5 * Math.sqrt(p * d * (u - d) / u) * (c - u / 2 < 0 ? -1 : 1), y = Math.max(r, Math.floor(n - c * d / u + h)), f = Math.min(o, Math.floor(n + (u - c) * d / u + h));
      sA(e, t, n, y, f, i);
    }
    const s = t[2 * n + i];
    let a = r, l = o;
    for (ll(e, t, r, n), t[2 * o + i] > s && ll(e, t, r, o); a < l; ) {
      for (ll(e, t, a, l), a++, l--; t[2 * a + i] < s; ) a++;
      for (; t[2 * l + i] > s; ) l--;
    }
    t[2 * r + i] === s ? ll(e, t, r, l) : (l++, ll(e, t, l, o)), l <= n && (r = l + 1), n <= l && (o = l - 1);
  }
}
function ll(e, t, n, r) {
  ng(e, n, r), ng(t, 2 * n, 2 * r), ng(t, 2 * n + 1, 2 * r + 1);
}
function ng(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function zw(e, t, n, r) {
  const o = e - n, i = t - r;
  return o * o + i * i;
}
const _z = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, Uw = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Us = 2, us = 3, rg = 4, os = 5, aA = 6;
class Az {
  constructor(t) {
    this.options = Object.assign(Object.create(_z), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    const { log: n, minZoom: r, maxZoom: o } = this.options;
    n && console.time("total time");
    const i = `prepare ${t.length} points`;
    n && console.time(i), this.points = t;
    const s = [];
    for (let l = 0; l < t.length; l++) {
      const u = t[l];
      if (!u.geometry) continue;
      const [c, p] = u.geometry.coordinates, d = Uw(Cc(c)), h = Uw(xc(p));
      s.push(
        d,
        h,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        l,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && s.push(0);
    }
    let a = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (let l = o; l >= r; l--) {
      const u = +Date.now();
      a = this.trees[l] = this._createTree(this._cluster(a, l)), n && console.log("z%d: %d clusters in %dms", l, a.numItems, +Date.now() - u);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    let r = ((t[0] + 180) % 360 + 360) % 360 - 180;
    const o = Math.max(-90, Math.min(90, t[1]));
    let i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
    const s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      const p = this.getClusters([r, o, 180, s], n), d = this.getClusters([-180, o, i, s], n);
      return p.concat(d);
    }
    const a = this.trees[this._limitZoom(n)], l = a.range(Cc(r), xc(s), Cc(i), xc(o)), u = a.data, c = [];
    for (const p of l) {
      const d = this.stride * p;
      c.push(u[d + os] > 1 ? $w(u, d, this.clusterProps) : this.points[u[d + us]]);
    }
    return c;
  }
  getChildren(t) {
    const n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    const s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    const a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (const d of c) {
      const h = d * this.stride;
      s[h + rg] === t && p.push(s[h + os] > 1 ? $w(s, h, this.clusterProps) : this.points[s[h + us]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    const o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    const o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), { extent: s, radius: a } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(
      o.range((n - l) / i, u, (n + 1 + l) / i, c),
      o.data,
      n,
      r,
      i,
      p
    ), n === 0 && this._addTileFeatures(
      o.range(1 - l / i, u, 1, c),
      o.data,
      i,
      r,
      i,
      p
    ), n === i - 1 && this._addTileFeatures(
      o.range(0, u, l / i, c),
      o.data,
      -1,
      r,
      i,
      p
    ), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    let n = this._getOriginZoom(t) - 1;
    for (; n <= this.options.maxZoom; ) {
      const r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    const s = this.getChildren(n);
    for (const a of s) {
      const l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    const n = new w0(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (const a of t) {
      const l = a * this.stride, u = n[l + os] > 1;
      let c, p, d;
      if (u)
        c = lA(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        const f = this.points[n[l + us]];
        c = f.properties;
        const [g, x] = f.geometry.coordinates;
        p = Cc(g), d = xc(x);
      }
      const h = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (p * i - r)),
          Math.round(this.options.extent * (d * i - o))
        ]],
        tags: c
      };
      let y;
      u || this.options.generateId ? y = n[l + us] : y = this.points[n[l + us]].id, y !== void 0 && (h.id = y), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    const { radius: r, extent: o, reduce: i, minPoints: s } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride;
    for (let p = 0; p < l.length; p += c) {
      if (l[p + Us] <= n) continue;
      l[p + Us] = n;
      const d = l[p], h = l[p + 1], y = t.within(l[p], l[p + 1], a), f = l[p + os];
      let g = f;
      for (const x of y) {
        const L = x * c;
        l[L + Us] > n && (g += l[L + os]);
      }
      if (g > f && g >= s) {
        let x = d * f, L = h * f, E, T = -1;
        const b = ((p / c | 0) << 5) + (n + 1) + this.points.length;
        for (const C of y) {
          const M = C * c;
          if (l[M + Us] <= n) continue;
          l[M + Us] = n;
          const S = l[M + os];
          x += l[M] * S, L += l[M + 1] * S, l[M + rg] = b, i && (E || (E = this._map(l, p, !0), T = this.clusterProps.length, this.clusterProps.push(E)), i(E, this._map(l, M)));
        }
        l[p + rg] = b, u.push(x / g, L / g, 1 / 0, b, -1, g), i && u.push(T);
      } else {
        for (let x = 0; x < c; x++) u.push(l[p + x]);
        if (g > 1)
          for (const x of y) {
            const L = x * c;
            if (!(l[L + Us] <= n)) {
              l[L + Us] = n;
              for (let E = 0; E < c; E++) u.push(l[L + E]);
            }
          }
      }
    }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + os] > 1) {
      const s = this.clusterProps[t[n + aA]];
      return r ? Object.assign({}, s) : s;
    }
    const o = this.points[t[n + us]].properties, i = this.options.map(o);
    return r && i === o ? Object.assign({}, i) : i;
  }
}
function $w(e, t, n) {
  return {
    type: "Feature",
    id: e[t + us],
    properties: lA(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [Bz(e[t]), Iz(e[t + 1])]
    }
  };
}
function lA(e, t, n) {
  const r = e[t + os], o = r >= 1e4 ? `${Math.round(r / 1e3)}k` : r >= 1e3 ? `${Math.round(r / 100) / 10}k` : r, i = e[t + aA], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + us],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Cc(e) {
  return e / 360 + 0.5;
}
function xc(e) {
  const t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Bz(e) {
  return (e - 0.5) * 360;
}
function Iz(e) {
  const t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function jz(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Eo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class xv {
  constructor({ markers: t, position: n }) {
    this.markers = t, n && (n instanceof google.maps.LatLng ? this._position = n : this._position = new google.maps.LatLng(n));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const t = new google.maps.LatLngBounds(this._position, this._position);
    for (const n of this.markers)
      t.extend(Eo.getPosition(n));
    return t;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Eo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Eo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Rz {
  constructor({ maxZoom: t = 16 }) {
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: t }) {
    return Nz(t);
  }
}
const Nz = (e) => e.map((n) => new xv({
  position: Eo.getPosition(n),
  markers: [n]
}));
class Fz extends Rz {
  constructor(t) {
    var { maxZoom: n, radius: r = 60 } = t, o = jz(t, ["maxZoom", "radius"]);
    super({ maxZoom: n }), this.state = { zoom: -1 }, this.superCluster = new Az(Object.assign({ maxZoom: this.maxZoom, radius: r }, o));
  }
  calculate(t) {
    let n = !1;
    const r = { zoom: t.map.getZoom() };
    if (!Nw(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      const o = this.markers.map((i) => {
        const s = Eo.getPosition(i);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [s.lng(), s.lat()]
          },
          properties: { marker: i }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !Nw(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), { clusters: this.clusters, changed: n };
  }
  cluster({ map: t }) {
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t.getZoom())).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [t, n] }, properties: r }) {
    if (r.cluster)
      return new xv({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((i) => i.properties.marker),
        position: { lat: n, lng: t }
      });
    const o = r.marker;
    return new xv({
      markers: [o],
      position: Eo.getPosition(o)
    });
  }
}
class zz {
  constructor(t, n) {
    this.markers = { sum: t.length };
    const r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Uz {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: t, position: n }, r, o) {
    const s = `<svg fill="${t > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>
</svg>`, a = `Cluster of ${t} markers`, l = Number(google.maps.Marker.MAX_ZINDEX) + t;
    if (Eo.isAdvancedMarkerAvailable(o)) {
      const p = new DOMParser().parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      const d = {
        map: o,
        position: n,
        zIndex: l,
        title: a,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    const u = {
      position: n,
      zIndex: l,
      title: a,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(s)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(u);
  }
}
function $z(e, t) {
  for (let n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class C0 {
  constructor() {
    $z(C0, google.maps.OverlayView);
  }
}
var Ul;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Ul || (Ul = {}));
const Wz = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Hz extends C0 {
  constructor({ map: t, markers: n = [], algorithmOptions: r = {}, algorithm: o = new Fz(r), renderer: i = new Uz(), onClusterClick: s = Wz }) {
    super(), this.markers = [...n], this.clusters = [], this.algorithm = o, this.renderer = i, this.onClusterClick = s, t && this.setMap(t);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    const r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Eo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    let r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Ul.CLUSTERING_BEGIN, this);
      const { clusters: n, changed: r } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        const o = /* @__PURE__ */ new Set();
        for (const s of n)
          s.markers.length == 1 && o.add(s.markers[0]);
        const i = [];
        for (const s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Eo.setMap(s.marker, null) : i.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => i.forEach((s) => Eo.setMap(s, null)));
      }
      google.maps.event.trigger(this, Ul.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Eo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    const t = new zz(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Eo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Ul.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Eo.setMap(r.marker, n);
    });
  }
}
function Vz(e) {
  var t = ez(), n = k(null), r = n[0], o = n[1];
  return m(function() {
    if (t && r === null) {
      var i = new Hz(Xe(Xe({}, e), { map: t }));
      o(i);
    }
  }, [t]), r;
}
function Zz(e) {
  var t = e.children, n = e.options, r = Vz(n);
  return r !== null ? t(r) : null;
}
Ie(Zz);
var Ww = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Hw = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
function qz(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, h = Te(ht), y = k(null), f = y[0], g = y[1], x = k(null), L = x[0], E = x[1], T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = it(null);
  return m(function() {
    f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), m(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), m(function() {
    o && f !== null && f.setPosition(o);
  }, [o]), m(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), m(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), E(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), m(function() {
    f && a && (b !== null && google.maps.event.removeListener(b), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), m(function() {
    f && l && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), m(function() {
    f && u && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), m(function() {
    f && c && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), m(function() {
    var j = new google.maps.InfoWindow(Xe({}, r || {}));
    return g(j), J.current = document.createElement("div"), s && E(google.maps.event.addListener(j, "closeclick", s)), a && C(google.maps.event.addListener(j, "domready", a)), l && F(google.maps.event.addListener(j, "content_changed", l)), u && U(google.maps.event.addListener(j, "position_changed", u)), c && V(google.maps.event.addListener(j, "zindex_changed", c)), j.setContent(J.current), o && j.setPosition(o), i && j.setZIndex(i), n ? j.open(h, n) : j.getPosition() ? j.open(h) : _r(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(j), function() {
      L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), Z && google.maps.event.removeListener(Z), N && google.maps.event.removeListener(N), d && d(j), j.close();
    };
  }, []), J.current ? Nr(at.only(t), J.current) : null;
}
Ie(qz);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoWindow: null
    }, n.open = function(r, o) {
      o ? r.open(n.context, o) : r.getPosition() ? r.open(n.context) : _r(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }, n.setInfoWindowCallback = function() {
      n.state.infoWindow !== null && n.containerElement !== null && (n.state.infoWindow.setContent(n.containerElement), n.open(n.state.infoWindow, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoWindow));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.InfoWindow(Xe({}, this.props.options || {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Ot({
      updaterMap: Hw,
      eventMap: Ww,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        infoWindow: n
      };
    }, this.setInfoWindowCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.infoWindow !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: Hw,
      eventMap: Ww,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.infoWindow !== null && (jt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Nr(at.only(this.props.children), this.containerElement) : null;
  }, t.contextType = ht, t;
})(Ee);
var Vw = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Zw = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, Gz = {};
function Xz(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, h = e.onMouseUp, y = e.onRightClick, f = e.onClick, g = e.onDrag, x = e.onLoad, L = e.onUnmount, E = Te(ht), T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1];
  return m(function() {
    b !== null && b.setMap(E);
  }, [E]), m(function() {
    typeof t < "u" && b !== null && b.setOptions(t);
  }, [b, t]), m(function() {
    typeof n < "u" && b !== null && b.setDraggable(n);
  }, [b, n]), m(function() {
    typeof r < "u" && b !== null && b.setEditable(r);
  }, [b, r]), m(function() {
    typeof o < "u" && b !== null && b.setVisible(o);
  }, [b, o]), m(function() {
    typeof i < "u" && b !== null && b.setPath(i);
  }, [b, i]), m(function() {
    b && s && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(b, "dblclick", s)));
  }, [s]), m(function() {
    b && a && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(b, "dragend", a)));
  }, [a]), m(function() {
    b && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(b, "dragstart", l)));
  }, [l]), m(function() {
    b && u && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(b, "mousedown", u)));
  }, [u]), m(function() {
    b && c && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(b, "mousemove", c)));
  }, [c]), m(function() {
    b && p && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(b, "mouseout", p)));
  }, [p]), m(function() {
    b && d && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(b, "mouseover", d)));
  }, [d]), m(function() {
    b && h && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(b, "mouseup", h)));
  }, [h]), m(function() {
    b && y && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(b, "rightclick", y)));
  }, [y]), m(function() {
    b && f && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(b, "click", f)));
  }, [f]), m(function() {
    b && g && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(b, "drag", g)));
  }, [g]), m(function() {
    var se = new google.maps.Polyline(Xe(Xe({}, t || Gz), { map: E }));
    return i && se.setPath(i), typeof o < "u" && se.setVisible(o), typeof r < "u" && se.setEditable(r), typeof n < "u" && se.setDraggable(n), s && F(google.maps.event.addListener(se, "dblclick", s)), a && U(google.maps.event.addListener(se, "dragend", a)), l && V(google.maps.event.addListener(se, "dragstart", l)), u && K(google.maps.event.addListener(se, "mousedown", u)), c && P(google.maps.event.addListener(se, "mousemove", c)), p && W(google.maps.event.addListener(se, "mouseout", p)), d && R(google.maps.event.addListener(se, "mouseover", d)), h && Y(google.maps.event.addListener(se, "mouseup", h)), y && ae(google.maps.event.addListener(se, "rightclick", y)), f && de(google.maps.event.addListener(se, "click", f)), g && ge(google.maps.event.addListener(se, "drag", g)), C(se), x && x(se), function() {
      S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), L && L(se), se.setMap(null);
    };
  }, []), null;
}
Ie(Xz);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polyline: null
    }, n.setPolylineCallback = function() {
      n.state.polyline !== null && n.props.onLoad && n.props.onLoad(n.state.polyline);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polyline(Xe(Xe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ot({
      updaterMap: Zw,
      eventMap: Vw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polyline: n
      };
    }, this.setPolylineCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polyline !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: Zw,
      eventMap: Vw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), jt(this.registeredEvents), this.state.polyline.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ht, t;
})(Ee);
var qw = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Gw = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  paths: function(e, t) {
    e.setPaths(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function Yz(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.paths, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, h = e.onMouseOver, y = e.onMouseUp, f = e.onRightClick, g = e.onClick, x = e.onDrag, L = e.onLoad, E = e.onUnmount, T = e.onEdit, b = Te(ht), C = k(null), M = C[0], S = C[1], F = k(null), D = F[0], Z = F[1], U = k(null), $ = U[0], N = U[1], V = k(null), J = V[0], j = V[1], K = k(null), te = K[0], O = K[1], P = k(null), H = P[0], I = P[1], W = k(null), X = W[0], w = W[1], R = k(null), z = R[0], _ = R[1], Y = k(null), Q = Y[0], A = Y[1], ae = k(null), ce = ae[0], ue = ae[1], de = k(null), be = de[0], ve = de[1], ge = k(null), se = ge[0], xe = ge[1];
  return m(function() {
    M !== null && M.setMap(b);
  }, [b]), m(function() {
    typeof t < "u" && M !== null && M.setOptions(t);
  }, [M, t]), m(function() {
    typeof n < "u" && M !== null && M.setDraggable(n);
  }, [M, n]), m(function() {
    typeof r < "u" && M !== null && M.setEditable(r);
  }, [M, r]), m(function() {
    typeof o < "u" && M !== null && M.setVisible(o);
  }, [M, o]), m(function() {
    typeof i < "u" && M !== null && M.setPath(i);
  }, [M, i]), m(function() {
    typeof s < "u" && M !== null && M.setPaths(s);
  }, [M, s]), m(function() {
    M && a && (D !== null && google.maps.event.removeListener(D), Z(google.maps.event.addListener(M, "dblclick", a)));
  }, [a]), m(function() {
    M && (google.maps.event.addListener(M.getPath(), "insert_at", function() {
      T == null || T(M);
    }), google.maps.event.addListener(M.getPath(), "set_at", function() {
      T == null || T(M);
    }));
  }, [M, T]), m(function() {
    M && l && ($ !== null && google.maps.event.removeListener($), N(google.maps.event.addListener(M, "dragend", l)));
  }, [l]), m(function() {
    M && u && (J !== null && google.maps.event.removeListener(J), j(google.maps.event.addListener(M, "dragstart", u)));
  }, [u]), m(function() {
    M && c && (te !== null && google.maps.event.removeListener(te), O(google.maps.event.addListener(M, "mousedown", c)));
  }, [c]), m(function() {
    M && p && (H !== null && google.maps.event.removeListener(H), I(google.maps.event.addListener(M, "mousemove", p)));
  }, [p]), m(function() {
    M && d && (X !== null && google.maps.event.removeListener(X), w(google.maps.event.addListener(M, "mouseout", d)));
  }, [d]), m(function() {
    M && h && (z !== null && google.maps.event.removeListener(z), _(google.maps.event.addListener(M, "mouseover", h)));
  }, [h]), m(function() {
    M && y && (Q !== null && google.maps.event.removeListener(Q), A(google.maps.event.addListener(M, "mouseup", y)));
  }, [y]), m(function() {
    M && f && (ce !== null && google.maps.event.removeListener(ce), ue(google.maps.event.addListener(M, "rightclick", f)));
  }, [f]), m(function() {
    M && g && (be !== null && google.maps.event.removeListener(be), ve(google.maps.event.addListener(M, "click", g)));
  }, [g]), m(function() {
    M && x && (se !== null && google.maps.event.removeListener(se), xe(google.maps.event.addListener(M, "drag", x)));
  }, [x]), m(function() {
    var ne = new google.maps.Polygon(Xe(Xe({}, t || {}), { map: b }));
    return i && ne.setPath(i), s && ne.setPaths(s), typeof o < "u" && ne.setVisible(o), typeof r < "u" && ne.setEditable(r), typeof n < "u" && ne.setDraggable(n), a && Z(google.maps.event.addListener(ne, "dblclick", a)), l && N(google.maps.event.addListener(ne, "dragend", l)), u && j(google.maps.event.addListener(ne, "dragstart", u)), c && O(google.maps.event.addListener(ne, "mousedown", c)), p && I(google.maps.event.addListener(ne, "mousemove", p)), d && w(google.maps.event.addListener(ne, "mouseout", d)), h && _(google.maps.event.addListener(ne, "mouseover", h)), y && A(google.maps.event.addListener(ne, "mouseup", y)), f && ue(google.maps.event.addListener(ne, "rightclick", f)), g && ve(google.maps.event.addListener(ne, "click", g)), x && xe(google.maps.event.addListener(ne, "drag", x)), S(ne), L && L(ne), function() {
      D !== null && google.maps.event.removeListener(D), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), H !== null && google.maps.event.removeListener(H), X !== null && google.maps.event.removeListener(X), z !== null && google.maps.event.removeListener(z), Q !== null && google.maps.event.removeListener(Q), ce !== null && google.maps.event.removeListener(ce), be !== null && google.maps.event.removeListener(be), E && E(ne), ne.setMap(null);
    };
  }, []), null;
}
Ie(Yz);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polygon: null
    }, n.setPolygonCallback = function() {
      n.state.polygon !== null && n.props.onLoad && n.props.onLoad(n.state.polygon);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polygon(Xe(Xe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ot({
      updaterMap: Gw,
      eventMap: qw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polygon: n
      };
    }, this.setPolygonCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polygon !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: Gw,
      eventMap: qw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polygon
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polygon !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polygon), jt(this.registeredEvents), this.state.polygon && this.state.polygon.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ht, t;
})(Ee);
var Xw = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Yw = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function Jz(e) {
  var t = e.options, n = e.bounds, r = e.draggable, o = e.editable, i = e.visible, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, h = e.onMouseUp, y = e.onRightClick, f = e.onClick, g = e.onDrag, x = e.onBoundsChanged, L = e.onLoad, E = e.onUnmount, T = Te(ht), b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1], j = k(null), K = j[0], te = j[1], O = k(null), P = O[0], H = O[1], I = k(null), W = I[0], X = I[1], w = k(null), R = w[0], z = w[1], _ = k(null), Y = _[0], Q = _[1], A = k(null), ae = A[0], ce = A[1], ue = k(null), de = ue[0], be = ue[1], ve = k(null), ge = ve[0], se = ve[1], xe = k(null), ne = xe[0], Me = xe[1];
  return m(function() {
    C !== null && C.setMap(T);
  }, [T]), m(function() {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), m(function() {
    typeof r < "u" && C !== null && C.setDraggable(r);
  }, [C, r]), m(function() {
    typeof o < "u" && C !== null && C.setEditable(o);
  }, [C, o]), m(function() {
    typeof i < "u" && C !== null && C.setVisible(i);
  }, [C, i]), m(function() {
    typeof n < "u" && C !== null && C.setBounds(n);
  }, [C, n]), m(function() {
    C && s && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), m(function() {
    C && a && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(C, "dragend", a)));
  }, [a]), m(function() {
    C && l && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(C, "dragstart", l)));
  }, [l]), m(function() {
    C && u && (K !== null && google.maps.event.removeListener(K), te(google.maps.event.addListener(C, "mousedown", u)));
  }, [u]), m(function() {
    C && c && (P !== null && google.maps.event.removeListener(P), H(google.maps.event.addListener(C, "mousemove", c)));
  }, [c]), m(function() {
    C && p && (W !== null && google.maps.event.removeListener(W), X(google.maps.event.addListener(C, "mouseout", p)));
  }, [p]), m(function() {
    C && d && (R !== null && google.maps.event.removeListener(R), z(google.maps.event.addListener(C, "mouseover", d)));
  }, [d]), m(function() {
    C && h && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(C, "mouseup", h)));
  }, [h]), m(function() {
    C && y && (ae !== null && google.maps.event.removeListener(ae), ce(google.maps.event.addListener(C, "rightclick", y)));
  }, [y]), m(function() {
    C && f && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(C, "click", f)));
  }, [f]), m(function() {
    C && g && (ge !== null && google.maps.event.removeListener(ge), se(google.maps.event.addListener(C, "drag", g)));
  }, [g]), m(function() {
    C && x && (ne !== null && google.maps.event.removeListener(ne), Me(google.maps.event.addListener(C, "bounds_changed", x)));
  }, [x]), m(function() {
    var ee = new google.maps.Rectangle(Xe(Xe({}, t || {}), { map: T }));
    return typeof i < "u" && ee.setVisible(i), typeof o < "u" && ee.setEditable(o), typeof r < "u" && ee.setDraggable(r), typeof n < "u" && ee.setBounds(n), s && D(google.maps.event.addListener(ee, "dblclick", s)), a && $(google.maps.event.addListener(ee, "dragend", a)), l && J(google.maps.event.addListener(ee, "dragstart", l)), u && te(google.maps.event.addListener(ee, "mousedown", u)), c && H(google.maps.event.addListener(ee, "mousemove", c)), p && X(google.maps.event.addListener(ee, "mouseout", p)), d && z(google.maps.event.addListener(ee, "mouseover", d)), h && Q(google.maps.event.addListener(ee, "mouseup", h)), y && ce(google.maps.event.addListener(ee, "rightclick", y)), f && be(google.maps.event.addListener(ee, "click", f)), g && se(google.maps.event.addListener(ee, "drag", g)), x && Me(google.maps.event.addListener(ee, "bounds_changed", x)), M(ee), L && L(ee), function() {
      F !== null && google.maps.event.removeListener(F), U !== null && google.maps.event.removeListener(U), V !== null && google.maps.event.removeListener(V), K !== null && google.maps.event.removeListener(K), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), R !== null && google.maps.event.removeListener(R), Y !== null && google.maps.event.removeListener(Y), ae !== null && google.maps.event.removeListener(ae), de !== null && google.maps.event.removeListener(de), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), E && E(ee), ee.setMap(null);
    };
  }, []), null;
}
Ie(Jz);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      rectangle: null
    }, n.setRectangleCallback = function() {
      n.state.rectangle !== null && n.props.onLoad && n.props.onLoad(n.state.rectangle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Rectangle(Xe(Xe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ot({
      updaterMap: Yw,
      eventMap: Xw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        rectangle: n
      };
    }, this.setRectangleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.rectangle !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: Yw,
      eventMap: Xw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), jt(this.registeredEvents), this.state.rectangle.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ht, t;
})(Ee);
var Jw = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Kw = {
  center: function(e, t) {
    e.setCenter(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  radius: function(e, t) {
    e.setRadius(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, Kz = {};
function Qz(e) {
  var t = e.options, n = e.center, r = e.radius, o = e.draggable, i = e.editable, s = e.visible, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, h = e.onMouseOver, y = e.onMouseUp, f = e.onRightClick, g = e.onClick, x = e.onDrag, L = e.onCenterChanged, E = e.onRadiusChanged, T = e.onLoad, b = e.onUnmount, C = Te(ht), M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1], se = k(null), xe = se[0], ne = se[1], Me = k(null), ee = Me[0], Ce = Me[1], Be = k(null), _e = Be[0], $e = Be[1];
  return m(function() {
    S !== null && S.setMap(C);
  }, [C]), m(function() {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), m(function() {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), m(function() {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), m(function() {
    typeof s < "u" && S !== null && S.setVisible(s);
  }, [S, s]), m(function() {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), m(function() {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), m(function() {
    S && a && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(S, "dblclick", a)));
  }, [a]), m(function() {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), m(function() {
    S && u && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), m(function() {
    S && c && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), m(function() {
    S && p && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), m(function() {
    S && d && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), m(function() {
    S && h && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(S, "mouseover", h)));
  }, [h]), m(function() {
    S && y && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(S, "mouseup", y)));
  }, [y]), m(function() {
    S && f && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(S, "rightclick", f)));
  }, [f]), m(function() {
    S && g && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(S, "click", g)));
  }, [g]), m(function() {
    S && x && (xe !== null && google.maps.event.removeListener(xe), ne(google.maps.event.addListener(S, "drag", x)));
  }, [x]), m(function() {
    S && L && (ee !== null && google.maps.event.removeListener(ee), Ce(google.maps.event.addListener(S, "center_changed", L)));
  }, [g]), m(function() {
    S && E && (_e !== null && google.maps.event.removeListener(_e), $e(google.maps.event.addListener(S, "radius_changed", E)));
  }, [E]), m(function() {
    var he = new google.maps.Circle(Xe(Xe({}, t || Kz), { map: C }));
    return typeof r == "number" && he.setRadius(r), typeof n < "u" && he.setCenter(n), typeof r == "number" && he.setRadius(r), typeof s < "u" && he.setVisible(s), typeof i < "u" && he.setEditable(i), typeof o < "u" && he.setDraggable(o), a && U(google.maps.event.addListener(he, "dblclick", a)), l && V(google.maps.event.addListener(he, "dragend", l)), u && K(google.maps.event.addListener(he, "dragstart", u)), c && P(google.maps.event.addListener(he, "mousedown", c)), p && W(google.maps.event.addListener(he, "mousemove", p)), d && R(google.maps.event.addListener(he, "mouseout", d)), h && Y(google.maps.event.addListener(he, "mouseover", h)), y && ae(google.maps.event.addListener(he, "mouseup", y)), f && de(google.maps.event.addListener(he, "rightclick", f)), g && ge(google.maps.event.addListener(he, "click", g)), x && ne(google.maps.event.addListener(he, "drag", x)), L && Ce(google.maps.event.addListener(he, "center_changed", L)), E && $e(google.maps.event.addListener(he, "radius_changed", E)), F(he), T && T(he), function() {
      Z !== null && google.maps.event.removeListener(Z), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), ve !== null && google.maps.event.removeListener(ve), ee !== null && google.maps.event.removeListener(ee), _e !== null && google.maps.event.removeListener(_e), b && b(he), he.setMap(null);
    };
  }, []), null;
}
Ie(Qz);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      circle: null
    }, n.setCircleCallback = function() {
      n.state.circle !== null && n.props.onLoad && n.props.onLoad(n.state.circle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Circle(Xe(Xe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ot({
      updaterMap: Kw,
      eventMap: Jw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        circle: n
      };
    }, this.setCircleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.circle !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: Kw,
      eventMap: Jw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n;
    this.state.circle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.circle), jt(this.registeredEvents), (n = this.state.circle) === null || n === void 0 || n.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ht, t;
})(Ee);
var Qw = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, eC = {
  add: function(e, t) {
    e.add(t);
  },
  addgeojson: function(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains: function(e, t) {
    e.contains(t);
  },
  foreach: function(e, t) {
    e.forEach(t);
  },
  loadgeojson: function(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle: function(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove: function(e, t) {
    e.remove(t);
  },
  revertstyle: function(e, t) {
    e.revertStyle(t);
  },
  controlposition: function(e, t) {
    e.setControlPosition(t);
  },
  controls: function(e, t) {
    e.setControls(t);
  },
  drawingmode: function(e, t) {
    e.setDrawingMode(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  style: function(e, t) {
    e.setStyle(t);
  },
  togeojson: function(e, t) {
    e.toGeoJson(t);
  }
};
function eU(e) {
  var t = e.options, n = e.onClick, r = e.onDblClick, o = e.onMouseDown, i = e.onMouseMove, s = e.onMouseOut, a = e.onMouseOver, l = e.onMouseUp, u = e.onRightClick, c = e.onAddFeature, p = e.onRemoveFeature, d = e.onRemoveProperty, h = e.onSetGeometry, y = e.onSetProperty, f = e.onLoad, g = e.onUnmount, x = Te(ht), L = k(null), E = L[0], T = L[1], b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1], j = k(null), K = j[0], te = j[1], O = k(null), P = O[0], H = O[1], I = k(null), W = I[0], X = I[1], w = k(null), R = w[0], z = w[1], _ = k(null), Y = _[0], Q = _[1], A = k(null), ae = A[0], ce = A[1], ue = k(null), de = ue[0], be = ue[1], ve = k(null), ge = ve[0], se = ve[1], xe = k(null), ne = xe[0], Me = xe[1];
  return m(function() {
    E !== null && E.setMap(x);
  }, [x]), m(function() {
    E && r && (C !== null && google.maps.event.removeListener(C), M(google.maps.event.addListener(E, "dblclick", r)));
  }, [r]), m(function() {
    E && o && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(E, "mousedown", o)));
  }, [o]), m(function() {
    E && i && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(E, "mousemove", i)));
  }, [i]), m(function() {
    E && s && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(E, "mouseout", s)));
  }, [s]), m(function() {
    E && a && (K !== null && google.maps.event.removeListener(K), te(google.maps.event.addListener(E, "mouseover", a)));
  }, [a]), m(function() {
    E && l && (P !== null && google.maps.event.removeListener(P), H(google.maps.event.addListener(E, "mouseup", l)));
  }, [l]), m(function() {
    E && u && (W !== null && google.maps.event.removeListener(W), X(google.maps.event.addListener(E, "rightclick", u)));
  }, [u]), m(function() {
    E && n && (R !== null && google.maps.event.removeListener(R), z(google.maps.event.addListener(E, "click", n)));
  }, [n]), m(function() {
    E && c && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(E, "addfeature", c)));
  }, [c]), m(function() {
    E && p && (ae !== null && google.maps.event.removeListener(ae), ce(google.maps.event.addListener(E, "removefeature", p)));
  }, [p]), m(function() {
    E && d && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(E, "removeproperty", d)));
  }, [d]), m(function() {
    E && h && (ge !== null && google.maps.event.removeListener(ge), se(google.maps.event.addListener(E, "setgeometry", h)));
  }, [h]), m(function() {
    E && y && (ne !== null && google.maps.event.removeListener(ne), Me(google.maps.event.addListener(E, "setproperty", y)));
  }, [y]), m(function() {
    if (x !== null) {
      var ee = new google.maps.Data(Xe(Xe({}, t || {}), { map: x }));
      r && M(google.maps.event.addListener(ee, "dblclick", r)), o && D(google.maps.event.addListener(ee, "mousedown", o)), i && $(google.maps.event.addListener(ee, "mousemove", i)), s && J(google.maps.event.addListener(ee, "mouseout", s)), a && te(google.maps.event.addListener(ee, "mouseover", a)), l && H(google.maps.event.addListener(ee, "mouseup", l)), u && X(google.maps.event.addListener(ee, "rightclick", u)), n && z(google.maps.event.addListener(ee, "click", n)), c && Q(google.maps.event.addListener(ee, "addfeature", c)), p && ce(google.maps.event.addListener(ee, "removefeature", p)), d && be(google.maps.event.addListener(ee, "removeproperty", d)), h && se(google.maps.event.addListener(ee, "setgeometry", h)), y && Me(google.maps.event.addListener(ee, "setproperty", y)), T(ee), f && f(ee);
    }
    return function() {
      E && (C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), U !== null && google.maps.event.removeListener(U), V !== null && google.maps.event.removeListener(V), K !== null && google.maps.event.removeListener(K), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), R !== null && google.maps.event.removeListener(R), Y !== null && google.maps.event.removeListener(Y), ae !== null && google.maps.event.removeListener(ae), de !== null && google.maps.event.removeListener(de), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), g && g(E), E.setMap(null));
    };
  }, []), null;
}
Ie(eU);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      data: null
    }, n.setDataCallback = function() {
      n.state.data !== null && n.props.onLoad && n.props.onLoad(n.state.data);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context !== null) {
      var n = new google.maps.Data(Xe(Xe({}, this.props.options || {}), { map: this.context }));
      this.registeredEvents = Ot({
        updaterMap: eC,
        eventMap: Qw,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          data: n
        };
      }, this.setDataCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.data !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: eC,
      eventMap: Qw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.data
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), jt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ht, t;
})(Ee);
var tC = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, nC = {
  options: function(e, t) {
    e.setOptions(t);
  },
  url: function(e, t) {
    e.setUrl(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      kmlLayer: null
    }, n.setKmlLayerCallback = function() {
      n.state.kmlLayer !== null && n.props.onLoad && n.props.onLoad(n.state.kmlLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.KmlLayer(Xe(Xe({}, this.props.options), { map: this.context }));
    this.registeredEvents = Ot({
      updaterMap: nC,
      eventMap: tC,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        kmlLayer: n
      };
    }, this.setKmlLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.kmlLayer !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: nC,
      eventMap: tC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), jt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ht, t;
})(Ee);
function uA(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function tU(e, t) {
  return new t(e.lat, e.lng);
}
function nU(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function rU(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function oU(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function iU(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function sU(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var o = r.x, i = r.y;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function cA(e, t, n, r) {
  return n !== void 0 ? iU(e, t, oU(n, google.maps.LatLngBounds, nU)) : sU(e, t, rU(r, google.maps.LatLng, tU));
}
function aU(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function lU(e, t, n, r, o) {
  var i = (
    /** @class */
    function(s) {
      An(a, s);
      function a(l, u, c, p) {
        var d = s.call(this) || this;
        return d.container = l, d.pane = u, d.position = c, d.bounds = p, d;
      }
      return a.prototype.onAdd = function() {
        var l, u = (l = this.getPanes()) === null || l === void 0 ? void 0 : l[this.pane];
        u == null || u.appendChild(this.container);
      }, a.prototype.draw = function() {
        for (var l = this.getProjection(), u = Xe({}, this.container ? uA(this.container, o) : {
          x: 0,
          y: 0
        }), c = cA(l, u, this.bounds, this.position), p = 0, d = Object.entries(c); p < d.length; p++) {
          var h = d[p], y = h[0], f = h[1];
          this.container.style[y] = f;
        }
      }, a.prototype.onRemove = function() {
        this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
      }, a;
    }(google.maps.OverlayView)
  );
  return new i(e, t, n, r);
}
function rC(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function oC(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function uU(e) {
  var t = e.position, n = e.bounds, r = e.mapPaneName, o = e.zIndex, i = e.onLoad, s = e.onUnmount, a = e.getPixelPositionOffset, l = e.children, u = Te(ht), c = Zn(function() {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Zn(function() {
    return lU(c, r, t, n, a);
  }, [c, r, t, n]);
  return m(function() {
    return i == null || i(p), p == null || p.setMap(u), function() {
      s == null || s(p), p == null || p.setMap(null);
    };
  }, [u, p]), m(function() {
    c.style.zIndex = "".concat(o);
  }, [o, c]), di.createPortal(l, c);
}
Ie(uU);
(function(e) {
  An(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    r.state = {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }, r.updatePane = function() {
      var i = r.props.mapPaneName, s = r.overlayView.getPanes();
      _r(!!i, "OverlayView requires props.mapPaneName but got %s", i), s ? r.setState({
        paneEl: s[i]
      }) : r.setState({
        paneEl: null
      });
    }, r.onAdd = function() {
      var i, s;
      r.updatePane(), (s = (i = r.props).onLoad) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.onPositionElement = function() {
      var i = r.overlayView.getProjection(), s = Xe({ x: 0, y: 0 }, r.containerRef.current ? uA(r.containerRef.current, r.props.getPixelPositionOffset) : {}), a = cA(i, s, r.props.bounds, r.props.position), l = r.state.containerStyle, u = l.left, c = l.top, p = l.width, d = l.height;
      aU(a, { left: u, top: c, width: p, height: d }) || r.setState({
        containerStyle: {
          top: a.top || 0,
          left: a.left || 0,
          width: a.width || 0,
          height: a.height || 0,
          position: "absolute"
        }
      });
    }, r.draw = function() {
      r.onPositionElement();
    }, r.onRemove = function() {
      var i, s;
      r.setState(function() {
        return {
          paneEl: null
        };
      }), (s = (i = r.props).onUnmount) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.containerRef = Rr();
    var o = new google.maps.OverlayView();
    return o.onAdd = r.onAdd, o.draw = r.draw, o.onRemove = r.onRemove, r.overlayView = o, r;
  }
  return t.prototype.componentDidMount = function() {
    this.overlayView.setMap(this.context);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = rC(n.position), o = rC(this.props.position), i = oC(n.bounds), s = oC(this.props.bounds);
    (r !== o || i !== s) && this.overlayView.draw(), n.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }, t.prototype.componentWillUnmount = function() {
    this.overlayView.setMap(null);
  }, t.prototype.render = function() {
    var n = this.state.paneEl;
    return n ? di.createPortal(re.jsx("div", { ref: this.containerRef, style: this.state.containerStyle, children: at.only(this.props.children) }), n) : null;
  }, t.FLOAT_PANE = "floatPane", t.MAP_PANE = "mapPane", t.MARKER_LAYER = "markerLayer", t.OVERLAY_LAYER = "overlayLayer", t.OVERLAY_MOUSE_TARGET = "overlayMouseTarget", t.contextType = ht, t;
})(Ee);
function cU() {
}
var iC = {
  onDblClick: "dblclick",
  onClick: "click"
}, sC = {
  opacity: function(e, t) {
    e.setOpacity(t);
  }
};
function pU(e) {
  var t = e.url, n = e.bounds, r = e.options, o = e.visible, i = Te(ht), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Zn(function() {
    var l = new google.maps.GroundOverlay(t, s, Xe({}, r));
    return l;
  }, []);
  return m(function() {
    a !== null && a.setMap(i);
  }, [i]), m(function() {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), m(function() {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), m(function() {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Ie(pU);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      groundOverlay: null
    }, n.setGroundOverlayCallback = function() {
      n.state.groundOverlay !== null && n.props.onLoad && n.props.onLoad(n.state.groundOverlay);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    _r(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var n = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Xe(Xe({}, this.props.options), { map: this.context }));
    this.registeredEvents = Ot({
      updaterMap: sC,
      eventMap: iC,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        groundOverlay: n
      };
    }, this.setGroundOverlayCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.groundOverlay !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: sC,
      eventMap: iC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.defaultProps = {
    onLoad: cU
  }, t.contextType = ht, t;
})(Ee);
var aC = {}, lC = {
  data: function(e, t) {
    e.setData(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function dU(e) {
  var t = e.data, n = e.onLoad, r = e.onUnmount, o = e.options, i = Te(ht), s = k(null), a = s[0], l = s[1];
  return m(function() {
    google.maps.visualization || _r(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), m(function() {
    _r(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), m(function() {
    a !== null && a.setMap(i);
  }, [i]), m(function() {
    o && a !== null && a.setOptions(o);
  }, [a, o]), m(function() {
    var u = new google.maps.visualization.HeatmapLayer(Xe(Xe({}, o || {}), { data: t, map: i }));
    return l(u), n && n(u), function() {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Ie(dU);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      heatmapLayer: null
    }, n.setHeatmapLayerCallback = function() {
      n.state.heatmapLayer !== null && n.props.onLoad && n.props.onLoad(n.state.heatmapLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    _r(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), _r(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var n = new google.maps.visualization.HeatmapLayer(Xe(Xe({}, this.props.options || {}), { data: this.props.data, map: this.context }));
    this.registeredEvents = Ot({
      updaterMap: lC,
      eventMap: aC,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        heatmapLayer: n
      };
    }, this.setHeatmapLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: lC,
      eventMap: aC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), jt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ht, t;
})(Ee);
var uC = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, cC = {
  register: function(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links: function(e, t) {
    e.setLinks(t);
  },
  motionTracking: function(e, t) {
    e.setMotionTracking(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  pano: function(e, t) {
    e.setPano(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  pov: function(e, t) {
    e.setPov(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      streetViewPanorama: null
    }, n.setStreetViewPanoramaCallback = function() {
      n.state.streetViewPanorama !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewPanorama);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n, r, o = (r = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && r !== void 0 ? r : null;
    this.registeredEvents = Ot({
      updaterMap: cC,
      eventMap: uC,
      prevProps: {},
      nextProps: this.props,
      instance: o
    }), this.setState(function() {
      return {
        streetViewPanorama: o
      };
    }, this.setStreetViewPanoramaCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.streetViewPanorama !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: cC,
      eventMap: uC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), jt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ht, t;
})(Ee);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      streetViewService: null
    }, n.setStreetViewServiceCallback = function() {
      n.state.streetViewService !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: n
      };
    }, this.setStreetViewServiceCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ht, t;
})(Ee);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      directionsService: null
    }, n.setDirectionsServiceCallback = function() {
      n.state.directionsService !== null && n.props.onLoad && n.props.onLoad(n.state.directionsService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    _r(!!this.props.options, "DirectionsService expected options object as parameter, but got %s", this.props.options);
    var n = new google.maps.DirectionsService();
    this.setState(function() {
      return {
        directionsService: n
      };
    }, this.setDirectionsServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.directionsService !== null && this.state.directionsService.route(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsService !== null && this.props.onUnmount && this.props.onUnmount(this.state.directionsService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Ee);
var pC = {
  onDirectionsChanged: "directions_changed"
}, dC = {
  directions: function(e, t) {
    e.setDirections(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  panel: function(e, t) {
    e.setPanel(t);
  },
  routeIndex: function(e, t) {
    e.setRouteIndex(t);
  }
};
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      directionsRenderer: null
    }, n.setDirectionsRendererCallback = function() {
      n.state.directionsRenderer !== null && (n.state.directionsRenderer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.directionsRenderer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Ot({
      updaterMap: dC,
      eventMap: pC,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        directionsRenderer: n
      };
    }, this.setDirectionsRendererCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.directionsRenderer !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: dC,
      eventMap: pC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), jt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }, t.prototype.render = function() {
    return re.jsx(re.Fragment, {});
  }, t.contextType = ht, t;
})(Ee);
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      distanceMatrixService: null
    }, n.setDistanceMatrixServiceCallback = function() {
      n.state.distanceMatrixService !== null && n.props.onLoad && n.props.onLoad(n.state.distanceMatrixService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    _r(!!this.props.options, "DistanceMatrixService expected options object as parameter, but go %s", this.props.options);
    var n = new google.maps.DistanceMatrixService();
    this.setState(function() {
      return {
        distanceMatrixService: n
      };
    }, this.setDistanceMatrixServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.distanceMatrixService !== null && this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.distanceMatrixService !== null && this.props.onUnmount && this.props.onUnmount(this.state.distanceMatrixService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Ee);
var fC = {
  onPlacesChanged: "places_changed"
}, hC = {
  bounds: function(e, t) {
    e.setBounds(t);
  }
}, fU = (
  /** @class */
  function(e) {
    An(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.registeredEvents = [], n.containerElement = Rr(), n.state = {
        searchBox: null
      }, n.setSearchBoxCallback = function() {
        n.state.searchBox !== null && n.props.onLoad && n.props.onLoad(n.state.searchBox);
      }, n;
    }
    return t.prototype.componentDidMount = function() {
      if (_r(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
        var n = this.containerElement.current.querySelector("input");
        if (n !== null) {
          var r = new google.maps.places.SearchBox(n, this.props.options);
          this.registeredEvents = Ot({
            updaterMap: hC,
            eventMap: fC,
            prevProps: {},
            nextProps: this.props,
            instance: r
          }), this.setState(function() {
            return {
              searchBox: r
            };
          }, this.setSearchBoxCallback);
        }
      }
    }, t.prototype.componentDidUpdate = function(n) {
      this.state.searchBox !== null && (jt(this.registeredEvents), this.registeredEvents = Ot({
        updaterMap: hC,
        eventMap: fC,
        prevProps: n,
        nextProps: this.props,
        instance: this.state.searchBox
      }));
    }, t.prototype.componentWillUnmount = function() {
      this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), jt(this.registeredEvents));
    }, t.prototype.render = function() {
      return re.jsx("div", { ref: this.containerElement, children: at.only(this.props.children) });
    }, t.contextType = ht, t;
  }(Ee)
), gC = {
  onPlaceChanged: "place_changed"
}, mC = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  restrictions: function(e, t) {
    e.setComponentRestrictions(t);
  },
  fields: function(e, t) {
    e.setFields(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  types: function(e, t) {
    e.setTypes(t);
  }
};
(function(e) {
  An(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = Rr(), n.state = {
      autocomplete: null
    }, n.setAutocompleteCallback = function() {
      n.state.autocomplete !== null && n.props.onLoad && n.props.onLoad(n.state.autocomplete);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n;
    _r(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var r = (n = this.containerElement.current) === null || n === void 0 ? void 0 : n.querySelector("input");
    if (r) {
      var o = new google.maps.places.Autocomplete(r, this.props.options);
      this.registeredEvents = Ot({
        updaterMap: mC,
        eventMap: gC,
        prevProps: {},
        nextProps: this.props,
        instance: o
      }), this.setState(function() {
        return {
          autocomplete: o
        };
      }, this.setAutocompleteCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    jt(this.registeredEvents), this.registeredEvents = Ot({
      updaterMap: mC,
      eventMap: gC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.autocomplete !== null && jt(this.registeredEvents);
  }, t.prototype.render = function() {
    return re.jsx("div", { ref: this.containerElement, className: this.props.className, children: at.only(this.props.children) });
  }, t.defaultProps = {
    className: ""
  }, t.contextType = ht, t;
})(Ee);
function Tme({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ re.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ re.jsx(
    az,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ re.jsx(vz, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ re.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ re.jsx(L2, {}) });
}
function _me(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ re.jsx("aside", { className: r.trim(), ...n });
}
function Ame(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, s = at.count(r) === 0;
  return /* @__PURE__ */ re.jsx("tbody", { className: i.trim(), ...o, children: s ? /* @__PURE__ */ re.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ re.jsx("td", { colSpan: 100, children: /* @__PURE__ */ re.jsx("div", { children: t }) }) }) : r });
}
function Bme(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ re.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ re.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function Ime(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ re.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ re.jsx("table", { children: t }) });
}
function jme(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ re.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ re.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ re.jsx("tr", { children: /* @__PURE__ */ re.jsx("th", { colSpan: 100, children: /* @__PURE__ */ re.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function Rme(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ re.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ re.jsx("tr", { children: n }),
    /* @__PURE__ */ re.jsx("tr", { className: "spacingRow" })
  ] });
}
function Nme(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: s,
    rightIcon: a,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, h = { xs: 12, sm: 16, md: 20, lg: 24 }[i], g = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ re.jsxs("button", { className: g, disabled: l || t, ...p, children: [
    /* @__PURE__ */ re.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ re.jsx(Ui, { size: h, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ re.jsxs("div", { className: "arkynButtonContent", children: [
      dd(h, s),
      c,
      dd(h, a)
    ] })
  ] });
}
function hU() {
  const e = v0(), t = q_(), n = G_(), [r, o] = k(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function s() {
    r && o(null);
  }
  m(() => {
    var c, p;
    let u = ((p = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : p.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), m(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && s();
  }, [n, t]);
  const a = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(a || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const pA = qe({});
function Fme(e) {
  var p;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = hU(), s = it(null), a = ((p = s.current) == null ? void 0 : p.name) || "", l = (i == null ? void 0 : i[a]) || null, u = w2(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ re.jsx(pA.Provider, { value: { error: l, id: u, inputRef: s }, children: /* @__PURE__ */ re.jsx(
    "section",
    {
      id: r || a || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function Fo() {
  return Te(pA);
}
function zme(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: s = null,
    onCheck: a,
    value: l,
    ...u
  } = e, { id: c, inputRef: p, error: d } = Fo(), h = o || !!d, [y, f] = k(i || !1), g = typeof s == "boolean" ? s : y, E = `arkynCheckbox ${r} ${h ? "errorTrue" : "errorFalse"} ${g ? "checkedTrue" : "checkedFalse"} ${n}`;
  function T() {
    const b = y;
    f(!b), a && a(b ? "" : l || "checked");
  }
  return /* @__PURE__ */ re.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: E,
      onClick: T,
      ...u,
      children: [
        /* @__PURE__ */ re.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: p,
            value: g ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ re.jsx(V_, {})
      ]
    }
  );
}
function Ume(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = Fo();
  return t ? /* @__PURE__ */ re.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ re.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ re.jsx(re.Fragment, {});
}
function $me(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = Fo(), s = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ re.jsx("label", { className: s.trim(), htmlFor: o, ...r });
}
function Es(e, t, n) {
  if (!e) return /* @__PURE__ */ re.jsx(re.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ re.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ re.jsx("p", { className: n, children: /* @__PURE__ */ re.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function x0(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function dA(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function fA(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const E0 = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, hA = x0(E0.CNPJ).length;
function gU(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    defaultValue: d,
    readOnly: h,
    onFocus: y,
    onBlur: f,
    title: g,
    style: x,
    onChange: L,
    ...E
  } = e;
  function T(N) {
    let V = x0(N);
    const J = fA(V);
    if (!(V.length > hA))
      return V = dA(V, E0[J]), V;
  }
  const b = c ? "right" : "left", Z = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || h || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, $ = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: Z,
    prefix: Es(a, $, "prefix"),
    sufix: Es(l, $, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: T(d || ""),
    disabled: p,
    readOnly: h,
    onFocus: y,
    onBlur: f,
    title: g,
    style: x,
    onChange: L,
    loadingPosition: b,
    iconSize: $,
    Spinner: /* @__PURE__ */ re.jsx(Ui, { className: "spinner", size: $, strokeWidth: 2.5 }),
    ...E
  };
}
function mU(e) {
  const [t, n] = k(!1), r = it(null), { inputRef: o, id: i, error: s } = Fo(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: h,
    sufix: y,
    iconSize: f,
    loadingPosition: g,
    isLoading: x,
    LeftIcon: L,
    readOnly: E,
    onFocus: T,
    onBlur: b,
    RightIcon: C,
    Spinner: M,
    onChange: S,
    value: F,
    defaultValue: D,
    ...Z
  } = gU({ ...e, id: i, isError: l }, t), [U, $] = k(D), N = L && !x, V = C && !x, J = g === "left" && x, j = g === "right" && x;
  function K() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function te(H) {
    let I = x0(H.target.value);
    const W = fA(I);
    I.length > hA || (I = dA(I, E0[W]), H.target.value = I, $(I), S && S(H));
  }
  function O(H) {
    n(!0), T && T(H);
  }
  function P(H) {
    n(!1), b && b(H);
  }
  return /* @__PURE__ */ re.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: K,
      className: d,
      children: [
        h,
        J && M,
        N && /* @__PURE__ */ re.jsx(L, { size: f, strokeWidth: 2.5 }),
        /* @__PURE__ */ re.jsx(
          "input",
          {
            disabled: u || x,
            readOnly: E,
            ref: a,
            value: F || U,
            onFocus: O,
            onChange: te,
            onBlur: P,
            ...Z
          }
        ),
        V && /* @__PURE__ */ re.jsx(C, { size: f, strokeWidth: 2.5 }),
        j && M,
        y
      ]
    }
  );
}
const vU = 3, yU = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? vU : 0), Ec = 2, vC = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), Ev = (e) => {
  let t = e;
  return typeof e == "string" ? (t = vC(e), t % 1 !== 0 && (t = t.toFixed(Ec))) : t = Number.isInteger(e) ? Number(e) * 10 ** Ec : e.toFixed(Ec), vC(t) / 10 ** Ec;
}, yC = (e, t, n) => {
  if (!t) return [0, ""];
  const r = Ev(t), o = yU(e, r, n);
  return [r, o];
};
function bU(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: h,
    onBlur: y,
    title: f,
    style: g,
    // showCents = false,
    max: x = 1e9,
    locale: L = "pt-BR",
    currency: E = "BRL",
    ...T
  } = e, b = c ? "right" : "left", Z = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, $ = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: Z,
    prefix: Es(a, $, "prefix"),
    sufix: Es(l, $, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    locale: L,
    currency: E,
    readOnly: d,
    onFocus: h,
    onBlur: y,
    title: f,
    style: g,
    max: x,
    // showCents,
    loadingPosition: b,
    iconSize: $,
    Spinner: /* @__PURE__ */ re.jsx(Ui, { className: "spinner", size: $, strokeWidth: 2.5 }),
    ...T
  };
}
function wU(e) {
  const [t, n] = k(!1), [r, o] = k("0"), i = it(null), { inputRef: s, id: a, error: l } = Fo(), u = s || i, c = e.isError || !!l, {
    disabled: p,
    title: d,
    style: h,
    className: y,
    prefix: f,
    sufix: g,
    iconSize: x,
    loadingPosition: L,
    isLoading: E,
    LeftIcon: T,
    readOnly: b,
    onFocus: C,
    onBlur: M,
    RightIcon: S,
    Spinner: F,
    value: D,
    max: Z,
    onChangeValue: U,
    onKeyPress: $,
    currency: N,
    locale: V,
    name: J,
    defaultValue: j,
    ...K
  } = bU({ ...e, id: a, isError: c }, t), te = T && !E, O = S && !E, P = L === "left" && E, H = L === "right" && E;
  function I() {
    p || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function W(_) {
    n(!0), C && C(_);
  }
  function X(_) {
    n(!1), M && M(_);
  }
  const w = (_) => {
    const [Y, Q] = yC(
      V,
      _,
      N
    );
    return !Z || Y <= Z ? (o(Q), [Y, Q]) : [Ev(r), r];
  }, R = (_) => {
    _.preventDefault();
    const [Y, Q] = w(_.target.value);
    U(_, String(Y), String(Q));
  }, z = (_) => $ && $(_, _.key, _.key);
  return m(() => {
    const _ = D || +j || void 0, [, Y] = yC(V, _, N);
    o(Y);
  }, [N, j, D]), /* @__PURE__ */ re.jsxs(
    "section",
    {
      title: d,
      style: h,
      onClick: I,
      className: y,
      children: [
        f,
        P && F,
        te && /* @__PURE__ */ re.jsx(T, { size: x, strokeWidth: 2.5 }),
        /* @__PURE__ */ re.jsx(
          "input",
          {
            value: r,
            onChange: R,
            onBlur: X,
            onFocus: W,
            onKeyUp: z,
            disabled: p || E,
            readOnly: b,
            ...K
          }
        ),
        /* @__PURE__ */ re.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: J,
            value: Ev(r)
          }
        ),
        H && F,
        O && /* @__PURE__ */ re.jsx(S, { size: x, strokeWidth: 2.5 }),
        g
      ]
    }
  );
}
function CU(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: h,
    onBlur: y,
    title: f,
    style: g,
    onChange: x,
    showMask: L = !1,
    type: E,
    ...T
  } = e, b = c ? "right" : "left", Z = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, $ = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: Z,
    prefix: Es(a, $, "prefix"),
    sufix: Es(l, $, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: h,
    onBlur: y,
    title: f,
    style: g,
    onChange: x,
    loadingPosition: b,
    iconSize: $,
    showMask: L,
    Spinner: /* @__PURE__ */ re.jsx(Ui, { className: "spinner", size: $, strokeWidth: 2.5 }),
    ...T
  };
}
const xU = Ba((e, t) => /* @__PURE__ */ re.jsx("input", { ref: t, ...e }));
function EU(e) {
  const [t, n] = k(!1), r = it(null), { inputRef: o, id: i, error: s } = Fo(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: h,
    sufix: y,
    iconSize: f,
    loadingPosition: g,
    isLoading: x,
    LeftIcon: L,
    readOnly: E,
    onFocus: T,
    onBlur: b,
    RightIcon: C,
    Spinner: M,
    ...S
  } = CU({ ...e, id: i, isError: l }, t), F = L && !x, D = C && !x, Z = g === "left" && x, U = g === "right" && x;
  function $() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function N(J) {
    n(!0), T && T(J);
  }
  function V(J) {
    n(!1), b && b(J);
  }
  return /* @__PURE__ */ re.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: $,
      className: d,
      children: [
        h,
        Z && M,
        F && /* @__PURE__ */ re.jsx(L, { size: f, strokeWidth: 2.5 }),
        /* @__PURE__ */ re.jsx(
          U2,
          {
            component: xU,
            ref: a,
            onFocus: N,
            onBlur: V,
            disabled: u,
            ...S
          }
        ),
        D && /* @__PURE__ */ re.jsx(C, { size: f, strokeWidth: 2.5 }),
        U && M,
        y
      ]
    }
  );
}
function LU(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: h,
    onBlur: y,
    title: f,
    style: g,
    onChange: x,
    ...L
  } = e, E = c ? "right" : "left", F = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, Z = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: F,
    prefix: Es(a, Z, "prefix"),
    sufix: Es(l, Z, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: h,
    onBlur: y,
    title: f,
    style: g,
    onChange: x,
    loadingPosition: E,
    iconSize: Z,
    Spinner: /* @__PURE__ */ re.jsx(Ui, { className: "spinner", size: Z, strokeWidth: 2.5 }),
    ...L
  };
}
function kU(e) {
  const [t, n] = k(!1), r = it(null), { inputRef: o, id: i, error: s } = Fo(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: h,
    sufix: y,
    iconSize: f,
    loadingPosition: g,
    isLoading: x,
    LeftIcon: L,
    readOnly: E,
    onFocus: T,
    onBlur: b,
    RightIcon: C,
    type: M,
    Spinner: S,
    ...F
  } = LU({ ...e, id: i, isError: l }, t), D = L && !x, Z = C && !x, U = g === "left" && x, $ = g === "right" && x;
  function N() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function V(j) {
    n(!0), T && T(j);
  }
  function J(j) {
    n(!1), b && b(j);
  }
  return M === "hidden" ? /* @__PURE__ */ re.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: a,
      ...F
    }
  ) : /* @__PURE__ */ re.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: N,
      className: d,
      children: [
        h,
        U && S,
        D && /* @__PURE__ */ re.jsx(L, { size: f, strokeWidth: 2.5 }),
        /* @__PURE__ */ re.jsx(
          "input",
          {
            disabled: u || x,
            readOnly: E,
            ref: a,
            onFocus: V,
            onBlur: J,
            type: M,
            ...F
          }
        ),
        Z && /* @__PURE__ */ re.jsx(C, { size: f, strokeWidth: 2.5 }),
        $ && S,
        y
      ]
    }
  );
}
function gA(e) {
  return e.type === "currency" ? /* @__PURE__ */ re.jsx(wU, { ...e }) : e.type === "masked" ? /* @__PURE__ */ re.jsx(EU, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ re.jsx(mU, { ...e }) : /* @__PURE__ */ re.jsx(kU, { ...e });
}
function Wme({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = k(null), s = (l) => i(l), a = () => {
    var h, y, f, g;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function p(x) {
      const L = c.find((E) => E.types[0] === x);
      return L ? L.long_name : "";
    }
    function d(x) {
      const L = c.find((E) => E.types[0] === x);
      return L ? L.short_name : "";
    }
    if (u) {
      const x = p("route"), L = p("street_number"), E = p("sublocality_level_1"), T = p("administrative_area_level_2"), b = p("administrative_area_level_1"), C = d("administrative_area_level_1"), M = p("postal_code"), S = (y = (h = u.geometry) == null ? void 0 : h.location) == null ? void 0 : y.lat(), F = (g = (f = u.geometry) == null ? void 0 : f.location) == null ? void 0 : g.lng();
      t && t({
        street: x,
        city: T,
        state: b,
        district: E,
        cep: M,
        streetNumber: L,
        stateShortName: C,
        coordinates: { lat: S, lng: F }
      });
    }
  };
  return /* @__PURE__ */ re.jsx(
    fU,
    {
      onLoad: s,
      onPlacesChanged: a,
      options: n,
      children: /* @__PURE__ */ re.jsx(gA, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function Hme(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: s,
    className: a = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, p = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${a}`;
  return /* @__PURE__ */ re.jsxs(
    "button",
    {
      disabled: s || t,
      className: p.trim(),
      ...l,
      children: [
        /* @__PURE__ */ re.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ re.jsx(Ui, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ re.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ re.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
var Dn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function OU(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Lv = { exports: {} }, ul = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bC;
function MU() {
  if (bC) return ul;
  bC = 1;
  var e = Ae, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, h = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: h, props: p, _owner: o.current };
  }
  return ul.Fragment = n, ul.jsx = s, ul.jsxs = s, ul;
}
var Lc = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wC;
function SU() {
  return wC || (wC = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ae, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), y = Symbol.iterator, f = "@@iterator";
    function g(v) {
      if (v === null || typeof v != "object")
        return null;
      var B = y && v[y] || v[f];
      return typeof B == "function" ? B : null;
    }
    var x = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function L(v) {
      {
        for (var B = arguments.length, G = new Array(B > 1 ? B - 1 : 0), oe = 1; oe < B; oe++)
          G[oe - 1] = arguments[oe];
        E("error", v, G);
      }
    }
    function E(v, B, G) {
      {
        var oe = x.ReactDebugCurrentFrame, me = oe.getStackAddendum();
        me !== "" && (B += "%s", G = G.concat([me]));
        var ye = G.map(function(fe) {
          return String(fe);
        });
        ye.unshift("Warning: " + B), Function.prototype.apply.call(console[v], console, ye);
      }
    }
    var T = !1, b = !1, C = !1, M = !1, S = !1, F;
    F = Symbol.for("react.module.reference");
    function D(v) {
      return !!(typeof v == "string" || typeof v == "function" || v === r || v === i || S || v === o || v === u || v === c || M || v === h || T || b || C || typeof v == "object" && v !== null && (v.$$typeof === d || v.$$typeof === p || v.$$typeof === s || v.$$typeof === a || v.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      v.$$typeof === F || v.getModuleId !== void 0));
    }
    function Z(v, B, G) {
      var oe = v.displayName;
      if (oe)
        return oe;
      var me = B.displayName || B.name || "";
      return me !== "" ? G + "(" + me + ")" : G;
    }
    function U(v) {
      return v.displayName || "Context";
    }
    function $(v) {
      if (v == null)
        return null;
      if (typeof v.tag == "number" && L("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof v == "function")
        return v.displayName || v.name || null;
      if (typeof v == "string")
        return v;
      switch (v) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof v == "object")
        switch (v.$$typeof) {
          case a:
            var B = v;
            return U(B) + ".Consumer";
          case s:
            var G = v;
            return U(G._context) + ".Provider";
          case l:
            return Z(v, v.render, "ForwardRef");
          case p:
            var oe = v.displayName || null;
            return oe !== null ? oe : $(v.type) || "Memo";
          case d: {
            var me = v, ye = me._payload, fe = me._init;
            try {
              return $(fe(ye));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var N = Object.assign, V = 0, J, j, K, te, O, P, H;
    function I() {
    }
    I.__reactDisabledLog = !0;
    function W() {
      {
        if (V === 0) {
          J = console.log, j = console.info, K = console.warn, te = console.error, O = console.group, P = console.groupCollapsed, H = console.groupEnd;
          var v = {
            configurable: !0,
            enumerable: !0,
            value: I,
            writable: !0
          };
          Object.defineProperties(console, {
            info: v,
            log: v,
            warn: v,
            error: v,
            group: v,
            groupCollapsed: v,
            groupEnd: v
          });
        }
        V++;
      }
    }
    function X() {
      {
        if (V--, V === 0) {
          var v = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: N({}, v, {
              value: J
            }),
            info: N({}, v, {
              value: j
            }),
            warn: N({}, v, {
              value: K
            }),
            error: N({}, v, {
              value: te
            }),
            group: N({}, v, {
              value: O
            }),
            groupCollapsed: N({}, v, {
              value: P
            }),
            groupEnd: N({}, v, {
              value: H
            })
          });
        }
        V < 0 && L("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var w = x.ReactCurrentDispatcher, R;
    function z(v, B, G) {
      {
        if (R === void 0)
          try {
            throw Error();
          } catch (me) {
            var oe = me.stack.trim().match(/\n( *(at )?)/);
            R = oe && oe[1] || "";
          }
        return `
` + R + v;
      }
    }
    var _ = !1, Y;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      Y = new Q();
    }
    function A(v, B) {
      if (!v || _)
        return "";
      {
        var G = Y.get(v);
        if (G !== void 0)
          return G;
      }
      var oe;
      _ = !0;
      var me = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ye;
      ye = w.current, w.current = null, W();
      try {
        if (B) {
          var fe = function() {
            throw Error();
          };
          if (Object.defineProperty(fe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fe, []);
            } catch (Pe) {
              oe = Pe;
            }
            Reflect.construct(v, [], fe);
          } else {
            try {
              fe.call();
            } catch (Pe) {
              oe = Pe;
            }
            v.call(fe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Pe) {
            oe = Pe;
          }
          v();
        }
      } catch (Pe) {
        if (Pe && oe && typeof Pe.stack == "string") {
          for (var pe = Pe.stack.split(`
`), De = oe.stack.split(`
`), Le = pe.length - 1, Oe = De.length - 1; Le >= 1 && Oe >= 0 && pe[Le] !== De[Oe]; )
            Oe--;
          for (; Le >= 1 && Oe >= 0; Le--, Oe--)
            if (pe[Le] !== De[Oe]) {
              if (Le !== 1 || Oe !== 1)
                do
                  if (Le--, Oe--, Oe < 0 || pe[Le] !== De[Oe]) {
                    var ze = `
` + pe[Le].replace(" at new ", " at ");
                    return v.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", v.displayName)), typeof v == "function" && Y.set(v, ze), ze;
                  }
                while (Le >= 1 && Oe >= 0);
              break;
            }
        }
      } finally {
        _ = !1, w.current = ye, X(), Error.prepareStackTrace = me;
      }
      var nt = v ? v.displayName || v.name : "", rt = nt ? z(nt) : "";
      return typeof v == "function" && Y.set(v, rt), rt;
    }
    function ae(v, B, G) {
      return A(v, !1);
    }
    function ce(v) {
      var B = v.prototype;
      return !!(B && B.isReactComponent);
    }
    function ue(v, B, G) {
      if (v == null)
        return "";
      if (typeof v == "function")
        return A(v, ce(v));
      if (typeof v == "string")
        return z(v);
      switch (v) {
        case u:
          return z("Suspense");
        case c:
          return z("SuspenseList");
      }
      if (typeof v == "object")
        switch (v.$$typeof) {
          case l:
            return ae(v.render);
          case p:
            return ue(v.type, B, G);
          case d: {
            var oe = v, me = oe._payload, ye = oe._init;
            try {
              return ue(ye(me), B, G);
            } catch {
            }
          }
        }
      return "";
    }
    var de = Object.prototype.hasOwnProperty, be = {}, ve = x.ReactDebugCurrentFrame;
    function ge(v) {
      if (v) {
        var B = v._owner, G = ue(v.type, v._source, B ? B.type : null);
        ve.setExtraStackFrame(G);
      } else
        ve.setExtraStackFrame(null);
    }
    function se(v, B, G, oe, me) {
      {
        var ye = Function.call.bind(de);
        for (var fe in v)
          if (ye(v, fe)) {
            var pe = void 0;
            try {
              if (typeof v[fe] != "function") {
                var De = Error((oe || "React class") + ": " + G + " type `" + fe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof v[fe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw De.name = "Invariant Violation", De;
              }
              pe = v[fe](B, fe, oe, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Le) {
              pe = Le;
            }
            pe && !(pe instanceof Error) && (ge(me), L("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", oe || "React class", G, fe, typeof pe), ge(null)), pe instanceof Error && !(pe.message in be) && (be[pe.message] = !0, ge(me), L("Failed %s type: %s", G, pe.message), ge(null));
          }
      }
    }
    var xe = Array.isArray;
    function ne(v) {
      return xe(v);
    }
    function Me(v) {
      {
        var B = typeof Symbol == "function" && Symbol.toStringTag, G = B && v[Symbol.toStringTag] || v.constructor.name || "Object";
        return G;
      }
    }
    function ee(v) {
      try {
        return Ce(v), !1;
      } catch {
        return !0;
      }
    }
    function Ce(v) {
      return "" + v;
    }
    function Be(v) {
      if (ee(v))
        return L("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Me(v)), Ce(v);
    }
    var _e = x.ReactCurrentOwner, $e = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, he, Ge, We;
    We = {};
    function Ut(v) {
      if (de.call(v, "ref")) {
        var B = Object.getOwnPropertyDescriptor(v, "ref").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return v.ref !== void 0;
    }
    function ot(v) {
      if (de.call(v, "key")) {
        var B = Object.getOwnPropertyDescriptor(v, "key").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return v.key !== void 0;
    }
    function st(v, B) {
      if (typeof v.ref == "string" && _e.current && B && _e.current.stateNode !== B) {
        var G = $(_e.current.type);
        We[G] || (L('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(_e.current.type), v.ref), We[G] = !0);
      }
    }
    function Zt(v, B) {
      {
        var G = function() {
          he || (he = !0, L("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(v, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function qt(v, B) {
      {
        var G = function() {
          Ge || (Ge = !0, L("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(v, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Gt = function(v, B, G, oe, me, ye, fe) {
      var pe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: v,
        key: B,
        ref: G,
        props: fe,
        // Record the component responsible for creating this element.
        _owner: ye
      };
      return pe._store = {}, Object.defineProperty(pe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(pe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: oe
      }), Object.defineProperty(pe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: me
      }), Object.freeze && (Object.freeze(pe.props), Object.freeze(pe)), pe;
    };
    function Xt(v, B, G, oe, me) {
      {
        var ye, fe = {}, pe = null, De = null;
        G !== void 0 && (Be(G), pe = "" + G), ot(B) && (Be(B.key), pe = "" + B.key), Ut(B) && (De = B.ref, st(B, me));
        for (ye in B)
          de.call(B, ye) && !$e.hasOwnProperty(ye) && (fe[ye] = B[ye]);
        if (v && v.defaultProps) {
          var Le = v.defaultProps;
          for (ye in Le)
            fe[ye] === void 0 && (fe[ye] = Le[ye]);
        }
        if (pe || De) {
          var Oe = typeof v == "function" ? v.displayName || v.name || "Unknown" : v;
          pe && Zt(fe, Oe), De && qt(fe, Oe);
        }
        return Gt(v, pe, De, me, oe, _e.current, fe);
      }
    }
    var et = x.ReactCurrentOwner, bt = x.ReactDebugCurrentFrame;
    function tt(v) {
      if (v) {
        var B = v._owner, G = ue(v.type, v._source, B ? B.type : null);
        bt.setExtraStackFrame(G);
      } else
        bt.setExtraStackFrame(null);
    }
    var ut;
    ut = !1;
    function Yt(v) {
      return typeof v == "object" && v !== null && v.$$typeof === t;
    }
    function gn() {
      {
        if (et.current) {
          var v = $(et.current.type);
          if (v)
            return `

Check the render method of \`` + v + "`.";
        }
        return "";
      }
    }
    function Jt(v) {
      {
        if (v !== void 0) {
          var B = v.fileName.replace(/^.*[\\\/]/, ""), G = v.lineNumber;
          return `

Check your code at ` + B + ":" + G + ".";
        }
        return "";
      }
    }
    var mn = {};
    function qn(v) {
      {
        var B = gn();
        if (!B) {
          var G = typeof v == "string" ? v : v.displayName || v.name;
          G && (B = `

Check the top-level render call using <` + G + ">.");
        }
        return B;
      }
    }
    function wt(v, B) {
      {
        if (!v._store || v._store.validated || v.key != null)
          return;
        v._store.validated = !0;
        var G = qn(B);
        if (mn[G])
          return;
        mn[G] = !0;
        var oe = "";
        v && v._owner && v._owner !== et.current && (oe = " It was passed a child from " + $(v._owner.type) + "."), tt(v), L('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, oe), tt(null);
      }
    }
    function vn(v, B) {
      {
        if (typeof v != "object")
          return;
        if (ne(v))
          for (var G = 0; G < v.length; G++) {
            var oe = v[G];
            Yt(oe) && wt(oe, B);
          }
        else if (Yt(v))
          v._store && (v._store.validated = !0);
        else if (v) {
          var me = g(v);
          if (typeof me == "function" && me !== v.entries)
            for (var ye = me.call(v), fe; !(fe = ye.next()).done; )
              Yt(fe.value) && wt(fe.value, B);
        }
      }
    }
    function Gn(v) {
      {
        var B = v.type;
        if (B == null || typeof B == "string")
          return;
        var G;
        if (typeof B == "function")
          G = B.propTypes;
        else if (typeof B == "object" && (B.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        B.$$typeof === p))
          G = B.propTypes;
        else
          return;
        if (G) {
          var oe = $(B);
          se(G, v.props, "prop", oe, v);
        } else if (B.PropTypes !== void 0 && !ut) {
          ut = !0;
          var me = $(B);
          L("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", me || "Unknown");
        }
        typeof B.getDefaultProps == "function" && !B.getDefaultProps.isReactClassApproved && L("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Kt(v) {
      {
        for (var B = Object.keys(v.props), G = 0; G < B.length; G++) {
          var oe = B[G];
          if (oe !== "children" && oe !== "key") {
            tt(v), L("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", oe), tt(null);
            break;
          }
        }
        v.ref !== null && (tt(v), L("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var yn = {};
    function bn(v, B, G, oe, me, ye) {
      {
        var fe = D(v);
        if (!fe) {
          var pe = "";
          (v === void 0 || typeof v == "object" && v !== null && Object.keys(v).length === 0) && (pe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var De = Jt(me);
          De ? pe += De : pe += gn();
          var Le;
          v === null ? Le = "null" : ne(v) ? Le = "array" : v !== void 0 && v.$$typeof === t ? (Le = "<" + ($(v.type) || "Unknown") + " />", pe = " Did you accidentally export a JSX literal instead of a component?") : Le = typeof v, L("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Le, pe);
        }
        var Oe = Xt(v, B, G, me, ye);
        if (Oe == null)
          return Oe;
        if (fe) {
          var ze = B.children;
          if (ze !== void 0)
            if (oe)
              if (ne(ze)) {
                for (var nt = 0; nt < ze.length; nt++)
                  vn(ze[nt], v);
                Object.freeze && Object.freeze(ze);
              } else
                L("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              vn(ze, v);
        }
        if (de.call(B, "key")) {
          var rt = $(v), Pe = Object.keys(B).filter(function(bi) {
            return bi !== "key";
          }), ie = Pe.length > 0 ? "{key: someKey, " + Pe.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!yn[rt + ie]) {
            var yi = Pe.length > 0 ? "{" + Pe.join(": ..., ") + ": ...}" : "{}";
            L(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ie, rt, yi, rt), yn[rt + ie] = !0;
          }
        }
        return v === r ? Kt(Oe) : Gn(Oe), Oe;
      }
    }
    function Qt(v, B, G) {
      return bn(v, B, G, !0);
    }
    function Xn(v, B, G) {
      return bn(v, B, G, !1);
    }
    var Yn = Xn, en = Qt;
    Lc.Fragment = r, Lc.jsx = Yn, Lc.jsxs = en;
  }()), Lc;
}
process.env.NODE_ENV === "production" ? Lv.exports = MU() : Lv.exports = SU();
var an = Lv.exports;
qe({});
function CC(e, t) {
  return t ? /* @__PURE__ */ an.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ an.jsx(an.Fragment, {});
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var kv = function(e, t) {
  return kv = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
  }, kv(e, t);
};
function Bn(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  kv(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Ye = function() {
  return Ye = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ye.apply(this, arguments);
};
function L0(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function DU(e, t, n, r) {
  function o(i) {
    return i instanceof n ? i : new n(function(s) {
      s(i);
    });
  }
  return new (n || (n = Promise))(function(i, s) {
    function a(c) {
      try {
        u(r.next(c));
      } catch (p) {
        s(p);
      }
    }
    function l(c) {
      try {
        u(r.throw(c));
      } catch (p) {
        s(p);
      }
    }
    function u(c) {
      c.done ? i(c.value) : o(c.value).then(a, l);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function PU(e, t) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, o, i, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(c) {
      return l([u, c]);
    };
  }
  function l(u) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, o && (i = u[0] & 2 ? o.return : u[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, u[1])).done) return i;
      switch (o = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
        case 0:
        case 1:
          i = u;
          break;
        case 4:
          return n.label++, { value: u[1], done: !1 };
        case 5:
          n.label++, o = u[1], u = [0];
          continue;
        case 7:
          u = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            n = 0;
            continue;
          }
          if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
            n.label = u[1];
            break;
          }
          if (u[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = u;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(u);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      u = t.call(e, n);
    } catch (c) {
      u = [6, c], o = 0;
    } finally {
      r = i = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function mA(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var TU = process.env.NODE_ENV, _U = function(e, t, n, r, o, i, s, a) {
  if (TU !== "production" && t === void 0)
    throw new Error("invariant requires an error message argument");
  if (!e) {
    var l;
    if (t === void 0)
      l = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var u = [n, r, o, i, s, a], c = 0;
      l = new Error(
        t.replace(/%s/g, function() {
          return u[c++];
        })
      ), l.name = "Invariant Violation";
    }
    throw l.framesToPop = 1, l;
  }
}, AU = _U, Ar = /* @__PURE__ */ mA(AU), gt = qe(null);
function BU() {
  Ar(!!Te, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Te(gt);
  return Ar(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function IU(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function jU(e, t) {
  Object.keys(e).forEach(function(n) {
    return t(e[n], n);
  });
}
function RU(e, t, n, r) {
  var o = {}, i = function(s, a) {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return jU(e, i), o;
}
function NU(e, t, n) {
  var r = IU(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function FU(e) {
  google.maps.event.removeListener(e);
}
function Rt(e) {
  e === void 0 && (e = []), e.forEach(FU);
}
function Mt(e) {
  var t = e.updaterMap, n = e.eventMap, r = e.prevProps, o = e.nextProps, i = e.instance, s = NU(o, i, n);
  return RU(t, r, o, i), s;
}
var xC = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, EC = {
  extraMapTypes: function(e, t) {
    t.forEach(function(n, r) {
      e.mapTypes.set(String(r), n);
    });
  },
  center: function(e, t) {
    e.setCenter(t);
  },
  clickableIcons: function(e, t) {
    e.setClickableIcons(t);
  },
  heading: function(e, t) {
    e.setHeading(t);
  },
  mapTypeId: function(e, t) {
    e.setMapTypeId(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  streetView: function(e, t) {
    e.setStreetView(t);
  },
  tilt: function(e, t) {
    e.setTilt(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
function zU(e) {
  var t = e.children, n = e.options, r = e.id, o = e.mapContainerStyle, i = e.mapContainerClassName, s = e.center, a = e.onClick, l = e.onDblClick, u = e.onDrag, c = e.onDragEnd, p = e.onDragStart, d = e.onMouseMove, h = e.onMouseOut, y = e.onMouseOver, f = e.onMouseDown, g = e.onMouseUp, x = e.onRightClick, L = e.onCenterChanged, E = e.onLoad, T = e.onUnmount, b = k(null), C = b[0], M = b[1], S = it(null), F = k(null), D = F[0], Z = F[1], U = k(null), $ = U[0], N = U[1], V = k(null), J = V[0], j = V[1], K = k(null), te = K[0], O = K[1], P = k(null), H = P[0], I = P[1], W = k(null), X = W[0], w = W[1], R = k(null), z = R[0], _ = R[1], Y = k(null), Q = Y[0], A = Y[1], ae = k(null), ce = ae[0], ue = ae[1], de = k(null), be = de[0], ve = de[1], ge = k(null), se = ge[0], xe = ge[1], ne = k(null), Me = ne[0], ee = ne[1];
  return m(function() {
    n && C !== null && C.setOptions(n);
  }, [C, n]), m(function() {
    C !== null && typeof s < "u" && C.setCenter(s);
  }, [C, s]), m(function() {
    C && l && ($ !== null && google.maps.event.removeListener($), N(google.maps.event.addListener(C, "dblclick", l)));
  }, [l]), m(function() {
    C && c && (J !== null && google.maps.event.removeListener(J), j(google.maps.event.addListener(C, "dragend", c)));
  }, [c]), m(function() {
    C && p && (te !== null && google.maps.event.removeListener(te), O(google.maps.event.addListener(C, "dragstart", p)));
  }, [p]), m(function() {
    C && f && (H !== null && google.maps.event.removeListener(H), I(google.maps.event.addListener(C, "mousedown", f)));
  }, [f]), m(function() {
    C && d && (X !== null && google.maps.event.removeListener(X), w(google.maps.event.addListener(C, "mousemove", d)));
  }, [d]), m(function() {
    C && h && (z !== null && google.maps.event.removeListener(z), _(google.maps.event.addListener(C, "mouseout", h)));
  }, [h]), m(function() {
    C && y && (Q !== null && google.maps.event.removeListener(Q), A(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), m(function() {
    C && g && (ce !== null && google.maps.event.removeListener(ce), ue(google.maps.event.addListener(C, "mouseup", g)));
  }, [g]), m(function() {
    C && x && (be !== null && google.maps.event.removeListener(be), ve(google.maps.event.addListener(C, "rightclick", x)));
  }, [x]), m(function() {
    C && a && (se !== null && google.maps.event.removeListener(se), xe(google.maps.event.addListener(C, "click", a)));
  }, [a]), m(function() {
    C && u && (Me !== null && google.maps.event.removeListener(Me), ee(google.maps.event.addListener(C, "drag", u)));
  }, [u]), m(function() {
    C && L && (D !== null && google.maps.event.removeListener(D), Z(google.maps.event.addListener(C, "center_changed", L)));
  }, [a]), m(function() {
    var Ce = S.current === null ? null : new google.maps.Map(S.current, n);
    return M(Ce), Ce !== null && E && E(Ce), function() {
      Ce !== null && T && T(Ce);
    };
  }, []), an.jsx("div", { id: r, ref: S, style: o, className: i, children: an.jsx(gt.Provider, { value: C, children: C !== null ? t : null }) });
}
Ie(zU);
/** @class */
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      map: null
    }, n.registeredEvents = [], n.mapRef = null, n.getInstance = function() {
      return n.mapRef === null ? null : new google.maps.Map(n.mapRef, n.props.options);
    }, n.panTo = function(r) {
      var o = n.getInstance();
      o && o.panTo(r);
    }, n.setMapCallback = function() {
      n.state.map !== null && n.props.onLoad && n.props.onLoad(n.state.map);
    }, n.getRef = function(r) {
      n.mapRef = r;
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.getInstance();
    this.registeredEvents = Mt({
      updaterMap: EC,
      eventMap: xC,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        map: n
      };
    }, this.setMapCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.map !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: EC,
      eventMap: xC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.map
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), Rt(this.registeredEvents));
  }, t.prototype.render = function() {
    return an.jsx("div", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName, children: an.jsx(gt.Provider, { value: this.state.map, children: this.state.map !== null ? this.props.children : null }) });
  }, t;
})(Ee);
var ca = typeof document < "u";
function vA(e) {
  var t = e.url, n = e.id, r = e.nonce;
  return ca ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch(function(o) {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function LC(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function yA() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return LC(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return LC(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
function bA(e) {
  var t = e.googleMapsApiKey, n = e.googleMapsClientId, r = e.version, o = r === void 0 ? "weekly" : r, i = e.language, s = e.region, a = e.libraries, l = e.channel, u = e.mapIds, c = e.authReferrerPolicy, p = [];
  return Ar(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? p.push("key=".concat(t)) : n && p.push("client=".concat(n)), o && p.push("v=".concat(o)), i && p.push("language=".concat(i)), s && p.push("region=".concat(s)), a && a.length && p.push("libraries=".concat(a.sort().join(","))), l && p.push("channel=".concat(l)), u && u.length && p.push("map_ids=".concat(u.join(","))), c && p.push("auth_referrer_policy=".concat(c)), p.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(p.join("&"));
}
var cl = !1;
function wA() {
  return an.jsx("div", { children: "Loading..." });
}
var Ov = {
  id: "script-loader",
  version: "weekly"
};
/** @class */
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.check = Rr(), n.state = {
      loaded: !1
    }, n.cleanupCallback = function() {
      delete window.google.maps, n.injectScript();
    }, n.isCleaningUp = function() {
      return DU(n, void 0, void 0, function() {
        function r(o) {
          if (!cl)
            o();
          else if (ca)
            var i = window.setInterval(function() {
              cl || (window.clearInterval(i), o());
            }, 1);
        }
        return PU(this, function(o) {
          return [2, new Promise(r)];
        });
      });
    }, n.cleanup = function() {
      cl = !0;
      var r = document.getElementById(n.props.id);
      r && r.parentNode && r.parentNode.removeChild(r), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(o) {
        return typeof o.src == "string" && o.src.includes("maps.googleapis");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(o) {
        return o.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(o) {
        return o.innerText !== void 0 && o.innerText.length > 0 && o.innerText.includes(".gm-");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      });
    }, n.injectScript = function() {
      n.props.preventGoogleFontsLoading && yA(), Ar(!!n.props.id, 'LoadScript requires "id" prop to be a string: %s', n.props.id);
      var r = {
        id: n.props.id,
        nonce: n.props.nonce,
        url: bA(n.props)
      };
      vA(r).then(function() {
        n.props.onLoad && n.props.onLoad(), n.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch(function(o) {
        n.props.onError && n.props.onError(o), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(n.props.googleMapsApiKey || "-", ") or Client ID (").concat(n.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (ca) {
      if (window.google && window.google.maps && !cl) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.props.libraries !== n.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), ca && n.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }, t.prototype.componentWillUnmount = function() {
    var n = this;
    if (ca) {
      this.cleanup();
      var r = function() {
        n.check.current || (delete window.google, cl = !1);
      };
      window.setTimeout(r, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }, t.prototype.render = function() {
    return an.jsxs(an.Fragment, { children: [an.jsx("div", { ref: this.check }), this.state.loaded ? this.props.children : this.props.loadingElement || an.jsx(wA, {})] });
  }, t.defaultProps = Ov, t;
})(Ee);
var kC;
function UU(e) {
  var t = e.id, n = t === void 0 ? Ov.id : t, r = e.version, o = r === void 0 ? Ov.version : r, i = e.nonce, s = e.googleMapsApiKey, a = e.googleMapsClientId, l = e.language, u = e.region, c = e.libraries, p = e.preventGoogleFontsLoading, d = e.channel, h = e.mapIds, y = e.authReferrerPolicy, f = it(!1), g = k(!1), x = g[0], L = g[1], E = k(void 0), T = E[0], b = E[1];
  m(function() {
    return f.current = !0, function() {
      f.current = !1;
    };
  }, []), m(function() {
    ca && p && yA();
  }, [p]), m(function() {
    x && Ar(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [x]);
  var C = bA({
    version: o,
    googleMapsApiKey: s,
    googleMapsClientId: a,
    language: l,
    region: u,
    libraries: c,
    channel: d,
    mapIds: h,
    authReferrerPolicy: y
  });
  m(function() {
    if (!ca)
      return;
    function S() {
      f.current && (L(!0), kC = C);
    }
    if (window.google && window.google.maps && kC === C) {
      S();
      return;
    }
    vA({ id: n, url: C, nonce: i }).then(S).catch(function(F) {
      f.current && b(F), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(s || "-", ") or Client ID (").concat(a || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(F);
    });
  }, [n, C, i]);
  var M = it();
  return m(function() {
    M.current && c !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = c;
  }, [c]), { isLoaded: x, loadError: T, url: C };
}
var $U = an.jsx(wA, {});
function WU(e) {
  var t = e.loadingElement, n = e.onLoad, r = e.onError, o = e.onUnmount, i = e.children, s = L0(e, ["loadingElement", "onLoad", "onError", "onUnmount", "children"]), a = UU(s), l = a.isLoaded, u = a.loadError;
  return m(function() {
    l && typeof n == "function" && n();
  }, [l, n]), m(function() {
    u && typeof r == "function" && r(u);
  }, [u, r]), m(function() {
    return function() {
      o && o();
    };
  }, [o]), l ? i : t || $U;
}
Ie(WU);
var OC;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(OC || (OC = {}));
var MC = {}, SC = {
  options: function(e, t) {
    e.setOptions(t);
  }
};
function HU(e) {
  var t = e.options, n = e.onLoad, r = e.onUnmount, o = Te(gt), i = k(null), s = i[0], a = i[1];
  return m(function() {
    s !== null && s.setMap(o);
  }, [o]), m(function() {
    t && s !== null && s.setOptions(t);
  }, [s, t]), m(function() {
    var l = new google.maps.TrafficLayer(Ye(Ye({}, t || {}), { map: o }));
    return a(l), n && n(l), function() {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Ie(HU);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      trafficLayer: null
    }, n.setTrafficLayerCallback = function() {
      n.state.trafficLayer !== null && n.props.onLoad && n.props.onLoad(n.state.trafficLayer);
    }, n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TrafficLayer(Ye(Ye({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Mt({
      updaterMap: SC,
      eventMap: MC,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        trafficLayer: n
      };
    }, this.setTrafficLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.trafficLayer !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: SC,
      eventMap: MC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Rt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = gt, t;
})(Ee);
function VU(e) {
  var t = e.onLoad, n = e.onUnmount, r = Te(gt), o = k(null), i = o[0], s = o[1];
  return m(function() {
    i !== null && i.setMap(r);
  }, [r]), m(function() {
    var a = new google.maps.BicyclingLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Ie(VU);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      bicyclingLayer: null
    }, n.setBicyclingLayerCallback = function() {
      n.state.bicyclingLayer !== null && (n.state.bicyclingLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.bicyclingLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.BicyclingLayer();
    this.setState(function() {
      return {
        bicyclingLayer: n
      };
    }, this.setBicyclingLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = gt, t;
})(Ee);
function ZU(e) {
  var t = e.onLoad, n = e.onUnmount, r = Te(gt), o = k(null), i = o[0], s = o[1];
  return m(function() {
    i !== null && i.setMap(r);
  }, [r]), m(function() {
    var a = new google.maps.TransitLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      i !== null && (n && n(i), i.setMap(null));
    };
  }, []), null;
}
Ie(ZU);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      transitLayer: null
    }, n.setTransitLayerCallback = function() {
      n.state.transitLayer !== null && (n.state.transitLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.transitLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: n
      };
    }, this.setTransitLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = gt, t;
})(Ee);
var DC = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, PC = {
  drawingMode: function(e, t) {
    e.setDrawingMode(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function qU(e) {
  var t = e.options, n = e.drawingMode, r = e.onCircleComplete, o = e.onMarkerComplete, i = e.onOverlayComplete, s = e.onPolygonComplete, a = e.onPolylineComplete, l = e.onRectangleComplete, u = e.onLoad, c = e.onUnmount, p = Te(gt), d = k(null), h = d[0], y = d[1], f = k(null), g = f[0], x = f[1], L = k(null), E = L[0], T = L[1], b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1];
  return m(function() {
    h !== null && h.setMap(p);
  }, [p]), m(function() {
    t && h !== null && h.setOptions(t);
  }, [h, t]), m(function() {
    h !== null && h.setDrawingMode(n ?? null);
  }, [h, n]), m(function() {
    h && r && (g !== null && google.maps.event.removeListener(g), x(google.maps.event.addListener(h, "circlecomplete", r)));
  }, [h, r]), m(function() {
    h && o && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(h, "markercomplete", o)));
  }, [h, o]), m(function() {
    h && i && (C !== null && google.maps.event.removeListener(C), M(google.maps.event.addListener(h, "overlaycomplete", i)));
  }, [h, i]), m(function() {
    h && s && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(h, "polygoncomplete", s)));
  }, [h, s]), m(function() {
    h && a && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(h, "polylinecomplete", a)));
  }, [h, a]), m(function() {
    h && l && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(h, "rectanglecomplete", l)));
  }, [h, l]), m(function() {
    Ar(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var j = new google.maps.drawing.DrawingManager(Ye(Ye({}, t || {}), { map: p }));
    return n && j.setDrawingMode(n), r && x(google.maps.event.addListener(j, "circlecomplete", r)), o && T(google.maps.event.addListener(j, "markercomplete", o)), i && M(google.maps.event.addListener(j, "overlaycomplete", i)), s && D(google.maps.event.addListener(j, "polygoncomplete", s)), a && $(google.maps.event.addListener(j, "polylinecomplete", a)), l && J(google.maps.event.addListener(j, "rectanglecomplete", l)), y(j), u && u(j), function() {
      h !== null && (g && google.maps.event.removeListener(g), E && google.maps.event.removeListener(E), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), U && google.maps.event.removeListener(U), V && google.maps.event.removeListener(V), c && c(h), h.setMap(null));
    };
  }, []), null;
}
Ie(qU);
(function(e) {
  Bn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    return r.registeredEvents = [], r.state = {
      drawingManager: null
    }, r.setDrawingManagerCallback = function() {
      r.state.drawingManager !== null && r.props.onLoad && r.props.onLoad(r.state.drawingManager);
    }, Ar(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing), r;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.drawing.DrawingManager(Ye(Ye({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Mt({
      updaterMap: PC,
      eventMap: DC,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        drawingManager: n
      };
    }, this.setDrawingManagerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.drawingManager !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: PC,
      eventMap: DC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Rt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = gt, t;
})(Ee);
var TC = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, _C = {
  animation: function(e, t) {
    e.setAnimation(t);
  },
  clickable: function(e, t) {
    e.setClickable(t);
  },
  cursor: function(e, t) {
    e.setCursor(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  icon: function(e, t) {
    e.setIcon(t);
  },
  label: function(e, t) {
    e.setLabel(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  opacity: function(e, t) {
    e.setOpacity(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  shape: function(e, t) {
    e.setShape(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, hd = {};
function GU(e) {
  var t = e.position, n = e.options, r = e.clusterer, o = e.noClustererRedraw, i = e.children, s = e.draggable, a = e.visible, l = e.animation, u = e.clickable, c = e.cursor, p = e.icon, d = e.label, h = e.opacity, y = e.shape, f = e.title, g = e.zIndex, x = e.onClick, L = e.onDblClick, E = e.onDrag, T = e.onDragEnd, b = e.onDragStart, C = e.onMouseOut, M = e.onMouseOver, S = e.onMouseUp, F = e.onMouseDown, D = e.onRightClick, Z = e.onClickableChanged, U = e.onCursorChanged, $ = e.onAnimationChanged, N = e.onDraggableChanged, V = e.onFlatChanged, J = e.onIconChanged, j = e.onPositionChanged, K = e.onShapeChanged, te = e.onTitleChanged, O = e.onVisibleChanged, P = e.onZindexChanged, H = e.onLoad, I = e.onUnmount, W = Te(gt), X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1], se = k(null), xe = se[0], ne = se[1], Me = k(null), ee = Me[0], Ce = Me[1], Be = k(null), _e = Be[0], $e = Be[1], he = k(null), Ge = he[0], We = he[1], Ut = k(null), ot = Ut[0], st = Ut[1], Zt = k(null), qt = Zt[0], Gt = Zt[1], Xt = k(null), et = Xt[0], bt = Xt[1], tt = k(null), ut = tt[0], Yt = tt[1], gn = k(null), Jt = gn[0], mn = gn[1], qn = k(null), wt = qn[0], vn = qn[1], Gn = k(null), Kt = Gn[0], yn = Gn[1], bn = k(null), Qt = bn[0], Xn = bn[1], Yn = k(null), en = Yn[0], v = Yn[1], B = k(null), G = B[0], oe = B[1], me = k(null), ye = me[0], fe = me[1], pe = k(null), De = pe[0], Le = pe[1], Oe = k(null), ze = Oe[0], nt = Oe[1];
  m(function() {
    w !== null && w.setMap(W);
  }, [W]), m(function() {
    typeof n < "u" && w !== null && w.setOptions(n);
  }, [w, n]), m(function() {
    typeof s < "u" && w !== null && w.setDraggable(s);
  }, [w, s]), m(function() {
    t && w !== null && w.setPosition(t);
  }, [w, t]), m(function() {
    typeof a < "u" && w !== null && w.setVisible(a);
  }, [w, a]), m(function() {
    w == null || w.setAnimation(l);
  }, [w, l]), m(function() {
    w && u !== void 0 && w.setClickable(u);
  }, [w, u]), m(function() {
    w && c !== void 0 && w.setCursor(c);
  }, [w, c]), m(function() {
    w && p !== void 0 && w.setIcon(p);
  }, [w, p]), m(function() {
    w && d !== void 0 && w.setLabel(d);
  }, [w, d]), m(function() {
    w && h !== void 0 && w.setOpacity(h);
  }, [w, h]), m(function() {
    w && y !== void 0 && w.setShape(y);
  }, [w, y]), m(function() {
    w && f !== void 0 && w.setTitle(f);
  }, [w, f]), m(function() {
    w && g !== void 0 && w.setZIndex(g);
  }, [w, g]), m(function() {
    w && L && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(w, "dblclick", L)));
  }, [L]), m(function() {
    w && T && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(w, "dragend", T)));
  }, [T]), m(function() {
    w && b && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(w, "dragstart", b)));
  }, [b]), m(function() {
    w && F && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(w, "mousedown", F)));
  }, [F]), m(function() {
    w && C && (xe !== null && google.maps.event.removeListener(xe), ne(google.maps.event.addListener(w, "mouseout", C)));
  }, [C]), m(function() {
    w && M && (ee !== null && google.maps.event.removeListener(ee), Ce(google.maps.event.addListener(w, "mouseover", M)));
  }, [M]), m(function() {
    w && S && (_e !== null && google.maps.event.removeListener(_e), $e(google.maps.event.addListener(w, "mouseup", S)));
  }, [S]), m(function() {
    w && D && (Ge !== null && google.maps.event.removeListener(Ge), We(google.maps.event.addListener(w, "rightclick", D)));
  }, [D]), m(function() {
    w && x && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(w, "click", x)));
  }, [x]), m(function() {
    w && E && (qt !== null && google.maps.event.removeListener(qt), Gt(google.maps.event.addListener(w, "drag", E)));
  }, [E]), m(function() {
    w && Z && (et !== null && google.maps.event.removeListener(et), bt(google.maps.event.addListener(w, "clickable_changed", Z)));
  }, [Z]), m(function() {
    w && U && (ut !== null && google.maps.event.removeListener(ut), Yt(google.maps.event.addListener(w, "cursor_changed", U)));
  }, [U]), m(function() {
    w && $ && (Jt !== null && google.maps.event.removeListener(Jt), mn(google.maps.event.addListener(w, "animation_changed", $)));
  }, [$]), m(function() {
    w && N && (wt !== null && google.maps.event.removeListener(wt), vn(google.maps.event.addListener(w, "draggable_changed", N)));
  }, [N]), m(function() {
    w && V && (Kt !== null && google.maps.event.removeListener(Kt), yn(google.maps.event.addListener(w, "flat_changed", V)));
  }, [V]), m(function() {
    w && J && (Qt !== null && google.maps.event.removeListener(Qt), Xn(google.maps.event.addListener(w, "icon_changed", J)));
  }, [J]), m(function() {
    w && j && (en !== null && google.maps.event.removeListener(en), v(google.maps.event.addListener(w, "position_changed", j)));
  }, [j]), m(function() {
    w && K && (G !== null && google.maps.event.removeListener(G), oe(google.maps.event.addListener(w, "shape_changed", K)));
  }, [K]), m(function() {
    w && te && (ye !== null && google.maps.event.removeListener(ye), fe(google.maps.event.addListener(w, "title_changed", te)));
  }, [te]), m(function() {
    w && O && (De !== null && google.maps.event.removeListener(De), Le(google.maps.event.addListener(w, "visible_changed", O)));
  }, [O]), m(function() {
    w && P && (ze !== null && google.maps.event.removeListener(ze), nt(google.maps.event.addListener(w, "zindex_changed", P)));
  }, [P]), m(function() {
    var Pe = Ye(Ye(Ye({}, n || hd), r ? hd : { map: W }), { position: t }), ie = new google.maps.Marker(Pe);
    return r ? r.addMarker(ie, !!o) : ie.setMap(W), t && ie.setPosition(t), typeof a < "u" && ie.setVisible(a), typeof s < "u" && ie.setDraggable(s), typeof u < "u" && ie.setClickable(u), typeof c == "string" && ie.setCursor(c), p && ie.setIcon(p), typeof d < "u" && ie.setLabel(d), typeof h < "u" && ie.setOpacity(h), y && ie.setShape(y), typeof f == "string" && ie.setTitle(f), typeof g == "number" && ie.setZIndex(g), L && Y(google.maps.event.addListener(ie, "dblclick", L)), T && ae(google.maps.event.addListener(ie, "dragend", T)), b && de(google.maps.event.addListener(ie, "dragstart", b)), F && ge(google.maps.event.addListener(ie, "mousedown", F)), C && ne(google.maps.event.addListener(ie, "mouseout", C)), M && Ce(google.maps.event.addListener(ie, "mouseover", M)), S && $e(google.maps.event.addListener(ie, "mouseup", S)), D && We(google.maps.event.addListener(ie, "rightclick", D)), x && st(google.maps.event.addListener(ie, "click", x)), E && Gt(google.maps.event.addListener(ie, "drag", E)), Z && bt(google.maps.event.addListener(ie, "clickable_changed", Z)), U && Yt(google.maps.event.addListener(ie, "cursor_changed", U)), $ && mn(google.maps.event.addListener(ie, "animation_changed", $)), N && vn(google.maps.event.addListener(ie, "draggable_changed", N)), V && yn(google.maps.event.addListener(ie, "flat_changed", V)), J && Xn(google.maps.event.addListener(ie, "icon_changed", J)), j && v(google.maps.event.addListener(ie, "position_changed", j)), K && oe(google.maps.event.addListener(ie, "shape_changed", K)), te && fe(google.maps.event.addListener(ie, "title_changed", te)), O && Le(google.maps.event.addListener(ie, "visible_changed", O)), P && nt(google.maps.event.addListener(ie, "zindex_changed", P)), R(ie), H && H(ie), function() {
      _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), ve !== null && google.maps.event.removeListener(ve), xe !== null && google.maps.event.removeListener(xe), ee !== null && google.maps.event.removeListener(ee), _e !== null && google.maps.event.removeListener(_e), Ge !== null && google.maps.event.removeListener(Ge), ot !== null && google.maps.event.removeListener(ot), et !== null && google.maps.event.removeListener(et), ut !== null && google.maps.event.removeListener(ut), Jt !== null && google.maps.event.removeListener(Jt), wt !== null && google.maps.event.removeListener(wt), Kt !== null && google.maps.event.removeListener(Kt), Qt !== null && google.maps.event.removeListener(Qt), en !== null && google.maps.event.removeListener(en), ye !== null && google.maps.event.removeListener(ye), De !== null && google.maps.event.removeListener(De), ze !== null && google.maps.event.removeListener(ze), I && I(ie), r ? r.removeMarker(ie, !!o) : ie && ie.setMap(null);
    };
  }, []);
  var rt = Zn(function() {
    return i ? at.map(i, function(Pe) {
      if (!ci(Pe))
        return Pe;
      var ie = Pe;
      return pi(ie, { anchor: w });
    }) : null;
  }, [i, w]);
  return an.jsx(an.Fragment, { children: rt }) || null;
}
Ie(GU);
/** @class */
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = Ye(Ye(Ye({}, this.props.options || hd), this.props.clusterer ? hd : { map: this.context }), { position: this.props.position });
    this.marker = new google.maps.Marker(n), this.props.clusterer ? this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw) : this.marker.setMap(this.context), this.registeredEvents = Mt({
      updaterMap: _C,
      eventMap: TC,
      prevProps: {},
      nextProps: this.props,
      instance: this.marker
    }), this.props.onLoad && this.props.onLoad(this.marker);
  }, t.prototype.componentDidUpdate = function(n) {
    this.marker && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: _C,
      eventMap: TC,
      prevProps: n,
      nextProps: this.props,
      instance: this.marker
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Rt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }, t.prototype.render = function() {
    var n = this, r = null;
    return this.props.children && (r = at.map(this.props.children, function(o) {
      if (!ci(o))
        return o;
      var i = o;
      return pi(i, { anchor: n.marker });
    })), r || null;
  }, t.contextType = gt, t;
})(Ee);
var XU = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var h = document.createElement("div");
        h.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (h.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (h.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(h), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), YU = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new XU(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function JU(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var KU = 2e3, QU = 500, e$ = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", t$ = "png", n$ = [53, 56, 66, 78, 90], r$ = "cluster", CA = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || e$, this.imageExtension = r.imageExtension || t$, this.imageSizes = r.imageSizes || n$, this.calculator = r.calculator || JU, this.batchSize = r.batchSize || KU, this.batchSizeIE = r.batchSizeIE || QU, this.clusterClass = r.clusterClass || r$, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [
        google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged),
        google.maps.event.addListener(t, "idle", this.onIdle)
      ]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new YU(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var h = d[p];
            h.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Uo = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, nn = {
  averageCenter: function(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE: function(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator: function(e, t) {
    e.setCalculator(t);
  },
  clusterClass: function(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons: function(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize: function(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden: function(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension: function(e, t) {
    e.setImageExtension(t);
  },
  imagePath: function(e, t) {
    e.setImagePath(t);
  },
  imageSizes: function(e, t) {
    e.setImageSizes(t);
  },
  maxZoom: function(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize: function(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles: function(e, t) {
    e.setStyles(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  zoomOnClick: function(e, t) {
    e.setZoomOnClick(t);
  }
}, o$ = {};
function i$(e) {
  var t = e.children, n = e.options, r = e.averageCenter, o = e.batchSizeIE, i = e.calculator, s = e.clusterClass, a = e.enableRetinaIcons, l = e.gridSize, u = e.ignoreHidden, c = e.imageExtension, p = e.imagePath, d = e.imageSizes, h = e.maxZoom, y = e.minimumClusterSize, f = e.styles, g = e.title, x = e.zoomOnClick, L = e.onClick, E = e.onClusteringBegin, T = e.onClusteringEnd, b = e.onMouseOver, C = e.onMouseOut, M = e.onLoad, S = e.onUnmount, F = k(null), D = F[0], Z = F[1], U = Te(gt), $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1];
  return m(function() {
    D && C && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(D, Uo.onMouseOut, C)));
  }, [C]), m(function() {
    D && b && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(D, Uo.onMouseOver, b)));
  }, [b]), m(function() {
    D && L && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(D, Uo.onClick, L)));
  }, [L]), m(function() {
    D && E && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(D, Uo.onClusteringBegin, E)));
  }, [E]), m(function() {
    D && T && (O !== null && google.maps.event.removeListener(O), K(google.maps.event.addListener(D, Uo.onClusteringEnd, T)));
  }, [T]), m(function() {
    typeof r < "u" && D !== null && nn.averageCenter(D, r);
  }, [D, r]), m(function() {
    typeof o < "u" && D !== null && nn.batchSizeIE(D, o);
  }, [D, o]), m(function() {
    typeof i < "u" && D !== null && nn.calculator(D, i);
  }, [D, i]), m(function() {
    typeof s < "u" && D !== null && nn.clusterClass(D, s);
  }, [D, s]), m(function() {
    typeof a < "u" && D !== null && nn.enableRetinaIcons(D, a);
  }, [D, a]), m(function() {
    typeof l < "u" && D !== null && nn.gridSize(D, l);
  }, [D, l]), m(function() {
    typeof u < "u" && D !== null && nn.ignoreHidden(D, u);
  }, [D, u]), m(function() {
    typeof c < "u" && D !== null && nn.imageExtension(D, c);
  }, [D, c]), m(function() {
    typeof p < "u" && D !== null && nn.imagePath(D, p);
  }, [D, p]), m(function() {
    typeof d < "u" && D !== null && nn.imageSizes(D, d);
  }, [D, d]), m(function() {
    typeof h < "u" && D !== null && nn.maxZoom(D, h);
  }, [D, h]), m(function() {
    typeof y < "u" && D !== null && nn.minimumClusterSize(D, y);
  }, [D, y]), m(function() {
    typeof f < "u" && D !== null && nn.styles(D, f);
  }, [D, f]), m(function() {
    typeof g < "u" && D !== null && nn.title(D, g);
  }, [D, g]), m(function() {
    typeof x < "u" && D !== null && nn.zoomOnClick(D, x);
  }, [D, x]), m(function() {
    if (U) {
      var z = Ye({}, n || o$), _ = new CA(U, [], z);
      return r && nn.averageCenter(_, r), o && nn.batchSizeIE(_, o), i && nn.calculator(_, i), s && nn.clusterClass(_, s), a && nn.enableRetinaIcons(_, a), l && nn.gridSize(_, l), u && nn.ignoreHidden(_, u), c && nn.imageExtension(_, c), p && nn.imagePath(_, p), d && nn.imageSizes(_, d), h && nn.maxZoom(_, h), y && nn.minimumClusterSize(_, y), f && nn.styles(_, f), g && nn.title(_, g), x && nn.zoomOnClick(_, x), C && W(google.maps.event.addListener(_, Uo.onMouseOut, C)), b && R(google.maps.event.addListener(_, Uo.onMouseOver, b)), L && V(google.maps.event.addListener(_, Uo.onClick, L)), E && K(google.maps.event.addListener(_, Uo.onClusteringBegin, E)), T && P(google.maps.event.addListener(_, Uo.onClusteringEnd, T)), Z(_), M && M(_), function() {
        I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), S && S(_);
      };
    }
  }, []), D !== null && t(D) || null;
}
Ie(i$);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      markerClusterer: null
    }, n.setClustererCallback = function() {
      n.state.markerClusterer !== null && n.props.onLoad && n.props.onLoad(n.state.markerClusterer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context) {
      var n = new CA(this.context, [], this.props.options);
      this.registeredEvents = Mt({
        updaterMap: nn,
        eventMap: Uo,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          markerClusterer: n
        };
      }, this.setClustererCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.markerClusterer && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: nn,
      eventMap: Uo,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Rt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }, t.prototype.render = function() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }, t.contextType = gt, t;
})(Ee);
function AC(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var xA = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || AC(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = [
            "mousedown",
            "mouseover",
            "mouseout",
            "mouseup",
            "click",
            "dblclick",
            "touchstart",
            "touchend",
            "touchmove"
          ], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, AC));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, h = this.infoBoxClearance.width, y = this.infoBoxClearance.height, f = this.getProjection(), g = f.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + h ? r = g.x + u - h : g.x + p + u + h > a && (r = g.x + p + u + h - a), this.alignBottom ? g.y < -c + y + d ? o = g.y + c - y - d : g.y + c + y > l && (o = g.y + c + y - l) : g.y < -c + y ? o = g.y + c - y : g.y + d + c + y > l && (o = g.y + d + c + y - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = { top: 0, bottom: 0, left: 0, right: 0 };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), BC = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, IC = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, s$ = {};
function a$(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, h = Te(gt), y = k(null), f = y[0], g = y[1], x = k(null), L = x[0], E = x[1], T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = it(null);
  return m(function() {
    h && f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), m(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), m(function() {
    if (o && f !== null) {
      var j = o instanceof google.maps.LatLng ? o : new google.maps.LatLng(o.lat, o.lng);
      f.setPosition(j);
    }
  }, [o]), m(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), m(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), E(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), m(function() {
    f && a && (b !== null && google.maps.event.removeListener(b), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), m(function() {
    f && l && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), m(function() {
    f && u && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), m(function() {
    f && c && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), m(function() {
    if (h) {
      var j = r || s$, K = j.position, te = L0(j, ["position"]), O = void 0;
      K && !(K instanceof google.maps.LatLng) && (O = new google.maps.LatLng(K.lat, K.lng));
      var P = new xA(Ye(Ye({}, te), O ? { position: O } : {}));
      J.current = document.createElement("div"), g(P), s && E(google.maps.event.addListener(P, "closeclick", s)), a && C(google.maps.event.addListener(P, "domready", a)), l && F(google.maps.event.addListener(P, "content_changed", l)), u && U(google.maps.event.addListener(P, "position_changed", u)), c && V(google.maps.event.addListener(P, "zindex_changed", c)), P.setContent(J.current), n ? P.open(h, n) : P.getPosition() ? P.open(h) : Ar(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(P);
    }
    return function() {
      f !== null && (L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), Z && google.maps.event.removeListener(Z), N && google.maps.event.removeListener(N), d && d(f), f.close());
    };
  }, []), J.current ? Nr(at.only(t), J.current) : null;
}
Ie(a$);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoBox: null
    }, n.open = function(r, o) {
      o ? n.context !== null && r.open(n.context, o) : r.getPosition() ? n.context !== null && r.open(n.context) : Ar(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }, n.setInfoBoxCallback = function() {
      n.state.infoBox !== null && n.containerElement !== null && (n.state.infoBox.setContent(n.containerElement), n.open(n.state.infoBox, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoBox));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.props.options || {}, r = n.position, o = L0(n, ["position"]), i;
    r && !(r instanceof google.maps.LatLng) && (i = new google.maps.LatLng(r.lat, r.lng));
    var s = new xA(Ye(Ye({}, o), i ? { position: i } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Mt({
      updaterMap: IC,
      eventMap: BC,
      prevProps: {},
      nextProps: this.props,
      instance: s
    }), this.setState({ infoBox: s }, this.setInfoBoxCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = this.state.infoBox;
    r !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: IC,
      eventMap: BC,
      prevProps: n,
      nextProps: this.props,
      instance: r
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n = this.props.onUnmount, r = this.state.infoBox;
    r !== null && (n && n(r), Rt(this.registeredEvents), r.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Nr(at.only(this.props.children), this.containerElement) : null;
  }, t.contextType = gt, t;
})(Ee);
var l$ = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, o, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
    for (o = r; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
    for (o = r; o-- !== 0; ) {
      var s = i[o];
      if (!e(t[s], n[s])) return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
}, jC = /* @__PURE__ */ mA(l$);
const RC = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], og = 1, pl = 8;
class k0 {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const o = r >> 4;
    if (o !== og)
      throw new Error(`Got v${o} data when expected v${og}.`);
    const i = RC[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new k0(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, o) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = RC.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, pl, t), this.coords = new this.ArrayType(this.data, pl + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(pl + s + a + l), this.ids = new this.IndexArrayType(this.data, pl, t), this.coords = new this.ArrayType(this.data, pl + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (og << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return Mv(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: s, nodeSize: a } = this, l = [0, i.length - 1, 0], u = [];
    for (; l.length; ) {
      const c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (let g = d; g <= p; g++) {
          const x = s[2 * g], L = s[2 * g + 1];
          x >= t && x <= r && L >= n && L <= o && u.push(i[g]);
        }
        continue;
      }
      const h = d + p >> 1, y = s[2 * h], f = s[2 * h + 1];
      y >= t && y <= r && f >= n && f <= o && u.push(i[h]), (c === 0 ? t <= y : n <= f) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= y : o >= f) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: o, coords: i, nodeSize: s } = this, a = [0, o.length - 1, 0], l = [], u = r * r;
    for (; a.length; ) {
      const c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (let g = d; g <= p; g++)
          NC(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      const h = d + p >> 1, y = i[2 * h], f = i[2 * h + 1];
      NC(y, f, t, n) <= u && l.push(o[h]), (c === 0 ? t - r <= y : n - r <= f) && (a.push(d), a.push(h - 1), a.push(1 - c)), (c === 0 ? t + r >= y : n + r >= f) && (a.push(h + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function Mv(e, t, n, r, o, i) {
  if (o - r <= n) return;
  const s = r + o >> 1;
  EA(e, t, s, r, o, i), Mv(e, t, n, r, s - 1, 1 - i), Mv(e, t, n, s + 1, o, 1 - i);
}
function EA(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      const u = o - r + 1, c = n - r + 1, p = Math.log(u), d = 0.5 * Math.exp(2 * p / 3), h = 0.5 * Math.sqrt(p * d * (u - d) / u) * (c - u / 2 < 0 ? -1 : 1), y = Math.max(r, Math.floor(n - c * d / u + h)), f = Math.min(o, Math.floor(n + (u - c) * d / u + h));
      EA(e, t, n, y, f, i);
    }
    const s = t[2 * n + i];
    let a = r, l = o;
    for (dl(e, t, r, n), t[2 * o + i] > s && dl(e, t, r, o); a < l; ) {
      for (dl(e, t, a, l), a++, l--; t[2 * a + i] < s; ) a++;
      for (; t[2 * l + i] > s; ) l--;
    }
    t[2 * r + i] === s ? dl(e, t, r, l) : (l++, dl(e, t, l, o)), l <= n && (r = l + 1), n <= l && (o = l - 1);
  }
}
function dl(e, t, n, r) {
  ig(e, n, r), ig(t, 2 * n, 2 * r), ig(t, 2 * n + 1, 2 * r + 1);
}
function ig(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function NC(e, t, n, r) {
  const o = e - n, i = t - r;
  return o * o + i * i;
}
const u$ = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, FC = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), $s = 2, cs = 3, sg = 4, is = 5, LA = 6;
class c$ {
  constructor(t) {
    this.options = Object.assign(Object.create(u$), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    const { log: n, minZoom: r, maxZoom: o } = this.options;
    n && console.time("total time");
    const i = `prepare ${t.length} points`;
    n && console.time(i), this.points = t;
    const s = [];
    for (let l = 0; l < t.length; l++) {
      const u = t[l];
      if (!u.geometry) continue;
      const [c, p] = u.geometry.coordinates, d = FC(kc(c)), h = FC(Oc(p));
      s.push(
        d,
        h,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        l,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && s.push(0);
    }
    let a = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (let l = o; l >= r; l--) {
      const u = +Date.now();
      a = this.trees[l] = this._createTree(this._cluster(a, l)), n && console.log("z%d: %d clusters in %dms", l, a.numItems, +Date.now() - u);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    let r = ((t[0] + 180) % 360 + 360) % 360 - 180;
    const o = Math.max(-90, Math.min(90, t[1]));
    let i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
    const s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      const p = this.getClusters([r, o, 180, s], n), d = this.getClusters([-180, o, i, s], n);
      return p.concat(d);
    }
    const a = this.trees[this._limitZoom(n)], l = a.range(kc(r), Oc(s), kc(i), Oc(o)), u = a.data, c = [];
    for (const p of l) {
      const d = this.stride * p;
      c.push(u[d + is] > 1 ? zC(u, d, this.clusterProps) : this.points[u[d + cs]]);
    }
    return c;
  }
  getChildren(t) {
    const n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    const s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    const a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (const d of c) {
      const h = d * this.stride;
      s[h + sg] === t && p.push(s[h + is] > 1 ? zC(s, h, this.clusterProps) : this.points[s[h + cs]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    const o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    const o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), { extent: s, radius: a } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(
      o.range((n - l) / i, u, (n + 1 + l) / i, c),
      o.data,
      n,
      r,
      i,
      p
    ), n === 0 && this._addTileFeatures(
      o.range(1 - l / i, u, 1, c),
      o.data,
      i,
      r,
      i,
      p
    ), n === i - 1 && this._addTileFeatures(
      o.range(0, u, l / i, c),
      o.data,
      -1,
      r,
      i,
      p
    ), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    let n = this._getOriginZoom(t) - 1;
    for (; n <= this.options.maxZoom; ) {
      const r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    const s = this.getChildren(n);
    for (const a of s) {
      const l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    const n = new k0(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (const a of t) {
      const l = a * this.stride, u = n[l + is] > 1;
      let c, p, d;
      if (u)
        c = kA(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        const f = this.points[n[l + cs]];
        c = f.properties;
        const [g, x] = f.geometry.coordinates;
        p = kc(g), d = Oc(x);
      }
      const h = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (p * i - r)),
          Math.round(this.options.extent * (d * i - o))
        ]],
        tags: c
      };
      let y;
      u || this.options.generateId ? y = n[l + cs] : y = this.points[n[l + cs]].id, y !== void 0 && (h.id = y), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    const { radius: r, extent: o, reduce: i, minPoints: s } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride;
    for (let p = 0; p < l.length; p += c) {
      if (l[p + $s] <= n) continue;
      l[p + $s] = n;
      const d = l[p], h = l[p + 1], y = t.within(l[p], l[p + 1], a), f = l[p + is];
      let g = f;
      for (const x of y) {
        const L = x * c;
        l[L + $s] > n && (g += l[L + is]);
      }
      if (g > f && g >= s) {
        let x = d * f, L = h * f, E, T = -1;
        const b = ((p / c | 0) << 5) + (n + 1) + this.points.length;
        for (const C of y) {
          const M = C * c;
          if (l[M + $s] <= n) continue;
          l[M + $s] = n;
          const S = l[M + is];
          x += l[M] * S, L += l[M + 1] * S, l[M + sg] = b, i && (E || (E = this._map(l, p, !0), T = this.clusterProps.length, this.clusterProps.push(E)), i(E, this._map(l, M)));
        }
        l[p + sg] = b, u.push(x / g, L / g, 1 / 0, b, -1, g), i && u.push(T);
      } else {
        for (let x = 0; x < c; x++) u.push(l[p + x]);
        if (g > 1)
          for (const x of y) {
            const L = x * c;
            if (!(l[L + $s] <= n)) {
              l[L + $s] = n;
              for (let E = 0; E < c; E++) u.push(l[L + E]);
            }
          }
      }
    }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + is] > 1) {
      const s = this.clusterProps[t[n + LA]];
      return r ? Object.assign({}, s) : s;
    }
    const o = this.points[t[n + cs]].properties, i = this.options.map(o);
    return r && i === o ? Object.assign({}, i) : i;
  }
}
function zC(e, t, n) {
  return {
    type: "Feature",
    id: e[t + cs],
    properties: kA(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [p$(e[t]), d$(e[t + 1])]
    }
  };
}
function kA(e, t, n) {
  const r = e[t + is], o = r >= 1e4 ? `${Math.round(r / 1e3)}k` : r >= 1e3 ? `${Math.round(r / 100) / 10}k` : r, i = e[t + LA], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + cs],
    point_count: r,
    point_count_abbreviated: o
  });
}
function kc(e) {
  return e / 360 + 0.5;
}
function Oc(e) {
  const t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function p$(e) {
  return (e - 0.5) * 360;
}
function d$(e) {
  const t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function f$(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Lo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Sv {
  constructor({ markers: t, position: n }) {
    this.markers = t, n && (n instanceof google.maps.LatLng ? this._position = n : this._position = new google.maps.LatLng(n));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const t = new google.maps.LatLngBounds(this._position, this._position);
    for (const n of this.markers)
      t.extend(Lo.getPosition(n));
    return t;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Lo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Lo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class h$ {
  constructor({ maxZoom: t = 16 }) {
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: t }) {
    return g$(t);
  }
}
const g$ = (e) => e.map((t) => new Sv({
  position: Lo.getPosition(t),
  markers: [t]
}));
class m$ extends h$ {
  constructor(t) {
    var { maxZoom: n, radius: r = 60 } = t, o = f$(t, ["maxZoom", "radius"]);
    super({ maxZoom: n }), this.state = { zoom: -1 }, this.superCluster = new c$(Object.assign({ maxZoom: this.maxZoom, radius: r }, o));
  }
  calculate(t) {
    let n = !1;
    const r = { zoom: t.map.getZoom() };
    if (!jC(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      const o = this.markers.map((i) => {
        const s = Lo.getPosition(i);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [s.lng(), s.lat()]
          },
          properties: { marker: i }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !jC(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), { clusters: this.clusters, changed: n };
  }
  cluster({ map: t }) {
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t.getZoom())).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [t, n] }, properties: r }) {
    if (r.cluster)
      return new Sv({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((i) => i.properties.marker),
        position: { lat: n, lng: t }
      });
    const o = r.marker;
    return new Sv({
      markers: [o],
      position: Lo.getPosition(o)
    });
  }
}
class v$ {
  constructor(t, n) {
    this.markers = { sum: t.length };
    const r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class y$ {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: t, position: n }, r, o) {
    const i = `<svg fill="${t > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>
</svg>`, s = `Cluster of ${t} markers`, a = Number(google.maps.Marker.MAX_ZINDEX) + t;
    if (Lo.isAdvancedMarkerAvailable(o)) {
      const u = new DOMParser().parseFromString(i, "image/svg+xml").documentElement;
      u.setAttribute("transform", "translate(0 25)");
      const c = {
        map: o,
        position: n,
        zIndex: a,
        title: s,
        content: u
      };
      return new google.maps.marker.AdvancedMarkerElement(c);
    }
    const l = {
      position: n,
      zIndex: a,
      title: s,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(i)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(l);
  }
}
function b$(e, t) {
  for (let n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class O0 {
  constructor() {
    b$(O0, google.maps.OverlayView);
  }
}
var $l;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})($l || ($l = {}));
const w$ = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class C$ extends O0 {
  constructor({ map: t, markers: n = [], algorithmOptions: r = {}, algorithm: o = new m$(r), renderer: i = new y$(), onClusterClick: s = w$ }) {
    super(), this.markers = [...n], this.clusters = [], this.algorithm = o, this.renderer = i, this.onClusterClick = s, t && this.setMap(t);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    const r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Lo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    let r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, $l.CLUSTERING_BEGIN, this);
      const { clusters: n, changed: r } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        const o = /* @__PURE__ */ new Set();
        for (const s of n)
          s.markers.length == 1 && o.add(s.markers[0]);
        const i = [];
        for (const s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Lo.setMap(s.marker, null) : i.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => i.forEach((s) => Lo.setMap(s, null)));
      }
      google.maps.event.trigger(this, $l.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Lo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    const t = new v$(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Lo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, $l.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Lo.setMap(r.marker, n);
    });
  }
}
function x$(e) {
  var t = BU(), n = k(null), r = n[0], o = n[1];
  return m(function() {
    if (t && r === null) {
      var i = new C$(Ye(Ye({}, e), { map: t }));
      o(i);
    }
  }, [t]), r;
}
function E$(e) {
  var t = e.children, n = e.options, r = x$(n);
  return r !== null ? t(r) : null;
}
Ie(E$);
var UC = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, $C = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
function L$(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, h = Te(gt), y = k(null), f = y[0], g = y[1], x = k(null), L = x[0], E = x[1], T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = it(null);
  return m(function() {
    f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), m(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), m(function() {
    o && f !== null && f.setPosition(o);
  }, [o]), m(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), m(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), E(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), m(function() {
    f && a && (b !== null && google.maps.event.removeListener(b), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), m(function() {
    f && l && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), m(function() {
    f && u && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), m(function() {
    f && c && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), m(function() {
    var j = new google.maps.InfoWindow(Ye({}, r || {}));
    return g(j), J.current = document.createElement("div"), s && E(google.maps.event.addListener(j, "closeclick", s)), a && C(google.maps.event.addListener(j, "domready", a)), l && F(google.maps.event.addListener(j, "content_changed", l)), u && U(google.maps.event.addListener(j, "position_changed", u)), c && V(google.maps.event.addListener(j, "zindex_changed", c)), j.setContent(J.current), o && j.setPosition(o), i && j.setZIndex(i), n ? j.open(h, n) : j.getPosition() ? j.open(h) : Ar(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(j), function() {
      L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), Z && google.maps.event.removeListener(Z), N && google.maps.event.removeListener(N), d && d(j), j.close();
    };
  }, []), J.current ? Nr(at.only(t), J.current) : null;
}
Ie(L$);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoWindow: null
    }, n.open = function(r, o) {
      o ? r.open(n.context, o) : r.getPosition() ? r.open(n.context) : Ar(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }, n.setInfoWindowCallback = function() {
      n.state.infoWindow !== null && n.containerElement !== null && (n.state.infoWindow.setContent(n.containerElement), n.open(n.state.infoWindow, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoWindow));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.InfoWindow(Ye({}, this.props.options || {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Mt({
      updaterMap: $C,
      eventMap: UC,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        infoWindow: n
      };
    }, this.setInfoWindowCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.infoWindow !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: $C,
      eventMap: UC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.infoWindow !== null && (Rt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Nr(at.only(this.props.children), this.containerElement) : null;
  }, t.contextType = gt, t;
})(Ee);
var WC = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, HC = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, k$ = {};
function O$(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, h = e.onMouseUp, y = e.onRightClick, f = e.onClick, g = e.onDrag, x = e.onLoad, L = e.onUnmount, E = Te(gt), T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1];
  return m(function() {
    b !== null && b.setMap(E);
  }, [E]), m(function() {
    typeof t < "u" && b !== null && b.setOptions(t);
  }, [b, t]), m(function() {
    typeof n < "u" && b !== null && b.setDraggable(n);
  }, [b, n]), m(function() {
    typeof r < "u" && b !== null && b.setEditable(r);
  }, [b, r]), m(function() {
    typeof o < "u" && b !== null && b.setVisible(o);
  }, [b, o]), m(function() {
    typeof i < "u" && b !== null && b.setPath(i);
  }, [b, i]), m(function() {
    b && s && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(b, "dblclick", s)));
  }, [s]), m(function() {
    b && a && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(b, "dragend", a)));
  }, [a]), m(function() {
    b && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(b, "dragstart", l)));
  }, [l]), m(function() {
    b && u && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(b, "mousedown", u)));
  }, [u]), m(function() {
    b && c && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(b, "mousemove", c)));
  }, [c]), m(function() {
    b && p && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(b, "mouseout", p)));
  }, [p]), m(function() {
    b && d && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(b, "mouseover", d)));
  }, [d]), m(function() {
    b && h && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(b, "mouseup", h)));
  }, [h]), m(function() {
    b && y && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(b, "rightclick", y)));
  }, [y]), m(function() {
    b && f && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(b, "click", f)));
  }, [f]), m(function() {
    b && g && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(b, "drag", g)));
  }, [g]), m(function() {
    var se = new google.maps.Polyline(Ye(Ye({}, t || k$), { map: E }));
    return i && se.setPath(i), typeof o < "u" && se.setVisible(o), typeof r < "u" && se.setEditable(r), typeof n < "u" && se.setDraggable(n), s && F(google.maps.event.addListener(se, "dblclick", s)), a && U(google.maps.event.addListener(se, "dragend", a)), l && V(google.maps.event.addListener(se, "dragstart", l)), u && K(google.maps.event.addListener(se, "mousedown", u)), c && P(google.maps.event.addListener(se, "mousemove", c)), p && W(google.maps.event.addListener(se, "mouseout", p)), d && R(google.maps.event.addListener(se, "mouseover", d)), h && Y(google.maps.event.addListener(se, "mouseup", h)), y && ae(google.maps.event.addListener(se, "rightclick", y)), f && de(google.maps.event.addListener(se, "click", f)), g && ge(google.maps.event.addListener(se, "drag", g)), C(se), x && x(se), function() {
      S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), L && L(se), se.setMap(null);
    };
  }, []), null;
}
Ie(O$);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polyline: null
    }, n.setPolylineCallback = function() {
      n.state.polyline !== null && n.props.onLoad && n.props.onLoad(n.state.polyline);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polyline(Ye(Ye({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Mt({
      updaterMap: HC,
      eventMap: WC,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polyline: n
      };
    }, this.setPolylineCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polyline !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: HC,
      eventMap: WC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Rt(this.registeredEvents), this.state.polyline.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = gt, t;
})(Ee);
var VC = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, ZC = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  paths: function(e, t) {
    e.setPaths(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function M$(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.paths, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, h = e.onMouseOver, y = e.onMouseUp, f = e.onRightClick, g = e.onClick, x = e.onDrag, L = e.onLoad, E = e.onUnmount, T = e.onEdit, b = Te(gt), C = k(null), M = C[0], S = C[1], F = k(null), D = F[0], Z = F[1], U = k(null), $ = U[0], N = U[1], V = k(null), J = V[0], j = V[1], K = k(null), te = K[0], O = K[1], P = k(null), H = P[0], I = P[1], W = k(null), X = W[0], w = W[1], R = k(null), z = R[0], _ = R[1], Y = k(null), Q = Y[0], A = Y[1], ae = k(null), ce = ae[0], ue = ae[1], de = k(null), be = de[0], ve = de[1], ge = k(null), se = ge[0], xe = ge[1];
  return m(function() {
    M !== null && M.setMap(b);
  }, [b]), m(function() {
    typeof t < "u" && M !== null && M.setOptions(t);
  }, [M, t]), m(function() {
    typeof n < "u" && M !== null && M.setDraggable(n);
  }, [M, n]), m(function() {
    typeof r < "u" && M !== null && M.setEditable(r);
  }, [M, r]), m(function() {
    typeof o < "u" && M !== null && M.setVisible(o);
  }, [M, o]), m(function() {
    typeof i < "u" && M !== null && M.setPath(i);
  }, [M, i]), m(function() {
    typeof s < "u" && M !== null && M.setPaths(s);
  }, [M, s]), m(function() {
    M && a && (D !== null && google.maps.event.removeListener(D), Z(google.maps.event.addListener(M, "dblclick", a)));
  }, [a]), m(function() {
    M && (google.maps.event.addListener(M.getPath(), "insert_at", function() {
      T == null || T(M);
    }), google.maps.event.addListener(M.getPath(), "set_at", function() {
      T == null || T(M);
    }));
  }, [M, T]), m(function() {
    M && l && ($ !== null && google.maps.event.removeListener($), N(google.maps.event.addListener(M, "dragend", l)));
  }, [l]), m(function() {
    M && u && (J !== null && google.maps.event.removeListener(J), j(google.maps.event.addListener(M, "dragstart", u)));
  }, [u]), m(function() {
    M && c && (te !== null && google.maps.event.removeListener(te), O(google.maps.event.addListener(M, "mousedown", c)));
  }, [c]), m(function() {
    M && p && (H !== null && google.maps.event.removeListener(H), I(google.maps.event.addListener(M, "mousemove", p)));
  }, [p]), m(function() {
    M && d && (X !== null && google.maps.event.removeListener(X), w(google.maps.event.addListener(M, "mouseout", d)));
  }, [d]), m(function() {
    M && h && (z !== null && google.maps.event.removeListener(z), _(google.maps.event.addListener(M, "mouseover", h)));
  }, [h]), m(function() {
    M && y && (Q !== null && google.maps.event.removeListener(Q), A(google.maps.event.addListener(M, "mouseup", y)));
  }, [y]), m(function() {
    M && f && (ce !== null && google.maps.event.removeListener(ce), ue(google.maps.event.addListener(M, "rightclick", f)));
  }, [f]), m(function() {
    M && g && (be !== null && google.maps.event.removeListener(be), ve(google.maps.event.addListener(M, "click", g)));
  }, [g]), m(function() {
    M && x && (se !== null && google.maps.event.removeListener(se), xe(google.maps.event.addListener(M, "drag", x)));
  }, [x]), m(function() {
    var ne = new google.maps.Polygon(Ye(Ye({}, t || {}), { map: b }));
    return i && ne.setPath(i), s && ne.setPaths(s), typeof o < "u" && ne.setVisible(o), typeof r < "u" && ne.setEditable(r), typeof n < "u" && ne.setDraggable(n), a && Z(google.maps.event.addListener(ne, "dblclick", a)), l && N(google.maps.event.addListener(ne, "dragend", l)), u && j(google.maps.event.addListener(ne, "dragstart", u)), c && O(google.maps.event.addListener(ne, "mousedown", c)), p && I(google.maps.event.addListener(ne, "mousemove", p)), d && w(google.maps.event.addListener(ne, "mouseout", d)), h && _(google.maps.event.addListener(ne, "mouseover", h)), y && A(google.maps.event.addListener(ne, "mouseup", y)), f && ue(google.maps.event.addListener(ne, "rightclick", f)), g && ve(google.maps.event.addListener(ne, "click", g)), x && xe(google.maps.event.addListener(ne, "drag", x)), S(ne), L && L(ne), function() {
      D !== null && google.maps.event.removeListener(D), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), H !== null && google.maps.event.removeListener(H), X !== null && google.maps.event.removeListener(X), z !== null && google.maps.event.removeListener(z), Q !== null && google.maps.event.removeListener(Q), ce !== null && google.maps.event.removeListener(ce), be !== null && google.maps.event.removeListener(be), E && E(ne), ne.setMap(null);
    };
  }, []), null;
}
Ie(M$);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polygon: null
    }, n.setPolygonCallback = function() {
      n.state.polygon !== null && n.props.onLoad && n.props.onLoad(n.state.polygon);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polygon(Ye(Ye({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Mt({
      updaterMap: ZC,
      eventMap: VC,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polygon: n
      };
    }, this.setPolygonCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polygon !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: ZC,
      eventMap: VC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polygon
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polygon !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polygon), Rt(this.registeredEvents), this.state.polygon && this.state.polygon.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = gt, t;
})(Ee);
var qC = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, GC = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function S$(e) {
  var t = e.options, n = e.bounds, r = e.draggable, o = e.editable, i = e.visible, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, h = e.onMouseUp, y = e.onRightClick, f = e.onClick, g = e.onDrag, x = e.onBoundsChanged, L = e.onLoad, E = e.onUnmount, T = Te(gt), b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1], j = k(null), K = j[0], te = j[1], O = k(null), P = O[0], H = O[1], I = k(null), W = I[0], X = I[1], w = k(null), R = w[0], z = w[1], _ = k(null), Y = _[0], Q = _[1], A = k(null), ae = A[0], ce = A[1], ue = k(null), de = ue[0], be = ue[1], ve = k(null), ge = ve[0], se = ve[1], xe = k(null), ne = xe[0], Me = xe[1];
  return m(function() {
    C !== null && C.setMap(T);
  }, [T]), m(function() {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), m(function() {
    typeof r < "u" && C !== null && C.setDraggable(r);
  }, [C, r]), m(function() {
    typeof o < "u" && C !== null && C.setEditable(o);
  }, [C, o]), m(function() {
    typeof i < "u" && C !== null && C.setVisible(i);
  }, [C, i]), m(function() {
    typeof n < "u" && C !== null && C.setBounds(n);
  }, [C, n]), m(function() {
    C && s && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), m(function() {
    C && a && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(C, "dragend", a)));
  }, [a]), m(function() {
    C && l && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(C, "dragstart", l)));
  }, [l]), m(function() {
    C && u && (K !== null && google.maps.event.removeListener(K), te(google.maps.event.addListener(C, "mousedown", u)));
  }, [u]), m(function() {
    C && c && (P !== null && google.maps.event.removeListener(P), H(google.maps.event.addListener(C, "mousemove", c)));
  }, [c]), m(function() {
    C && p && (W !== null && google.maps.event.removeListener(W), X(google.maps.event.addListener(C, "mouseout", p)));
  }, [p]), m(function() {
    C && d && (R !== null && google.maps.event.removeListener(R), z(google.maps.event.addListener(C, "mouseover", d)));
  }, [d]), m(function() {
    C && h && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(C, "mouseup", h)));
  }, [h]), m(function() {
    C && y && (ae !== null && google.maps.event.removeListener(ae), ce(google.maps.event.addListener(C, "rightclick", y)));
  }, [y]), m(function() {
    C && f && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(C, "click", f)));
  }, [f]), m(function() {
    C && g && (ge !== null && google.maps.event.removeListener(ge), se(google.maps.event.addListener(C, "drag", g)));
  }, [g]), m(function() {
    C && x && (ne !== null && google.maps.event.removeListener(ne), Me(google.maps.event.addListener(C, "bounds_changed", x)));
  }, [x]), m(function() {
    var ee = new google.maps.Rectangle(Ye(Ye({}, t || {}), { map: T }));
    return typeof i < "u" && ee.setVisible(i), typeof o < "u" && ee.setEditable(o), typeof r < "u" && ee.setDraggable(r), typeof n < "u" && ee.setBounds(n), s && D(google.maps.event.addListener(ee, "dblclick", s)), a && $(google.maps.event.addListener(ee, "dragend", a)), l && J(google.maps.event.addListener(ee, "dragstart", l)), u && te(google.maps.event.addListener(ee, "mousedown", u)), c && H(google.maps.event.addListener(ee, "mousemove", c)), p && X(google.maps.event.addListener(ee, "mouseout", p)), d && z(google.maps.event.addListener(ee, "mouseover", d)), h && Q(google.maps.event.addListener(ee, "mouseup", h)), y && ce(google.maps.event.addListener(ee, "rightclick", y)), f && be(google.maps.event.addListener(ee, "click", f)), g && se(google.maps.event.addListener(ee, "drag", g)), x && Me(google.maps.event.addListener(ee, "bounds_changed", x)), M(ee), L && L(ee), function() {
      F !== null && google.maps.event.removeListener(F), U !== null && google.maps.event.removeListener(U), V !== null && google.maps.event.removeListener(V), K !== null && google.maps.event.removeListener(K), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), R !== null && google.maps.event.removeListener(R), Y !== null && google.maps.event.removeListener(Y), ae !== null && google.maps.event.removeListener(ae), de !== null && google.maps.event.removeListener(de), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), E && E(ee), ee.setMap(null);
    };
  }, []), null;
}
Ie(S$);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      rectangle: null
    }, n.setRectangleCallback = function() {
      n.state.rectangle !== null && n.props.onLoad && n.props.onLoad(n.state.rectangle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Rectangle(Ye(Ye({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Mt({
      updaterMap: GC,
      eventMap: qC,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        rectangle: n
      };
    }, this.setRectangleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.rectangle !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: GC,
      eventMap: qC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Rt(this.registeredEvents), this.state.rectangle.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = gt, t;
})(Ee);
var XC = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, YC = {
  center: function(e, t) {
    e.setCenter(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  radius: function(e, t) {
    e.setRadius(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, D$ = {};
function P$(e) {
  var t = e.options, n = e.center, r = e.radius, o = e.draggable, i = e.editable, s = e.visible, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, h = e.onMouseOver, y = e.onMouseUp, f = e.onRightClick, g = e.onClick, x = e.onDrag, L = e.onCenterChanged, E = e.onRadiusChanged, T = e.onLoad, b = e.onUnmount, C = Te(gt), M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1], se = k(null), xe = se[0], ne = se[1], Me = k(null), ee = Me[0], Ce = Me[1], Be = k(null), _e = Be[0], $e = Be[1];
  return m(function() {
    S !== null && S.setMap(C);
  }, [C]), m(function() {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), m(function() {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), m(function() {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), m(function() {
    typeof s < "u" && S !== null && S.setVisible(s);
  }, [S, s]), m(function() {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), m(function() {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), m(function() {
    S && a && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(S, "dblclick", a)));
  }, [a]), m(function() {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), m(function() {
    S && u && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), m(function() {
    S && c && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), m(function() {
    S && p && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), m(function() {
    S && d && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), m(function() {
    S && h && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(S, "mouseover", h)));
  }, [h]), m(function() {
    S && y && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(S, "mouseup", y)));
  }, [y]), m(function() {
    S && f && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(S, "rightclick", f)));
  }, [f]), m(function() {
    S && g && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(S, "click", g)));
  }, [g]), m(function() {
    S && x && (xe !== null && google.maps.event.removeListener(xe), ne(google.maps.event.addListener(S, "drag", x)));
  }, [x]), m(function() {
    S && L && (ee !== null && google.maps.event.removeListener(ee), Ce(google.maps.event.addListener(S, "center_changed", L)));
  }, [g]), m(function() {
    S && E && (_e !== null && google.maps.event.removeListener(_e), $e(google.maps.event.addListener(S, "radius_changed", E)));
  }, [E]), m(function() {
    var he = new google.maps.Circle(Ye(Ye({}, t || D$), { map: C }));
    return typeof r == "number" && he.setRadius(r), typeof n < "u" && he.setCenter(n), typeof r == "number" && he.setRadius(r), typeof s < "u" && he.setVisible(s), typeof i < "u" && he.setEditable(i), typeof o < "u" && he.setDraggable(o), a && U(google.maps.event.addListener(he, "dblclick", a)), l && V(google.maps.event.addListener(he, "dragend", l)), u && K(google.maps.event.addListener(he, "dragstart", u)), c && P(google.maps.event.addListener(he, "mousedown", c)), p && W(google.maps.event.addListener(he, "mousemove", p)), d && R(google.maps.event.addListener(he, "mouseout", d)), h && Y(google.maps.event.addListener(he, "mouseover", h)), y && ae(google.maps.event.addListener(he, "mouseup", y)), f && de(google.maps.event.addListener(he, "rightclick", f)), g && ge(google.maps.event.addListener(he, "click", g)), x && ne(google.maps.event.addListener(he, "drag", x)), L && Ce(google.maps.event.addListener(he, "center_changed", L)), E && $e(google.maps.event.addListener(he, "radius_changed", E)), F(he), T && T(he), function() {
      Z !== null && google.maps.event.removeListener(Z), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), ve !== null && google.maps.event.removeListener(ve), ee !== null && google.maps.event.removeListener(ee), _e !== null && google.maps.event.removeListener(_e), b && b(he), he.setMap(null);
    };
  }, []), null;
}
Ie(P$);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      circle: null
    }, n.setCircleCallback = function() {
      n.state.circle !== null && n.props.onLoad && n.props.onLoad(n.state.circle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Circle(Ye(Ye({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Mt({
      updaterMap: YC,
      eventMap: XC,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        circle: n
      };
    }, this.setCircleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.circle !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: YC,
      eventMap: XC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n;
    this.state.circle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.circle), Rt(this.registeredEvents), (n = this.state.circle) === null || n === void 0 || n.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = gt, t;
})(Ee);
var JC = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, KC = {
  add: function(e, t) {
    e.add(t);
  },
  addgeojson: function(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains: function(e, t) {
    e.contains(t);
  },
  foreach: function(e, t) {
    e.forEach(t);
  },
  loadgeojson: function(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle: function(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove: function(e, t) {
    e.remove(t);
  },
  revertstyle: function(e, t) {
    e.revertStyle(t);
  },
  controlposition: function(e, t) {
    e.setControlPosition(t);
  },
  controls: function(e, t) {
    e.setControls(t);
  },
  drawingmode: function(e, t) {
    e.setDrawingMode(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  style: function(e, t) {
    e.setStyle(t);
  },
  togeojson: function(e, t) {
    e.toGeoJson(t);
  }
};
function T$(e) {
  var t = e.options, n = e.onClick, r = e.onDblClick, o = e.onMouseDown, i = e.onMouseMove, s = e.onMouseOut, a = e.onMouseOver, l = e.onMouseUp, u = e.onRightClick, c = e.onAddFeature, p = e.onRemoveFeature, d = e.onRemoveProperty, h = e.onSetGeometry, y = e.onSetProperty, f = e.onLoad, g = e.onUnmount, x = Te(gt), L = k(null), E = L[0], T = L[1], b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1], j = k(null), K = j[0], te = j[1], O = k(null), P = O[0], H = O[1], I = k(null), W = I[0], X = I[1], w = k(null), R = w[0], z = w[1], _ = k(null), Y = _[0], Q = _[1], A = k(null), ae = A[0], ce = A[1], ue = k(null), de = ue[0], be = ue[1], ve = k(null), ge = ve[0], se = ve[1], xe = k(null), ne = xe[0], Me = xe[1];
  return m(function() {
    E !== null && E.setMap(x);
  }, [x]), m(function() {
    E && r && (C !== null && google.maps.event.removeListener(C), M(google.maps.event.addListener(E, "dblclick", r)));
  }, [r]), m(function() {
    E && o && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(E, "mousedown", o)));
  }, [o]), m(function() {
    E && i && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(E, "mousemove", i)));
  }, [i]), m(function() {
    E && s && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(E, "mouseout", s)));
  }, [s]), m(function() {
    E && a && (K !== null && google.maps.event.removeListener(K), te(google.maps.event.addListener(E, "mouseover", a)));
  }, [a]), m(function() {
    E && l && (P !== null && google.maps.event.removeListener(P), H(google.maps.event.addListener(E, "mouseup", l)));
  }, [l]), m(function() {
    E && u && (W !== null && google.maps.event.removeListener(W), X(google.maps.event.addListener(E, "rightclick", u)));
  }, [u]), m(function() {
    E && n && (R !== null && google.maps.event.removeListener(R), z(google.maps.event.addListener(E, "click", n)));
  }, [n]), m(function() {
    E && c && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(E, "addfeature", c)));
  }, [c]), m(function() {
    E && p && (ae !== null && google.maps.event.removeListener(ae), ce(google.maps.event.addListener(E, "removefeature", p)));
  }, [p]), m(function() {
    E && d && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(E, "removeproperty", d)));
  }, [d]), m(function() {
    E && h && (ge !== null && google.maps.event.removeListener(ge), se(google.maps.event.addListener(E, "setgeometry", h)));
  }, [h]), m(function() {
    E && y && (ne !== null && google.maps.event.removeListener(ne), Me(google.maps.event.addListener(E, "setproperty", y)));
  }, [y]), m(function() {
    if (x !== null) {
      var ee = new google.maps.Data(Ye(Ye({}, t || {}), { map: x }));
      r && M(google.maps.event.addListener(ee, "dblclick", r)), o && D(google.maps.event.addListener(ee, "mousedown", o)), i && $(google.maps.event.addListener(ee, "mousemove", i)), s && J(google.maps.event.addListener(ee, "mouseout", s)), a && te(google.maps.event.addListener(ee, "mouseover", a)), l && H(google.maps.event.addListener(ee, "mouseup", l)), u && X(google.maps.event.addListener(ee, "rightclick", u)), n && z(google.maps.event.addListener(ee, "click", n)), c && Q(google.maps.event.addListener(ee, "addfeature", c)), p && ce(google.maps.event.addListener(ee, "removefeature", p)), d && be(google.maps.event.addListener(ee, "removeproperty", d)), h && se(google.maps.event.addListener(ee, "setgeometry", h)), y && Me(google.maps.event.addListener(ee, "setproperty", y)), T(ee), f && f(ee);
    }
    return function() {
      E && (C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), U !== null && google.maps.event.removeListener(U), V !== null && google.maps.event.removeListener(V), K !== null && google.maps.event.removeListener(K), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), R !== null && google.maps.event.removeListener(R), Y !== null && google.maps.event.removeListener(Y), ae !== null && google.maps.event.removeListener(ae), de !== null && google.maps.event.removeListener(de), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), g && g(E), E.setMap(null));
    };
  }, []), null;
}
Ie(T$);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      data: null
    }, n.setDataCallback = function() {
      n.state.data !== null && n.props.onLoad && n.props.onLoad(n.state.data);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context !== null) {
      var n = new google.maps.Data(Ye(Ye({}, this.props.options || {}), { map: this.context }));
      this.registeredEvents = Mt({
        updaterMap: KC,
        eventMap: JC,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          data: n
        };
      }, this.setDataCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.data !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: KC,
      eventMap: JC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.data
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Rt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = gt, t;
})(Ee);
var QC = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, ex = {
  options: function(e, t) {
    e.setOptions(t);
  },
  url: function(e, t) {
    e.setUrl(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      kmlLayer: null
    }, n.setKmlLayerCallback = function() {
      n.state.kmlLayer !== null && n.props.onLoad && n.props.onLoad(n.state.kmlLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.KmlLayer(Ye(Ye({}, this.props.options), { map: this.context }));
    this.registeredEvents = Mt({
      updaterMap: ex,
      eventMap: QC,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        kmlLayer: n
      };
    }, this.setKmlLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.kmlLayer !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: ex,
      eventMap: QC,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Rt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = gt, t;
})(Ee);
function OA(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function _$(e, t) {
  return new t(e.lat, e.lng);
}
function A$(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function B$(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function I$(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function j$(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function R$(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var o = r.x, i = r.y;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function MA(e, t, n, r) {
  return n !== void 0 ? j$(e, t, I$(n, google.maps.LatLngBounds, A$)) : R$(e, t, B$(r, google.maps.LatLng, _$));
}
function N$(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function F$(e, t, n, r, o) {
  var i = (
    /** @class */
    function(s) {
      Bn(a, s);
      function a(l, u, c, p) {
        var d = s.call(this) || this;
        return d.container = l, d.pane = u, d.position = c, d.bounds = p, d;
      }
      return a.prototype.onAdd = function() {
        var l, u = (l = this.getPanes()) === null || l === void 0 ? void 0 : l[this.pane];
        u == null || u.appendChild(this.container);
      }, a.prototype.draw = function() {
        for (var l = this.getProjection(), u = Ye({}, this.container ? OA(this.container, o) : {
          x: 0,
          y: 0
        }), c = MA(l, u, this.bounds, this.position), p = 0, d = Object.entries(c); p < d.length; p++) {
          var h = d[p], y = h[0], f = h[1];
          this.container.style[y] = f;
        }
      }, a.prototype.onRemove = function() {
        this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
      }, a;
    }(google.maps.OverlayView)
  );
  return new i(e, t, n, r);
}
function tx(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function nx(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function z$(e) {
  var t = e.position, n = e.bounds, r = e.mapPaneName, o = e.zIndex, i = e.onLoad, s = e.onUnmount, a = e.getPixelPositionOffset, l = e.children, u = Te(gt), c = Zn(function() {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Zn(function() {
    return F$(c, r, t, n, a);
  }, [c, r, t, n]);
  return m(function() {
    return i == null || i(p), p == null || p.setMap(u), function() {
      s == null || s(p), p == null || p.setMap(null);
    };
  }, [u, p]), m(function() {
    c.style.zIndex = "".concat(o);
  }, [o, c]), di.createPortal(l, c);
}
Ie(z$);
(function(e) {
  Bn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    r.state = {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }, r.updatePane = function() {
      var i = r.props.mapPaneName, s = r.overlayView.getPanes();
      Ar(!!i, "OverlayView requires props.mapPaneName but got %s", i), s ? r.setState({
        paneEl: s[i]
      }) : r.setState({
        paneEl: null
      });
    }, r.onAdd = function() {
      var i, s;
      r.updatePane(), (s = (i = r.props).onLoad) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.onPositionElement = function() {
      var i = r.overlayView.getProjection(), s = Ye({ x: 0, y: 0 }, r.containerRef.current ? OA(r.containerRef.current, r.props.getPixelPositionOffset) : {}), a = MA(i, s, r.props.bounds, r.props.position), l = r.state.containerStyle, u = l.left, c = l.top, p = l.width, d = l.height;
      N$(a, { left: u, top: c, width: p, height: d }) || r.setState({
        containerStyle: {
          top: a.top || 0,
          left: a.left || 0,
          width: a.width || 0,
          height: a.height || 0,
          position: "absolute"
        }
      });
    }, r.draw = function() {
      r.onPositionElement();
    }, r.onRemove = function() {
      var i, s;
      r.setState(function() {
        return {
          paneEl: null
        };
      }), (s = (i = r.props).onUnmount) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.containerRef = Rr();
    var o = new google.maps.OverlayView();
    return o.onAdd = r.onAdd, o.draw = r.draw, o.onRemove = r.onRemove, r.overlayView = o, r;
  }
  return t.prototype.componentDidMount = function() {
    this.overlayView.setMap(this.context);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = tx(n.position), o = tx(this.props.position), i = nx(n.bounds), s = nx(this.props.bounds);
    (r !== o || i !== s) && this.overlayView.draw(), n.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }, t.prototype.componentWillUnmount = function() {
    this.overlayView.setMap(null);
  }, t.prototype.render = function() {
    var n = this.state.paneEl;
    return n ? di.createPortal(an.jsx("div", { ref: this.containerRef, style: this.state.containerStyle, children: at.only(this.props.children) }), n) : null;
  }, t.FLOAT_PANE = "floatPane", t.MAP_PANE = "mapPane", t.MARKER_LAYER = "markerLayer", t.OVERLAY_LAYER = "overlayLayer", t.OVERLAY_MOUSE_TARGET = "overlayMouseTarget", t.contextType = gt, t;
})(Ee);
function U$() {
}
var rx = {
  onDblClick: "dblclick",
  onClick: "click"
}, ox = {
  opacity: function(e, t) {
    e.setOpacity(t);
  }
};
function $$(e) {
  var t = e.url, n = e.bounds, r = e.options, o = e.visible, i = Te(gt), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Zn(function() {
    var l = new google.maps.GroundOverlay(t, s, Ye({}, r));
    return l;
  }, []);
  return m(function() {
    a !== null && a.setMap(i);
  }, [i]), m(function() {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), m(function() {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), m(function() {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Ie($$);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      groundOverlay: null
    }, n.setGroundOverlayCallback = function() {
      n.state.groundOverlay !== null && n.props.onLoad && n.props.onLoad(n.state.groundOverlay);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Ar(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var n = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Ye(Ye({}, this.props.options), { map: this.context }));
    this.registeredEvents = Mt({
      updaterMap: ox,
      eventMap: rx,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        groundOverlay: n
      };
    }, this.setGroundOverlayCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.groundOverlay !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: ox,
      eventMap: rx,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.defaultProps = {
    onLoad: U$
  }, t.contextType = gt, t;
})(Ee);
var ix = {}, sx = {
  data: function(e, t) {
    e.setData(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function W$(e) {
  var t = e.data, n = e.onLoad, r = e.onUnmount, o = e.options, i = Te(gt), s = k(null), a = s[0], l = s[1];
  return m(function() {
    google.maps.visualization || Ar(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), m(function() {
    Ar(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), m(function() {
    a !== null && a.setMap(i);
  }, [i]), m(function() {
    o && a !== null && a.setOptions(o);
  }, [a, o]), m(function() {
    var u = new google.maps.visualization.HeatmapLayer(Ye(Ye({}, o || {}), { data: t, map: i }));
    return l(u), n && n(u), function() {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Ie(W$);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      heatmapLayer: null
    }, n.setHeatmapLayerCallback = function() {
      n.state.heatmapLayer !== null && n.props.onLoad && n.props.onLoad(n.state.heatmapLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Ar(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Ar(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var n = new google.maps.visualization.HeatmapLayer(Ye(Ye({}, this.props.options || {}), { data: this.props.data, map: this.context }));
    this.registeredEvents = Mt({
      updaterMap: sx,
      eventMap: ix,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        heatmapLayer: n
      };
    }, this.setHeatmapLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: sx,
      eventMap: ix,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Rt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = gt, t;
})(Ee);
var ax = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, lx = {
  register: function(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links: function(e, t) {
    e.setLinks(t);
  },
  motionTracking: function(e, t) {
    e.setMotionTracking(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  pano: function(e, t) {
    e.setPano(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  pov: function(e, t) {
    e.setPov(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      streetViewPanorama: null
    }, n.setStreetViewPanoramaCallback = function() {
      n.state.streetViewPanorama !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewPanorama);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n, r, o = (r = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && r !== void 0 ? r : null;
    this.registeredEvents = Mt({
      updaterMap: lx,
      eventMap: ax,
      prevProps: {},
      nextProps: this.props,
      instance: o
    }), this.setState(function() {
      return {
        streetViewPanorama: o
      };
    }, this.setStreetViewPanoramaCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.streetViewPanorama !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: lx,
      eventMap: ax,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Rt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = gt, t;
})(Ee);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      streetViewService: null
    }, n.setStreetViewServiceCallback = function() {
      n.state.streetViewService !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: n
      };
    }, this.setStreetViewServiceCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = gt, t;
})(Ee);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      directionsService: null
    }, n.setDirectionsServiceCallback = function() {
      n.state.directionsService !== null && n.props.onLoad && n.props.onLoad(n.state.directionsService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Ar(!!this.props.options, "DirectionsService expected options object as parameter, but got %s", this.props.options);
    var n = new google.maps.DirectionsService();
    this.setState(function() {
      return {
        directionsService: n
      };
    }, this.setDirectionsServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.directionsService !== null && this.state.directionsService.route(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsService !== null && this.props.onUnmount && this.props.onUnmount(this.state.directionsService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Ee);
var ux = {
  onDirectionsChanged: "directions_changed"
}, cx = {
  directions: function(e, t) {
    e.setDirections(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  panel: function(e, t) {
    e.setPanel(t);
  },
  routeIndex: function(e, t) {
    e.setRouteIndex(t);
  }
};
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      directionsRenderer: null
    }, n.setDirectionsRendererCallback = function() {
      n.state.directionsRenderer !== null && (n.state.directionsRenderer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.directionsRenderer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Mt({
      updaterMap: cx,
      eventMap: ux,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        directionsRenderer: n
      };
    }, this.setDirectionsRendererCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.directionsRenderer !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: cx,
      eventMap: ux,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Rt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }, t.prototype.render = function() {
    return an.jsx(an.Fragment, {});
  }, t.contextType = gt, t;
})(Ee);
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      distanceMatrixService: null
    }, n.setDistanceMatrixServiceCallback = function() {
      n.state.distanceMatrixService !== null && n.props.onLoad && n.props.onLoad(n.state.distanceMatrixService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Ar(!!this.props.options, "DistanceMatrixService expected options object as parameter, but go %s", this.props.options);
    var n = new google.maps.DistanceMatrixService();
    this.setState(function() {
      return {
        distanceMatrixService: n
      };
    }, this.setDistanceMatrixServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.distanceMatrixService !== null && this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.distanceMatrixService !== null && this.props.onUnmount && this.props.onUnmount(this.state.distanceMatrixService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Ee);
var px = {
  onPlacesChanged: "places_changed"
}, dx = {
  bounds: function(e, t) {
    e.setBounds(t);
  }
};
/** @class */
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = Rr(), n.state = {
      searchBox: null
    }, n.setSearchBoxCallback = function() {
      n.state.searchBox !== null && n.props.onLoad && n.props.onLoad(n.state.searchBox);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (Ar(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var n = this.containerElement.current.querySelector("input");
      if (n !== null) {
        var r = new google.maps.places.SearchBox(n, this.props.options);
        this.registeredEvents = Mt({
          updaterMap: dx,
          eventMap: px,
          prevProps: {},
          nextProps: this.props,
          instance: r
        }), this.setState(function() {
          return {
            searchBox: r
          };
        }, this.setSearchBoxCallback);
      }
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.searchBox !== null && (Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: dx,
      eventMap: px,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Rt(this.registeredEvents));
  }, t.prototype.render = function() {
    return an.jsx("div", { ref: this.containerElement, children: at.only(this.props.children) });
  }, t.contextType = gt, t;
})(Ee);
var fx = {
  onPlaceChanged: "place_changed"
}, hx = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  restrictions: function(e, t) {
    e.setComponentRestrictions(t);
  },
  fields: function(e, t) {
    e.setFields(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  types: function(e, t) {
    e.setTypes(t);
  }
};
(function(e) {
  Bn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = Rr(), n.state = {
      autocomplete: null
    }, n.setAutocompleteCallback = function() {
      n.state.autocomplete !== null && n.props.onLoad && n.props.onLoad(n.state.autocomplete);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n;
    Ar(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var r = (n = this.containerElement.current) === null || n === void 0 ? void 0 : n.querySelector("input");
    if (r) {
      var o = new google.maps.places.Autocomplete(r, this.props.options);
      this.registeredEvents = Mt({
        updaterMap: hx,
        eventMap: fx,
        prevProps: {},
        nextProps: this.props,
        instance: o
      }), this.setState(function() {
        return {
          autocomplete: o
        };
      }, this.setAutocompleteCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    Rt(this.registeredEvents), this.registeredEvents = Mt({
      updaterMap: hx,
      eventMap: fx,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.autocomplete !== null && Rt(this.registeredEvents);
  }, t.prototype.render = function() {
    return an.jsx("div", { ref: this.containerElement, className: this.props.className, children: at.only(this.props.children) });
  }, t.defaultProps = {
    className: ""
  }, t.contextType = gt, t;
})(Ee);
function SA(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: s,
    rightIcon: a,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, d = { xs: 12, sm: 16, md: 20, lg: 24 }[i], h = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ an.jsxs("button", { className: h, disabled: l || t, ...p, children: [
    /* @__PURE__ */ an.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ an.jsx(Ui, { size: d, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ an.jsxs("div", { className: "arkynButtonContent", children: [
      CC(d, s),
      c,
      CC(d, a)
    ] })
  ] });
}
function H$() {
  const e = v0(), t = q_(), n = G_(), [r, o] = k(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function s() {
    r && o(null);
  }
  m(() => {
    var u, c;
    let p = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, p) || Object.entries(p).length !== 0 && o(p);
  }, [n, e]), m(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && s();
  }, [n, t]);
  const a = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(a || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
qe({});
function V$(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Z$ = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
V$(Z$.CNPJ).length;
Ba((e, t) => /* @__PURE__ */ an.jsx("input", { ref: t, ...e }));
function q$(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: s,
    className: a = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${a}`;
  return /* @__PURE__ */ an.jsxs(
    "button",
    {
      disabled: s || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ an.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ an.jsx(Ui, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ an.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ an.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
var Pn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function G$(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Dv = { exports: {} }, fl = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gx;
function X$() {
  if (gx) return fl;
  gx = 1;
  var e = Ae, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, h = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: h, props: p, _owner: o.current };
  }
  return fl.Fragment = n, fl.jsx = s, fl.jsxs = s, fl;
}
var Mc = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mx;
function Y$() {
  return mx || (mx = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ae, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), y = Symbol.iterator, f = "@@iterator";
    function g(v) {
      if (v === null || typeof v != "object")
        return null;
      var B = y && v[y] || v[f];
      return typeof B == "function" ? B : null;
    }
    var x = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function L(v) {
      {
        for (var B = arguments.length, G = new Array(B > 1 ? B - 1 : 0), oe = 1; oe < B; oe++)
          G[oe - 1] = arguments[oe];
        E("error", v, G);
      }
    }
    function E(v, B, G) {
      {
        var oe = x.ReactDebugCurrentFrame, me = oe.getStackAddendum();
        me !== "" && (B += "%s", G = G.concat([me]));
        var ye = G.map(function(fe) {
          return String(fe);
        });
        ye.unshift("Warning: " + B), Function.prototype.apply.call(console[v], console, ye);
      }
    }
    var T = !1, b = !1, C = !1, M = !1, S = !1, F;
    F = Symbol.for("react.module.reference");
    function D(v) {
      return !!(typeof v == "string" || typeof v == "function" || v === r || v === i || S || v === o || v === u || v === c || M || v === h || T || b || C || typeof v == "object" && v !== null && (v.$$typeof === d || v.$$typeof === p || v.$$typeof === s || v.$$typeof === a || v.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      v.$$typeof === F || v.getModuleId !== void 0));
    }
    function Z(v, B, G) {
      var oe = v.displayName;
      if (oe)
        return oe;
      var me = B.displayName || B.name || "";
      return me !== "" ? G + "(" + me + ")" : G;
    }
    function U(v) {
      return v.displayName || "Context";
    }
    function $(v) {
      if (v == null)
        return null;
      if (typeof v.tag == "number" && L("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof v == "function")
        return v.displayName || v.name || null;
      if (typeof v == "string")
        return v;
      switch (v) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof v == "object")
        switch (v.$$typeof) {
          case a:
            var B = v;
            return U(B) + ".Consumer";
          case s:
            var G = v;
            return U(G._context) + ".Provider";
          case l:
            return Z(v, v.render, "ForwardRef");
          case p:
            var oe = v.displayName || null;
            return oe !== null ? oe : $(v.type) || "Memo";
          case d: {
            var me = v, ye = me._payload, fe = me._init;
            try {
              return $(fe(ye));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var N = Object.assign, V = 0, J, j, K, te, O, P, H;
    function I() {
    }
    I.__reactDisabledLog = !0;
    function W() {
      {
        if (V === 0) {
          J = console.log, j = console.info, K = console.warn, te = console.error, O = console.group, P = console.groupCollapsed, H = console.groupEnd;
          var v = {
            configurable: !0,
            enumerable: !0,
            value: I,
            writable: !0
          };
          Object.defineProperties(console, {
            info: v,
            log: v,
            warn: v,
            error: v,
            group: v,
            groupCollapsed: v,
            groupEnd: v
          });
        }
        V++;
      }
    }
    function X() {
      {
        if (V--, V === 0) {
          var v = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: N({}, v, {
              value: J
            }),
            info: N({}, v, {
              value: j
            }),
            warn: N({}, v, {
              value: K
            }),
            error: N({}, v, {
              value: te
            }),
            group: N({}, v, {
              value: O
            }),
            groupCollapsed: N({}, v, {
              value: P
            }),
            groupEnd: N({}, v, {
              value: H
            })
          });
        }
        V < 0 && L("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var w = x.ReactCurrentDispatcher, R;
    function z(v, B, G) {
      {
        if (R === void 0)
          try {
            throw Error();
          } catch (me) {
            var oe = me.stack.trim().match(/\n( *(at )?)/);
            R = oe && oe[1] || "";
          }
        return `
` + R + v;
      }
    }
    var _ = !1, Y;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      Y = new Q();
    }
    function A(v, B) {
      if (!v || _)
        return "";
      {
        var G = Y.get(v);
        if (G !== void 0)
          return G;
      }
      var oe;
      _ = !0;
      var me = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ye;
      ye = w.current, w.current = null, W();
      try {
        if (B) {
          var fe = function() {
            throw Error();
          };
          if (Object.defineProperty(fe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fe, []);
            } catch (Pe) {
              oe = Pe;
            }
            Reflect.construct(v, [], fe);
          } else {
            try {
              fe.call();
            } catch (Pe) {
              oe = Pe;
            }
            v.call(fe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Pe) {
            oe = Pe;
          }
          v();
        }
      } catch (Pe) {
        if (Pe && oe && typeof Pe.stack == "string") {
          for (var pe = Pe.stack.split(`
`), De = oe.stack.split(`
`), Le = pe.length - 1, Oe = De.length - 1; Le >= 1 && Oe >= 0 && pe[Le] !== De[Oe]; )
            Oe--;
          for (; Le >= 1 && Oe >= 0; Le--, Oe--)
            if (pe[Le] !== De[Oe]) {
              if (Le !== 1 || Oe !== 1)
                do
                  if (Le--, Oe--, Oe < 0 || pe[Le] !== De[Oe]) {
                    var ze = `
` + pe[Le].replace(" at new ", " at ");
                    return v.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", v.displayName)), typeof v == "function" && Y.set(v, ze), ze;
                  }
                while (Le >= 1 && Oe >= 0);
              break;
            }
        }
      } finally {
        _ = !1, w.current = ye, X(), Error.prepareStackTrace = me;
      }
      var nt = v ? v.displayName || v.name : "", rt = nt ? z(nt) : "";
      return typeof v == "function" && Y.set(v, rt), rt;
    }
    function ae(v, B, G) {
      return A(v, !1);
    }
    function ce(v) {
      var B = v.prototype;
      return !!(B && B.isReactComponent);
    }
    function ue(v, B, G) {
      if (v == null)
        return "";
      if (typeof v == "function")
        return A(v, ce(v));
      if (typeof v == "string")
        return z(v);
      switch (v) {
        case u:
          return z("Suspense");
        case c:
          return z("SuspenseList");
      }
      if (typeof v == "object")
        switch (v.$$typeof) {
          case l:
            return ae(v.render);
          case p:
            return ue(v.type, B, G);
          case d: {
            var oe = v, me = oe._payload, ye = oe._init;
            try {
              return ue(ye(me), B, G);
            } catch {
            }
          }
        }
      return "";
    }
    var de = Object.prototype.hasOwnProperty, be = {}, ve = x.ReactDebugCurrentFrame;
    function ge(v) {
      if (v) {
        var B = v._owner, G = ue(v.type, v._source, B ? B.type : null);
        ve.setExtraStackFrame(G);
      } else
        ve.setExtraStackFrame(null);
    }
    function se(v, B, G, oe, me) {
      {
        var ye = Function.call.bind(de);
        for (var fe in v)
          if (ye(v, fe)) {
            var pe = void 0;
            try {
              if (typeof v[fe] != "function") {
                var De = Error((oe || "React class") + ": " + G + " type `" + fe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof v[fe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw De.name = "Invariant Violation", De;
              }
              pe = v[fe](B, fe, oe, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Le) {
              pe = Le;
            }
            pe && !(pe instanceof Error) && (ge(me), L("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", oe || "React class", G, fe, typeof pe), ge(null)), pe instanceof Error && !(pe.message in be) && (be[pe.message] = !0, ge(me), L("Failed %s type: %s", G, pe.message), ge(null));
          }
      }
    }
    var xe = Array.isArray;
    function ne(v) {
      return xe(v);
    }
    function Me(v) {
      {
        var B = typeof Symbol == "function" && Symbol.toStringTag, G = B && v[Symbol.toStringTag] || v.constructor.name || "Object";
        return G;
      }
    }
    function ee(v) {
      try {
        return Ce(v), !1;
      } catch {
        return !0;
      }
    }
    function Ce(v) {
      return "" + v;
    }
    function Be(v) {
      if (ee(v))
        return L("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Me(v)), Ce(v);
    }
    var _e = x.ReactCurrentOwner, $e = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, he, Ge, We;
    We = {};
    function Ut(v) {
      if (de.call(v, "ref")) {
        var B = Object.getOwnPropertyDescriptor(v, "ref").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return v.ref !== void 0;
    }
    function ot(v) {
      if (de.call(v, "key")) {
        var B = Object.getOwnPropertyDescriptor(v, "key").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return v.key !== void 0;
    }
    function st(v, B) {
      if (typeof v.ref == "string" && _e.current && B && _e.current.stateNode !== B) {
        var G = $(_e.current.type);
        We[G] || (L('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(_e.current.type), v.ref), We[G] = !0);
      }
    }
    function Zt(v, B) {
      {
        var G = function() {
          he || (he = !0, L("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(v, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function qt(v, B) {
      {
        var G = function() {
          Ge || (Ge = !0, L("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(v, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Gt = function(v, B, G, oe, me, ye, fe) {
      var pe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: v,
        key: B,
        ref: G,
        props: fe,
        // Record the component responsible for creating this element.
        _owner: ye
      };
      return pe._store = {}, Object.defineProperty(pe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(pe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: oe
      }), Object.defineProperty(pe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: me
      }), Object.freeze && (Object.freeze(pe.props), Object.freeze(pe)), pe;
    };
    function Xt(v, B, G, oe, me) {
      {
        var ye, fe = {}, pe = null, De = null;
        G !== void 0 && (Be(G), pe = "" + G), ot(B) && (Be(B.key), pe = "" + B.key), Ut(B) && (De = B.ref, st(B, me));
        for (ye in B)
          de.call(B, ye) && !$e.hasOwnProperty(ye) && (fe[ye] = B[ye]);
        if (v && v.defaultProps) {
          var Le = v.defaultProps;
          for (ye in Le)
            fe[ye] === void 0 && (fe[ye] = Le[ye]);
        }
        if (pe || De) {
          var Oe = typeof v == "function" ? v.displayName || v.name || "Unknown" : v;
          pe && Zt(fe, Oe), De && qt(fe, Oe);
        }
        return Gt(v, pe, De, me, oe, _e.current, fe);
      }
    }
    var et = x.ReactCurrentOwner, bt = x.ReactDebugCurrentFrame;
    function tt(v) {
      if (v) {
        var B = v._owner, G = ue(v.type, v._source, B ? B.type : null);
        bt.setExtraStackFrame(G);
      } else
        bt.setExtraStackFrame(null);
    }
    var ut;
    ut = !1;
    function Yt(v) {
      return typeof v == "object" && v !== null && v.$$typeof === t;
    }
    function gn() {
      {
        if (et.current) {
          var v = $(et.current.type);
          if (v)
            return `

Check the render method of \`` + v + "`.";
        }
        return "";
      }
    }
    function Jt(v) {
      {
        if (v !== void 0) {
          var B = v.fileName.replace(/^.*[\\\/]/, ""), G = v.lineNumber;
          return `

Check your code at ` + B + ":" + G + ".";
        }
        return "";
      }
    }
    var mn = {};
    function qn(v) {
      {
        var B = gn();
        if (!B) {
          var G = typeof v == "string" ? v : v.displayName || v.name;
          G && (B = `

Check the top-level render call using <` + G + ">.");
        }
        return B;
      }
    }
    function wt(v, B) {
      {
        if (!v._store || v._store.validated || v.key != null)
          return;
        v._store.validated = !0;
        var G = qn(B);
        if (mn[G])
          return;
        mn[G] = !0;
        var oe = "";
        v && v._owner && v._owner !== et.current && (oe = " It was passed a child from " + $(v._owner.type) + "."), tt(v), L('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, oe), tt(null);
      }
    }
    function vn(v, B) {
      {
        if (typeof v != "object")
          return;
        if (ne(v))
          for (var G = 0; G < v.length; G++) {
            var oe = v[G];
            Yt(oe) && wt(oe, B);
          }
        else if (Yt(v))
          v._store && (v._store.validated = !0);
        else if (v) {
          var me = g(v);
          if (typeof me == "function" && me !== v.entries)
            for (var ye = me.call(v), fe; !(fe = ye.next()).done; )
              Yt(fe.value) && wt(fe.value, B);
        }
      }
    }
    function Gn(v) {
      {
        var B = v.type;
        if (B == null || typeof B == "string")
          return;
        var G;
        if (typeof B == "function")
          G = B.propTypes;
        else if (typeof B == "object" && (B.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        B.$$typeof === p))
          G = B.propTypes;
        else
          return;
        if (G) {
          var oe = $(B);
          se(G, v.props, "prop", oe, v);
        } else if (B.PropTypes !== void 0 && !ut) {
          ut = !0;
          var me = $(B);
          L("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", me || "Unknown");
        }
        typeof B.getDefaultProps == "function" && !B.getDefaultProps.isReactClassApproved && L("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Kt(v) {
      {
        for (var B = Object.keys(v.props), G = 0; G < B.length; G++) {
          var oe = B[G];
          if (oe !== "children" && oe !== "key") {
            tt(v), L("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", oe), tt(null);
            break;
          }
        }
        v.ref !== null && (tt(v), L("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var yn = {};
    function bn(v, B, G, oe, me, ye) {
      {
        var fe = D(v);
        if (!fe) {
          var pe = "";
          (v === void 0 || typeof v == "object" && v !== null && Object.keys(v).length === 0) && (pe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var De = Jt(me);
          De ? pe += De : pe += gn();
          var Le;
          v === null ? Le = "null" : ne(v) ? Le = "array" : v !== void 0 && v.$$typeof === t ? (Le = "<" + ($(v.type) || "Unknown") + " />", pe = " Did you accidentally export a JSX literal instead of a component?") : Le = typeof v, L("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Le, pe);
        }
        var Oe = Xt(v, B, G, me, ye);
        if (Oe == null)
          return Oe;
        if (fe) {
          var ze = B.children;
          if (ze !== void 0)
            if (oe)
              if (ne(ze)) {
                for (var nt = 0; nt < ze.length; nt++)
                  vn(ze[nt], v);
                Object.freeze && Object.freeze(ze);
              } else
                L("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              vn(ze, v);
        }
        if (de.call(B, "key")) {
          var rt = $(v), Pe = Object.keys(B).filter(function(bi) {
            return bi !== "key";
          }), ie = Pe.length > 0 ? "{key: someKey, " + Pe.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!yn[rt + ie]) {
            var yi = Pe.length > 0 ? "{" + Pe.join(": ..., ") + ": ...}" : "{}";
            L(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ie, rt, yi, rt), yn[rt + ie] = !0;
          }
        }
        return v === r ? Kt(Oe) : Gn(Oe), Oe;
      }
    }
    function Qt(v, B, G) {
      return bn(v, B, G, !0);
    }
    function Xn(v, B, G) {
      return bn(v, B, G, !1);
    }
    var Yn = Xn, en = Qt;
    Mc.Fragment = r, Mc.jsx = Yn, Mc.jsxs = en;
  }()), Mc;
}
process.env.NODE_ENV === "production" ? Dv.exports = X$() : Dv.exports = Y$();
var zr = Dv.exports;
qe({});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Pv = function(e, t) {
  return Pv = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
  }, Pv(e, t);
};
function In(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Pv(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Je = function() {
  return Je = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Je.apply(this, arguments);
};
function M0(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function J$(e, t, n, r) {
  function o(i) {
    return i instanceof n ? i : new n(function(s) {
      s(i);
    });
  }
  return new (n || (n = Promise))(function(i, s) {
    function a(c) {
      try {
        u(r.next(c));
      } catch (p) {
        s(p);
      }
    }
    function l(c) {
      try {
        u(r.throw(c));
      } catch (p) {
        s(p);
      }
    }
    function u(c) {
      c.done ? i(c.value) : o(c.value).then(a, l);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function K$(e, t) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, o, i, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(c) {
      return l([u, c]);
    };
  }
  function l(u) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, o && (i = u[0] & 2 ? o.return : u[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, u[1])).done) return i;
      switch (o = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
        case 0:
        case 1:
          i = u;
          break;
        case 4:
          return n.label++, { value: u[1], done: !1 };
        case 5:
          n.label++, o = u[1], u = [0];
          continue;
        case 7:
          u = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            n = 0;
            continue;
          }
          if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
            n.label = u[1];
            break;
          }
          if (u[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = u;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(u);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      u = t.call(e, n);
    } catch (c) {
      u = [6, c], o = 0;
    } finally {
      r = i = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function DA(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Q$ = process.env.NODE_ENV, e3 = function(e, t, n, r, o, i, s, a) {
  if (Q$ !== "production" && t === void 0)
    throw new Error("invariant requires an error message argument");
  if (!e) {
    var l;
    if (t === void 0)
      l = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var u = [n, r, o, i, s, a], c = 0;
      l = new Error(
        t.replace(/%s/g, function() {
          return u[c++];
        })
      ), l.name = "Invariant Violation";
    }
    throw l.framesToPop = 1, l;
  }
}, t3 = e3, Br = /* @__PURE__ */ DA(t3), mt = qe(null);
function n3() {
  Br(!!Te, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Te(mt);
  return Br(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function r3(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function o3(e, t) {
  Object.keys(e).forEach(function(n) {
    return t(e[n], n);
  });
}
function i3(e, t, n, r) {
  var o = {}, i = function(s, a) {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return o3(e, i), o;
}
function s3(e, t, n) {
  var r = r3(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function a3(e) {
  google.maps.event.removeListener(e);
}
function Nt(e) {
  e === void 0 && (e = []), e.forEach(a3);
}
function St(e) {
  var t = e.updaterMap, n = e.eventMap, r = e.prevProps, o = e.nextProps, i = e.instance, s = s3(o, i, n);
  return i3(t, r, o, i), s;
}
var vx = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, yx = {
  extraMapTypes: function(e, t) {
    t.forEach(function(n, r) {
      e.mapTypes.set(String(r), n);
    });
  },
  center: function(e, t) {
    e.setCenter(t);
  },
  clickableIcons: function(e, t) {
    e.setClickableIcons(t);
  },
  heading: function(e, t) {
    e.setHeading(t);
  },
  mapTypeId: function(e, t) {
    e.setMapTypeId(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  streetView: function(e, t) {
    e.setStreetView(t);
  },
  tilt: function(e, t) {
    e.setTilt(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
function l3(e) {
  var t = e.children, n = e.options, r = e.id, o = e.mapContainerStyle, i = e.mapContainerClassName, s = e.center, a = e.onClick, l = e.onDblClick, u = e.onDrag, c = e.onDragEnd, p = e.onDragStart, d = e.onMouseMove, h = e.onMouseOut, y = e.onMouseOver, f = e.onMouseDown, g = e.onMouseUp, x = e.onRightClick, L = e.onCenterChanged, E = e.onLoad, T = e.onUnmount, b = k(null), C = b[0], M = b[1], S = it(null), F = k(null), D = F[0], Z = F[1], U = k(null), $ = U[0], N = U[1], V = k(null), J = V[0], j = V[1], K = k(null), te = K[0], O = K[1], P = k(null), H = P[0], I = P[1], W = k(null), X = W[0], w = W[1], R = k(null), z = R[0], _ = R[1], Y = k(null), Q = Y[0], A = Y[1], ae = k(null), ce = ae[0], ue = ae[1], de = k(null), be = de[0], ve = de[1], ge = k(null), se = ge[0], xe = ge[1], ne = k(null), Me = ne[0], ee = ne[1];
  return m(function() {
    n && C !== null && C.setOptions(n);
  }, [C, n]), m(function() {
    C !== null && typeof s < "u" && C.setCenter(s);
  }, [C, s]), m(function() {
    C && l && ($ !== null && google.maps.event.removeListener($), N(google.maps.event.addListener(C, "dblclick", l)));
  }, [l]), m(function() {
    C && c && (J !== null && google.maps.event.removeListener(J), j(google.maps.event.addListener(C, "dragend", c)));
  }, [c]), m(function() {
    C && p && (te !== null && google.maps.event.removeListener(te), O(google.maps.event.addListener(C, "dragstart", p)));
  }, [p]), m(function() {
    C && f && (H !== null && google.maps.event.removeListener(H), I(google.maps.event.addListener(C, "mousedown", f)));
  }, [f]), m(function() {
    C && d && (X !== null && google.maps.event.removeListener(X), w(google.maps.event.addListener(C, "mousemove", d)));
  }, [d]), m(function() {
    C && h && (z !== null && google.maps.event.removeListener(z), _(google.maps.event.addListener(C, "mouseout", h)));
  }, [h]), m(function() {
    C && y && (Q !== null && google.maps.event.removeListener(Q), A(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), m(function() {
    C && g && (ce !== null && google.maps.event.removeListener(ce), ue(google.maps.event.addListener(C, "mouseup", g)));
  }, [g]), m(function() {
    C && x && (be !== null && google.maps.event.removeListener(be), ve(google.maps.event.addListener(C, "rightclick", x)));
  }, [x]), m(function() {
    C && a && (se !== null && google.maps.event.removeListener(se), xe(google.maps.event.addListener(C, "click", a)));
  }, [a]), m(function() {
    C && u && (Me !== null && google.maps.event.removeListener(Me), ee(google.maps.event.addListener(C, "drag", u)));
  }, [u]), m(function() {
    C && L && (D !== null && google.maps.event.removeListener(D), Z(google.maps.event.addListener(C, "center_changed", L)));
  }, [a]), m(function() {
    var Ce = S.current === null ? null : new google.maps.Map(S.current, n);
    return M(Ce), Ce !== null && E && E(Ce), function() {
      Ce !== null && T && T(Ce);
    };
  }, []), zr.jsx("div", { id: r, ref: S, style: o, className: i, children: zr.jsx(mt.Provider, { value: C, children: C !== null ? t : null }) });
}
Ie(l3);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      map: null
    }, n.registeredEvents = [], n.mapRef = null, n.getInstance = function() {
      return n.mapRef === null ? null : new google.maps.Map(n.mapRef, n.props.options);
    }, n.panTo = function(r) {
      var o = n.getInstance();
      o && o.panTo(r);
    }, n.setMapCallback = function() {
      n.state.map !== null && n.props.onLoad && n.props.onLoad(n.state.map);
    }, n.getRef = function(r) {
      n.mapRef = r;
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.getInstance();
    this.registeredEvents = St({
      updaterMap: yx,
      eventMap: vx,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        map: n
      };
    }, this.setMapCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.map !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: yx,
      eventMap: vx,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.map
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), Nt(this.registeredEvents));
  }, t.prototype.render = function() {
    return zr.jsx("div", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName, children: zr.jsx(mt.Provider, { value: this.state.map, children: this.state.map !== null ? this.props.children : null }) });
  }, t;
})(Ee);
var pa = typeof document < "u";
function PA(e) {
  var t = e.url, n = e.id, r = e.nonce;
  return pa ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch(function(o) {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function bx(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function TA() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return bx(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return bx(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
function _A(e) {
  var t = e.googleMapsApiKey, n = e.googleMapsClientId, r = e.version, o = r === void 0 ? "weekly" : r, i = e.language, s = e.region, a = e.libraries, l = e.channel, u = e.mapIds, c = e.authReferrerPolicy, p = [];
  return Br(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? p.push("key=".concat(t)) : n && p.push("client=".concat(n)), o && p.push("v=".concat(o)), i && p.push("language=".concat(i)), s && p.push("region=".concat(s)), a && a.length && p.push("libraries=".concat(a.sort().join(","))), l && p.push("channel=".concat(l)), u && u.length && p.push("map_ids=".concat(u.join(","))), c && p.push("auth_referrer_policy=".concat(c)), p.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(p.join("&"));
}
var hl = !1;
function AA() {
  return zr.jsx("div", { children: "Loading..." });
}
var Tv = {
  id: "script-loader",
  version: "weekly"
};
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.check = Rr(), n.state = {
      loaded: !1
    }, n.cleanupCallback = function() {
      delete window.google.maps, n.injectScript();
    }, n.isCleaningUp = function() {
      return J$(n, void 0, void 0, function() {
        function r(o) {
          if (!hl)
            o();
          else if (pa)
            var i = window.setInterval(function() {
              hl || (window.clearInterval(i), o());
            }, 1);
        }
        return K$(this, function(o) {
          return [2, new Promise(r)];
        });
      });
    }, n.cleanup = function() {
      hl = !0;
      var r = document.getElementById(n.props.id);
      r && r.parentNode && r.parentNode.removeChild(r), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(o) {
        return typeof o.src == "string" && o.src.includes("maps.googleapis");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(o) {
        return o.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(o) {
        return o.innerText !== void 0 && o.innerText.length > 0 && o.innerText.includes(".gm-");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      });
    }, n.injectScript = function() {
      n.props.preventGoogleFontsLoading && TA(), Br(!!n.props.id, 'LoadScript requires "id" prop to be a string: %s', n.props.id);
      var r = {
        id: n.props.id,
        nonce: n.props.nonce,
        url: _A(n.props)
      };
      PA(r).then(function() {
        n.props.onLoad && n.props.onLoad(), n.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch(function(o) {
        n.props.onError && n.props.onError(o), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(n.props.googleMapsApiKey || "-", ") or Client ID (").concat(n.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (pa) {
      if (window.google && window.google.maps && !hl) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.props.libraries !== n.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), pa && n.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }, t.prototype.componentWillUnmount = function() {
    var n = this;
    if (pa) {
      this.cleanup();
      var r = function() {
        n.check.current || (delete window.google, hl = !1);
      };
      window.setTimeout(r, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }, t.prototype.render = function() {
    return zr.jsxs(zr.Fragment, { children: [zr.jsx("div", { ref: this.check }), this.state.loaded ? this.props.children : this.props.loadingElement || zr.jsx(AA, {})] });
  }, t.defaultProps = Tv, t;
})(Ee);
var wx;
function u3(e) {
  var t = e.id, n = t === void 0 ? Tv.id : t, r = e.version, o = r === void 0 ? Tv.version : r, i = e.nonce, s = e.googleMapsApiKey, a = e.googleMapsClientId, l = e.language, u = e.region, c = e.libraries, p = e.preventGoogleFontsLoading, d = e.channel, h = e.mapIds, y = e.authReferrerPolicy, f = it(!1), g = k(!1), x = g[0], L = g[1], E = k(void 0), T = E[0], b = E[1];
  m(function() {
    return f.current = !0, function() {
      f.current = !1;
    };
  }, []), m(function() {
    pa && p && TA();
  }, [p]), m(function() {
    x && Br(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [x]);
  var C = _A({
    version: o,
    googleMapsApiKey: s,
    googleMapsClientId: a,
    language: l,
    region: u,
    libraries: c,
    channel: d,
    mapIds: h,
    authReferrerPolicy: y
  });
  m(function() {
    if (!pa)
      return;
    function S() {
      f.current && (L(!0), wx = C);
    }
    if (window.google && window.google.maps && wx === C) {
      S();
      return;
    }
    PA({ id: n, url: C, nonce: i }).then(S).catch(function(F) {
      f.current && b(F), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(s || "-", ") or Client ID (").concat(a || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(F);
    });
  }, [n, C, i]);
  var M = it();
  return m(function() {
    M.current && c !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = c;
  }, [c]), { isLoaded: x, loadError: T, url: C };
}
var c3 = zr.jsx(AA, {});
function p3(e) {
  var t = e.loadingElement, n = e.onLoad, r = e.onError, o = e.onUnmount, i = e.children, s = M0(e, ["loadingElement", "onLoad", "onError", "onUnmount", "children"]), a = u3(s), l = a.isLoaded, u = a.loadError;
  return m(function() {
    l && typeof n == "function" && n();
  }, [l, n]), m(function() {
    u && typeof r == "function" && r(u);
  }, [u, r]), m(function() {
    return function() {
      o && o();
    };
  }, [o]), l ? i : t || c3;
}
Ie(p3);
var Cx;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Cx || (Cx = {}));
var xx = {}, Ex = {
  options: function(e, t) {
    e.setOptions(t);
  }
};
function d3(e) {
  var t = e.options, n = e.onLoad, r = e.onUnmount, o = Te(mt), i = k(null), s = i[0], a = i[1];
  return m(function() {
    s !== null && s.setMap(o);
  }, [o]), m(function() {
    t && s !== null && s.setOptions(t);
  }, [s, t]), m(function() {
    var l = new google.maps.TrafficLayer(Je(Je({}, t || {}), { map: o }));
    return a(l), n && n(l), function() {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Ie(d3);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      trafficLayer: null
    }, n.setTrafficLayerCallback = function() {
      n.state.trafficLayer !== null && n.props.onLoad && n.props.onLoad(n.state.trafficLayer);
    }, n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TrafficLayer(Je(Je({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = St({
      updaterMap: Ex,
      eventMap: xx,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        trafficLayer: n
      };
    }, this.setTrafficLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.trafficLayer !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: Ex,
      eventMap: xx,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Nt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = mt, t;
})(Ee);
function f3(e) {
  var t = e.onLoad, n = e.onUnmount, r = Te(mt), o = k(null), i = o[0], s = o[1];
  return m(function() {
    i !== null && i.setMap(r);
  }, [r]), m(function() {
    var a = new google.maps.BicyclingLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Ie(f3);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      bicyclingLayer: null
    }, n.setBicyclingLayerCallback = function() {
      n.state.bicyclingLayer !== null && (n.state.bicyclingLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.bicyclingLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.BicyclingLayer();
    this.setState(function() {
      return {
        bicyclingLayer: n
      };
    }, this.setBicyclingLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = mt, t;
})(Ee);
function h3(e) {
  var t = e.onLoad, n = e.onUnmount, r = Te(mt), o = k(null), i = o[0], s = o[1];
  return m(function() {
    i !== null && i.setMap(r);
  }, [r]), m(function() {
    var a = new google.maps.TransitLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      i !== null && (n && n(i), i.setMap(null));
    };
  }, []), null;
}
Ie(h3);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      transitLayer: null
    }, n.setTransitLayerCallback = function() {
      n.state.transitLayer !== null && (n.state.transitLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.transitLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: n
      };
    }, this.setTransitLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = mt, t;
})(Ee);
var Lx = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, kx = {
  drawingMode: function(e, t) {
    e.setDrawingMode(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function g3(e) {
  var t = e.options, n = e.drawingMode, r = e.onCircleComplete, o = e.onMarkerComplete, i = e.onOverlayComplete, s = e.onPolygonComplete, a = e.onPolylineComplete, l = e.onRectangleComplete, u = e.onLoad, c = e.onUnmount, p = Te(mt), d = k(null), h = d[0], y = d[1], f = k(null), g = f[0], x = f[1], L = k(null), E = L[0], T = L[1], b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1];
  return m(function() {
    h !== null && h.setMap(p);
  }, [p]), m(function() {
    t && h !== null && h.setOptions(t);
  }, [h, t]), m(function() {
    h !== null && h.setDrawingMode(n ?? null);
  }, [h, n]), m(function() {
    h && r && (g !== null && google.maps.event.removeListener(g), x(google.maps.event.addListener(h, "circlecomplete", r)));
  }, [h, r]), m(function() {
    h && o && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(h, "markercomplete", o)));
  }, [h, o]), m(function() {
    h && i && (C !== null && google.maps.event.removeListener(C), M(google.maps.event.addListener(h, "overlaycomplete", i)));
  }, [h, i]), m(function() {
    h && s && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(h, "polygoncomplete", s)));
  }, [h, s]), m(function() {
    h && a && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(h, "polylinecomplete", a)));
  }, [h, a]), m(function() {
    h && l && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(h, "rectanglecomplete", l)));
  }, [h, l]), m(function() {
    Br(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var j = new google.maps.drawing.DrawingManager(Je(Je({}, t || {}), { map: p }));
    return n && j.setDrawingMode(n), r && x(google.maps.event.addListener(j, "circlecomplete", r)), o && T(google.maps.event.addListener(j, "markercomplete", o)), i && M(google.maps.event.addListener(j, "overlaycomplete", i)), s && D(google.maps.event.addListener(j, "polygoncomplete", s)), a && $(google.maps.event.addListener(j, "polylinecomplete", a)), l && J(google.maps.event.addListener(j, "rectanglecomplete", l)), y(j), u && u(j), function() {
      h !== null && (g && google.maps.event.removeListener(g), E && google.maps.event.removeListener(E), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), U && google.maps.event.removeListener(U), V && google.maps.event.removeListener(V), c && c(h), h.setMap(null));
    };
  }, []), null;
}
Ie(g3);
(function(e) {
  In(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    return r.registeredEvents = [], r.state = {
      drawingManager: null
    }, r.setDrawingManagerCallback = function() {
      r.state.drawingManager !== null && r.props.onLoad && r.props.onLoad(r.state.drawingManager);
    }, Br(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing), r;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.drawing.DrawingManager(Je(Je({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = St({
      updaterMap: kx,
      eventMap: Lx,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        drawingManager: n
      };
    }, this.setDrawingManagerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.drawingManager !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: kx,
      eventMap: Lx,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Nt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = mt, t;
})(Ee);
var Ox = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, Mx = {
  animation: function(e, t) {
    e.setAnimation(t);
  },
  clickable: function(e, t) {
    e.setClickable(t);
  },
  cursor: function(e, t) {
    e.setCursor(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  icon: function(e, t) {
    e.setIcon(t);
  },
  label: function(e, t) {
    e.setLabel(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  opacity: function(e, t) {
    e.setOpacity(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  shape: function(e, t) {
    e.setShape(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, gd = {};
function m3(e) {
  var t = e.position, n = e.options, r = e.clusterer, o = e.noClustererRedraw, i = e.children, s = e.draggable, a = e.visible, l = e.animation, u = e.clickable, c = e.cursor, p = e.icon, d = e.label, h = e.opacity, y = e.shape, f = e.title, g = e.zIndex, x = e.onClick, L = e.onDblClick, E = e.onDrag, T = e.onDragEnd, b = e.onDragStart, C = e.onMouseOut, M = e.onMouseOver, S = e.onMouseUp, F = e.onMouseDown, D = e.onRightClick, Z = e.onClickableChanged, U = e.onCursorChanged, $ = e.onAnimationChanged, N = e.onDraggableChanged, V = e.onFlatChanged, J = e.onIconChanged, j = e.onPositionChanged, K = e.onShapeChanged, te = e.onTitleChanged, O = e.onVisibleChanged, P = e.onZindexChanged, H = e.onLoad, I = e.onUnmount, W = Te(mt), X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1], se = k(null), xe = se[0], ne = se[1], Me = k(null), ee = Me[0], Ce = Me[1], Be = k(null), _e = Be[0], $e = Be[1], he = k(null), Ge = he[0], We = he[1], Ut = k(null), ot = Ut[0], st = Ut[1], Zt = k(null), qt = Zt[0], Gt = Zt[1], Xt = k(null), et = Xt[0], bt = Xt[1], tt = k(null), ut = tt[0], Yt = tt[1], gn = k(null), Jt = gn[0], mn = gn[1], qn = k(null), wt = qn[0], vn = qn[1], Gn = k(null), Kt = Gn[0], yn = Gn[1], bn = k(null), Qt = bn[0], Xn = bn[1], Yn = k(null), en = Yn[0], v = Yn[1], B = k(null), G = B[0], oe = B[1], me = k(null), ye = me[0], fe = me[1], pe = k(null), De = pe[0], Le = pe[1], Oe = k(null), ze = Oe[0], nt = Oe[1];
  m(function() {
    w !== null && w.setMap(W);
  }, [W]), m(function() {
    typeof n < "u" && w !== null && w.setOptions(n);
  }, [w, n]), m(function() {
    typeof s < "u" && w !== null && w.setDraggable(s);
  }, [w, s]), m(function() {
    t && w !== null && w.setPosition(t);
  }, [w, t]), m(function() {
    typeof a < "u" && w !== null && w.setVisible(a);
  }, [w, a]), m(function() {
    w == null || w.setAnimation(l);
  }, [w, l]), m(function() {
    w && u !== void 0 && w.setClickable(u);
  }, [w, u]), m(function() {
    w && c !== void 0 && w.setCursor(c);
  }, [w, c]), m(function() {
    w && p !== void 0 && w.setIcon(p);
  }, [w, p]), m(function() {
    w && d !== void 0 && w.setLabel(d);
  }, [w, d]), m(function() {
    w && h !== void 0 && w.setOpacity(h);
  }, [w, h]), m(function() {
    w && y !== void 0 && w.setShape(y);
  }, [w, y]), m(function() {
    w && f !== void 0 && w.setTitle(f);
  }, [w, f]), m(function() {
    w && g !== void 0 && w.setZIndex(g);
  }, [w, g]), m(function() {
    w && L && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(w, "dblclick", L)));
  }, [L]), m(function() {
    w && T && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(w, "dragend", T)));
  }, [T]), m(function() {
    w && b && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(w, "dragstart", b)));
  }, [b]), m(function() {
    w && F && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(w, "mousedown", F)));
  }, [F]), m(function() {
    w && C && (xe !== null && google.maps.event.removeListener(xe), ne(google.maps.event.addListener(w, "mouseout", C)));
  }, [C]), m(function() {
    w && M && (ee !== null && google.maps.event.removeListener(ee), Ce(google.maps.event.addListener(w, "mouseover", M)));
  }, [M]), m(function() {
    w && S && (_e !== null && google.maps.event.removeListener(_e), $e(google.maps.event.addListener(w, "mouseup", S)));
  }, [S]), m(function() {
    w && D && (Ge !== null && google.maps.event.removeListener(Ge), We(google.maps.event.addListener(w, "rightclick", D)));
  }, [D]), m(function() {
    w && x && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(w, "click", x)));
  }, [x]), m(function() {
    w && E && (qt !== null && google.maps.event.removeListener(qt), Gt(google.maps.event.addListener(w, "drag", E)));
  }, [E]), m(function() {
    w && Z && (et !== null && google.maps.event.removeListener(et), bt(google.maps.event.addListener(w, "clickable_changed", Z)));
  }, [Z]), m(function() {
    w && U && (ut !== null && google.maps.event.removeListener(ut), Yt(google.maps.event.addListener(w, "cursor_changed", U)));
  }, [U]), m(function() {
    w && $ && (Jt !== null && google.maps.event.removeListener(Jt), mn(google.maps.event.addListener(w, "animation_changed", $)));
  }, [$]), m(function() {
    w && N && (wt !== null && google.maps.event.removeListener(wt), vn(google.maps.event.addListener(w, "draggable_changed", N)));
  }, [N]), m(function() {
    w && V && (Kt !== null && google.maps.event.removeListener(Kt), yn(google.maps.event.addListener(w, "flat_changed", V)));
  }, [V]), m(function() {
    w && J && (Qt !== null && google.maps.event.removeListener(Qt), Xn(google.maps.event.addListener(w, "icon_changed", J)));
  }, [J]), m(function() {
    w && j && (en !== null && google.maps.event.removeListener(en), v(google.maps.event.addListener(w, "position_changed", j)));
  }, [j]), m(function() {
    w && K && (G !== null && google.maps.event.removeListener(G), oe(google.maps.event.addListener(w, "shape_changed", K)));
  }, [K]), m(function() {
    w && te && (ye !== null && google.maps.event.removeListener(ye), fe(google.maps.event.addListener(w, "title_changed", te)));
  }, [te]), m(function() {
    w && O && (De !== null && google.maps.event.removeListener(De), Le(google.maps.event.addListener(w, "visible_changed", O)));
  }, [O]), m(function() {
    w && P && (ze !== null && google.maps.event.removeListener(ze), nt(google.maps.event.addListener(w, "zindex_changed", P)));
  }, [P]), m(function() {
    var Pe = Je(Je(Je({}, n || gd), r ? gd : { map: W }), { position: t }), ie = new google.maps.Marker(Pe);
    return r ? r.addMarker(ie, !!o) : ie.setMap(W), t && ie.setPosition(t), typeof a < "u" && ie.setVisible(a), typeof s < "u" && ie.setDraggable(s), typeof u < "u" && ie.setClickable(u), typeof c == "string" && ie.setCursor(c), p && ie.setIcon(p), typeof d < "u" && ie.setLabel(d), typeof h < "u" && ie.setOpacity(h), y && ie.setShape(y), typeof f == "string" && ie.setTitle(f), typeof g == "number" && ie.setZIndex(g), L && Y(google.maps.event.addListener(ie, "dblclick", L)), T && ae(google.maps.event.addListener(ie, "dragend", T)), b && de(google.maps.event.addListener(ie, "dragstart", b)), F && ge(google.maps.event.addListener(ie, "mousedown", F)), C && ne(google.maps.event.addListener(ie, "mouseout", C)), M && Ce(google.maps.event.addListener(ie, "mouseover", M)), S && $e(google.maps.event.addListener(ie, "mouseup", S)), D && We(google.maps.event.addListener(ie, "rightclick", D)), x && st(google.maps.event.addListener(ie, "click", x)), E && Gt(google.maps.event.addListener(ie, "drag", E)), Z && bt(google.maps.event.addListener(ie, "clickable_changed", Z)), U && Yt(google.maps.event.addListener(ie, "cursor_changed", U)), $ && mn(google.maps.event.addListener(ie, "animation_changed", $)), N && vn(google.maps.event.addListener(ie, "draggable_changed", N)), V && yn(google.maps.event.addListener(ie, "flat_changed", V)), J && Xn(google.maps.event.addListener(ie, "icon_changed", J)), j && v(google.maps.event.addListener(ie, "position_changed", j)), K && oe(google.maps.event.addListener(ie, "shape_changed", K)), te && fe(google.maps.event.addListener(ie, "title_changed", te)), O && Le(google.maps.event.addListener(ie, "visible_changed", O)), P && nt(google.maps.event.addListener(ie, "zindex_changed", P)), R(ie), H && H(ie), function() {
      _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), ve !== null && google.maps.event.removeListener(ve), xe !== null && google.maps.event.removeListener(xe), ee !== null && google.maps.event.removeListener(ee), _e !== null && google.maps.event.removeListener(_e), Ge !== null && google.maps.event.removeListener(Ge), ot !== null && google.maps.event.removeListener(ot), et !== null && google.maps.event.removeListener(et), ut !== null && google.maps.event.removeListener(ut), Jt !== null && google.maps.event.removeListener(Jt), wt !== null && google.maps.event.removeListener(wt), Kt !== null && google.maps.event.removeListener(Kt), Qt !== null && google.maps.event.removeListener(Qt), en !== null && google.maps.event.removeListener(en), ye !== null && google.maps.event.removeListener(ye), De !== null && google.maps.event.removeListener(De), ze !== null && google.maps.event.removeListener(ze), I && I(ie), r ? r.removeMarker(ie, !!o) : ie && ie.setMap(null);
    };
  }, []);
  var rt = Zn(function() {
    return i ? at.map(i, function(Pe) {
      if (!ci(Pe))
        return Pe;
      var ie = Pe;
      return pi(ie, { anchor: w });
    }) : null;
  }, [i, w]);
  return zr.jsx(zr.Fragment, { children: rt }) || null;
}
Ie(m3);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = Je(Je(Je({}, this.props.options || gd), this.props.clusterer ? gd : { map: this.context }), { position: this.props.position });
    this.marker = new google.maps.Marker(n), this.props.clusterer ? this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw) : this.marker.setMap(this.context), this.registeredEvents = St({
      updaterMap: Mx,
      eventMap: Ox,
      prevProps: {},
      nextProps: this.props,
      instance: this.marker
    }), this.props.onLoad && this.props.onLoad(this.marker);
  }, t.prototype.componentDidUpdate = function(n) {
    this.marker && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: Mx,
      eventMap: Ox,
      prevProps: n,
      nextProps: this.props,
      instance: this.marker
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Nt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }, t.prototype.render = function() {
    var n = this, r = null;
    return this.props.children && (r = at.map(this.props.children, function(o) {
      if (!ci(o))
        return o;
      var i = o;
      return pi(i, { anchor: n.marker });
    })), r || null;
  }, t.contextType = mt, t;
})(Ee);
var v3 = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var h = document.createElement("div");
        h.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (h.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (h.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(h), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), y3 = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new v3(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function b3(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var w3 = 2e3, C3 = 500, x3 = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", E3 = "png", L3 = [53, 56, 66, 78, 90], k3 = "cluster", BA = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || x3, this.imageExtension = r.imageExtension || E3, this.imageSizes = r.imageSizes || L3, this.calculator = r.calculator || b3, this.batchSize = r.batchSize || w3, this.batchSizeIE = r.batchSizeIE || C3, this.clusterClass = r.clusterClass || k3, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [
        google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged),
        google.maps.event.addListener(t, "idle", this.onIdle)
      ]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new y3(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var h = d[p];
            h.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), $o = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, rn = {
  averageCenter: function(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE: function(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator: function(e, t) {
    e.setCalculator(t);
  },
  clusterClass: function(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons: function(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize: function(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden: function(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension: function(e, t) {
    e.setImageExtension(t);
  },
  imagePath: function(e, t) {
    e.setImagePath(t);
  },
  imageSizes: function(e, t) {
    e.setImageSizes(t);
  },
  maxZoom: function(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize: function(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles: function(e, t) {
    e.setStyles(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  zoomOnClick: function(e, t) {
    e.setZoomOnClick(t);
  }
}, O3 = {};
function M3(e) {
  var t = e.children, n = e.options, r = e.averageCenter, o = e.batchSizeIE, i = e.calculator, s = e.clusterClass, a = e.enableRetinaIcons, l = e.gridSize, u = e.ignoreHidden, c = e.imageExtension, p = e.imagePath, d = e.imageSizes, h = e.maxZoom, y = e.minimumClusterSize, f = e.styles, g = e.title, x = e.zoomOnClick, L = e.onClick, E = e.onClusteringBegin, T = e.onClusteringEnd, b = e.onMouseOver, C = e.onMouseOut, M = e.onLoad, S = e.onUnmount, F = k(null), D = F[0], Z = F[1], U = Te(mt), $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1];
  return m(function() {
    D && C && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(D, $o.onMouseOut, C)));
  }, [C]), m(function() {
    D && b && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(D, $o.onMouseOver, b)));
  }, [b]), m(function() {
    D && L && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(D, $o.onClick, L)));
  }, [L]), m(function() {
    D && E && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(D, $o.onClusteringBegin, E)));
  }, [E]), m(function() {
    D && T && (O !== null && google.maps.event.removeListener(O), K(google.maps.event.addListener(D, $o.onClusteringEnd, T)));
  }, [T]), m(function() {
    typeof r < "u" && D !== null && rn.averageCenter(D, r);
  }, [D, r]), m(function() {
    typeof o < "u" && D !== null && rn.batchSizeIE(D, o);
  }, [D, o]), m(function() {
    typeof i < "u" && D !== null && rn.calculator(D, i);
  }, [D, i]), m(function() {
    typeof s < "u" && D !== null && rn.clusterClass(D, s);
  }, [D, s]), m(function() {
    typeof a < "u" && D !== null && rn.enableRetinaIcons(D, a);
  }, [D, a]), m(function() {
    typeof l < "u" && D !== null && rn.gridSize(D, l);
  }, [D, l]), m(function() {
    typeof u < "u" && D !== null && rn.ignoreHidden(D, u);
  }, [D, u]), m(function() {
    typeof c < "u" && D !== null && rn.imageExtension(D, c);
  }, [D, c]), m(function() {
    typeof p < "u" && D !== null && rn.imagePath(D, p);
  }, [D, p]), m(function() {
    typeof d < "u" && D !== null && rn.imageSizes(D, d);
  }, [D, d]), m(function() {
    typeof h < "u" && D !== null && rn.maxZoom(D, h);
  }, [D, h]), m(function() {
    typeof y < "u" && D !== null && rn.minimumClusterSize(D, y);
  }, [D, y]), m(function() {
    typeof f < "u" && D !== null && rn.styles(D, f);
  }, [D, f]), m(function() {
    typeof g < "u" && D !== null && rn.title(D, g);
  }, [D, g]), m(function() {
    typeof x < "u" && D !== null && rn.zoomOnClick(D, x);
  }, [D, x]), m(function() {
    if (U) {
      var z = Je({}, n || O3), _ = new BA(U, [], z);
      return r && rn.averageCenter(_, r), o && rn.batchSizeIE(_, o), i && rn.calculator(_, i), s && rn.clusterClass(_, s), a && rn.enableRetinaIcons(_, a), l && rn.gridSize(_, l), u && rn.ignoreHidden(_, u), c && rn.imageExtension(_, c), p && rn.imagePath(_, p), d && rn.imageSizes(_, d), h && rn.maxZoom(_, h), y && rn.minimumClusterSize(_, y), f && rn.styles(_, f), g && rn.title(_, g), x && rn.zoomOnClick(_, x), C && W(google.maps.event.addListener(_, $o.onMouseOut, C)), b && R(google.maps.event.addListener(_, $o.onMouseOver, b)), L && V(google.maps.event.addListener(_, $o.onClick, L)), E && K(google.maps.event.addListener(_, $o.onClusteringBegin, E)), T && P(google.maps.event.addListener(_, $o.onClusteringEnd, T)), Z(_), M && M(_), function() {
        I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), S && S(_);
      };
    }
  }, []), D !== null && t(D) || null;
}
Ie(M3);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      markerClusterer: null
    }, n.setClustererCallback = function() {
      n.state.markerClusterer !== null && n.props.onLoad && n.props.onLoad(n.state.markerClusterer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context) {
      var n = new BA(this.context, [], this.props.options);
      this.registeredEvents = St({
        updaterMap: rn,
        eventMap: $o,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          markerClusterer: n
        };
      }, this.setClustererCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.markerClusterer && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: rn,
      eventMap: $o,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Nt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }, t.prototype.render = function() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }, t.contextType = mt, t;
})(Ee);
function Sx(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var IA = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || Sx(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = [
            "mousedown",
            "mouseover",
            "mouseout",
            "mouseup",
            "click",
            "dblclick",
            "touchstart",
            "touchend",
            "touchmove"
          ], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, Sx));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, h = this.infoBoxClearance.width, y = this.infoBoxClearance.height, f = this.getProjection(), g = f.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + h ? r = g.x + u - h : g.x + p + u + h > a && (r = g.x + p + u + h - a), this.alignBottom ? g.y < -c + y + d ? o = g.y + c - y - d : g.y + c + y > l && (o = g.y + c + y - l) : g.y < -c + y ? o = g.y + c - y : g.y + d + c + y > l && (o = g.y + d + c + y - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = { top: 0, bottom: 0, left: 0, right: 0 };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Dx = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Px = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, S3 = {};
function D3(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, h = Te(mt), y = k(null), f = y[0], g = y[1], x = k(null), L = x[0], E = x[1], T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = it(null);
  return m(function() {
    h && f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), m(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), m(function() {
    if (o && f !== null) {
      var j = o instanceof google.maps.LatLng ? o : new google.maps.LatLng(o.lat, o.lng);
      f.setPosition(j);
    }
  }, [o]), m(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), m(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), E(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), m(function() {
    f && a && (b !== null && google.maps.event.removeListener(b), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), m(function() {
    f && l && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), m(function() {
    f && u && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), m(function() {
    f && c && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), m(function() {
    if (h) {
      var j = r || S3, K = j.position, te = M0(j, ["position"]), O = void 0;
      K && !(K instanceof google.maps.LatLng) && (O = new google.maps.LatLng(K.lat, K.lng));
      var P = new IA(Je(Je({}, te), O ? { position: O } : {}));
      J.current = document.createElement("div"), g(P), s && E(google.maps.event.addListener(P, "closeclick", s)), a && C(google.maps.event.addListener(P, "domready", a)), l && F(google.maps.event.addListener(P, "content_changed", l)), u && U(google.maps.event.addListener(P, "position_changed", u)), c && V(google.maps.event.addListener(P, "zindex_changed", c)), P.setContent(J.current), n ? P.open(h, n) : P.getPosition() ? P.open(h) : Br(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(P);
    }
    return function() {
      f !== null && (L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), Z && google.maps.event.removeListener(Z), N && google.maps.event.removeListener(N), d && d(f), f.close());
    };
  }, []), J.current ? Nr(at.only(t), J.current) : null;
}
Ie(D3);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoBox: null
    }, n.open = function(r, o) {
      o ? n.context !== null && r.open(n.context, o) : r.getPosition() ? n.context !== null && r.open(n.context) : Br(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }, n.setInfoBoxCallback = function() {
      n.state.infoBox !== null && n.containerElement !== null && (n.state.infoBox.setContent(n.containerElement), n.open(n.state.infoBox, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoBox));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.props.options || {}, r = n.position, o = M0(n, ["position"]), i;
    r && !(r instanceof google.maps.LatLng) && (i = new google.maps.LatLng(r.lat, r.lng));
    var s = new IA(Je(Je({}, o), i ? { position: i } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = St({
      updaterMap: Px,
      eventMap: Dx,
      prevProps: {},
      nextProps: this.props,
      instance: s
    }), this.setState({ infoBox: s }, this.setInfoBoxCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = this.state.infoBox;
    r !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: Px,
      eventMap: Dx,
      prevProps: n,
      nextProps: this.props,
      instance: r
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n = this.props.onUnmount, r = this.state.infoBox;
    r !== null && (n && n(r), Nt(this.registeredEvents), r.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Nr(at.only(this.props.children), this.containerElement) : null;
  }, t.contextType = mt, t;
})(Ee);
var P3 = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, o, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
    for (o = r; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
    for (o = r; o-- !== 0; ) {
      var s = i[o];
      if (!e(t[s], n[s])) return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
}, Tx = /* @__PURE__ */ DA(P3);
const _x = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], ag = 1, gl = 8;
class S0 {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const o = r >> 4;
    if (o !== ag)
      throw new Error(`Got v${o} data when expected v${ag}.`);
    const i = _x[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new S0(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, o) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = _x.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, gl, t), this.coords = new this.ArrayType(this.data, gl + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(gl + s + a + l), this.ids = new this.IndexArrayType(this.data, gl, t), this.coords = new this.ArrayType(this.data, gl + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (ag << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return _v(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: s, nodeSize: a } = this, l = [0, i.length - 1, 0], u = [];
    for (; l.length; ) {
      const c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (let g = d; g <= p; g++) {
          const x = s[2 * g], L = s[2 * g + 1];
          x >= t && x <= r && L >= n && L <= o && u.push(i[g]);
        }
        continue;
      }
      const h = d + p >> 1, y = s[2 * h], f = s[2 * h + 1];
      y >= t && y <= r && f >= n && f <= o && u.push(i[h]), (c === 0 ? t <= y : n <= f) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= y : o >= f) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: o, coords: i, nodeSize: s } = this, a = [0, o.length - 1, 0], l = [], u = r * r;
    for (; a.length; ) {
      const c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (let g = d; g <= p; g++)
          Ax(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      const h = d + p >> 1, y = i[2 * h], f = i[2 * h + 1];
      Ax(y, f, t, n) <= u && l.push(o[h]), (c === 0 ? t - r <= y : n - r <= f) && (a.push(d), a.push(h - 1), a.push(1 - c)), (c === 0 ? t + r >= y : n + r >= f) && (a.push(h + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function _v(e, t, n, r, o, i) {
  if (o - r <= n) return;
  const s = r + o >> 1;
  jA(e, t, s, r, o, i), _v(e, t, n, r, s - 1, 1 - i), _v(e, t, n, s + 1, o, 1 - i);
}
function jA(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      const u = o - r + 1, c = n - r + 1, p = Math.log(u), d = 0.5 * Math.exp(2 * p / 3), h = 0.5 * Math.sqrt(p * d * (u - d) / u) * (c - u / 2 < 0 ? -1 : 1), y = Math.max(r, Math.floor(n - c * d / u + h)), f = Math.min(o, Math.floor(n + (u - c) * d / u + h));
      jA(e, t, n, y, f, i);
    }
    const s = t[2 * n + i];
    let a = r, l = o;
    for (ml(e, t, r, n), t[2 * o + i] > s && ml(e, t, r, o); a < l; ) {
      for (ml(e, t, a, l), a++, l--; t[2 * a + i] < s; ) a++;
      for (; t[2 * l + i] > s; ) l--;
    }
    t[2 * r + i] === s ? ml(e, t, r, l) : (l++, ml(e, t, l, o)), l <= n && (r = l + 1), n <= l && (o = l - 1);
  }
}
function ml(e, t, n, r) {
  lg(e, n, r), lg(t, 2 * n, 2 * r), lg(t, 2 * n + 1, 2 * r + 1);
}
function lg(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function Ax(e, t, n, r) {
  const o = e - n, i = t - r;
  return o * o + i * i;
}
const T3 = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, Bx = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Ws = 2, ps = 3, ug = 4, ss = 5, RA = 6;
class _3 {
  constructor(t) {
    this.options = Object.assign(Object.create(T3), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    const { log: n, minZoom: r, maxZoom: o } = this.options;
    n && console.time("total time");
    const i = `prepare ${t.length} points`;
    n && console.time(i), this.points = t;
    const s = [];
    for (let l = 0; l < t.length; l++) {
      const u = t[l];
      if (!u.geometry) continue;
      const [c, p] = u.geometry.coordinates, d = Bx(Sc(c)), h = Bx(Dc(p));
      s.push(
        d,
        h,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        l,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && s.push(0);
    }
    let a = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (let l = o; l >= r; l--) {
      const u = +Date.now();
      a = this.trees[l] = this._createTree(this._cluster(a, l)), n && console.log("z%d: %d clusters in %dms", l, a.numItems, +Date.now() - u);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    let r = ((t[0] + 180) % 360 + 360) % 360 - 180;
    const o = Math.max(-90, Math.min(90, t[1]));
    let i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
    const s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      const p = this.getClusters([r, o, 180, s], n), d = this.getClusters([-180, o, i, s], n);
      return p.concat(d);
    }
    const a = this.trees[this._limitZoom(n)], l = a.range(Sc(r), Dc(s), Sc(i), Dc(o)), u = a.data, c = [];
    for (const p of l) {
      const d = this.stride * p;
      c.push(u[d + ss] > 1 ? Ix(u, d, this.clusterProps) : this.points[u[d + ps]]);
    }
    return c;
  }
  getChildren(t) {
    const n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    const s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    const a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (const d of c) {
      const h = d * this.stride;
      s[h + ug] === t && p.push(s[h + ss] > 1 ? Ix(s, h, this.clusterProps) : this.points[s[h + ps]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    const o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    const o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), { extent: s, radius: a } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(
      o.range((n - l) / i, u, (n + 1 + l) / i, c),
      o.data,
      n,
      r,
      i,
      p
    ), n === 0 && this._addTileFeatures(
      o.range(1 - l / i, u, 1, c),
      o.data,
      i,
      r,
      i,
      p
    ), n === i - 1 && this._addTileFeatures(
      o.range(0, u, l / i, c),
      o.data,
      -1,
      r,
      i,
      p
    ), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    let n = this._getOriginZoom(t) - 1;
    for (; n <= this.options.maxZoom; ) {
      const r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    const s = this.getChildren(n);
    for (const a of s) {
      const l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    const n = new S0(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (const a of t) {
      const l = a * this.stride, u = n[l + ss] > 1;
      let c, p, d;
      if (u)
        c = NA(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        const f = this.points[n[l + ps]];
        c = f.properties;
        const [g, x] = f.geometry.coordinates;
        p = Sc(g), d = Dc(x);
      }
      const h = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (p * i - r)),
          Math.round(this.options.extent * (d * i - o))
        ]],
        tags: c
      };
      let y;
      u || this.options.generateId ? y = n[l + ps] : y = this.points[n[l + ps]].id, y !== void 0 && (h.id = y), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    const { radius: r, extent: o, reduce: i, minPoints: s } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride;
    for (let p = 0; p < l.length; p += c) {
      if (l[p + Ws] <= n) continue;
      l[p + Ws] = n;
      const d = l[p], h = l[p + 1], y = t.within(l[p], l[p + 1], a), f = l[p + ss];
      let g = f;
      for (const x of y) {
        const L = x * c;
        l[L + Ws] > n && (g += l[L + ss]);
      }
      if (g > f && g >= s) {
        let x = d * f, L = h * f, E, T = -1;
        const b = ((p / c | 0) << 5) + (n + 1) + this.points.length;
        for (const C of y) {
          const M = C * c;
          if (l[M + Ws] <= n) continue;
          l[M + Ws] = n;
          const S = l[M + ss];
          x += l[M] * S, L += l[M + 1] * S, l[M + ug] = b, i && (E || (E = this._map(l, p, !0), T = this.clusterProps.length, this.clusterProps.push(E)), i(E, this._map(l, M)));
        }
        l[p + ug] = b, u.push(x / g, L / g, 1 / 0, b, -1, g), i && u.push(T);
      } else {
        for (let x = 0; x < c; x++) u.push(l[p + x]);
        if (g > 1)
          for (const x of y) {
            const L = x * c;
            if (!(l[L + Ws] <= n)) {
              l[L + Ws] = n;
              for (let E = 0; E < c; E++) u.push(l[L + E]);
            }
          }
      }
    }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ss] > 1) {
      const s = this.clusterProps[t[n + RA]];
      return r ? Object.assign({}, s) : s;
    }
    const o = this.points[t[n + ps]].properties, i = this.options.map(o);
    return r && i === o ? Object.assign({}, i) : i;
  }
}
function Ix(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ps],
    properties: NA(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [A3(e[t]), B3(e[t + 1])]
    }
  };
}
function NA(e, t, n) {
  const r = e[t + ss], o = r >= 1e4 ? `${Math.round(r / 1e3)}k` : r >= 1e3 ? `${Math.round(r / 100) / 10}k` : r, i = e[t + RA], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + ps],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Sc(e) {
  return e / 360 + 0.5;
}
function Dc(e) {
  const t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function A3(e) {
  return (e - 0.5) * 360;
}
function B3(e) {
  const t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function I3(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class ko {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Av {
  constructor({ markers: t, position: n }) {
    this.markers = t, n && (n instanceof google.maps.LatLng ? this._position = n : this._position = new google.maps.LatLng(n));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const t = new google.maps.LatLngBounds(this._position, this._position);
    for (const n of this.markers)
      t.extend(ko.getPosition(n));
    return t;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => ko.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (ko.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class j3 {
  constructor({ maxZoom: t = 16 }) {
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: t }) {
    return R3(t);
  }
}
const R3 = (e) => e.map((t) => new Av({
  position: ko.getPosition(t),
  markers: [t]
}));
class N3 extends j3 {
  constructor(t) {
    var { maxZoom: n, radius: r = 60 } = t, o = I3(t, ["maxZoom", "radius"]);
    super({ maxZoom: n }), this.state = { zoom: -1 }, this.superCluster = new _3(Object.assign({ maxZoom: this.maxZoom, radius: r }, o));
  }
  calculate(t) {
    let n = !1;
    const r = { zoom: t.map.getZoom() };
    if (!Tx(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      const o = this.markers.map((i) => {
        const s = ko.getPosition(i);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [s.lng(), s.lat()]
          },
          properties: { marker: i }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !Tx(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), { clusters: this.clusters, changed: n };
  }
  cluster({ map: t }) {
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t.getZoom())).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [t, n] }, properties: r }) {
    if (r.cluster)
      return new Av({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((i) => i.properties.marker),
        position: { lat: n, lng: t }
      });
    const o = r.marker;
    return new Av({
      markers: [o],
      position: ko.getPosition(o)
    });
  }
}
class F3 {
  constructor(t, n) {
    this.markers = { sum: t.length };
    const r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class z3 {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: t, position: n }, r, o) {
    const i = `<svg fill="${t > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>
</svg>`, s = `Cluster of ${t} markers`, a = Number(google.maps.Marker.MAX_ZINDEX) + t;
    if (ko.isAdvancedMarkerAvailable(o)) {
      const u = new DOMParser().parseFromString(i, "image/svg+xml").documentElement;
      u.setAttribute("transform", "translate(0 25)");
      const c = {
        map: o,
        position: n,
        zIndex: a,
        title: s,
        content: u
      };
      return new google.maps.marker.AdvancedMarkerElement(c);
    }
    const l = {
      position: n,
      zIndex: a,
      title: s,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(i)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(l);
  }
}
function U3(e, t) {
  for (let n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class D0 {
  constructor() {
    U3(D0, google.maps.OverlayView);
  }
}
var Wl;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Wl || (Wl = {}));
const $3 = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class W3 extends D0 {
  constructor({ map: t, markers: n = [], algorithmOptions: r = {}, algorithm: o = new N3(r), renderer: i = new z3(), onClusterClick: s = $3 }) {
    super(), this.markers = [...n], this.clusters = [], this.algorithm = o, this.renderer = i, this.onClusterClick = s, t && this.setMap(t);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    const r = this.markers.indexOf(t);
    return r === -1 ? !1 : (ko.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    let r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Wl.CLUSTERING_BEGIN, this);
      const { clusters: n, changed: r } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        const o = /* @__PURE__ */ new Set();
        for (const s of n)
          s.markers.length == 1 && o.add(s.markers[0]);
        const i = [];
        for (const s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || ko.setMap(s.marker, null) : i.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => i.forEach((s) => ko.setMap(s, null)));
      }
      google.maps.event.trigger(this, Wl.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => ko.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    const t = new F3(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => ko.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Wl.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), ko.setMap(r.marker, n);
    });
  }
}
function H3(e) {
  var t = n3(), n = k(null), r = n[0], o = n[1];
  return m(function() {
    if (t && r === null) {
      var i = new W3(Je(Je({}, e), { map: t }));
      o(i);
    }
  }, [t]), r;
}
function V3(e) {
  var t = e.children, n = e.options, r = H3(n);
  return r !== null ? t(r) : null;
}
Ie(V3);
var jx = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Rx = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
function Z3(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, h = Te(mt), y = k(null), f = y[0], g = y[1], x = k(null), L = x[0], E = x[1], T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = it(null);
  return m(function() {
    f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), m(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), m(function() {
    o && f !== null && f.setPosition(o);
  }, [o]), m(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), m(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), E(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), m(function() {
    f && a && (b !== null && google.maps.event.removeListener(b), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), m(function() {
    f && l && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), m(function() {
    f && u && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), m(function() {
    f && c && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), m(function() {
    var j = new google.maps.InfoWindow(Je({}, r || {}));
    return g(j), J.current = document.createElement("div"), s && E(google.maps.event.addListener(j, "closeclick", s)), a && C(google.maps.event.addListener(j, "domready", a)), l && F(google.maps.event.addListener(j, "content_changed", l)), u && U(google.maps.event.addListener(j, "position_changed", u)), c && V(google.maps.event.addListener(j, "zindex_changed", c)), j.setContent(J.current), o && j.setPosition(o), i && j.setZIndex(i), n ? j.open(h, n) : j.getPosition() ? j.open(h) : Br(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(j), function() {
      L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), Z && google.maps.event.removeListener(Z), N && google.maps.event.removeListener(N), d && d(j), j.close();
    };
  }, []), J.current ? Nr(at.only(t), J.current) : null;
}
Ie(Z3);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoWindow: null
    }, n.open = function(r, o) {
      o ? r.open(n.context, o) : r.getPosition() ? r.open(n.context) : Br(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }, n.setInfoWindowCallback = function() {
      n.state.infoWindow !== null && n.containerElement !== null && (n.state.infoWindow.setContent(n.containerElement), n.open(n.state.infoWindow, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoWindow));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.InfoWindow(Je({}, this.props.options || {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = St({
      updaterMap: Rx,
      eventMap: jx,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        infoWindow: n
      };
    }, this.setInfoWindowCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.infoWindow !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: Rx,
      eventMap: jx,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.infoWindow !== null && (Nt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Nr(at.only(this.props.children), this.containerElement) : null;
  }, t.contextType = mt, t;
})(Ee);
var Nx = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Fx = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, q3 = {};
function G3(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, h = e.onMouseUp, y = e.onRightClick, f = e.onClick, g = e.onDrag, x = e.onLoad, L = e.onUnmount, E = Te(mt), T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1];
  return m(function() {
    b !== null && b.setMap(E);
  }, [E]), m(function() {
    typeof t < "u" && b !== null && b.setOptions(t);
  }, [b, t]), m(function() {
    typeof n < "u" && b !== null && b.setDraggable(n);
  }, [b, n]), m(function() {
    typeof r < "u" && b !== null && b.setEditable(r);
  }, [b, r]), m(function() {
    typeof o < "u" && b !== null && b.setVisible(o);
  }, [b, o]), m(function() {
    typeof i < "u" && b !== null && b.setPath(i);
  }, [b, i]), m(function() {
    b && s && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(b, "dblclick", s)));
  }, [s]), m(function() {
    b && a && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(b, "dragend", a)));
  }, [a]), m(function() {
    b && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(b, "dragstart", l)));
  }, [l]), m(function() {
    b && u && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(b, "mousedown", u)));
  }, [u]), m(function() {
    b && c && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(b, "mousemove", c)));
  }, [c]), m(function() {
    b && p && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(b, "mouseout", p)));
  }, [p]), m(function() {
    b && d && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(b, "mouseover", d)));
  }, [d]), m(function() {
    b && h && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(b, "mouseup", h)));
  }, [h]), m(function() {
    b && y && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(b, "rightclick", y)));
  }, [y]), m(function() {
    b && f && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(b, "click", f)));
  }, [f]), m(function() {
    b && g && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(b, "drag", g)));
  }, [g]), m(function() {
    var se = new google.maps.Polyline(Je(Je({}, t || q3), { map: E }));
    return i && se.setPath(i), typeof o < "u" && se.setVisible(o), typeof r < "u" && se.setEditable(r), typeof n < "u" && se.setDraggable(n), s && F(google.maps.event.addListener(se, "dblclick", s)), a && U(google.maps.event.addListener(se, "dragend", a)), l && V(google.maps.event.addListener(se, "dragstart", l)), u && K(google.maps.event.addListener(se, "mousedown", u)), c && P(google.maps.event.addListener(se, "mousemove", c)), p && W(google.maps.event.addListener(se, "mouseout", p)), d && R(google.maps.event.addListener(se, "mouseover", d)), h && Y(google.maps.event.addListener(se, "mouseup", h)), y && ae(google.maps.event.addListener(se, "rightclick", y)), f && de(google.maps.event.addListener(se, "click", f)), g && ge(google.maps.event.addListener(se, "drag", g)), C(se), x && x(se), function() {
      S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), L && L(se), se.setMap(null);
    };
  }, []), null;
}
Ie(G3);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polyline: null
    }, n.setPolylineCallback = function() {
      n.state.polyline !== null && n.props.onLoad && n.props.onLoad(n.state.polyline);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polyline(Je(Je({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = St({
      updaterMap: Fx,
      eventMap: Nx,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polyline: n
      };
    }, this.setPolylineCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polyline !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: Fx,
      eventMap: Nx,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Nt(this.registeredEvents), this.state.polyline.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = mt, t;
})(Ee);
var zx = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Ux = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  paths: function(e, t) {
    e.setPaths(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function X3(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.paths, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, h = e.onMouseOver, y = e.onMouseUp, f = e.onRightClick, g = e.onClick, x = e.onDrag, L = e.onLoad, E = e.onUnmount, T = e.onEdit, b = Te(mt), C = k(null), M = C[0], S = C[1], F = k(null), D = F[0], Z = F[1], U = k(null), $ = U[0], N = U[1], V = k(null), J = V[0], j = V[1], K = k(null), te = K[0], O = K[1], P = k(null), H = P[0], I = P[1], W = k(null), X = W[0], w = W[1], R = k(null), z = R[0], _ = R[1], Y = k(null), Q = Y[0], A = Y[1], ae = k(null), ce = ae[0], ue = ae[1], de = k(null), be = de[0], ve = de[1], ge = k(null), se = ge[0], xe = ge[1];
  return m(function() {
    M !== null && M.setMap(b);
  }, [b]), m(function() {
    typeof t < "u" && M !== null && M.setOptions(t);
  }, [M, t]), m(function() {
    typeof n < "u" && M !== null && M.setDraggable(n);
  }, [M, n]), m(function() {
    typeof r < "u" && M !== null && M.setEditable(r);
  }, [M, r]), m(function() {
    typeof o < "u" && M !== null && M.setVisible(o);
  }, [M, o]), m(function() {
    typeof i < "u" && M !== null && M.setPath(i);
  }, [M, i]), m(function() {
    typeof s < "u" && M !== null && M.setPaths(s);
  }, [M, s]), m(function() {
    M && a && (D !== null && google.maps.event.removeListener(D), Z(google.maps.event.addListener(M, "dblclick", a)));
  }, [a]), m(function() {
    M && (google.maps.event.addListener(M.getPath(), "insert_at", function() {
      T == null || T(M);
    }), google.maps.event.addListener(M.getPath(), "set_at", function() {
      T == null || T(M);
    }));
  }, [M, T]), m(function() {
    M && l && ($ !== null && google.maps.event.removeListener($), N(google.maps.event.addListener(M, "dragend", l)));
  }, [l]), m(function() {
    M && u && (J !== null && google.maps.event.removeListener(J), j(google.maps.event.addListener(M, "dragstart", u)));
  }, [u]), m(function() {
    M && c && (te !== null && google.maps.event.removeListener(te), O(google.maps.event.addListener(M, "mousedown", c)));
  }, [c]), m(function() {
    M && p && (H !== null && google.maps.event.removeListener(H), I(google.maps.event.addListener(M, "mousemove", p)));
  }, [p]), m(function() {
    M && d && (X !== null && google.maps.event.removeListener(X), w(google.maps.event.addListener(M, "mouseout", d)));
  }, [d]), m(function() {
    M && h && (z !== null && google.maps.event.removeListener(z), _(google.maps.event.addListener(M, "mouseover", h)));
  }, [h]), m(function() {
    M && y && (Q !== null && google.maps.event.removeListener(Q), A(google.maps.event.addListener(M, "mouseup", y)));
  }, [y]), m(function() {
    M && f && (ce !== null && google.maps.event.removeListener(ce), ue(google.maps.event.addListener(M, "rightclick", f)));
  }, [f]), m(function() {
    M && g && (be !== null && google.maps.event.removeListener(be), ve(google.maps.event.addListener(M, "click", g)));
  }, [g]), m(function() {
    M && x && (se !== null && google.maps.event.removeListener(se), xe(google.maps.event.addListener(M, "drag", x)));
  }, [x]), m(function() {
    var ne = new google.maps.Polygon(Je(Je({}, t || {}), { map: b }));
    return i && ne.setPath(i), s && ne.setPaths(s), typeof o < "u" && ne.setVisible(o), typeof r < "u" && ne.setEditable(r), typeof n < "u" && ne.setDraggable(n), a && Z(google.maps.event.addListener(ne, "dblclick", a)), l && N(google.maps.event.addListener(ne, "dragend", l)), u && j(google.maps.event.addListener(ne, "dragstart", u)), c && O(google.maps.event.addListener(ne, "mousedown", c)), p && I(google.maps.event.addListener(ne, "mousemove", p)), d && w(google.maps.event.addListener(ne, "mouseout", d)), h && _(google.maps.event.addListener(ne, "mouseover", h)), y && A(google.maps.event.addListener(ne, "mouseup", y)), f && ue(google.maps.event.addListener(ne, "rightclick", f)), g && ve(google.maps.event.addListener(ne, "click", g)), x && xe(google.maps.event.addListener(ne, "drag", x)), S(ne), L && L(ne), function() {
      D !== null && google.maps.event.removeListener(D), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), H !== null && google.maps.event.removeListener(H), X !== null && google.maps.event.removeListener(X), z !== null && google.maps.event.removeListener(z), Q !== null && google.maps.event.removeListener(Q), ce !== null && google.maps.event.removeListener(ce), be !== null && google.maps.event.removeListener(be), E && E(ne), ne.setMap(null);
    };
  }, []), null;
}
Ie(X3);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polygon: null
    }, n.setPolygonCallback = function() {
      n.state.polygon !== null && n.props.onLoad && n.props.onLoad(n.state.polygon);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polygon(Je(Je({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = St({
      updaterMap: Ux,
      eventMap: zx,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polygon: n
      };
    }, this.setPolygonCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polygon !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: Ux,
      eventMap: zx,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polygon
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polygon !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polygon), Nt(this.registeredEvents), this.state.polygon && this.state.polygon.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = mt, t;
})(Ee);
var $x = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Wx = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function Y3(e) {
  var t = e.options, n = e.bounds, r = e.draggable, o = e.editable, i = e.visible, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, h = e.onMouseUp, y = e.onRightClick, f = e.onClick, g = e.onDrag, x = e.onBoundsChanged, L = e.onLoad, E = e.onUnmount, T = Te(mt), b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1], j = k(null), K = j[0], te = j[1], O = k(null), P = O[0], H = O[1], I = k(null), W = I[0], X = I[1], w = k(null), R = w[0], z = w[1], _ = k(null), Y = _[0], Q = _[1], A = k(null), ae = A[0], ce = A[1], ue = k(null), de = ue[0], be = ue[1], ve = k(null), ge = ve[0], se = ve[1], xe = k(null), ne = xe[0], Me = xe[1];
  return m(function() {
    C !== null && C.setMap(T);
  }, [T]), m(function() {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), m(function() {
    typeof r < "u" && C !== null && C.setDraggable(r);
  }, [C, r]), m(function() {
    typeof o < "u" && C !== null && C.setEditable(o);
  }, [C, o]), m(function() {
    typeof i < "u" && C !== null && C.setVisible(i);
  }, [C, i]), m(function() {
    typeof n < "u" && C !== null && C.setBounds(n);
  }, [C, n]), m(function() {
    C && s && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), m(function() {
    C && a && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(C, "dragend", a)));
  }, [a]), m(function() {
    C && l && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(C, "dragstart", l)));
  }, [l]), m(function() {
    C && u && (K !== null && google.maps.event.removeListener(K), te(google.maps.event.addListener(C, "mousedown", u)));
  }, [u]), m(function() {
    C && c && (P !== null && google.maps.event.removeListener(P), H(google.maps.event.addListener(C, "mousemove", c)));
  }, [c]), m(function() {
    C && p && (W !== null && google.maps.event.removeListener(W), X(google.maps.event.addListener(C, "mouseout", p)));
  }, [p]), m(function() {
    C && d && (R !== null && google.maps.event.removeListener(R), z(google.maps.event.addListener(C, "mouseover", d)));
  }, [d]), m(function() {
    C && h && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(C, "mouseup", h)));
  }, [h]), m(function() {
    C && y && (ae !== null && google.maps.event.removeListener(ae), ce(google.maps.event.addListener(C, "rightclick", y)));
  }, [y]), m(function() {
    C && f && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(C, "click", f)));
  }, [f]), m(function() {
    C && g && (ge !== null && google.maps.event.removeListener(ge), se(google.maps.event.addListener(C, "drag", g)));
  }, [g]), m(function() {
    C && x && (ne !== null && google.maps.event.removeListener(ne), Me(google.maps.event.addListener(C, "bounds_changed", x)));
  }, [x]), m(function() {
    var ee = new google.maps.Rectangle(Je(Je({}, t || {}), { map: T }));
    return typeof i < "u" && ee.setVisible(i), typeof o < "u" && ee.setEditable(o), typeof r < "u" && ee.setDraggable(r), typeof n < "u" && ee.setBounds(n), s && D(google.maps.event.addListener(ee, "dblclick", s)), a && $(google.maps.event.addListener(ee, "dragend", a)), l && J(google.maps.event.addListener(ee, "dragstart", l)), u && te(google.maps.event.addListener(ee, "mousedown", u)), c && H(google.maps.event.addListener(ee, "mousemove", c)), p && X(google.maps.event.addListener(ee, "mouseout", p)), d && z(google.maps.event.addListener(ee, "mouseover", d)), h && Q(google.maps.event.addListener(ee, "mouseup", h)), y && ce(google.maps.event.addListener(ee, "rightclick", y)), f && be(google.maps.event.addListener(ee, "click", f)), g && se(google.maps.event.addListener(ee, "drag", g)), x && Me(google.maps.event.addListener(ee, "bounds_changed", x)), M(ee), L && L(ee), function() {
      F !== null && google.maps.event.removeListener(F), U !== null && google.maps.event.removeListener(U), V !== null && google.maps.event.removeListener(V), K !== null && google.maps.event.removeListener(K), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), R !== null && google.maps.event.removeListener(R), Y !== null && google.maps.event.removeListener(Y), ae !== null && google.maps.event.removeListener(ae), de !== null && google.maps.event.removeListener(de), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), E && E(ee), ee.setMap(null);
    };
  }, []), null;
}
Ie(Y3);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      rectangle: null
    }, n.setRectangleCallback = function() {
      n.state.rectangle !== null && n.props.onLoad && n.props.onLoad(n.state.rectangle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Rectangle(Je(Je({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = St({
      updaterMap: Wx,
      eventMap: $x,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        rectangle: n
      };
    }, this.setRectangleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.rectangle !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: Wx,
      eventMap: $x,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Nt(this.registeredEvents), this.state.rectangle.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = mt, t;
})(Ee);
var Hx = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Vx = {
  center: function(e, t) {
    e.setCenter(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  radius: function(e, t) {
    e.setRadius(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, J3 = {};
function K3(e) {
  var t = e.options, n = e.center, r = e.radius, o = e.draggable, i = e.editable, s = e.visible, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, h = e.onMouseOver, y = e.onMouseUp, f = e.onRightClick, g = e.onClick, x = e.onDrag, L = e.onCenterChanged, E = e.onRadiusChanged, T = e.onLoad, b = e.onUnmount, C = Te(mt), M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1], se = k(null), xe = se[0], ne = se[1], Me = k(null), ee = Me[0], Ce = Me[1], Be = k(null), _e = Be[0], $e = Be[1];
  return m(function() {
    S !== null && S.setMap(C);
  }, [C]), m(function() {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), m(function() {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), m(function() {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), m(function() {
    typeof s < "u" && S !== null && S.setVisible(s);
  }, [S, s]), m(function() {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), m(function() {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), m(function() {
    S && a && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(S, "dblclick", a)));
  }, [a]), m(function() {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), m(function() {
    S && u && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), m(function() {
    S && c && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), m(function() {
    S && p && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), m(function() {
    S && d && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), m(function() {
    S && h && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(S, "mouseover", h)));
  }, [h]), m(function() {
    S && y && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(S, "mouseup", y)));
  }, [y]), m(function() {
    S && f && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(S, "rightclick", f)));
  }, [f]), m(function() {
    S && g && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(S, "click", g)));
  }, [g]), m(function() {
    S && x && (xe !== null && google.maps.event.removeListener(xe), ne(google.maps.event.addListener(S, "drag", x)));
  }, [x]), m(function() {
    S && L && (ee !== null && google.maps.event.removeListener(ee), Ce(google.maps.event.addListener(S, "center_changed", L)));
  }, [g]), m(function() {
    S && E && (_e !== null && google.maps.event.removeListener(_e), $e(google.maps.event.addListener(S, "radius_changed", E)));
  }, [E]), m(function() {
    var he = new google.maps.Circle(Je(Je({}, t || J3), { map: C }));
    return typeof r == "number" && he.setRadius(r), typeof n < "u" && he.setCenter(n), typeof r == "number" && he.setRadius(r), typeof s < "u" && he.setVisible(s), typeof i < "u" && he.setEditable(i), typeof o < "u" && he.setDraggable(o), a && U(google.maps.event.addListener(he, "dblclick", a)), l && V(google.maps.event.addListener(he, "dragend", l)), u && K(google.maps.event.addListener(he, "dragstart", u)), c && P(google.maps.event.addListener(he, "mousedown", c)), p && W(google.maps.event.addListener(he, "mousemove", p)), d && R(google.maps.event.addListener(he, "mouseout", d)), h && Y(google.maps.event.addListener(he, "mouseover", h)), y && ae(google.maps.event.addListener(he, "mouseup", y)), f && de(google.maps.event.addListener(he, "rightclick", f)), g && ge(google.maps.event.addListener(he, "click", g)), x && ne(google.maps.event.addListener(he, "drag", x)), L && Ce(google.maps.event.addListener(he, "center_changed", L)), E && $e(google.maps.event.addListener(he, "radius_changed", E)), F(he), T && T(he), function() {
      Z !== null && google.maps.event.removeListener(Z), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), ve !== null && google.maps.event.removeListener(ve), ee !== null && google.maps.event.removeListener(ee), _e !== null && google.maps.event.removeListener(_e), b && b(he), he.setMap(null);
    };
  }, []), null;
}
Ie(K3);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      circle: null
    }, n.setCircleCallback = function() {
      n.state.circle !== null && n.props.onLoad && n.props.onLoad(n.state.circle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Circle(Je(Je({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = St({
      updaterMap: Vx,
      eventMap: Hx,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        circle: n
      };
    }, this.setCircleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.circle !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: Vx,
      eventMap: Hx,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n;
    this.state.circle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.circle), Nt(this.registeredEvents), (n = this.state.circle) === null || n === void 0 || n.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = mt, t;
})(Ee);
var Zx = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, qx = {
  add: function(e, t) {
    e.add(t);
  },
  addgeojson: function(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains: function(e, t) {
    e.contains(t);
  },
  foreach: function(e, t) {
    e.forEach(t);
  },
  loadgeojson: function(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle: function(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove: function(e, t) {
    e.remove(t);
  },
  revertstyle: function(e, t) {
    e.revertStyle(t);
  },
  controlposition: function(e, t) {
    e.setControlPosition(t);
  },
  controls: function(e, t) {
    e.setControls(t);
  },
  drawingmode: function(e, t) {
    e.setDrawingMode(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  style: function(e, t) {
    e.setStyle(t);
  },
  togeojson: function(e, t) {
    e.toGeoJson(t);
  }
};
function Q3(e) {
  var t = e.options, n = e.onClick, r = e.onDblClick, o = e.onMouseDown, i = e.onMouseMove, s = e.onMouseOut, a = e.onMouseOver, l = e.onMouseUp, u = e.onRightClick, c = e.onAddFeature, p = e.onRemoveFeature, d = e.onRemoveProperty, h = e.onSetGeometry, y = e.onSetProperty, f = e.onLoad, g = e.onUnmount, x = Te(mt), L = k(null), E = L[0], T = L[1], b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1], j = k(null), K = j[0], te = j[1], O = k(null), P = O[0], H = O[1], I = k(null), W = I[0], X = I[1], w = k(null), R = w[0], z = w[1], _ = k(null), Y = _[0], Q = _[1], A = k(null), ae = A[0], ce = A[1], ue = k(null), de = ue[0], be = ue[1], ve = k(null), ge = ve[0], se = ve[1], xe = k(null), ne = xe[0], Me = xe[1];
  return m(function() {
    E !== null && E.setMap(x);
  }, [x]), m(function() {
    E && r && (C !== null && google.maps.event.removeListener(C), M(google.maps.event.addListener(E, "dblclick", r)));
  }, [r]), m(function() {
    E && o && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(E, "mousedown", o)));
  }, [o]), m(function() {
    E && i && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(E, "mousemove", i)));
  }, [i]), m(function() {
    E && s && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(E, "mouseout", s)));
  }, [s]), m(function() {
    E && a && (K !== null && google.maps.event.removeListener(K), te(google.maps.event.addListener(E, "mouseover", a)));
  }, [a]), m(function() {
    E && l && (P !== null && google.maps.event.removeListener(P), H(google.maps.event.addListener(E, "mouseup", l)));
  }, [l]), m(function() {
    E && u && (W !== null && google.maps.event.removeListener(W), X(google.maps.event.addListener(E, "rightclick", u)));
  }, [u]), m(function() {
    E && n && (R !== null && google.maps.event.removeListener(R), z(google.maps.event.addListener(E, "click", n)));
  }, [n]), m(function() {
    E && c && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(E, "addfeature", c)));
  }, [c]), m(function() {
    E && p && (ae !== null && google.maps.event.removeListener(ae), ce(google.maps.event.addListener(E, "removefeature", p)));
  }, [p]), m(function() {
    E && d && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(E, "removeproperty", d)));
  }, [d]), m(function() {
    E && h && (ge !== null && google.maps.event.removeListener(ge), se(google.maps.event.addListener(E, "setgeometry", h)));
  }, [h]), m(function() {
    E && y && (ne !== null && google.maps.event.removeListener(ne), Me(google.maps.event.addListener(E, "setproperty", y)));
  }, [y]), m(function() {
    if (x !== null) {
      var ee = new google.maps.Data(Je(Je({}, t || {}), { map: x }));
      r && M(google.maps.event.addListener(ee, "dblclick", r)), o && D(google.maps.event.addListener(ee, "mousedown", o)), i && $(google.maps.event.addListener(ee, "mousemove", i)), s && J(google.maps.event.addListener(ee, "mouseout", s)), a && te(google.maps.event.addListener(ee, "mouseover", a)), l && H(google.maps.event.addListener(ee, "mouseup", l)), u && X(google.maps.event.addListener(ee, "rightclick", u)), n && z(google.maps.event.addListener(ee, "click", n)), c && Q(google.maps.event.addListener(ee, "addfeature", c)), p && ce(google.maps.event.addListener(ee, "removefeature", p)), d && be(google.maps.event.addListener(ee, "removeproperty", d)), h && se(google.maps.event.addListener(ee, "setgeometry", h)), y && Me(google.maps.event.addListener(ee, "setproperty", y)), T(ee), f && f(ee);
    }
    return function() {
      E && (C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), U !== null && google.maps.event.removeListener(U), V !== null && google.maps.event.removeListener(V), K !== null && google.maps.event.removeListener(K), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), R !== null && google.maps.event.removeListener(R), Y !== null && google.maps.event.removeListener(Y), ae !== null && google.maps.event.removeListener(ae), de !== null && google.maps.event.removeListener(de), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), g && g(E), E.setMap(null));
    };
  }, []), null;
}
Ie(Q3);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      data: null
    }, n.setDataCallback = function() {
      n.state.data !== null && n.props.onLoad && n.props.onLoad(n.state.data);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context !== null) {
      var n = new google.maps.Data(Je(Je({}, this.props.options || {}), { map: this.context }));
      this.registeredEvents = St({
        updaterMap: qx,
        eventMap: Zx,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          data: n
        };
      }, this.setDataCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.data !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: qx,
      eventMap: Zx,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.data
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Nt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = mt, t;
})(Ee);
var Gx = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Xx = {
  options: function(e, t) {
    e.setOptions(t);
  },
  url: function(e, t) {
    e.setUrl(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      kmlLayer: null
    }, n.setKmlLayerCallback = function() {
      n.state.kmlLayer !== null && n.props.onLoad && n.props.onLoad(n.state.kmlLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.KmlLayer(Je(Je({}, this.props.options), { map: this.context }));
    this.registeredEvents = St({
      updaterMap: Xx,
      eventMap: Gx,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        kmlLayer: n
      };
    }, this.setKmlLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.kmlLayer !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: Xx,
      eventMap: Gx,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Nt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = mt, t;
})(Ee);
function FA(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function eW(e, t) {
  return new t(e.lat, e.lng);
}
function tW(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function nW(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function rW(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function oW(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function iW(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var o = r.x, i = r.y;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function zA(e, t, n, r) {
  return n !== void 0 ? oW(e, t, rW(n, google.maps.LatLngBounds, tW)) : iW(e, t, nW(r, google.maps.LatLng, eW));
}
function sW(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function aW(e, t, n, r, o) {
  var i = (
    /** @class */
    function(s) {
      In(a, s);
      function a(l, u, c, p) {
        var d = s.call(this) || this;
        return d.container = l, d.pane = u, d.position = c, d.bounds = p, d;
      }
      return a.prototype.onAdd = function() {
        var l, u = (l = this.getPanes()) === null || l === void 0 ? void 0 : l[this.pane];
        u == null || u.appendChild(this.container);
      }, a.prototype.draw = function() {
        for (var l = this.getProjection(), u = Je({}, this.container ? FA(this.container, o) : {
          x: 0,
          y: 0
        }), c = zA(l, u, this.bounds, this.position), p = 0, d = Object.entries(c); p < d.length; p++) {
          var h = d[p], y = h[0], f = h[1];
          this.container.style[y] = f;
        }
      }, a.prototype.onRemove = function() {
        this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
      }, a;
    }(google.maps.OverlayView)
  );
  return new i(e, t, n, r);
}
function Yx(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function Jx(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function lW(e) {
  var t = e.position, n = e.bounds, r = e.mapPaneName, o = e.zIndex, i = e.onLoad, s = e.onUnmount, a = e.getPixelPositionOffset, l = e.children, u = Te(mt), c = Zn(function() {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Zn(function() {
    return aW(c, r, t, n, a);
  }, [c, r, t, n]);
  return m(function() {
    return i == null || i(p), p == null || p.setMap(u), function() {
      s == null || s(p), p == null || p.setMap(null);
    };
  }, [u, p]), m(function() {
    c.style.zIndex = "".concat(o);
  }, [o, c]), di.createPortal(l, c);
}
Ie(lW);
(function(e) {
  In(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    r.state = {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }, r.updatePane = function() {
      var i = r.props.mapPaneName, s = r.overlayView.getPanes();
      Br(!!i, "OverlayView requires props.mapPaneName but got %s", i), s ? r.setState({
        paneEl: s[i]
      }) : r.setState({
        paneEl: null
      });
    }, r.onAdd = function() {
      var i, s;
      r.updatePane(), (s = (i = r.props).onLoad) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.onPositionElement = function() {
      var i = r.overlayView.getProjection(), s = Je({ x: 0, y: 0 }, r.containerRef.current ? FA(r.containerRef.current, r.props.getPixelPositionOffset) : {}), a = zA(i, s, r.props.bounds, r.props.position), l = r.state.containerStyle, u = l.left, c = l.top, p = l.width, d = l.height;
      sW(a, { left: u, top: c, width: p, height: d }) || r.setState({
        containerStyle: {
          top: a.top || 0,
          left: a.left || 0,
          width: a.width || 0,
          height: a.height || 0,
          position: "absolute"
        }
      });
    }, r.draw = function() {
      r.onPositionElement();
    }, r.onRemove = function() {
      var i, s;
      r.setState(function() {
        return {
          paneEl: null
        };
      }), (s = (i = r.props).onUnmount) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.containerRef = Rr();
    var o = new google.maps.OverlayView();
    return o.onAdd = r.onAdd, o.draw = r.draw, o.onRemove = r.onRemove, r.overlayView = o, r;
  }
  return t.prototype.componentDidMount = function() {
    this.overlayView.setMap(this.context);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = Yx(n.position), o = Yx(this.props.position), i = Jx(n.bounds), s = Jx(this.props.bounds);
    (r !== o || i !== s) && this.overlayView.draw(), n.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }, t.prototype.componentWillUnmount = function() {
    this.overlayView.setMap(null);
  }, t.prototype.render = function() {
    var n = this.state.paneEl;
    return n ? di.createPortal(zr.jsx("div", { ref: this.containerRef, style: this.state.containerStyle, children: at.only(this.props.children) }), n) : null;
  }, t.FLOAT_PANE = "floatPane", t.MAP_PANE = "mapPane", t.MARKER_LAYER = "markerLayer", t.OVERLAY_LAYER = "overlayLayer", t.OVERLAY_MOUSE_TARGET = "overlayMouseTarget", t.contextType = mt, t;
})(Ee);
function uW() {
}
var Kx = {
  onDblClick: "dblclick",
  onClick: "click"
}, Qx = {
  opacity: function(e, t) {
    e.setOpacity(t);
  }
};
function cW(e) {
  var t = e.url, n = e.bounds, r = e.options, o = e.visible, i = Te(mt), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Zn(function() {
    var l = new google.maps.GroundOverlay(t, s, Je({}, r));
    return l;
  }, []);
  return m(function() {
    a !== null && a.setMap(i);
  }, [i]), m(function() {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), m(function() {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), m(function() {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Ie(cW);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      groundOverlay: null
    }, n.setGroundOverlayCallback = function() {
      n.state.groundOverlay !== null && n.props.onLoad && n.props.onLoad(n.state.groundOverlay);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Br(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var n = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Je(Je({}, this.props.options), { map: this.context }));
    this.registeredEvents = St({
      updaterMap: Qx,
      eventMap: Kx,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        groundOverlay: n
      };
    }, this.setGroundOverlayCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.groundOverlay !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: Qx,
      eventMap: Kx,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.defaultProps = {
    onLoad: uW
  }, t.contextType = mt, t;
})(Ee);
var eE = {}, tE = {
  data: function(e, t) {
    e.setData(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function pW(e) {
  var t = e.data, n = e.onLoad, r = e.onUnmount, o = e.options, i = Te(mt), s = k(null), a = s[0], l = s[1];
  return m(function() {
    google.maps.visualization || Br(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), m(function() {
    Br(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), m(function() {
    a !== null && a.setMap(i);
  }, [i]), m(function() {
    o && a !== null && a.setOptions(o);
  }, [a, o]), m(function() {
    var u = new google.maps.visualization.HeatmapLayer(Je(Je({}, o || {}), { data: t, map: i }));
    return l(u), n && n(u), function() {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Ie(pW);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      heatmapLayer: null
    }, n.setHeatmapLayerCallback = function() {
      n.state.heatmapLayer !== null && n.props.onLoad && n.props.onLoad(n.state.heatmapLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Br(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Br(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var n = new google.maps.visualization.HeatmapLayer(Je(Je({}, this.props.options || {}), { data: this.props.data, map: this.context }));
    this.registeredEvents = St({
      updaterMap: tE,
      eventMap: eE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        heatmapLayer: n
      };
    }, this.setHeatmapLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: tE,
      eventMap: eE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Nt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = mt, t;
})(Ee);
var nE = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, rE = {
  register: function(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links: function(e, t) {
    e.setLinks(t);
  },
  motionTracking: function(e, t) {
    e.setMotionTracking(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  pano: function(e, t) {
    e.setPano(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  pov: function(e, t) {
    e.setPov(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      streetViewPanorama: null
    }, n.setStreetViewPanoramaCallback = function() {
      n.state.streetViewPanorama !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewPanorama);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n, r, o = (r = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && r !== void 0 ? r : null;
    this.registeredEvents = St({
      updaterMap: rE,
      eventMap: nE,
      prevProps: {},
      nextProps: this.props,
      instance: o
    }), this.setState(function() {
      return {
        streetViewPanorama: o
      };
    }, this.setStreetViewPanoramaCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.streetViewPanorama !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: rE,
      eventMap: nE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Nt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = mt, t;
})(Ee);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      streetViewService: null
    }, n.setStreetViewServiceCallback = function() {
      n.state.streetViewService !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: n
      };
    }, this.setStreetViewServiceCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = mt, t;
})(Ee);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      directionsService: null
    }, n.setDirectionsServiceCallback = function() {
      n.state.directionsService !== null && n.props.onLoad && n.props.onLoad(n.state.directionsService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Br(!!this.props.options, "DirectionsService expected options object as parameter, but got %s", this.props.options);
    var n = new google.maps.DirectionsService();
    this.setState(function() {
      return {
        directionsService: n
      };
    }, this.setDirectionsServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.directionsService !== null && this.state.directionsService.route(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsService !== null && this.props.onUnmount && this.props.onUnmount(this.state.directionsService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Ee);
var oE = {
  onDirectionsChanged: "directions_changed"
}, iE = {
  directions: function(e, t) {
    e.setDirections(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  panel: function(e, t) {
    e.setPanel(t);
  },
  routeIndex: function(e, t) {
    e.setRouteIndex(t);
  }
};
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      directionsRenderer: null
    }, n.setDirectionsRendererCallback = function() {
      n.state.directionsRenderer !== null && (n.state.directionsRenderer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.directionsRenderer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = St({
      updaterMap: iE,
      eventMap: oE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        directionsRenderer: n
      };
    }, this.setDirectionsRendererCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.directionsRenderer !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: iE,
      eventMap: oE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Nt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }, t.prototype.render = function() {
    return zr.jsx(zr.Fragment, {});
  }, t.contextType = mt, t;
})(Ee);
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      distanceMatrixService: null
    }, n.setDistanceMatrixServiceCallback = function() {
      n.state.distanceMatrixService !== null && n.props.onLoad && n.props.onLoad(n.state.distanceMatrixService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Br(!!this.props.options, "DistanceMatrixService expected options object as parameter, but go %s", this.props.options);
    var n = new google.maps.DistanceMatrixService();
    this.setState(function() {
      return {
        distanceMatrixService: n
      };
    }, this.setDistanceMatrixServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.distanceMatrixService !== null && this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.distanceMatrixService !== null && this.props.onUnmount && this.props.onUnmount(this.state.distanceMatrixService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Ee);
var sE = {
  onPlacesChanged: "places_changed"
}, aE = {
  bounds: function(e, t) {
    e.setBounds(t);
  }
};
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = Rr(), n.state = {
      searchBox: null
    }, n.setSearchBoxCallback = function() {
      n.state.searchBox !== null && n.props.onLoad && n.props.onLoad(n.state.searchBox);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (Br(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var n = this.containerElement.current.querySelector("input");
      if (n !== null) {
        var r = new google.maps.places.SearchBox(n, this.props.options);
        this.registeredEvents = St({
          updaterMap: aE,
          eventMap: sE,
          prevProps: {},
          nextProps: this.props,
          instance: r
        }), this.setState(function() {
          return {
            searchBox: r
          };
        }, this.setSearchBoxCallback);
      }
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.searchBox !== null && (Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: aE,
      eventMap: sE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Nt(this.registeredEvents));
  }, t.prototype.render = function() {
    return zr.jsx("div", { ref: this.containerElement, children: at.only(this.props.children) });
  }, t.contextType = mt, t;
})(Ee);
var lE = {
  onPlaceChanged: "place_changed"
}, uE = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  restrictions: function(e, t) {
    e.setComponentRestrictions(t);
  },
  fields: function(e, t) {
    e.setFields(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  types: function(e, t) {
    e.setTypes(t);
  }
};
(function(e) {
  In(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = Rr(), n.state = {
      autocomplete: null
    }, n.setAutocompleteCallback = function() {
      n.state.autocomplete !== null && n.props.onLoad && n.props.onLoad(n.state.autocomplete);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n;
    Br(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var r = (n = this.containerElement.current) === null || n === void 0 ? void 0 : n.querySelector("input");
    if (r) {
      var o = new google.maps.places.Autocomplete(r, this.props.options);
      this.registeredEvents = St({
        updaterMap: uE,
        eventMap: lE,
        prevProps: {},
        nextProps: this.props,
        instance: o
      }), this.setState(function() {
        return {
          autocomplete: o
        };
      }, this.setAutocompleteCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    Nt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: uE,
      eventMap: lE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.autocomplete !== null && Nt(this.registeredEvents);
  }, t.prototype.render = function() {
    return zr.jsx("div", { ref: this.containerElement, className: this.props.className, children: at.only(this.props.children) });
  }, t.defaultProps = {
    className: ""
  }, t.contextType = mt, t;
})(Ee);
qe({});
function dW(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const fW = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
dW(fW.CNPJ).length;
Ba((e, t) => /* @__PURE__ */ zr.jsx("input", { ref: t, ...e }));
var Tn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function hW(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Bv = { exports: {} }, vl = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cE;
function gW() {
  if (cE) return vl;
  cE = 1;
  var e = Ae, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, h = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: h, props: p, _owner: o.current };
  }
  return vl.Fragment = n, vl.jsx = s, vl.jsxs = s, vl;
}
var Pc = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pE;
function mW() {
  return pE || (pE = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ae, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), y = Symbol.iterator, f = "@@iterator";
    function g(v) {
      if (v === null || typeof v != "object")
        return null;
      var B = y && v[y] || v[f];
      return typeof B == "function" ? B : null;
    }
    var x = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function L(v) {
      {
        for (var B = arguments.length, G = new Array(B > 1 ? B - 1 : 0), oe = 1; oe < B; oe++)
          G[oe - 1] = arguments[oe];
        E("error", v, G);
      }
    }
    function E(v, B, G) {
      {
        var oe = x.ReactDebugCurrentFrame, me = oe.getStackAddendum();
        me !== "" && (B += "%s", G = G.concat([me]));
        var ye = G.map(function(fe) {
          return String(fe);
        });
        ye.unshift("Warning: " + B), Function.prototype.apply.call(console[v], console, ye);
      }
    }
    var T = !1, b = !1, C = !1, M = !1, S = !1, F;
    F = Symbol.for("react.module.reference");
    function D(v) {
      return !!(typeof v == "string" || typeof v == "function" || v === r || v === i || S || v === o || v === u || v === c || M || v === h || T || b || C || typeof v == "object" && v !== null && (v.$$typeof === d || v.$$typeof === p || v.$$typeof === s || v.$$typeof === a || v.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      v.$$typeof === F || v.getModuleId !== void 0));
    }
    function Z(v, B, G) {
      var oe = v.displayName;
      if (oe)
        return oe;
      var me = B.displayName || B.name || "";
      return me !== "" ? G + "(" + me + ")" : G;
    }
    function U(v) {
      return v.displayName || "Context";
    }
    function $(v) {
      if (v == null)
        return null;
      if (typeof v.tag == "number" && L("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof v == "function")
        return v.displayName || v.name || null;
      if (typeof v == "string")
        return v;
      switch (v) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof v == "object")
        switch (v.$$typeof) {
          case a:
            var B = v;
            return U(B) + ".Consumer";
          case s:
            var G = v;
            return U(G._context) + ".Provider";
          case l:
            return Z(v, v.render, "ForwardRef");
          case p:
            var oe = v.displayName || null;
            return oe !== null ? oe : $(v.type) || "Memo";
          case d: {
            var me = v, ye = me._payload, fe = me._init;
            try {
              return $(fe(ye));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var N = Object.assign, V = 0, J, j, K, te, O, P, H;
    function I() {
    }
    I.__reactDisabledLog = !0;
    function W() {
      {
        if (V === 0) {
          J = console.log, j = console.info, K = console.warn, te = console.error, O = console.group, P = console.groupCollapsed, H = console.groupEnd;
          var v = {
            configurable: !0,
            enumerable: !0,
            value: I,
            writable: !0
          };
          Object.defineProperties(console, {
            info: v,
            log: v,
            warn: v,
            error: v,
            group: v,
            groupCollapsed: v,
            groupEnd: v
          });
        }
        V++;
      }
    }
    function X() {
      {
        if (V--, V === 0) {
          var v = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: N({}, v, {
              value: J
            }),
            info: N({}, v, {
              value: j
            }),
            warn: N({}, v, {
              value: K
            }),
            error: N({}, v, {
              value: te
            }),
            group: N({}, v, {
              value: O
            }),
            groupCollapsed: N({}, v, {
              value: P
            }),
            groupEnd: N({}, v, {
              value: H
            })
          });
        }
        V < 0 && L("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var w = x.ReactCurrentDispatcher, R;
    function z(v, B, G) {
      {
        if (R === void 0)
          try {
            throw Error();
          } catch (me) {
            var oe = me.stack.trim().match(/\n( *(at )?)/);
            R = oe && oe[1] || "";
          }
        return `
` + R + v;
      }
    }
    var _ = !1, Y;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      Y = new Q();
    }
    function A(v, B) {
      if (!v || _)
        return "";
      {
        var G = Y.get(v);
        if (G !== void 0)
          return G;
      }
      var oe;
      _ = !0;
      var me = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ye;
      ye = w.current, w.current = null, W();
      try {
        if (B) {
          var fe = function() {
            throw Error();
          };
          if (Object.defineProperty(fe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fe, []);
            } catch (Pe) {
              oe = Pe;
            }
            Reflect.construct(v, [], fe);
          } else {
            try {
              fe.call();
            } catch (Pe) {
              oe = Pe;
            }
            v.call(fe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Pe) {
            oe = Pe;
          }
          v();
        }
      } catch (Pe) {
        if (Pe && oe && typeof Pe.stack == "string") {
          for (var pe = Pe.stack.split(`
`), De = oe.stack.split(`
`), Le = pe.length - 1, Oe = De.length - 1; Le >= 1 && Oe >= 0 && pe[Le] !== De[Oe]; )
            Oe--;
          for (; Le >= 1 && Oe >= 0; Le--, Oe--)
            if (pe[Le] !== De[Oe]) {
              if (Le !== 1 || Oe !== 1)
                do
                  if (Le--, Oe--, Oe < 0 || pe[Le] !== De[Oe]) {
                    var ze = `
` + pe[Le].replace(" at new ", " at ");
                    return v.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", v.displayName)), typeof v == "function" && Y.set(v, ze), ze;
                  }
                while (Le >= 1 && Oe >= 0);
              break;
            }
        }
      } finally {
        _ = !1, w.current = ye, X(), Error.prepareStackTrace = me;
      }
      var nt = v ? v.displayName || v.name : "", rt = nt ? z(nt) : "";
      return typeof v == "function" && Y.set(v, rt), rt;
    }
    function ae(v, B, G) {
      return A(v, !1);
    }
    function ce(v) {
      var B = v.prototype;
      return !!(B && B.isReactComponent);
    }
    function ue(v, B, G) {
      if (v == null)
        return "";
      if (typeof v == "function")
        return A(v, ce(v));
      if (typeof v == "string")
        return z(v);
      switch (v) {
        case u:
          return z("Suspense");
        case c:
          return z("SuspenseList");
      }
      if (typeof v == "object")
        switch (v.$$typeof) {
          case l:
            return ae(v.render);
          case p:
            return ue(v.type, B, G);
          case d: {
            var oe = v, me = oe._payload, ye = oe._init;
            try {
              return ue(ye(me), B, G);
            } catch {
            }
          }
        }
      return "";
    }
    var de = Object.prototype.hasOwnProperty, be = {}, ve = x.ReactDebugCurrentFrame;
    function ge(v) {
      if (v) {
        var B = v._owner, G = ue(v.type, v._source, B ? B.type : null);
        ve.setExtraStackFrame(G);
      } else
        ve.setExtraStackFrame(null);
    }
    function se(v, B, G, oe, me) {
      {
        var ye = Function.call.bind(de);
        for (var fe in v)
          if (ye(v, fe)) {
            var pe = void 0;
            try {
              if (typeof v[fe] != "function") {
                var De = Error((oe || "React class") + ": " + G + " type `" + fe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof v[fe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw De.name = "Invariant Violation", De;
              }
              pe = v[fe](B, fe, oe, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Le) {
              pe = Le;
            }
            pe && !(pe instanceof Error) && (ge(me), L("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", oe || "React class", G, fe, typeof pe), ge(null)), pe instanceof Error && !(pe.message in be) && (be[pe.message] = !0, ge(me), L("Failed %s type: %s", G, pe.message), ge(null));
          }
      }
    }
    var xe = Array.isArray;
    function ne(v) {
      return xe(v);
    }
    function Me(v) {
      {
        var B = typeof Symbol == "function" && Symbol.toStringTag, G = B && v[Symbol.toStringTag] || v.constructor.name || "Object";
        return G;
      }
    }
    function ee(v) {
      try {
        return Ce(v), !1;
      } catch {
        return !0;
      }
    }
    function Ce(v) {
      return "" + v;
    }
    function Be(v) {
      if (ee(v))
        return L("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Me(v)), Ce(v);
    }
    var _e = x.ReactCurrentOwner, $e = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, he, Ge, We;
    We = {};
    function Ut(v) {
      if (de.call(v, "ref")) {
        var B = Object.getOwnPropertyDescriptor(v, "ref").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return v.ref !== void 0;
    }
    function ot(v) {
      if (de.call(v, "key")) {
        var B = Object.getOwnPropertyDescriptor(v, "key").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return v.key !== void 0;
    }
    function st(v, B) {
      if (typeof v.ref == "string" && _e.current && B && _e.current.stateNode !== B) {
        var G = $(_e.current.type);
        We[G] || (L('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(_e.current.type), v.ref), We[G] = !0);
      }
    }
    function Zt(v, B) {
      {
        var G = function() {
          he || (he = !0, L("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(v, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function qt(v, B) {
      {
        var G = function() {
          Ge || (Ge = !0, L("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(v, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Gt = function(v, B, G, oe, me, ye, fe) {
      var pe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: v,
        key: B,
        ref: G,
        props: fe,
        // Record the component responsible for creating this element.
        _owner: ye
      };
      return pe._store = {}, Object.defineProperty(pe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(pe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: oe
      }), Object.defineProperty(pe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: me
      }), Object.freeze && (Object.freeze(pe.props), Object.freeze(pe)), pe;
    };
    function Xt(v, B, G, oe, me) {
      {
        var ye, fe = {}, pe = null, De = null;
        G !== void 0 && (Be(G), pe = "" + G), ot(B) && (Be(B.key), pe = "" + B.key), Ut(B) && (De = B.ref, st(B, me));
        for (ye in B)
          de.call(B, ye) && !$e.hasOwnProperty(ye) && (fe[ye] = B[ye]);
        if (v && v.defaultProps) {
          var Le = v.defaultProps;
          for (ye in Le)
            fe[ye] === void 0 && (fe[ye] = Le[ye]);
        }
        if (pe || De) {
          var Oe = typeof v == "function" ? v.displayName || v.name || "Unknown" : v;
          pe && Zt(fe, Oe), De && qt(fe, Oe);
        }
        return Gt(v, pe, De, me, oe, _e.current, fe);
      }
    }
    var et = x.ReactCurrentOwner, bt = x.ReactDebugCurrentFrame;
    function tt(v) {
      if (v) {
        var B = v._owner, G = ue(v.type, v._source, B ? B.type : null);
        bt.setExtraStackFrame(G);
      } else
        bt.setExtraStackFrame(null);
    }
    var ut;
    ut = !1;
    function Yt(v) {
      return typeof v == "object" && v !== null && v.$$typeof === t;
    }
    function gn() {
      {
        if (et.current) {
          var v = $(et.current.type);
          if (v)
            return `

Check the render method of \`` + v + "`.";
        }
        return "";
      }
    }
    function Jt(v) {
      {
        if (v !== void 0) {
          var B = v.fileName.replace(/^.*[\\\/]/, ""), G = v.lineNumber;
          return `

Check your code at ` + B + ":" + G + ".";
        }
        return "";
      }
    }
    var mn = {};
    function qn(v) {
      {
        var B = gn();
        if (!B) {
          var G = typeof v == "string" ? v : v.displayName || v.name;
          G && (B = `

Check the top-level render call using <` + G + ">.");
        }
        return B;
      }
    }
    function wt(v, B) {
      {
        if (!v._store || v._store.validated || v.key != null)
          return;
        v._store.validated = !0;
        var G = qn(B);
        if (mn[G])
          return;
        mn[G] = !0;
        var oe = "";
        v && v._owner && v._owner !== et.current && (oe = " It was passed a child from " + $(v._owner.type) + "."), tt(v), L('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, oe), tt(null);
      }
    }
    function vn(v, B) {
      {
        if (typeof v != "object")
          return;
        if (ne(v))
          for (var G = 0; G < v.length; G++) {
            var oe = v[G];
            Yt(oe) && wt(oe, B);
          }
        else if (Yt(v))
          v._store && (v._store.validated = !0);
        else if (v) {
          var me = g(v);
          if (typeof me == "function" && me !== v.entries)
            for (var ye = me.call(v), fe; !(fe = ye.next()).done; )
              Yt(fe.value) && wt(fe.value, B);
        }
      }
    }
    function Gn(v) {
      {
        var B = v.type;
        if (B == null || typeof B == "string")
          return;
        var G;
        if (typeof B == "function")
          G = B.propTypes;
        else if (typeof B == "object" && (B.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        B.$$typeof === p))
          G = B.propTypes;
        else
          return;
        if (G) {
          var oe = $(B);
          se(G, v.props, "prop", oe, v);
        } else if (B.PropTypes !== void 0 && !ut) {
          ut = !0;
          var me = $(B);
          L("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", me || "Unknown");
        }
        typeof B.getDefaultProps == "function" && !B.getDefaultProps.isReactClassApproved && L("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Kt(v) {
      {
        for (var B = Object.keys(v.props), G = 0; G < B.length; G++) {
          var oe = B[G];
          if (oe !== "children" && oe !== "key") {
            tt(v), L("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", oe), tt(null);
            break;
          }
        }
        v.ref !== null && (tt(v), L("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var yn = {};
    function bn(v, B, G, oe, me, ye) {
      {
        var fe = D(v);
        if (!fe) {
          var pe = "";
          (v === void 0 || typeof v == "object" && v !== null && Object.keys(v).length === 0) && (pe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var De = Jt(me);
          De ? pe += De : pe += gn();
          var Le;
          v === null ? Le = "null" : ne(v) ? Le = "array" : v !== void 0 && v.$$typeof === t ? (Le = "<" + ($(v.type) || "Unknown") + " />", pe = " Did you accidentally export a JSX literal instead of a component?") : Le = typeof v, L("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Le, pe);
        }
        var Oe = Xt(v, B, G, me, ye);
        if (Oe == null)
          return Oe;
        if (fe) {
          var ze = B.children;
          if (ze !== void 0)
            if (oe)
              if (ne(ze)) {
                for (var nt = 0; nt < ze.length; nt++)
                  vn(ze[nt], v);
                Object.freeze && Object.freeze(ze);
              } else
                L("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              vn(ze, v);
        }
        if (de.call(B, "key")) {
          var rt = $(v), Pe = Object.keys(B).filter(function(bi) {
            return bi !== "key";
          }), ie = Pe.length > 0 ? "{key: someKey, " + Pe.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!yn[rt + ie]) {
            var yi = Pe.length > 0 ? "{" + Pe.join(": ..., ") + ": ...}" : "{}";
            L(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ie, rt, yi, rt), yn[rt + ie] = !0;
          }
        }
        return v === r ? Kt(Oe) : Gn(Oe), Oe;
      }
    }
    function Qt(v, B, G) {
      return bn(v, B, G, !0);
    }
    function Xn(v, B, G) {
      return bn(v, B, G, !1);
    }
    var Yn = Xn, en = Qt;
    Pc.Fragment = r, Pc.jsx = Yn, Pc.jsxs = en;
  }()), Pc;
}
process.env.NODE_ENV === "production" ? Bv.exports = gW() : Bv.exports = mW();
var Ur = Bv.exports;
qe({});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Iv = function(e, t) {
  return Iv = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
  }, Iv(e, t);
};
function jn(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Iv(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Ke = function() {
  return Ke = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ke.apply(this, arguments);
};
function P0(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function vW(e, t, n, r) {
  function o(i) {
    return i instanceof n ? i : new n(function(s) {
      s(i);
    });
  }
  return new (n || (n = Promise))(function(i, s) {
    function a(c) {
      try {
        u(r.next(c));
      } catch (p) {
        s(p);
      }
    }
    function l(c) {
      try {
        u(r.throw(c));
      } catch (p) {
        s(p);
      }
    }
    function u(c) {
      c.done ? i(c.value) : o(c.value).then(a, l);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function yW(e, t) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, o, i, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(c) {
      return l([u, c]);
    };
  }
  function l(u) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, o && (i = u[0] & 2 ? o.return : u[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, u[1])).done) return i;
      switch (o = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
        case 0:
        case 1:
          i = u;
          break;
        case 4:
          return n.label++, { value: u[1], done: !1 };
        case 5:
          n.label++, o = u[1], u = [0];
          continue;
        case 7:
          u = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            n = 0;
            continue;
          }
          if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
            n.label = u[1];
            break;
          }
          if (u[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = u;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(u);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      u = t.call(e, n);
    } catch (c) {
      u = [6, c], o = 0;
    } finally {
      r = i = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function UA(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var bW = process.env.NODE_ENV, wW = function(e, t, n, r, o, i, s, a) {
  if (bW !== "production" && t === void 0)
    throw new Error("invariant requires an error message argument");
  if (!e) {
    var l;
    if (t === void 0)
      l = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var u = [n, r, o, i, s, a], c = 0;
      l = new Error(
        t.replace(/%s/g, function() {
          return u[c++];
        })
      ), l.name = "Invariant Violation";
    }
    throw l.framesToPop = 1, l;
  }
}, CW = wW, Ir = /* @__PURE__ */ UA(CW), vt = qe(null);
function xW() {
  Ir(!!Te, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Te(vt);
  return Ir(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function EW(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function LW(e, t) {
  Object.keys(e).forEach(function(n) {
    return t(e[n], n);
  });
}
function kW(e, t, n, r) {
  var o = {}, i = function(s, a) {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return LW(e, i), o;
}
function OW(e, t, n) {
  var r = EW(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function MW(e) {
  google.maps.event.removeListener(e);
}
function Ft(e) {
  e === void 0 && (e = []), e.forEach(MW);
}
function Dt(e) {
  var t = e.updaterMap, n = e.eventMap, r = e.prevProps, o = e.nextProps, i = e.instance, s = OW(o, i, n);
  return kW(t, r, o, i), s;
}
var dE = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, fE = {
  extraMapTypes: function(e, t) {
    t.forEach(function(n, r) {
      e.mapTypes.set(String(r), n);
    });
  },
  center: function(e, t) {
    e.setCenter(t);
  },
  clickableIcons: function(e, t) {
    e.setClickableIcons(t);
  },
  heading: function(e, t) {
    e.setHeading(t);
  },
  mapTypeId: function(e, t) {
    e.setMapTypeId(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  streetView: function(e, t) {
    e.setStreetView(t);
  },
  tilt: function(e, t) {
    e.setTilt(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
function SW(e) {
  var t = e.children, n = e.options, r = e.id, o = e.mapContainerStyle, i = e.mapContainerClassName, s = e.center, a = e.onClick, l = e.onDblClick, u = e.onDrag, c = e.onDragEnd, p = e.onDragStart, d = e.onMouseMove, h = e.onMouseOut, y = e.onMouseOver, f = e.onMouseDown, g = e.onMouseUp, x = e.onRightClick, L = e.onCenterChanged, E = e.onLoad, T = e.onUnmount, b = k(null), C = b[0], M = b[1], S = it(null), F = k(null), D = F[0], Z = F[1], U = k(null), $ = U[0], N = U[1], V = k(null), J = V[0], j = V[1], K = k(null), te = K[0], O = K[1], P = k(null), H = P[0], I = P[1], W = k(null), X = W[0], w = W[1], R = k(null), z = R[0], _ = R[1], Y = k(null), Q = Y[0], A = Y[1], ae = k(null), ce = ae[0], ue = ae[1], de = k(null), be = de[0], ve = de[1], ge = k(null), se = ge[0], xe = ge[1], ne = k(null), Me = ne[0], ee = ne[1];
  return m(function() {
    n && C !== null && C.setOptions(n);
  }, [C, n]), m(function() {
    C !== null && typeof s < "u" && C.setCenter(s);
  }, [C, s]), m(function() {
    C && l && ($ !== null && google.maps.event.removeListener($), N(google.maps.event.addListener(C, "dblclick", l)));
  }, [l]), m(function() {
    C && c && (J !== null && google.maps.event.removeListener(J), j(google.maps.event.addListener(C, "dragend", c)));
  }, [c]), m(function() {
    C && p && (te !== null && google.maps.event.removeListener(te), O(google.maps.event.addListener(C, "dragstart", p)));
  }, [p]), m(function() {
    C && f && (H !== null && google.maps.event.removeListener(H), I(google.maps.event.addListener(C, "mousedown", f)));
  }, [f]), m(function() {
    C && d && (X !== null && google.maps.event.removeListener(X), w(google.maps.event.addListener(C, "mousemove", d)));
  }, [d]), m(function() {
    C && h && (z !== null && google.maps.event.removeListener(z), _(google.maps.event.addListener(C, "mouseout", h)));
  }, [h]), m(function() {
    C && y && (Q !== null && google.maps.event.removeListener(Q), A(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), m(function() {
    C && g && (ce !== null && google.maps.event.removeListener(ce), ue(google.maps.event.addListener(C, "mouseup", g)));
  }, [g]), m(function() {
    C && x && (be !== null && google.maps.event.removeListener(be), ve(google.maps.event.addListener(C, "rightclick", x)));
  }, [x]), m(function() {
    C && a && (se !== null && google.maps.event.removeListener(se), xe(google.maps.event.addListener(C, "click", a)));
  }, [a]), m(function() {
    C && u && (Me !== null && google.maps.event.removeListener(Me), ee(google.maps.event.addListener(C, "drag", u)));
  }, [u]), m(function() {
    C && L && (D !== null && google.maps.event.removeListener(D), Z(google.maps.event.addListener(C, "center_changed", L)));
  }, [a]), m(function() {
    var Ce = S.current === null ? null : new google.maps.Map(S.current, n);
    return M(Ce), Ce !== null && E && E(Ce), function() {
      Ce !== null && T && T(Ce);
    };
  }, []), Ur.jsx("div", { id: r, ref: S, style: o, className: i, children: Ur.jsx(vt.Provider, { value: C, children: C !== null ? t : null }) });
}
Ie(SW);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      map: null
    }, n.registeredEvents = [], n.mapRef = null, n.getInstance = function() {
      return n.mapRef === null ? null : new google.maps.Map(n.mapRef, n.props.options);
    }, n.panTo = function(r) {
      var o = n.getInstance();
      o && o.panTo(r);
    }, n.setMapCallback = function() {
      n.state.map !== null && n.props.onLoad && n.props.onLoad(n.state.map);
    }, n.getRef = function(r) {
      n.mapRef = r;
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.getInstance();
    this.registeredEvents = Dt({
      updaterMap: fE,
      eventMap: dE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        map: n
      };
    }, this.setMapCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.map !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: fE,
      eventMap: dE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.map
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), Ft(this.registeredEvents));
  }, t.prototype.render = function() {
    return Ur.jsx("div", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName, children: Ur.jsx(vt.Provider, { value: this.state.map, children: this.state.map !== null ? this.props.children : null }) });
  }, t;
})(Ee);
var da = typeof document < "u";
function $A(e) {
  var t = e.url, n = e.id, r = e.nonce;
  return da ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch(function(o) {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function hE(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function WA() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return hE(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return hE(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
function HA(e) {
  var t = e.googleMapsApiKey, n = e.googleMapsClientId, r = e.version, o = r === void 0 ? "weekly" : r, i = e.language, s = e.region, a = e.libraries, l = e.channel, u = e.mapIds, c = e.authReferrerPolicy, p = [];
  return Ir(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? p.push("key=".concat(t)) : n && p.push("client=".concat(n)), o && p.push("v=".concat(o)), i && p.push("language=".concat(i)), s && p.push("region=".concat(s)), a && a.length && p.push("libraries=".concat(a.sort().join(","))), l && p.push("channel=".concat(l)), u && u.length && p.push("map_ids=".concat(u.join(","))), c && p.push("auth_referrer_policy=".concat(c)), p.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(p.join("&"));
}
var yl = !1;
function VA() {
  return Ur.jsx("div", { children: "Loading..." });
}
var jv = {
  id: "script-loader",
  version: "weekly"
};
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.check = Rr(), n.state = {
      loaded: !1
    }, n.cleanupCallback = function() {
      delete window.google.maps, n.injectScript();
    }, n.isCleaningUp = function() {
      return vW(n, void 0, void 0, function() {
        function r(o) {
          if (!yl)
            o();
          else if (da)
            var i = window.setInterval(function() {
              yl || (window.clearInterval(i), o());
            }, 1);
        }
        return yW(this, function(o) {
          return [2, new Promise(r)];
        });
      });
    }, n.cleanup = function() {
      yl = !0;
      var r = document.getElementById(n.props.id);
      r && r.parentNode && r.parentNode.removeChild(r), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(o) {
        return typeof o.src == "string" && o.src.includes("maps.googleapis");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(o) {
        return o.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(o) {
        return o.innerText !== void 0 && o.innerText.length > 0 && o.innerText.includes(".gm-");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      });
    }, n.injectScript = function() {
      n.props.preventGoogleFontsLoading && WA(), Ir(!!n.props.id, 'LoadScript requires "id" prop to be a string: %s', n.props.id);
      var r = {
        id: n.props.id,
        nonce: n.props.nonce,
        url: HA(n.props)
      };
      $A(r).then(function() {
        n.props.onLoad && n.props.onLoad(), n.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch(function(o) {
        n.props.onError && n.props.onError(o), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(n.props.googleMapsApiKey || "-", ") or Client ID (").concat(n.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (da) {
      if (window.google && window.google.maps && !yl) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.props.libraries !== n.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), da && n.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }, t.prototype.componentWillUnmount = function() {
    var n = this;
    if (da) {
      this.cleanup();
      var r = function() {
        n.check.current || (delete window.google, yl = !1);
      };
      window.setTimeout(r, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }, t.prototype.render = function() {
    return Ur.jsxs(Ur.Fragment, { children: [Ur.jsx("div", { ref: this.check }), this.state.loaded ? this.props.children : this.props.loadingElement || Ur.jsx(VA, {})] });
  }, t.defaultProps = jv, t;
})(Ee);
var gE;
function DW(e) {
  var t = e.id, n = t === void 0 ? jv.id : t, r = e.version, o = r === void 0 ? jv.version : r, i = e.nonce, s = e.googleMapsApiKey, a = e.googleMapsClientId, l = e.language, u = e.region, c = e.libraries, p = e.preventGoogleFontsLoading, d = e.channel, h = e.mapIds, y = e.authReferrerPolicy, f = it(!1), g = k(!1), x = g[0], L = g[1], E = k(void 0), T = E[0], b = E[1];
  m(function() {
    return f.current = !0, function() {
      f.current = !1;
    };
  }, []), m(function() {
    da && p && WA();
  }, [p]), m(function() {
    x && Ir(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [x]);
  var C = HA({
    version: o,
    googleMapsApiKey: s,
    googleMapsClientId: a,
    language: l,
    region: u,
    libraries: c,
    channel: d,
    mapIds: h,
    authReferrerPolicy: y
  });
  m(function() {
    if (!da)
      return;
    function S() {
      f.current && (L(!0), gE = C);
    }
    if (window.google && window.google.maps && gE === C) {
      S();
      return;
    }
    $A({ id: n, url: C, nonce: i }).then(S).catch(function(F) {
      f.current && b(F), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(s || "-", ") or Client ID (").concat(a || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(F);
    });
  }, [n, C, i]);
  var M = it();
  return m(function() {
    M.current && c !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = c;
  }, [c]), { isLoaded: x, loadError: T, url: C };
}
var PW = Ur.jsx(VA, {});
function TW(e) {
  var t = e.loadingElement, n = e.onLoad, r = e.onError, o = e.onUnmount, i = e.children, s = P0(e, ["loadingElement", "onLoad", "onError", "onUnmount", "children"]), a = DW(s), l = a.isLoaded, u = a.loadError;
  return m(function() {
    l && typeof n == "function" && n();
  }, [l, n]), m(function() {
    u && typeof r == "function" && r(u);
  }, [u, r]), m(function() {
    return function() {
      o && o();
    };
  }, [o]), l ? i : t || PW;
}
Ie(TW);
var mE;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(mE || (mE = {}));
var vE = {}, yE = {
  options: function(e, t) {
    e.setOptions(t);
  }
};
function _W(e) {
  var t = e.options, n = e.onLoad, r = e.onUnmount, o = Te(vt), i = k(null), s = i[0], a = i[1];
  return m(function() {
    s !== null && s.setMap(o);
  }, [o]), m(function() {
    t && s !== null && s.setOptions(t);
  }, [s, t]), m(function() {
    var l = new google.maps.TrafficLayer(Ke(Ke({}, t || {}), { map: o }));
    return a(l), n && n(l), function() {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Ie(_W);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      trafficLayer: null
    }, n.setTrafficLayerCallback = function() {
      n.state.trafficLayer !== null && n.props.onLoad && n.props.onLoad(n.state.trafficLayer);
    }, n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TrafficLayer(Ke(Ke({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Dt({
      updaterMap: yE,
      eventMap: vE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        trafficLayer: n
      };
    }, this.setTrafficLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.trafficLayer !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: yE,
      eventMap: vE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Ft(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = vt, t;
})(Ee);
function AW(e) {
  var t = e.onLoad, n = e.onUnmount, r = Te(vt), o = k(null), i = o[0], s = o[1];
  return m(function() {
    i !== null && i.setMap(r);
  }, [r]), m(function() {
    var a = new google.maps.BicyclingLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Ie(AW);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      bicyclingLayer: null
    }, n.setBicyclingLayerCallback = function() {
      n.state.bicyclingLayer !== null && (n.state.bicyclingLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.bicyclingLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.BicyclingLayer();
    this.setState(function() {
      return {
        bicyclingLayer: n
      };
    }, this.setBicyclingLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = vt, t;
})(Ee);
function BW(e) {
  var t = e.onLoad, n = e.onUnmount, r = Te(vt), o = k(null), i = o[0], s = o[1];
  return m(function() {
    i !== null && i.setMap(r);
  }, [r]), m(function() {
    var a = new google.maps.TransitLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      i !== null && (n && n(i), i.setMap(null));
    };
  }, []), null;
}
Ie(BW);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      transitLayer: null
    }, n.setTransitLayerCallback = function() {
      n.state.transitLayer !== null && (n.state.transitLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.transitLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: n
      };
    }, this.setTransitLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = vt, t;
})(Ee);
var bE = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, wE = {
  drawingMode: function(e, t) {
    e.setDrawingMode(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function IW(e) {
  var t = e.options, n = e.drawingMode, r = e.onCircleComplete, o = e.onMarkerComplete, i = e.onOverlayComplete, s = e.onPolygonComplete, a = e.onPolylineComplete, l = e.onRectangleComplete, u = e.onLoad, c = e.onUnmount, p = Te(vt), d = k(null), h = d[0], y = d[1], f = k(null), g = f[0], x = f[1], L = k(null), E = L[0], T = L[1], b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1];
  return m(function() {
    h !== null && h.setMap(p);
  }, [p]), m(function() {
    t && h !== null && h.setOptions(t);
  }, [h, t]), m(function() {
    h !== null && h.setDrawingMode(n ?? null);
  }, [h, n]), m(function() {
    h && r && (g !== null && google.maps.event.removeListener(g), x(google.maps.event.addListener(h, "circlecomplete", r)));
  }, [h, r]), m(function() {
    h && o && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(h, "markercomplete", o)));
  }, [h, o]), m(function() {
    h && i && (C !== null && google.maps.event.removeListener(C), M(google.maps.event.addListener(h, "overlaycomplete", i)));
  }, [h, i]), m(function() {
    h && s && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(h, "polygoncomplete", s)));
  }, [h, s]), m(function() {
    h && a && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(h, "polylinecomplete", a)));
  }, [h, a]), m(function() {
    h && l && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(h, "rectanglecomplete", l)));
  }, [h, l]), m(function() {
    Ir(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var j = new google.maps.drawing.DrawingManager(Ke(Ke({}, t || {}), { map: p }));
    return n && j.setDrawingMode(n), r && x(google.maps.event.addListener(j, "circlecomplete", r)), o && T(google.maps.event.addListener(j, "markercomplete", o)), i && M(google.maps.event.addListener(j, "overlaycomplete", i)), s && D(google.maps.event.addListener(j, "polygoncomplete", s)), a && $(google.maps.event.addListener(j, "polylinecomplete", a)), l && J(google.maps.event.addListener(j, "rectanglecomplete", l)), y(j), u && u(j), function() {
      h !== null && (g && google.maps.event.removeListener(g), E && google.maps.event.removeListener(E), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), U && google.maps.event.removeListener(U), V && google.maps.event.removeListener(V), c && c(h), h.setMap(null));
    };
  }, []), null;
}
Ie(IW);
(function(e) {
  jn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    return r.registeredEvents = [], r.state = {
      drawingManager: null
    }, r.setDrawingManagerCallback = function() {
      r.state.drawingManager !== null && r.props.onLoad && r.props.onLoad(r.state.drawingManager);
    }, Ir(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing), r;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.drawing.DrawingManager(Ke(Ke({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Dt({
      updaterMap: wE,
      eventMap: bE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        drawingManager: n
      };
    }, this.setDrawingManagerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.drawingManager !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: wE,
      eventMap: bE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Ft(this.registeredEvents), this.state.drawingManager.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = vt, t;
})(Ee);
var CE = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, xE = {
  animation: function(e, t) {
    e.setAnimation(t);
  },
  clickable: function(e, t) {
    e.setClickable(t);
  },
  cursor: function(e, t) {
    e.setCursor(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  icon: function(e, t) {
    e.setIcon(t);
  },
  label: function(e, t) {
    e.setLabel(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  opacity: function(e, t) {
    e.setOpacity(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  shape: function(e, t) {
    e.setShape(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, md = {};
function jW(e) {
  var t = e.position, n = e.options, r = e.clusterer, o = e.noClustererRedraw, i = e.children, s = e.draggable, a = e.visible, l = e.animation, u = e.clickable, c = e.cursor, p = e.icon, d = e.label, h = e.opacity, y = e.shape, f = e.title, g = e.zIndex, x = e.onClick, L = e.onDblClick, E = e.onDrag, T = e.onDragEnd, b = e.onDragStart, C = e.onMouseOut, M = e.onMouseOver, S = e.onMouseUp, F = e.onMouseDown, D = e.onRightClick, Z = e.onClickableChanged, U = e.onCursorChanged, $ = e.onAnimationChanged, N = e.onDraggableChanged, V = e.onFlatChanged, J = e.onIconChanged, j = e.onPositionChanged, K = e.onShapeChanged, te = e.onTitleChanged, O = e.onVisibleChanged, P = e.onZindexChanged, H = e.onLoad, I = e.onUnmount, W = Te(vt), X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1], se = k(null), xe = se[0], ne = se[1], Me = k(null), ee = Me[0], Ce = Me[1], Be = k(null), _e = Be[0], $e = Be[1], he = k(null), Ge = he[0], We = he[1], Ut = k(null), ot = Ut[0], st = Ut[1], Zt = k(null), qt = Zt[0], Gt = Zt[1], Xt = k(null), et = Xt[0], bt = Xt[1], tt = k(null), ut = tt[0], Yt = tt[1], gn = k(null), Jt = gn[0], mn = gn[1], qn = k(null), wt = qn[0], vn = qn[1], Gn = k(null), Kt = Gn[0], yn = Gn[1], bn = k(null), Qt = bn[0], Xn = bn[1], Yn = k(null), en = Yn[0], v = Yn[1], B = k(null), G = B[0], oe = B[1], me = k(null), ye = me[0], fe = me[1], pe = k(null), De = pe[0], Le = pe[1], Oe = k(null), ze = Oe[0], nt = Oe[1];
  m(function() {
    w !== null && w.setMap(W);
  }, [W]), m(function() {
    typeof n < "u" && w !== null && w.setOptions(n);
  }, [w, n]), m(function() {
    typeof s < "u" && w !== null && w.setDraggable(s);
  }, [w, s]), m(function() {
    t && w !== null && w.setPosition(t);
  }, [w, t]), m(function() {
    typeof a < "u" && w !== null && w.setVisible(a);
  }, [w, a]), m(function() {
    w == null || w.setAnimation(l);
  }, [w, l]), m(function() {
    w && u !== void 0 && w.setClickable(u);
  }, [w, u]), m(function() {
    w && c !== void 0 && w.setCursor(c);
  }, [w, c]), m(function() {
    w && p !== void 0 && w.setIcon(p);
  }, [w, p]), m(function() {
    w && d !== void 0 && w.setLabel(d);
  }, [w, d]), m(function() {
    w && h !== void 0 && w.setOpacity(h);
  }, [w, h]), m(function() {
    w && y !== void 0 && w.setShape(y);
  }, [w, y]), m(function() {
    w && f !== void 0 && w.setTitle(f);
  }, [w, f]), m(function() {
    w && g !== void 0 && w.setZIndex(g);
  }, [w, g]), m(function() {
    w && L && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(w, "dblclick", L)));
  }, [L]), m(function() {
    w && T && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(w, "dragend", T)));
  }, [T]), m(function() {
    w && b && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(w, "dragstart", b)));
  }, [b]), m(function() {
    w && F && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(w, "mousedown", F)));
  }, [F]), m(function() {
    w && C && (xe !== null && google.maps.event.removeListener(xe), ne(google.maps.event.addListener(w, "mouseout", C)));
  }, [C]), m(function() {
    w && M && (ee !== null && google.maps.event.removeListener(ee), Ce(google.maps.event.addListener(w, "mouseover", M)));
  }, [M]), m(function() {
    w && S && (_e !== null && google.maps.event.removeListener(_e), $e(google.maps.event.addListener(w, "mouseup", S)));
  }, [S]), m(function() {
    w && D && (Ge !== null && google.maps.event.removeListener(Ge), We(google.maps.event.addListener(w, "rightclick", D)));
  }, [D]), m(function() {
    w && x && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(w, "click", x)));
  }, [x]), m(function() {
    w && E && (qt !== null && google.maps.event.removeListener(qt), Gt(google.maps.event.addListener(w, "drag", E)));
  }, [E]), m(function() {
    w && Z && (et !== null && google.maps.event.removeListener(et), bt(google.maps.event.addListener(w, "clickable_changed", Z)));
  }, [Z]), m(function() {
    w && U && (ut !== null && google.maps.event.removeListener(ut), Yt(google.maps.event.addListener(w, "cursor_changed", U)));
  }, [U]), m(function() {
    w && $ && (Jt !== null && google.maps.event.removeListener(Jt), mn(google.maps.event.addListener(w, "animation_changed", $)));
  }, [$]), m(function() {
    w && N && (wt !== null && google.maps.event.removeListener(wt), vn(google.maps.event.addListener(w, "draggable_changed", N)));
  }, [N]), m(function() {
    w && V && (Kt !== null && google.maps.event.removeListener(Kt), yn(google.maps.event.addListener(w, "flat_changed", V)));
  }, [V]), m(function() {
    w && J && (Qt !== null && google.maps.event.removeListener(Qt), Xn(google.maps.event.addListener(w, "icon_changed", J)));
  }, [J]), m(function() {
    w && j && (en !== null && google.maps.event.removeListener(en), v(google.maps.event.addListener(w, "position_changed", j)));
  }, [j]), m(function() {
    w && K && (G !== null && google.maps.event.removeListener(G), oe(google.maps.event.addListener(w, "shape_changed", K)));
  }, [K]), m(function() {
    w && te && (ye !== null && google.maps.event.removeListener(ye), fe(google.maps.event.addListener(w, "title_changed", te)));
  }, [te]), m(function() {
    w && O && (De !== null && google.maps.event.removeListener(De), Le(google.maps.event.addListener(w, "visible_changed", O)));
  }, [O]), m(function() {
    w && P && (ze !== null && google.maps.event.removeListener(ze), nt(google.maps.event.addListener(w, "zindex_changed", P)));
  }, [P]), m(function() {
    var Pe = Ke(Ke(Ke({}, n || md), r ? md : { map: W }), { position: t }), ie = new google.maps.Marker(Pe);
    return r ? r.addMarker(ie, !!o) : ie.setMap(W), t && ie.setPosition(t), typeof a < "u" && ie.setVisible(a), typeof s < "u" && ie.setDraggable(s), typeof u < "u" && ie.setClickable(u), typeof c == "string" && ie.setCursor(c), p && ie.setIcon(p), typeof d < "u" && ie.setLabel(d), typeof h < "u" && ie.setOpacity(h), y && ie.setShape(y), typeof f == "string" && ie.setTitle(f), typeof g == "number" && ie.setZIndex(g), L && Y(google.maps.event.addListener(ie, "dblclick", L)), T && ae(google.maps.event.addListener(ie, "dragend", T)), b && de(google.maps.event.addListener(ie, "dragstart", b)), F && ge(google.maps.event.addListener(ie, "mousedown", F)), C && ne(google.maps.event.addListener(ie, "mouseout", C)), M && Ce(google.maps.event.addListener(ie, "mouseover", M)), S && $e(google.maps.event.addListener(ie, "mouseup", S)), D && We(google.maps.event.addListener(ie, "rightclick", D)), x && st(google.maps.event.addListener(ie, "click", x)), E && Gt(google.maps.event.addListener(ie, "drag", E)), Z && bt(google.maps.event.addListener(ie, "clickable_changed", Z)), U && Yt(google.maps.event.addListener(ie, "cursor_changed", U)), $ && mn(google.maps.event.addListener(ie, "animation_changed", $)), N && vn(google.maps.event.addListener(ie, "draggable_changed", N)), V && yn(google.maps.event.addListener(ie, "flat_changed", V)), J && Xn(google.maps.event.addListener(ie, "icon_changed", J)), j && v(google.maps.event.addListener(ie, "position_changed", j)), K && oe(google.maps.event.addListener(ie, "shape_changed", K)), te && fe(google.maps.event.addListener(ie, "title_changed", te)), O && Le(google.maps.event.addListener(ie, "visible_changed", O)), P && nt(google.maps.event.addListener(ie, "zindex_changed", P)), R(ie), H && H(ie), function() {
      _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), ve !== null && google.maps.event.removeListener(ve), xe !== null && google.maps.event.removeListener(xe), ee !== null && google.maps.event.removeListener(ee), _e !== null && google.maps.event.removeListener(_e), Ge !== null && google.maps.event.removeListener(Ge), ot !== null && google.maps.event.removeListener(ot), et !== null && google.maps.event.removeListener(et), ut !== null && google.maps.event.removeListener(ut), Jt !== null && google.maps.event.removeListener(Jt), wt !== null && google.maps.event.removeListener(wt), Kt !== null && google.maps.event.removeListener(Kt), Qt !== null && google.maps.event.removeListener(Qt), en !== null && google.maps.event.removeListener(en), ye !== null && google.maps.event.removeListener(ye), De !== null && google.maps.event.removeListener(De), ze !== null && google.maps.event.removeListener(ze), I && I(ie), r ? r.removeMarker(ie, !!o) : ie && ie.setMap(null);
    };
  }, []);
  var rt = Zn(function() {
    return i ? at.map(i, function(Pe) {
      if (!ci(Pe))
        return Pe;
      var ie = Pe;
      return pi(ie, { anchor: w });
    }) : null;
  }, [i, w]);
  return Ur.jsx(Ur.Fragment, { children: rt }) || null;
}
Ie(jW);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = Ke(Ke(Ke({}, this.props.options || md), this.props.clusterer ? md : { map: this.context }), { position: this.props.position });
    this.marker = new google.maps.Marker(n), this.props.clusterer ? this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw) : this.marker.setMap(this.context), this.registeredEvents = Dt({
      updaterMap: xE,
      eventMap: CE,
      prevProps: {},
      nextProps: this.props,
      instance: this.marker
    }), this.props.onLoad && this.props.onLoad(this.marker);
  }, t.prototype.componentDidUpdate = function(n) {
    this.marker && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: xE,
      eventMap: CE,
      prevProps: n,
      nextProps: this.props,
      instance: this.marker
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Ft(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }, t.prototype.render = function() {
    var n = this, r = null;
    return this.props.children && (r = at.map(this.props.children, function(o) {
      if (!ci(o))
        return o;
      var i = o;
      return pi(i, { anchor: n.marker });
    })), r || null;
  }, t.contextType = vt, t;
})(Ee);
var RW = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var h = document.createElement("div");
        h.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (h.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (h.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(h), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), NW = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new RW(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function FW(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var zW = 2e3, UW = 500, $W = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", WW = "png", HW = [53, 56, 66, 78, 90], VW = "cluster", ZA = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || $W, this.imageExtension = r.imageExtension || WW, this.imageSizes = r.imageSizes || HW, this.calculator = r.calculator || FW, this.batchSize = r.batchSize || zW, this.batchSizeIE = r.batchSizeIE || UW, this.clusterClass = r.clusterClass || VW, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [
        google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged),
        google.maps.event.addListener(t, "idle", this.onIdle)
      ]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new NW(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var h = d[p];
            h.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Wo = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, on = {
  averageCenter: function(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE: function(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator: function(e, t) {
    e.setCalculator(t);
  },
  clusterClass: function(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons: function(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize: function(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden: function(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension: function(e, t) {
    e.setImageExtension(t);
  },
  imagePath: function(e, t) {
    e.setImagePath(t);
  },
  imageSizes: function(e, t) {
    e.setImageSizes(t);
  },
  maxZoom: function(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize: function(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles: function(e, t) {
    e.setStyles(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  zoomOnClick: function(e, t) {
    e.setZoomOnClick(t);
  }
}, ZW = {};
function qW(e) {
  var t = e.children, n = e.options, r = e.averageCenter, o = e.batchSizeIE, i = e.calculator, s = e.clusterClass, a = e.enableRetinaIcons, l = e.gridSize, u = e.ignoreHidden, c = e.imageExtension, p = e.imagePath, d = e.imageSizes, h = e.maxZoom, y = e.minimumClusterSize, f = e.styles, g = e.title, x = e.zoomOnClick, L = e.onClick, E = e.onClusteringBegin, T = e.onClusteringEnd, b = e.onMouseOver, C = e.onMouseOut, M = e.onLoad, S = e.onUnmount, F = k(null), D = F[0], Z = F[1], U = Te(vt), $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1];
  return m(function() {
    D && C && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(D, Wo.onMouseOut, C)));
  }, [C]), m(function() {
    D && b && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(D, Wo.onMouseOver, b)));
  }, [b]), m(function() {
    D && L && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(D, Wo.onClick, L)));
  }, [L]), m(function() {
    D && E && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(D, Wo.onClusteringBegin, E)));
  }, [E]), m(function() {
    D && T && (O !== null && google.maps.event.removeListener(O), K(google.maps.event.addListener(D, Wo.onClusteringEnd, T)));
  }, [T]), m(function() {
    typeof r < "u" && D !== null && on.averageCenter(D, r);
  }, [D, r]), m(function() {
    typeof o < "u" && D !== null && on.batchSizeIE(D, o);
  }, [D, o]), m(function() {
    typeof i < "u" && D !== null && on.calculator(D, i);
  }, [D, i]), m(function() {
    typeof s < "u" && D !== null && on.clusterClass(D, s);
  }, [D, s]), m(function() {
    typeof a < "u" && D !== null && on.enableRetinaIcons(D, a);
  }, [D, a]), m(function() {
    typeof l < "u" && D !== null && on.gridSize(D, l);
  }, [D, l]), m(function() {
    typeof u < "u" && D !== null && on.ignoreHidden(D, u);
  }, [D, u]), m(function() {
    typeof c < "u" && D !== null && on.imageExtension(D, c);
  }, [D, c]), m(function() {
    typeof p < "u" && D !== null && on.imagePath(D, p);
  }, [D, p]), m(function() {
    typeof d < "u" && D !== null && on.imageSizes(D, d);
  }, [D, d]), m(function() {
    typeof h < "u" && D !== null && on.maxZoom(D, h);
  }, [D, h]), m(function() {
    typeof y < "u" && D !== null && on.minimumClusterSize(D, y);
  }, [D, y]), m(function() {
    typeof f < "u" && D !== null && on.styles(D, f);
  }, [D, f]), m(function() {
    typeof g < "u" && D !== null && on.title(D, g);
  }, [D, g]), m(function() {
    typeof x < "u" && D !== null && on.zoomOnClick(D, x);
  }, [D, x]), m(function() {
    if (U) {
      var z = Ke({}, n || ZW), _ = new ZA(U, [], z);
      return r && on.averageCenter(_, r), o && on.batchSizeIE(_, o), i && on.calculator(_, i), s && on.clusterClass(_, s), a && on.enableRetinaIcons(_, a), l && on.gridSize(_, l), u && on.ignoreHidden(_, u), c && on.imageExtension(_, c), p && on.imagePath(_, p), d && on.imageSizes(_, d), h && on.maxZoom(_, h), y && on.minimumClusterSize(_, y), f && on.styles(_, f), g && on.title(_, g), x && on.zoomOnClick(_, x), C && W(google.maps.event.addListener(_, Wo.onMouseOut, C)), b && R(google.maps.event.addListener(_, Wo.onMouseOver, b)), L && V(google.maps.event.addListener(_, Wo.onClick, L)), E && K(google.maps.event.addListener(_, Wo.onClusteringBegin, E)), T && P(google.maps.event.addListener(_, Wo.onClusteringEnd, T)), Z(_), M && M(_), function() {
        I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), S && S(_);
      };
    }
  }, []), D !== null && t(D) || null;
}
Ie(qW);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      markerClusterer: null
    }, n.setClustererCallback = function() {
      n.state.markerClusterer !== null && n.props.onLoad && n.props.onLoad(n.state.markerClusterer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context) {
      var n = new ZA(this.context, [], this.props.options);
      this.registeredEvents = Dt({
        updaterMap: on,
        eventMap: Wo,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          markerClusterer: n
        };
      }, this.setClustererCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.markerClusterer && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: on,
      eventMap: Wo,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Ft(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }, t.prototype.render = function() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }, t.contextType = vt, t;
})(Ee);
function EE(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var qA = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || EE(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = [
            "mousedown",
            "mouseover",
            "mouseout",
            "mouseup",
            "click",
            "dblclick",
            "touchstart",
            "touchend",
            "touchmove"
          ], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, EE));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, h = this.infoBoxClearance.width, y = this.infoBoxClearance.height, f = this.getProjection(), g = f.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + h ? r = g.x + u - h : g.x + p + u + h > a && (r = g.x + p + u + h - a), this.alignBottom ? g.y < -c + y + d ? o = g.y + c - y - d : g.y + c + y > l && (o = g.y + c + y - l) : g.y < -c + y ? o = g.y + c - y : g.y + d + c + y > l && (o = g.y + d + c + y - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = { top: 0, bottom: 0, left: 0, right: 0 };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), LE = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, kE = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, GW = {};
function XW(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, h = Te(vt), y = k(null), f = y[0], g = y[1], x = k(null), L = x[0], E = x[1], T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = it(null);
  return m(function() {
    h && f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), m(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), m(function() {
    if (o && f !== null) {
      var j = o instanceof google.maps.LatLng ? o : new google.maps.LatLng(o.lat, o.lng);
      f.setPosition(j);
    }
  }, [o]), m(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), m(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), E(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), m(function() {
    f && a && (b !== null && google.maps.event.removeListener(b), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), m(function() {
    f && l && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), m(function() {
    f && u && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), m(function() {
    f && c && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), m(function() {
    if (h) {
      var j = r || GW, K = j.position, te = P0(j, ["position"]), O = void 0;
      K && !(K instanceof google.maps.LatLng) && (O = new google.maps.LatLng(K.lat, K.lng));
      var P = new qA(Ke(Ke({}, te), O ? { position: O } : {}));
      J.current = document.createElement("div"), g(P), s && E(google.maps.event.addListener(P, "closeclick", s)), a && C(google.maps.event.addListener(P, "domready", a)), l && F(google.maps.event.addListener(P, "content_changed", l)), u && U(google.maps.event.addListener(P, "position_changed", u)), c && V(google.maps.event.addListener(P, "zindex_changed", c)), P.setContent(J.current), n ? P.open(h, n) : P.getPosition() ? P.open(h) : Ir(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(P);
    }
    return function() {
      f !== null && (L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), Z && google.maps.event.removeListener(Z), N && google.maps.event.removeListener(N), d && d(f), f.close());
    };
  }, []), J.current ? Nr(at.only(t), J.current) : null;
}
Ie(XW);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoBox: null
    }, n.open = function(r, o) {
      o ? n.context !== null && r.open(n.context, o) : r.getPosition() ? n.context !== null && r.open(n.context) : Ir(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }, n.setInfoBoxCallback = function() {
      n.state.infoBox !== null && n.containerElement !== null && (n.state.infoBox.setContent(n.containerElement), n.open(n.state.infoBox, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoBox));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.props.options || {}, r = n.position, o = P0(n, ["position"]), i;
    r && !(r instanceof google.maps.LatLng) && (i = new google.maps.LatLng(r.lat, r.lng));
    var s = new qA(Ke(Ke({}, o), i ? { position: i } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Dt({
      updaterMap: kE,
      eventMap: LE,
      prevProps: {},
      nextProps: this.props,
      instance: s
    }), this.setState({ infoBox: s }, this.setInfoBoxCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = this.state.infoBox;
    r !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: kE,
      eventMap: LE,
      prevProps: n,
      nextProps: this.props,
      instance: r
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n = this.props.onUnmount, r = this.state.infoBox;
    r !== null && (n && n(r), Ft(this.registeredEvents), r.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Nr(at.only(this.props.children), this.containerElement) : null;
  }, t.contextType = vt, t;
})(Ee);
var YW = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, o, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
    for (o = r; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
    for (o = r; o-- !== 0; ) {
      var s = i[o];
      if (!e(t[s], n[s])) return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
}, OE = /* @__PURE__ */ UA(YW);
const ME = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], cg = 1, bl = 8;
class T0 {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const o = r >> 4;
    if (o !== cg)
      throw new Error(`Got v${o} data when expected v${cg}.`);
    const i = ME[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new T0(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, o) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = ME.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, bl, t), this.coords = new this.ArrayType(this.data, bl + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(bl + s + a + l), this.ids = new this.IndexArrayType(this.data, bl, t), this.coords = new this.ArrayType(this.data, bl + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (cg << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return Rv(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: s, nodeSize: a } = this, l = [0, i.length - 1, 0], u = [];
    for (; l.length; ) {
      const c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (let g = d; g <= p; g++) {
          const x = s[2 * g], L = s[2 * g + 1];
          x >= t && x <= r && L >= n && L <= o && u.push(i[g]);
        }
        continue;
      }
      const h = d + p >> 1, y = s[2 * h], f = s[2 * h + 1];
      y >= t && y <= r && f >= n && f <= o && u.push(i[h]), (c === 0 ? t <= y : n <= f) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= y : o >= f) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: o, coords: i, nodeSize: s } = this, a = [0, o.length - 1, 0], l = [], u = r * r;
    for (; a.length; ) {
      const c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (let g = d; g <= p; g++)
          SE(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      const h = d + p >> 1, y = i[2 * h], f = i[2 * h + 1];
      SE(y, f, t, n) <= u && l.push(o[h]), (c === 0 ? t - r <= y : n - r <= f) && (a.push(d), a.push(h - 1), a.push(1 - c)), (c === 0 ? t + r >= y : n + r >= f) && (a.push(h + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function Rv(e, t, n, r, o, i) {
  if (o - r <= n) return;
  const s = r + o >> 1;
  GA(e, t, s, r, o, i), Rv(e, t, n, r, s - 1, 1 - i), Rv(e, t, n, s + 1, o, 1 - i);
}
function GA(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      const u = o - r + 1, c = n - r + 1, p = Math.log(u), d = 0.5 * Math.exp(2 * p / 3), h = 0.5 * Math.sqrt(p * d * (u - d) / u) * (c - u / 2 < 0 ? -1 : 1), y = Math.max(r, Math.floor(n - c * d / u + h)), f = Math.min(o, Math.floor(n + (u - c) * d / u + h));
      GA(e, t, n, y, f, i);
    }
    const s = t[2 * n + i];
    let a = r, l = o;
    for (wl(e, t, r, n), t[2 * o + i] > s && wl(e, t, r, o); a < l; ) {
      for (wl(e, t, a, l), a++, l--; t[2 * a + i] < s; ) a++;
      for (; t[2 * l + i] > s; ) l--;
    }
    t[2 * r + i] === s ? wl(e, t, r, l) : (l++, wl(e, t, l, o)), l <= n && (r = l + 1), n <= l && (o = l - 1);
  }
}
function wl(e, t, n, r) {
  pg(e, n, r), pg(t, 2 * n, 2 * r), pg(t, 2 * n + 1, 2 * r + 1);
}
function pg(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function SE(e, t, n, r) {
  const o = e - n, i = t - r;
  return o * o + i * i;
}
const JW = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, DE = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Hs = 2, ds = 3, dg = 4, as = 5, XA = 6;
class KW {
  constructor(t) {
    this.options = Object.assign(Object.create(JW), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    const { log: n, minZoom: r, maxZoom: o } = this.options;
    n && console.time("total time");
    const i = `prepare ${t.length} points`;
    n && console.time(i), this.points = t;
    const s = [];
    for (let l = 0; l < t.length; l++) {
      const u = t[l];
      if (!u.geometry) continue;
      const [c, p] = u.geometry.coordinates, d = DE(Tc(c)), h = DE(_c(p));
      s.push(
        d,
        h,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        l,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && s.push(0);
    }
    let a = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (let l = o; l >= r; l--) {
      const u = +Date.now();
      a = this.trees[l] = this._createTree(this._cluster(a, l)), n && console.log("z%d: %d clusters in %dms", l, a.numItems, +Date.now() - u);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    let r = ((t[0] + 180) % 360 + 360) % 360 - 180;
    const o = Math.max(-90, Math.min(90, t[1]));
    let i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
    const s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      const p = this.getClusters([r, o, 180, s], n), d = this.getClusters([-180, o, i, s], n);
      return p.concat(d);
    }
    const a = this.trees[this._limitZoom(n)], l = a.range(Tc(r), _c(s), Tc(i), _c(o)), u = a.data, c = [];
    for (const p of l) {
      const d = this.stride * p;
      c.push(u[d + as] > 1 ? PE(u, d, this.clusterProps) : this.points[u[d + ds]]);
    }
    return c;
  }
  getChildren(t) {
    const n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    const s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    const a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (const d of c) {
      const h = d * this.stride;
      s[h + dg] === t && p.push(s[h + as] > 1 ? PE(s, h, this.clusterProps) : this.points[s[h + ds]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    const o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    const o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), { extent: s, radius: a } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(
      o.range((n - l) / i, u, (n + 1 + l) / i, c),
      o.data,
      n,
      r,
      i,
      p
    ), n === 0 && this._addTileFeatures(
      o.range(1 - l / i, u, 1, c),
      o.data,
      i,
      r,
      i,
      p
    ), n === i - 1 && this._addTileFeatures(
      o.range(0, u, l / i, c),
      o.data,
      -1,
      r,
      i,
      p
    ), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    let n = this._getOriginZoom(t) - 1;
    for (; n <= this.options.maxZoom; ) {
      const r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    const s = this.getChildren(n);
    for (const a of s) {
      const l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    const n = new T0(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (const a of t) {
      const l = a * this.stride, u = n[l + as] > 1;
      let c, p, d;
      if (u)
        c = YA(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        const f = this.points[n[l + ds]];
        c = f.properties;
        const [g, x] = f.geometry.coordinates;
        p = Tc(g), d = _c(x);
      }
      const h = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (p * i - r)),
          Math.round(this.options.extent * (d * i - o))
        ]],
        tags: c
      };
      let y;
      u || this.options.generateId ? y = n[l + ds] : y = this.points[n[l + ds]].id, y !== void 0 && (h.id = y), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    const { radius: r, extent: o, reduce: i, minPoints: s } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride;
    for (let p = 0; p < l.length; p += c) {
      if (l[p + Hs] <= n) continue;
      l[p + Hs] = n;
      const d = l[p], h = l[p + 1], y = t.within(l[p], l[p + 1], a), f = l[p + as];
      let g = f;
      for (const x of y) {
        const L = x * c;
        l[L + Hs] > n && (g += l[L + as]);
      }
      if (g > f && g >= s) {
        let x = d * f, L = h * f, E, T = -1;
        const b = ((p / c | 0) << 5) + (n + 1) + this.points.length;
        for (const C of y) {
          const M = C * c;
          if (l[M + Hs] <= n) continue;
          l[M + Hs] = n;
          const S = l[M + as];
          x += l[M] * S, L += l[M + 1] * S, l[M + dg] = b, i && (E || (E = this._map(l, p, !0), T = this.clusterProps.length, this.clusterProps.push(E)), i(E, this._map(l, M)));
        }
        l[p + dg] = b, u.push(x / g, L / g, 1 / 0, b, -1, g), i && u.push(T);
      } else {
        for (let x = 0; x < c; x++) u.push(l[p + x]);
        if (g > 1)
          for (const x of y) {
            const L = x * c;
            if (!(l[L + Hs] <= n)) {
              l[L + Hs] = n;
              for (let E = 0; E < c; E++) u.push(l[L + E]);
            }
          }
      }
    }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + as] > 1) {
      const s = this.clusterProps[t[n + XA]];
      return r ? Object.assign({}, s) : s;
    }
    const o = this.points[t[n + ds]].properties, i = this.options.map(o);
    return r && i === o ? Object.assign({}, i) : i;
  }
}
function PE(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ds],
    properties: YA(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [QW(e[t]), eH(e[t + 1])]
    }
  };
}
function YA(e, t, n) {
  const r = e[t + as], o = r >= 1e4 ? `${Math.round(r / 1e3)}k` : r >= 1e3 ? `${Math.round(r / 100) / 10}k` : r, i = e[t + XA], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + ds],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Tc(e) {
  return e / 360 + 0.5;
}
function _c(e) {
  const t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function QW(e) {
  return (e - 0.5) * 360;
}
function eH(e) {
  const t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function tH(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Oo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Nv {
  constructor({ markers: t, position: n }) {
    this.markers = t, n && (n instanceof google.maps.LatLng ? this._position = n : this._position = new google.maps.LatLng(n));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const t = new google.maps.LatLngBounds(this._position, this._position);
    for (const n of this.markers)
      t.extend(Oo.getPosition(n));
    return t;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Oo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Oo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class nH {
  constructor({ maxZoom: t = 16 }) {
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: t }) {
    return rH(t);
  }
}
const rH = (e) => e.map((t) => new Nv({
  position: Oo.getPosition(t),
  markers: [t]
}));
class oH extends nH {
  constructor(t) {
    var { maxZoom: n, radius: r = 60 } = t, o = tH(t, ["maxZoom", "radius"]);
    super({ maxZoom: n }), this.state = { zoom: -1 }, this.superCluster = new KW(Object.assign({ maxZoom: this.maxZoom, radius: r }, o));
  }
  calculate(t) {
    let n = !1;
    const r = { zoom: t.map.getZoom() };
    if (!OE(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      const o = this.markers.map((i) => {
        const s = Oo.getPosition(i);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [s.lng(), s.lat()]
          },
          properties: { marker: i }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !OE(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), { clusters: this.clusters, changed: n };
  }
  cluster({ map: t }) {
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t.getZoom())).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [t, n] }, properties: r }) {
    if (r.cluster)
      return new Nv({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((i) => i.properties.marker),
        position: { lat: n, lng: t }
      });
    const o = r.marker;
    return new Nv({
      markers: [o],
      position: Oo.getPosition(o)
    });
  }
}
class iH {
  constructor(t, n) {
    this.markers = { sum: t.length };
    const r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class sH {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: t, position: n }, r, o) {
    const i = `<svg fill="${t > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>
</svg>`, s = `Cluster of ${t} markers`, a = Number(google.maps.Marker.MAX_ZINDEX) + t;
    if (Oo.isAdvancedMarkerAvailable(o)) {
      const u = new DOMParser().parseFromString(i, "image/svg+xml").documentElement;
      u.setAttribute("transform", "translate(0 25)");
      const c = {
        map: o,
        position: n,
        zIndex: a,
        title: s,
        content: u
      };
      return new google.maps.marker.AdvancedMarkerElement(c);
    }
    const l = {
      position: n,
      zIndex: a,
      title: s,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(i)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(l);
  }
}
function aH(e, t) {
  for (let n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class _0 {
  constructor() {
    aH(_0, google.maps.OverlayView);
  }
}
var Hl;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Hl || (Hl = {}));
const lH = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class uH extends _0 {
  constructor({ map: t, markers: n = [], algorithmOptions: r = {}, algorithm: o = new oH(r), renderer: i = new sH(), onClusterClick: s = lH }) {
    super(), this.markers = [...n], this.clusters = [], this.algorithm = o, this.renderer = i, this.onClusterClick = s, t && this.setMap(t);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    const r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Oo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    let r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Hl.CLUSTERING_BEGIN, this);
      const { clusters: n, changed: r } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        const o = /* @__PURE__ */ new Set();
        for (const s of n)
          s.markers.length == 1 && o.add(s.markers[0]);
        const i = [];
        for (const s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Oo.setMap(s.marker, null) : i.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => i.forEach((s) => Oo.setMap(s, null)));
      }
      google.maps.event.trigger(this, Hl.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Oo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    const t = new iH(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Oo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Hl.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Oo.setMap(r.marker, n);
    });
  }
}
function cH(e) {
  var t = xW(), n = k(null), r = n[0], o = n[1];
  return m(function() {
    if (t && r === null) {
      var i = new uH(Ke(Ke({}, e), { map: t }));
      o(i);
    }
  }, [t]), r;
}
function pH(e) {
  var t = e.children, n = e.options, r = cH(n);
  return r !== null ? t(r) : null;
}
Ie(pH);
var TE = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, _E = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
function dH(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, h = Te(vt), y = k(null), f = y[0], g = y[1], x = k(null), L = x[0], E = x[1], T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = it(null);
  return m(function() {
    f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), m(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), m(function() {
    o && f !== null && f.setPosition(o);
  }, [o]), m(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), m(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), E(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), m(function() {
    f && a && (b !== null && google.maps.event.removeListener(b), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), m(function() {
    f && l && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), m(function() {
    f && u && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), m(function() {
    f && c && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), m(function() {
    var j = new google.maps.InfoWindow(Ke({}, r || {}));
    return g(j), J.current = document.createElement("div"), s && E(google.maps.event.addListener(j, "closeclick", s)), a && C(google.maps.event.addListener(j, "domready", a)), l && F(google.maps.event.addListener(j, "content_changed", l)), u && U(google.maps.event.addListener(j, "position_changed", u)), c && V(google.maps.event.addListener(j, "zindex_changed", c)), j.setContent(J.current), o && j.setPosition(o), i && j.setZIndex(i), n ? j.open(h, n) : j.getPosition() ? j.open(h) : Ir(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(j), function() {
      L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), Z && google.maps.event.removeListener(Z), N && google.maps.event.removeListener(N), d && d(j), j.close();
    };
  }, []), J.current ? Nr(at.only(t), J.current) : null;
}
Ie(dH);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoWindow: null
    }, n.open = function(r, o) {
      o ? r.open(n.context, o) : r.getPosition() ? r.open(n.context) : Ir(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }, n.setInfoWindowCallback = function() {
      n.state.infoWindow !== null && n.containerElement !== null && (n.state.infoWindow.setContent(n.containerElement), n.open(n.state.infoWindow, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoWindow));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.InfoWindow(Ke({}, this.props.options || {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Dt({
      updaterMap: _E,
      eventMap: TE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        infoWindow: n
      };
    }, this.setInfoWindowCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.infoWindow !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: _E,
      eventMap: TE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.infoWindow !== null && (Ft(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Nr(at.only(this.props.children), this.containerElement) : null;
  }, t.contextType = vt, t;
})(Ee);
var AE = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, BE = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, fH = {};
function hH(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, h = e.onMouseUp, y = e.onRightClick, f = e.onClick, g = e.onDrag, x = e.onLoad, L = e.onUnmount, E = Te(vt), T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1];
  return m(function() {
    b !== null && b.setMap(E);
  }, [E]), m(function() {
    typeof t < "u" && b !== null && b.setOptions(t);
  }, [b, t]), m(function() {
    typeof n < "u" && b !== null && b.setDraggable(n);
  }, [b, n]), m(function() {
    typeof r < "u" && b !== null && b.setEditable(r);
  }, [b, r]), m(function() {
    typeof o < "u" && b !== null && b.setVisible(o);
  }, [b, o]), m(function() {
    typeof i < "u" && b !== null && b.setPath(i);
  }, [b, i]), m(function() {
    b && s && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(b, "dblclick", s)));
  }, [s]), m(function() {
    b && a && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(b, "dragend", a)));
  }, [a]), m(function() {
    b && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(b, "dragstart", l)));
  }, [l]), m(function() {
    b && u && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(b, "mousedown", u)));
  }, [u]), m(function() {
    b && c && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(b, "mousemove", c)));
  }, [c]), m(function() {
    b && p && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(b, "mouseout", p)));
  }, [p]), m(function() {
    b && d && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(b, "mouseover", d)));
  }, [d]), m(function() {
    b && h && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(b, "mouseup", h)));
  }, [h]), m(function() {
    b && y && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(b, "rightclick", y)));
  }, [y]), m(function() {
    b && f && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(b, "click", f)));
  }, [f]), m(function() {
    b && g && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(b, "drag", g)));
  }, [g]), m(function() {
    var se = new google.maps.Polyline(Ke(Ke({}, t || fH), { map: E }));
    return i && se.setPath(i), typeof o < "u" && se.setVisible(o), typeof r < "u" && se.setEditable(r), typeof n < "u" && se.setDraggable(n), s && F(google.maps.event.addListener(se, "dblclick", s)), a && U(google.maps.event.addListener(se, "dragend", a)), l && V(google.maps.event.addListener(se, "dragstart", l)), u && K(google.maps.event.addListener(se, "mousedown", u)), c && P(google.maps.event.addListener(se, "mousemove", c)), p && W(google.maps.event.addListener(se, "mouseout", p)), d && R(google.maps.event.addListener(se, "mouseover", d)), h && Y(google.maps.event.addListener(se, "mouseup", h)), y && ae(google.maps.event.addListener(se, "rightclick", y)), f && de(google.maps.event.addListener(se, "click", f)), g && ge(google.maps.event.addListener(se, "drag", g)), C(se), x && x(se), function() {
      S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), L && L(se), se.setMap(null);
    };
  }, []), null;
}
Ie(hH);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polyline: null
    }, n.setPolylineCallback = function() {
      n.state.polyline !== null && n.props.onLoad && n.props.onLoad(n.state.polyline);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polyline(Ke(Ke({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Dt({
      updaterMap: BE,
      eventMap: AE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polyline: n
      };
    }, this.setPolylineCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polyline !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: BE,
      eventMap: AE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Ft(this.registeredEvents), this.state.polyline.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = vt, t;
})(Ee);
var IE = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, jE = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  paths: function(e, t) {
    e.setPaths(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function gH(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.paths, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, h = e.onMouseOver, y = e.onMouseUp, f = e.onRightClick, g = e.onClick, x = e.onDrag, L = e.onLoad, E = e.onUnmount, T = e.onEdit, b = Te(vt), C = k(null), M = C[0], S = C[1], F = k(null), D = F[0], Z = F[1], U = k(null), $ = U[0], N = U[1], V = k(null), J = V[0], j = V[1], K = k(null), te = K[0], O = K[1], P = k(null), H = P[0], I = P[1], W = k(null), X = W[0], w = W[1], R = k(null), z = R[0], _ = R[1], Y = k(null), Q = Y[0], A = Y[1], ae = k(null), ce = ae[0], ue = ae[1], de = k(null), be = de[0], ve = de[1], ge = k(null), se = ge[0], xe = ge[1];
  return m(function() {
    M !== null && M.setMap(b);
  }, [b]), m(function() {
    typeof t < "u" && M !== null && M.setOptions(t);
  }, [M, t]), m(function() {
    typeof n < "u" && M !== null && M.setDraggable(n);
  }, [M, n]), m(function() {
    typeof r < "u" && M !== null && M.setEditable(r);
  }, [M, r]), m(function() {
    typeof o < "u" && M !== null && M.setVisible(o);
  }, [M, o]), m(function() {
    typeof i < "u" && M !== null && M.setPath(i);
  }, [M, i]), m(function() {
    typeof s < "u" && M !== null && M.setPaths(s);
  }, [M, s]), m(function() {
    M && a && (D !== null && google.maps.event.removeListener(D), Z(google.maps.event.addListener(M, "dblclick", a)));
  }, [a]), m(function() {
    M && (google.maps.event.addListener(M.getPath(), "insert_at", function() {
      T == null || T(M);
    }), google.maps.event.addListener(M.getPath(), "set_at", function() {
      T == null || T(M);
    }));
  }, [M, T]), m(function() {
    M && l && ($ !== null && google.maps.event.removeListener($), N(google.maps.event.addListener(M, "dragend", l)));
  }, [l]), m(function() {
    M && u && (J !== null && google.maps.event.removeListener(J), j(google.maps.event.addListener(M, "dragstart", u)));
  }, [u]), m(function() {
    M && c && (te !== null && google.maps.event.removeListener(te), O(google.maps.event.addListener(M, "mousedown", c)));
  }, [c]), m(function() {
    M && p && (H !== null && google.maps.event.removeListener(H), I(google.maps.event.addListener(M, "mousemove", p)));
  }, [p]), m(function() {
    M && d && (X !== null && google.maps.event.removeListener(X), w(google.maps.event.addListener(M, "mouseout", d)));
  }, [d]), m(function() {
    M && h && (z !== null && google.maps.event.removeListener(z), _(google.maps.event.addListener(M, "mouseover", h)));
  }, [h]), m(function() {
    M && y && (Q !== null && google.maps.event.removeListener(Q), A(google.maps.event.addListener(M, "mouseup", y)));
  }, [y]), m(function() {
    M && f && (ce !== null && google.maps.event.removeListener(ce), ue(google.maps.event.addListener(M, "rightclick", f)));
  }, [f]), m(function() {
    M && g && (be !== null && google.maps.event.removeListener(be), ve(google.maps.event.addListener(M, "click", g)));
  }, [g]), m(function() {
    M && x && (se !== null && google.maps.event.removeListener(se), xe(google.maps.event.addListener(M, "drag", x)));
  }, [x]), m(function() {
    var ne = new google.maps.Polygon(Ke(Ke({}, t || {}), { map: b }));
    return i && ne.setPath(i), s && ne.setPaths(s), typeof o < "u" && ne.setVisible(o), typeof r < "u" && ne.setEditable(r), typeof n < "u" && ne.setDraggable(n), a && Z(google.maps.event.addListener(ne, "dblclick", a)), l && N(google.maps.event.addListener(ne, "dragend", l)), u && j(google.maps.event.addListener(ne, "dragstart", u)), c && O(google.maps.event.addListener(ne, "mousedown", c)), p && I(google.maps.event.addListener(ne, "mousemove", p)), d && w(google.maps.event.addListener(ne, "mouseout", d)), h && _(google.maps.event.addListener(ne, "mouseover", h)), y && A(google.maps.event.addListener(ne, "mouseup", y)), f && ue(google.maps.event.addListener(ne, "rightclick", f)), g && ve(google.maps.event.addListener(ne, "click", g)), x && xe(google.maps.event.addListener(ne, "drag", x)), S(ne), L && L(ne), function() {
      D !== null && google.maps.event.removeListener(D), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), H !== null && google.maps.event.removeListener(H), X !== null && google.maps.event.removeListener(X), z !== null && google.maps.event.removeListener(z), Q !== null && google.maps.event.removeListener(Q), ce !== null && google.maps.event.removeListener(ce), be !== null && google.maps.event.removeListener(be), E && E(ne), ne.setMap(null);
    };
  }, []), null;
}
Ie(gH);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polygon: null
    }, n.setPolygonCallback = function() {
      n.state.polygon !== null && n.props.onLoad && n.props.onLoad(n.state.polygon);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polygon(Ke(Ke({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Dt({
      updaterMap: jE,
      eventMap: IE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polygon: n
      };
    }, this.setPolygonCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polygon !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: jE,
      eventMap: IE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polygon
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polygon !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polygon), Ft(this.registeredEvents), this.state.polygon && this.state.polygon.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = vt, t;
})(Ee);
var RE = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, NE = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function mH(e) {
  var t = e.options, n = e.bounds, r = e.draggable, o = e.editable, i = e.visible, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, h = e.onMouseUp, y = e.onRightClick, f = e.onClick, g = e.onDrag, x = e.onBoundsChanged, L = e.onLoad, E = e.onUnmount, T = Te(vt), b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1], j = k(null), K = j[0], te = j[1], O = k(null), P = O[0], H = O[1], I = k(null), W = I[0], X = I[1], w = k(null), R = w[0], z = w[1], _ = k(null), Y = _[0], Q = _[1], A = k(null), ae = A[0], ce = A[1], ue = k(null), de = ue[0], be = ue[1], ve = k(null), ge = ve[0], se = ve[1], xe = k(null), ne = xe[0], Me = xe[1];
  return m(function() {
    C !== null && C.setMap(T);
  }, [T]), m(function() {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), m(function() {
    typeof r < "u" && C !== null && C.setDraggable(r);
  }, [C, r]), m(function() {
    typeof o < "u" && C !== null && C.setEditable(o);
  }, [C, o]), m(function() {
    typeof i < "u" && C !== null && C.setVisible(i);
  }, [C, i]), m(function() {
    typeof n < "u" && C !== null && C.setBounds(n);
  }, [C, n]), m(function() {
    C && s && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), m(function() {
    C && a && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(C, "dragend", a)));
  }, [a]), m(function() {
    C && l && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(C, "dragstart", l)));
  }, [l]), m(function() {
    C && u && (K !== null && google.maps.event.removeListener(K), te(google.maps.event.addListener(C, "mousedown", u)));
  }, [u]), m(function() {
    C && c && (P !== null && google.maps.event.removeListener(P), H(google.maps.event.addListener(C, "mousemove", c)));
  }, [c]), m(function() {
    C && p && (W !== null && google.maps.event.removeListener(W), X(google.maps.event.addListener(C, "mouseout", p)));
  }, [p]), m(function() {
    C && d && (R !== null && google.maps.event.removeListener(R), z(google.maps.event.addListener(C, "mouseover", d)));
  }, [d]), m(function() {
    C && h && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(C, "mouseup", h)));
  }, [h]), m(function() {
    C && y && (ae !== null && google.maps.event.removeListener(ae), ce(google.maps.event.addListener(C, "rightclick", y)));
  }, [y]), m(function() {
    C && f && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(C, "click", f)));
  }, [f]), m(function() {
    C && g && (ge !== null && google.maps.event.removeListener(ge), se(google.maps.event.addListener(C, "drag", g)));
  }, [g]), m(function() {
    C && x && (ne !== null && google.maps.event.removeListener(ne), Me(google.maps.event.addListener(C, "bounds_changed", x)));
  }, [x]), m(function() {
    var ee = new google.maps.Rectangle(Ke(Ke({}, t || {}), { map: T }));
    return typeof i < "u" && ee.setVisible(i), typeof o < "u" && ee.setEditable(o), typeof r < "u" && ee.setDraggable(r), typeof n < "u" && ee.setBounds(n), s && D(google.maps.event.addListener(ee, "dblclick", s)), a && $(google.maps.event.addListener(ee, "dragend", a)), l && J(google.maps.event.addListener(ee, "dragstart", l)), u && te(google.maps.event.addListener(ee, "mousedown", u)), c && H(google.maps.event.addListener(ee, "mousemove", c)), p && X(google.maps.event.addListener(ee, "mouseout", p)), d && z(google.maps.event.addListener(ee, "mouseover", d)), h && Q(google.maps.event.addListener(ee, "mouseup", h)), y && ce(google.maps.event.addListener(ee, "rightclick", y)), f && be(google.maps.event.addListener(ee, "click", f)), g && se(google.maps.event.addListener(ee, "drag", g)), x && Me(google.maps.event.addListener(ee, "bounds_changed", x)), M(ee), L && L(ee), function() {
      F !== null && google.maps.event.removeListener(F), U !== null && google.maps.event.removeListener(U), V !== null && google.maps.event.removeListener(V), K !== null && google.maps.event.removeListener(K), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), R !== null && google.maps.event.removeListener(R), Y !== null && google.maps.event.removeListener(Y), ae !== null && google.maps.event.removeListener(ae), de !== null && google.maps.event.removeListener(de), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), E && E(ee), ee.setMap(null);
    };
  }, []), null;
}
Ie(mH);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      rectangle: null
    }, n.setRectangleCallback = function() {
      n.state.rectangle !== null && n.props.onLoad && n.props.onLoad(n.state.rectangle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Rectangle(Ke(Ke({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Dt({
      updaterMap: NE,
      eventMap: RE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        rectangle: n
      };
    }, this.setRectangleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.rectangle !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: NE,
      eventMap: RE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Ft(this.registeredEvents), this.state.rectangle.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = vt, t;
})(Ee);
var FE = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, zE = {
  center: function(e, t) {
    e.setCenter(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  radius: function(e, t) {
    e.setRadius(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, vH = {};
function yH(e) {
  var t = e.options, n = e.center, r = e.radius, o = e.draggable, i = e.editable, s = e.visible, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, h = e.onMouseOver, y = e.onMouseUp, f = e.onRightClick, g = e.onClick, x = e.onDrag, L = e.onCenterChanged, E = e.onRadiusChanged, T = e.onLoad, b = e.onUnmount, C = Te(vt), M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1], se = k(null), xe = se[0], ne = se[1], Me = k(null), ee = Me[0], Ce = Me[1], Be = k(null), _e = Be[0], $e = Be[1];
  return m(function() {
    S !== null && S.setMap(C);
  }, [C]), m(function() {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), m(function() {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), m(function() {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), m(function() {
    typeof s < "u" && S !== null && S.setVisible(s);
  }, [S, s]), m(function() {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), m(function() {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), m(function() {
    S && a && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(S, "dblclick", a)));
  }, [a]), m(function() {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), m(function() {
    S && u && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), m(function() {
    S && c && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), m(function() {
    S && p && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), m(function() {
    S && d && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), m(function() {
    S && h && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(S, "mouseover", h)));
  }, [h]), m(function() {
    S && y && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(S, "mouseup", y)));
  }, [y]), m(function() {
    S && f && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(S, "rightclick", f)));
  }, [f]), m(function() {
    S && g && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(S, "click", g)));
  }, [g]), m(function() {
    S && x && (xe !== null && google.maps.event.removeListener(xe), ne(google.maps.event.addListener(S, "drag", x)));
  }, [x]), m(function() {
    S && L && (ee !== null && google.maps.event.removeListener(ee), Ce(google.maps.event.addListener(S, "center_changed", L)));
  }, [g]), m(function() {
    S && E && (_e !== null && google.maps.event.removeListener(_e), $e(google.maps.event.addListener(S, "radius_changed", E)));
  }, [E]), m(function() {
    var he = new google.maps.Circle(Ke(Ke({}, t || vH), { map: C }));
    return typeof r == "number" && he.setRadius(r), typeof n < "u" && he.setCenter(n), typeof r == "number" && he.setRadius(r), typeof s < "u" && he.setVisible(s), typeof i < "u" && he.setEditable(i), typeof o < "u" && he.setDraggable(o), a && U(google.maps.event.addListener(he, "dblclick", a)), l && V(google.maps.event.addListener(he, "dragend", l)), u && K(google.maps.event.addListener(he, "dragstart", u)), c && P(google.maps.event.addListener(he, "mousedown", c)), p && W(google.maps.event.addListener(he, "mousemove", p)), d && R(google.maps.event.addListener(he, "mouseout", d)), h && Y(google.maps.event.addListener(he, "mouseover", h)), y && ae(google.maps.event.addListener(he, "mouseup", y)), f && de(google.maps.event.addListener(he, "rightclick", f)), g && ge(google.maps.event.addListener(he, "click", g)), x && ne(google.maps.event.addListener(he, "drag", x)), L && Ce(google.maps.event.addListener(he, "center_changed", L)), E && $e(google.maps.event.addListener(he, "radius_changed", E)), F(he), T && T(he), function() {
      Z !== null && google.maps.event.removeListener(Z), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), ve !== null && google.maps.event.removeListener(ve), ee !== null && google.maps.event.removeListener(ee), _e !== null && google.maps.event.removeListener(_e), b && b(he), he.setMap(null);
    };
  }, []), null;
}
Ie(yH);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      circle: null
    }, n.setCircleCallback = function() {
      n.state.circle !== null && n.props.onLoad && n.props.onLoad(n.state.circle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Circle(Ke(Ke({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Dt({
      updaterMap: zE,
      eventMap: FE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        circle: n
      };
    }, this.setCircleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.circle !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: zE,
      eventMap: FE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n;
    this.state.circle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.circle), Ft(this.registeredEvents), (n = this.state.circle) === null || n === void 0 || n.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = vt, t;
})(Ee);
var UE = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, $E = {
  add: function(e, t) {
    e.add(t);
  },
  addgeojson: function(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains: function(e, t) {
    e.contains(t);
  },
  foreach: function(e, t) {
    e.forEach(t);
  },
  loadgeojson: function(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle: function(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove: function(e, t) {
    e.remove(t);
  },
  revertstyle: function(e, t) {
    e.revertStyle(t);
  },
  controlposition: function(e, t) {
    e.setControlPosition(t);
  },
  controls: function(e, t) {
    e.setControls(t);
  },
  drawingmode: function(e, t) {
    e.setDrawingMode(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  style: function(e, t) {
    e.setStyle(t);
  },
  togeojson: function(e, t) {
    e.toGeoJson(t);
  }
};
function bH(e) {
  var t = e.options, n = e.onClick, r = e.onDblClick, o = e.onMouseDown, i = e.onMouseMove, s = e.onMouseOut, a = e.onMouseOver, l = e.onMouseUp, u = e.onRightClick, c = e.onAddFeature, p = e.onRemoveFeature, d = e.onRemoveProperty, h = e.onSetGeometry, y = e.onSetProperty, f = e.onLoad, g = e.onUnmount, x = Te(vt), L = k(null), E = L[0], T = L[1], b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1], j = k(null), K = j[0], te = j[1], O = k(null), P = O[0], H = O[1], I = k(null), W = I[0], X = I[1], w = k(null), R = w[0], z = w[1], _ = k(null), Y = _[0], Q = _[1], A = k(null), ae = A[0], ce = A[1], ue = k(null), de = ue[0], be = ue[1], ve = k(null), ge = ve[0], se = ve[1], xe = k(null), ne = xe[0], Me = xe[1];
  return m(function() {
    E !== null && E.setMap(x);
  }, [x]), m(function() {
    E && r && (C !== null && google.maps.event.removeListener(C), M(google.maps.event.addListener(E, "dblclick", r)));
  }, [r]), m(function() {
    E && o && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(E, "mousedown", o)));
  }, [o]), m(function() {
    E && i && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(E, "mousemove", i)));
  }, [i]), m(function() {
    E && s && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(E, "mouseout", s)));
  }, [s]), m(function() {
    E && a && (K !== null && google.maps.event.removeListener(K), te(google.maps.event.addListener(E, "mouseover", a)));
  }, [a]), m(function() {
    E && l && (P !== null && google.maps.event.removeListener(P), H(google.maps.event.addListener(E, "mouseup", l)));
  }, [l]), m(function() {
    E && u && (W !== null && google.maps.event.removeListener(W), X(google.maps.event.addListener(E, "rightclick", u)));
  }, [u]), m(function() {
    E && n && (R !== null && google.maps.event.removeListener(R), z(google.maps.event.addListener(E, "click", n)));
  }, [n]), m(function() {
    E && c && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(E, "addfeature", c)));
  }, [c]), m(function() {
    E && p && (ae !== null && google.maps.event.removeListener(ae), ce(google.maps.event.addListener(E, "removefeature", p)));
  }, [p]), m(function() {
    E && d && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(E, "removeproperty", d)));
  }, [d]), m(function() {
    E && h && (ge !== null && google.maps.event.removeListener(ge), se(google.maps.event.addListener(E, "setgeometry", h)));
  }, [h]), m(function() {
    E && y && (ne !== null && google.maps.event.removeListener(ne), Me(google.maps.event.addListener(E, "setproperty", y)));
  }, [y]), m(function() {
    if (x !== null) {
      var ee = new google.maps.Data(Ke(Ke({}, t || {}), { map: x }));
      r && M(google.maps.event.addListener(ee, "dblclick", r)), o && D(google.maps.event.addListener(ee, "mousedown", o)), i && $(google.maps.event.addListener(ee, "mousemove", i)), s && J(google.maps.event.addListener(ee, "mouseout", s)), a && te(google.maps.event.addListener(ee, "mouseover", a)), l && H(google.maps.event.addListener(ee, "mouseup", l)), u && X(google.maps.event.addListener(ee, "rightclick", u)), n && z(google.maps.event.addListener(ee, "click", n)), c && Q(google.maps.event.addListener(ee, "addfeature", c)), p && ce(google.maps.event.addListener(ee, "removefeature", p)), d && be(google.maps.event.addListener(ee, "removeproperty", d)), h && se(google.maps.event.addListener(ee, "setgeometry", h)), y && Me(google.maps.event.addListener(ee, "setproperty", y)), T(ee), f && f(ee);
    }
    return function() {
      E && (C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), U !== null && google.maps.event.removeListener(U), V !== null && google.maps.event.removeListener(V), K !== null && google.maps.event.removeListener(K), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), R !== null && google.maps.event.removeListener(R), Y !== null && google.maps.event.removeListener(Y), ae !== null && google.maps.event.removeListener(ae), de !== null && google.maps.event.removeListener(de), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), g && g(E), E.setMap(null));
    };
  }, []), null;
}
Ie(bH);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      data: null
    }, n.setDataCallback = function() {
      n.state.data !== null && n.props.onLoad && n.props.onLoad(n.state.data);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context !== null) {
      var n = new google.maps.Data(Ke(Ke({}, this.props.options || {}), { map: this.context }));
      this.registeredEvents = Dt({
        updaterMap: $E,
        eventMap: UE,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          data: n
        };
      }, this.setDataCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.data !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: $E,
      eventMap: UE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.data
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Ft(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = vt, t;
})(Ee);
var WE = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, HE = {
  options: function(e, t) {
    e.setOptions(t);
  },
  url: function(e, t) {
    e.setUrl(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      kmlLayer: null
    }, n.setKmlLayerCallback = function() {
      n.state.kmlLayer !== null && n.props.onLoad && n.props.onLoad(n.state.kmlLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.KmlLayer(Ke(Ke({}, this.props.options), { map: this.context }));
    this.registeredEvents = Dt({
      updaterMap: HE,
      eventMap: WE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        kmlLayer: n
      };
    }, this.setKmlLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.kmlLayer !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: HE,
      eventMap: WE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Ft(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = vt, t;
})(Ee);
function JA(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function wH(e, t) {
  return new t(e.lat, e.lng);
}
function CH(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function xH(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function EH(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function LH(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function kH(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var o = r.x, i = r.y;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function KA(e, t, n, r) {
  return n !== void 0 ? LH(e, t, EH(n, google.maps.LatLngBounds, CH)) : kH(e, t, xH(r, google.maps.LatLng, wH));
}
function OH(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function MH(e, t, n, r, o) {
  var i = (
    /** @class */
    function(s) {
      jn(a, s);
      function a(l, u, c, p) {
        var d = s.call(this) || this;
        return d.container = l, d.pane = u, d.position = c, d.bounds = p, d;
      }
      return a.prototype.onAdd = function() {
        var l, u = (l = this.getPanes()) === null || l === void 0 ? void 0 : l[this.pane];
        u == null || u.appendChild(this.container);
      }, a.prototype.draw = function() {
        for (var l = this.getProjection(), u = Ke({}, this.container ? JA(this.container, o) : {
          x: 0,
          y: 0
        }), c = KA(l, u, this.bounds, this.position), p = 0, d = Object.entries(c); p < d.length; p++) {
          var h = d[p], y = h[0], f = h[1];
          this.container.style[y] = f;
        }
      }, a.prototype.onRemove = function() {
        this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
      }, a;
    }(google.maps.OverlayView)
  );
  return new i(e, t, n, r);
}
function VE(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function ZE(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function SH(e) {
  var t = e.position, n = e.bounds, r = e.mapPaneName, o = e.zIndex, i = e.onLoad, s = e.onUnmount, a = e.getPixelPositionOffset, l = e.children, u = Te(vt), c = Zn(function() {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Zn(function() {
    return MH(c, r, t, n, a);
  }, [c, r, t, n]);
  return m(function() {
    return i == null || i(p), p == null || p.setMap(u), function() {
      s == null || s(p), p == null || p.setMap(null);
    };
  }, [u, p]), m(function() {
    c.style.zIndex = "".concat(o);
  }, [o, c]), di.createPortal(l, c);
}
Ie(SH);
(function(e) {
  jn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    r.state = {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }, r.updatePane = function() {
      var i = r.props.mapPaneName, s = r.overlayView.getPanes();
      Ir(!!i, "OverlayView requires props.mapPaneName but got %s", i), s ? r.setState({
        paneEl: s[i]
      }) : r.setState({
        paneEl: null
      });
    }, r.onAdd = function() {
      var i, s;
      r.updatePane(), (s = (i = r.props).onLoad) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.onPositionElement = function() {
      var i = r.overlayView.getProjection(), s = Ke({ x: 0, y: 0 }, r.containerRef.current ? JA(r.containerRef.current, r.props.getPixelPositionOffset) : {}), a = KA(i, s, r.props.bounds, r.props.position), l = r.state.containerStyle, u = l.left, c = l.top, p = l.width, d = l.height;
      OH(a, { left: u, top: c, width: p, height: d }) || r.setState({
        containerStyle: {
          top: a.top || 0,
          left: a.left || 0,
          width: a.width || 0,
          height: a.height || 0,
          position: "absolute"
        }
      });
    }, r.draw = function() {
      r.onPositionElement();
    }, r.onRemove = function() {
      var i, s;
      r.setState(function() {
        return {
          paneEl: null
        };
      }), (s = (i = r.props).onUnmount) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.containerRef = Rr();
    var o = new google.maps.OverlayView();
    return o.onAdd = r.onAdd, o.draw = r.draw, o.onRemove = r.onRemove, r.overlayView = o, r;
  }
  return t.prototype.componentDidMount = function() {
    this.overlayView.setMap(this.context);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = VE(n.position), o = VE(this.props.position), i = ZE(n.bounds), s = ZE(this.props.bounds);
    (r !== o || i !== s) && this.overlayView.draw(), n.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }, t.prototype.componentWillUnmount = function() {
    this.overlayView.setMap(null);
  }, t.prototype.render = function() {
    var n = this.state.paneEl;
    return n ? di.createPortal(Ur.jsx("div", { ref: this.containerRef, style: this.state.containerStyle, children: at.only(this.props.children) }), n) : null;
  }, t.FLOAT_PANE = "floatPane", t.MAP_PANE = "mapPane", t.MARKER_LAYER = "markerLayer", t.OVERLAY_LAYER = "overlayLayer", t.OVERLAY_MOUSE_TARGET = "overlayMouseTarget", t.contextType = vt, t;
})(Ee);
function DH() {
}
var qE = {
  onDblClick: "dblclick",
  onClick: "click"
}, GE = {
  opacity: function(e, t) {
    e.setOpacity(t);
  }
};
function PH(e) {
  var t = e.url, n = e.bounds, r = e.options, o = e.visible, i = Te(vt), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Zn(function() {
    var l = new google.maps.GroundOverlay(t, s, Ke({}, r));
    return l;
  }, []);
  return m(function() {
    a !== null && a.setMap(i);
  }, [i]), m(function() {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), m(function() {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), m(function() {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Ie(PH);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      groundOverlay: null
    }, n.setGroundOverlayCallback = function() {
      n.state.groundOverlay !== null && n.props.onLoad && n.props.onLoad(n.state.groundOverlay);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Ir(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var n = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Ke(Ke({}, this.props.options), { map: this.context }));
    this.registeredEvents = Dt({
      updaterMap: GE,
      eventMap: qE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        groundOverlay: n
      };
    }, this.setGroundOverlayCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.groundOverlay !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: GE,
      eventMap: qE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.defaultProps = {
    onLoad: DH
  }, t.contextType = vt, t;
})(Ee);
var XE = {}, YE = {
  data: function(e, t) {
    e.setData(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function TH(e) {
  var t = e.data, n = e.onLoad, r = e.onUnmount, o = e.options, i = Te(vt), s = k(null), a = s[0], l = s[1];
  return m(function() {
    google.maps.visualization || Ir(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), m(function() {
    Ir(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), m(function() {
    a !== null && a.setMap(i);
  }, [i]), m(function() {
    o && a !== null && a.setOptions(o);
  }, [a, o]), m(function() {
    var u = new google.maps.visualization.HeatmapLayer(Ke(Ke({}, o || {}), { data: t, map: i }));
    return l(u), n && n(u), function() {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Ie(TH);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      heatmapLayer: null
    }, n.setHeatmapLayerCallback = function() {
      n.state.heatmapLayer !== null && n.props.onLoad && n.props.onLoad(n.state.heatmapLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Ir(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Ir(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var n = new google.maps.visualization.HeatmapLayer(Ke(Ke({}, this.props.options || {}), { data: this.props.data, map: this.context }));
    this.registeredEvents = Dt({
      updaterMap: YE,
      eventMap: XE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        heatmapLayer: n
      };
    }, this.setHeatmapLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: YE,
      eventMap: XE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Ft(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = vt, t;
})(Ee);
var JE = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, KE = {
  register: function(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links: function(e, t) {
    e.setLinks(t);
  },
  motionTracking: function(e, t) {
    e.setMotionTracking(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  pano: function(e, t) {
    e.setPano(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  pov: function(e, t) {
    e.setPov(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      streetViewPanorama: null
    }, n.setStreetViewPanoramaCallback = function() {
      n.state.streetViewPanorama !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewPanorama);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n, r, o = (r = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && r !== void 0 ? r : null;
    this.registeredEvents = Dt({
      updaterMap: KE,
      eventMap: JE,
      prevProps: {},
      nextProps: this.props,
      instance: o
    }), this.setState(function() {
      return {
        streetViewPanorama: o
      };
    }, this.setStreetViewPanoramaCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.streetViewPanorama !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: KE,
      eventMap: JE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Ft(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = vt, t;
})(Ee);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      streetViewService: null
    }, n.setStreetViewServiceCallback = function() {
      n.state.streetViewService !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: n
      };
    }, this.setStreetViewServiceCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = vt, t;
})(Ee);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      directionsService: null
    }, n.setDirectionsServiceCallback = function() {
      n.state.directionsService !== null && n.props.onLoad && n.props.onLoad(n.state.directionsService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Ir(!!this.props.options, "DirectionsService expected options object as parameter, but got %s", this.props.options);
    var n = new google.maps.DirectionsService();
    this.setState(function() {
      return {
        directionsService: n
      };
    }, this.setDirectionsServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.directionsService !== null && this.state.directionsService.route(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsService !== null && this.props.onUnmount && this.props.onUnmount(this.state.directionsService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Ee);
var QE = {
  onDirectionsChanged: "directions_changed"
}, eL = {
  directions: function(e, t) {
    e.setDirections(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  panel: function(e, t) {
    e.setPanel(t);
  },
  routeIndex: function(e, t) {
    e.setRouteIndex(t);
  }
};
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      directionsRenderer: null
    }, n.setDirectionsRendererCallback = function() {
      n.state.directionsRenderer !== null && (n.state.directionsRenderer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.directionsRenderer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Dt({
      updaterMap: eL,
      eventMap: QE,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        directionsRenderer: n
      };
    }, this.setDirectionsRendererCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.directionsRenderer !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: eL,
      eventMap: QE,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Ft(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }, t.prototype.render = function() {
    return Ur.jsx(Ur.Fragment, {});
  }, t.contextType = vt, t;
})(Ee);
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      distanceMatrixService: null
    }, n.setDistanceMatrixServiceCallback = function() {
      n.state.distanceMatrixService !== null && n.props.onLoad && n.props.onLoad(n.state.distanceMatrixService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Ir(!!this.props.options, "DistanceMatrixService expected options object as parameter, but go %s", this.props.options);
    var n = new google.maps.DistanceMatrixService();
    this.setState(function() {
      return {
        distanceMatrixService: n
      };
    }, this.setDistanceMatrixServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.distanceMatrixService !== null && this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.distanceMatrixService !== null && this.props.onUnmount && this.props.onUnmount(this.state.distanceMatrixService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Ee);
var tL = {
  onPlacesChanged: "places_changed"
}, nL = {
  bounds: function(e, t) {
    e.setBounds(t);
  }
};
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = Rr(), n.state = {
      searchBox: null
    }, n.setSearchBoxCallback = function() {
      n.state.searchBox !== null && n.props.onLoad && n.props.onLoad(n.state.searchBox);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (Ir(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var n = this.containerElement.current.querySelector("input");
      if (n !== null) {
        var r = new google.maps.places.SearchBox(n, this.props.options);
        this.registeredEvents = Dt({
          updaterMap: nL,
          eventMap: tL,
          prevProps: {},
          nextProps: this.props,
          instance: r
        }), this.setState(function() {
          return {
            searchBox: r
          };
        }, this.setSearchBoxCallback);
      }
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.searchBox !== null && (Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: nL,
      eventMap: tL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Ft(this.registeredEvents));
  }, t.prototype.render = function() {
    return Ur.jsx("div", { ref: this.containerElement, children: at.only(this.props.children) });
  }, t.contextType = vt, t;
})(Ee);
var rL = {
  onPlaceChanged: "place_changed"
}, oL = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  restrictions: function(e, t) {
    e.setComponentRestrictions(t);
  },
  fields: function(e, t) {
    e.setFields(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  types: function(e, t) {
    e.setTypes(t);
  }
};
(function(e) {
  jn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = Rr(), n.state = {
      autocomplete: null
    }, n.setAutocompleteCallback = function() {
      n.state.autocomplete !== null && n.props.onLoad && n.props.onLoad(n.state.autocomplete);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n;
    Ir(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var r = (n = this.containerElement.current) === null || n === void 0 ? void 0 : n.querySelector("input");
    if (r) {
      var o = new google.maps.places.Autocomplete(r, this.props.options);
      this.registeredEvents = Dt({
        updaterMap: oL,
        eventMap: rL,
        prevProps: {},
        nextProps: this.props,
        instance: o
      }), this.setState(function() {
        return {
          autocomplete: o
        };
      }, this.setAutocompleteCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    Ft(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: oL,
      eventMap: rL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.autocomplete !== null && Ft(this.registeredEvents);
  }, t.prototype.render = function() {
    return Ur.jsx("div", { ref: this.containerElement, className: this.props.className, children: at.only(this.props.children) });
  }, t.defaultProps = {
    className: ""
  }, t.contextType = vt, t;
})(Ee);
qe({});
function _H(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const AH = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
_H(AH.CNPJ).length;
Ba((e, t) => /* @__PURE__ */ Ur.jsx("input", { ref: t, ...e }));
var _n = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function BH(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Fv = { exports: {} }, Cl = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iL;
function IH() {
  if (iL) return Cl;
  iL = 1;
  var e = Ae, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, h = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: h, props: p, _owner: o.current };
  }
  return Cl.Fragment = n, Cl.jsx = s, Cl.jsxs = s, Cl;
}
var Ac = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sL;
function jH() {
  return sL || (sL = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ae, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), y = Symbol.iterator, f = "@@iterator";
    function g(v) {
      if (v === null || typeof v != "object")
        return null;
      var B = y && v[y] || v[f];
      return typeof B == "function" ? B : null;
    }
    var x = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function L(v) {
      {
        for (var B = arguments.length, G = new Array(B > 1 ? B - 1 : 0), oe = 1; oe < B; oe++)
          G[oe - 1] = arguments[oe];
        E("error", v, G);
      }
    }
    function E(v, B, G) {
      {
        var oe = x.ReactDebugCurrentFrame, me = oe.getStackAddendum();
        me !== "" && (B += "%s", G = G.concat([me]));
        var ye = G.map(function(fe) {
          return String(fe);
        });
        ye.unshift("Warning: " + B), Function.prototype.apply.call(console[v], console, ye);
      }
    }
    var T = !1, b = !1, C = !1, M = !1, S = !1, F;
    F = Symbol.for("react.module.reference");
    function D(v) {
      return !!(typeof v == "string" || typeof v == "function" || v === r || v === i || S || v === o || v === u || v === c || M || v === h || T || b || C || typeof v == "object" && v !== null && (v.$$typeof === d || v.$$typeof === p || v.$$typeof === s || v.$$typeof === a || v.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      v.$$typeof === F || v.getModuleId !== void 0));
    }
    function Z(v, B, G) {
      var oe = v.displayName;
      if (oe)
        return oe;
      var me = B.displayName || B.name || "";
      return me !== "" ? G + "(" + me + ")" : G;
    }
    function U(v) {
      return v.displayName || "Context";
    }
    function $(v) {
      if (v == null)
        return null;
      if (typeof v.tag == "number" && L("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof v == "function")
        return v.displayName || v.name || null;
      if (typeof v == "string")
        return v;
      switch (v) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof v == "object")
        switch (v.$$typeof) {
          case a:
            var B = v;
            return U(B) + ".Consumer";
          case s:
            var G = v;
            return U(G._context) + ".Provider";
          case l:
            return Z(v, v.render, "ForwardRef");
          case p:
            var oe = v.displayName || null;
            return oe !== null ? oe : $(v.type) || "Memo";
          case d: {
            var me = v, ye = me._payload, fe = me._init;
            try {
              return $(fe(ye));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var N = Object.assign, V = 0, J, j, K, te, O, P, H;
    function I() {
    }
    I.__reactDisabledLog = !0;
    function W() {
      {
        if (V === 0) {
          J = console.log, j = console.info, K = console.warn, te = console.error, O = console.group, P = console.groupCollapsed, H = console.groupEnd;
          var v = {
            configurable: !0,
            enumerable: !0,
            value: I,
            writable: !0
          };
          Object.defineProperties(console, {
            info: v,
            log: v,
            warn: v,
            error: v,
            group: v,
            groupCollapsed: v,
            groupEnd: v
          });
        }
        V++;
      }
    }
    function X() {
      {
        if (V--, V === 0) {
          var v = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: N({}, v, {
              value: J
            }),
            info: N({}, v, {
              value: j
            }),
            warn: N({}, v, {
              value: K
            }),
            error: N({}, v, {
              value: te
            }),
            group: N({}, v, {
              value: O
            }),
            groupCollapsed: N({}, v, {
              value: P
            }),
            groupEnd: N({}, v, {
              value: H
            })
          });
        }
        V < 0 && L("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var w = x.ReactCurrentDispatcher, R;
    function z(v, B, G) {
      {
        if (R === void 0)
          try {
            throw Error();
          } catch (me) {
            var oe = me.stack.trim().match(/\n( *(at )?)/);
            R = oe && oe[1] || "";
          }
        return `
` + R + v;
      }
    }
    var _ = !1, Y;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      Y = new Q();
    }
    function A(v, B) {
      if (!v || _)
        return "";
      {
        var G = Y.get(v);
        if (G !== void 0)
          return G;
      }
      var oe;
      _ = !0;
      var me = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ye;
      ye = w.current, w.current = null, W();
      try {
        if (B) {
          var fe = function() {
            throw Error();
          };
          if (Object.defineProperty(fe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fe, []);
            } catch (Pe) {
              oe = Pe;
            }
            Reflect.construct(v, [], fe);
          } else {
            try {
              fe.call();
            } catch (Pe) {
              oe = Pe;
            }
            v.call(fe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Pe) {
            oe = Pe;
          }
          v();
        }
      } catch (Pe) {
        if (Pe && oe && typeof Pe.stack == "string") {
          for (var pe = Pe.stack.split(`
`), De = oe.stack.split(`
`), Le = pe.length - 1, Oe = De.length - 1; Le >= 1 && Oe >= 0 && pe[Le] !== De[Oe]; )
            Oe--;
          for (; Le >= 1 && Oe >= 0; Le--, Oe--)
            if (pe[Le] !== De[Oe]) {
              if (Le !== 1 || Oe !== 1)
                do
                  if (Le--, Oe--, Oe < 0 || pe[Le] !== De[Oe]) {
                    var ze = `
` + pe[Le].replace(" at new ", " at ");
                    return v.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", v.displayName)), typeof v == "function" && Y.set(v, ze), ze;
                  }
                while (Le >= 1 && Oe >= 0);
              break;
            }
        }
      } finally {
        _ = !1, w.current = ye, X(), Error.prepareStackTrace = me;
      }
      var nt = v ? v.displayName || v.name : "", rt = nt ? z(nt) : "";
      return typeof v == "function" && Y.set(v, rt), rt;
    }
    function ae(v, B, G) {
      return A(v, !1);
    }
    function ce(v) {
      var B = v.prototype;
      return !!(B && B.isReactComponent);
    }
    function ue(v, B, G) {
      if (v == null)
        return "";
      if (typeof v == "function")
        return A(v, ce(v));
      if (typeof v == "string")
        return z(v);
      switch (v) {
        case u:
          return z("Suspense");
        case c:
          return z("SuspenseList");
      }
      if (typeof v == "object")
        switch (v.$$typeof) {
          case l:
            return ae(v.render);
          case p:
            return ue(v.type, B, G);
          case d: {
            var oe = v, me = oe._payload, ye = oe._init;
            try {
              return ue(ye(me), B, G);
            } catch {
            }
          }
        }
      return "";
    }
    var de = Object.prototype.hasOwnProperty, be = {}, ve = x.ReactDebugCurrentFrame;
    function ge(v) {
      if (v) {
        var B = v._owner, G = ue(v.type, v._source, B ? B.type : null);
        ve.setExtraStackFrame(G);
      } else
        ve.setExtraStackFrame(null);
    }
    function se(v, B, G, oe, me) {
      {
        var ye = Function.call.bind(de);
        for (var fe in v)
          if (ye(v, fe)) {
            var pe = void 0;
            try {
              if (typeof v[fe] != "function") {
                var De = Error((oe || "React class") + ": " + G + " type `" + fe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof v[fe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw De.name = "Invariant Violation", De;
              }
              pe = v[fe](B, fe, oe, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Le) {
              pe = Le;
            }
            pe && !(pe instanceof Error) && (ge(me), L("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", oe || "React class", G, fe, typeof pe), ge(null)), pe instanceof Error && !(pe.message in be) && (be[pe.message] = !0, ge(me), L("Failed %s type: %s", G, pe.message), ge(null));
          }
      }
    }
    var xe = Array.isArray;
    function ne(v) {
      return xe(v);
    }
    function Me(v) {
      {
        var B = typeof Symbol == "function" && Symbol.toStringTag, G = B && v[Symbol.toStringTag] || v.constructor.name || "Object";
        return G;
      }
    }
    function ee(v) {
      try {
        return Ce(v), !1;
      } catch {
        return !0;
      }
    }
    function Ce(v) {
      return "" + v;
    }
    function Be(v) {
      if (ee(v))
        return L("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Me(v)), Ce(v);
    }
    var _e = x.ReactCurrentOwner, $e = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, he, Ge, We;
    We = {};
    function Ut(v) {
      if (de.call(v, "ref")) {
        var B = Object.getOwnPropertyDescriptor(v, "ref").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return v.ref !== void 0;
    }
    function ot(v) {
      if (de.call(v, "key")) {
        var B = Object.getOwnPropertyDescriptor(v, "key").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return v.key !== void 0;
    }
    function st(v, B) {
      if (typeof v.ref == "string" && _e.current && B && _e.current.stateNode !== B) {
        var G = $(_e.current.type);
        We[G] || (L('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(_e.current.type), v.ref), We[G] = !0);
      }
    }
    function Zt(v, B) {
      {
        var G = function() {
          he || (he = !0, L("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(v, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function qt(v, B) {
      {
        var G = function() {
          Ge || (Ge = !0, L("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(v, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Gt = function(v, B, G, oe, me, ye, fe) {
      var pe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: v,
        key: B,
        ref: G,
        props: fe,
        // Record the component responsible for creating this element.
        _owner: ye
      };
      return pe._store = {}, Object.defineProperty(pe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(pe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: oe
      }), Object.defineProperty(pe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: me
      }), Object.freeze && (Object.freeze(pe.props), Object.freeze(pe)), pe;
    };
    function Xt(v, B, G, oe, me) {
      {
        var ye, fe = {}, pe = null, De = null;
        G !== void 0 && (Be(G), pe = "" + G), ot(B) && (Be(B.key), pe = "" + B.key), Ut(B) && (De = B.ref, st(B, me));
        for (ye in B)
          de.call(B, ye) && !$e.hasOwnProperty(ye) && (fe[ye] = B[ye]);
        if (v && v.defaultProps) {
          var Le = v.defaultProps;
          for (ye in Le)
            fe[ye] === void 0 && (fe[ye] = Le[ye]);
        }
        if (pe || De) {
          var Oe = typeof v == "function" ? v.displayName || v.name || "Unknown" : v;
          pe && Zt(fe, Oe), De && qt(fe, Oe);
        }
        return Gt(v, pe, De, me, oe, _e.current, fe);
      }
    }
    var et = x.ReactCurrentOwner, bt = x.ReactDebugCurrentFrame;
    function tt(v) {
      if (v) {
        var B = v._owner, G = ue(v.type, v._source, B ? B.type : null);
        bt.setExtraStackFrame(G);
      } else
        bt.setExtraStackFrame(null);
    }
    var ut;
    ut = !1;
    function Yt(v) {
      return typeof v == "object" && v !== null && v.$$typeof === t;
    }
    function gn() {
      {
        if (et.current) {
          var v = $(et.current.type);
          if (v)
            return `

Check the render method of \`` + v + "`.";
        }
        return "";
      }
    }
    function Jt(v) {
      {
        if (v !== void 0) {
          var B = v.fileName.replace(/^.*[\\\/]/, ""), G = v.lineNumber;
          return `

Check your code at ` + B + ":" + G + ".";
        }
        return "";
      }
    }
    var mn = {};
    function qn(v) {
      {
        var B = gn();
        if (!B) {
          var G = typeof v == "string" ? v : v.displayName || v.name;
          G && (B = `

Check the top-level render call using <` + G + ">.");
        }
        return B;
      }
    }
    function wt(v, B) {
      {
        if (!v._store || v._store.validated || v.key != null)
          return;
        v._store.validated = !0;
        var G = qn(B);
        if (mn[G])
          return;
        mn[G] = !0;
        var oe = "";
        v && v._owner && v._owner !== et.current && (oe = " It was passed a child from " + $(v._owner.type) + "."), tt(v), L('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, oe), tt(null);
      }
    }
    function vn(v, B) {
      {
        if (typeof v != "object")
          return;
        if (ne(v))
          for (var G = 0; G < v.length; G++) {
            var oe = v[G];
            Yt(oe) && wt(oe, B);
          }
        else if (Yt(v))
          v._store && (v._store.validated = !0);
        else if (v) {
          var me = g(v);
          if (typeof me == "function" && me !== v.entries)
            for (var ye = me.call(v), fe; !(fe = ye.next()).done; )
              Yt(fe.value) && wt(fe.value, B);
        }
      }
    }
    function Gn(v) {
      {
        var B = v.type;
        if (B == null || typeof B == "string")
          return;
        var G;
        if (typeof B == "function")
          G = B.propTypes;
        else if (typeof B == "object" && (B.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        B.$$typeof === p))
          G = B.propTypes;
        else
          return;
        if (G) {
          var oe = $(B);
          se(G, v.props, "prop", oe, v);
        } else if (B.PropTypes !== void 0 && !ut) {
          ut = !0;
          var me = $(B);
          L("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", me || "Unknown");
        }
        typeof B.getDefaultProps == "function" && !B.getDefaultProps.isReactClassApproved && L("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Kt(v) {
      {
        for (var B = Object.keys(v.props), G = 0; G < B.length; G++) {
          var oe = B[G];
          if (oe !== "children" && oe !== "key") {
            tt(v), L("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", oe), tt(null);
            break;
          }
        }
        v.ref !== null && (tt(v), L("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var yn = {};
    function bn(v, B, G, oe, me, ye) {
      {
        var fe = D(v);
        if (!fe) {
          var pe = "";
          (v === void 0 || typeof v == "object" && v !== null && Object.keys(v).length === 0) && (pe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var De = Jt(me);
          De ? pe += De : pe += gn();
          var Le;
          v === null ? Le = "null" : ne(v) ? Le = "array" : v !== void 0 && v.$$typeof === t ? (Le = "<" + ($(v.type) || "Unknown") + " />", pe = " Did you accidentally export a JSX literal instead of a component?") : Le = typeof v, L("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Le, pe);
        }
        var Oe = Xt(v, B, G, me, ye);
        if (Oe == null)
          return Oe;
        if (fe) {
          var ze = B.children;
          if (ze !== void 0)
            if (oe)
              if (ne(ze)) {
                for (var nt = 0; nt < ze.length; nt++)
                  vn(ze[nt], v);
                Object.freeze && Object.freeze(ze);
              } else
                L("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              vn(ze, v);
        }
        if (de.call(B, "key")) {
          var rt = $(v), Pe = Object.keys(B).filter(function(bi) {
            return bi !== "key";
          }), ie = Pe.length > 0 ? "{key: someKey, " + Pe.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!yn[rt + ie]) {
            var yi = Pe.length > 0 ? "{" + Pe.join(": ..., ") + ": ...}" : "{}";
            L(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ie, rt, yi, rt), yn[rt + ie] = !0;
          }
        }
        return v === r ? Kt(Oe) : Gn(Oe), Oe;
      }
    }
    function Qt(v, B, G) {
      return bn(v, B, G, !0);
    }
    function Xn(v, B, G) {
      return bn(v, B, G, !1);
    }
    var Yn = Xn, en = Qt;
    Ac.Fragment = r, Ac.jsx = Yn, Ac.jsxs = en;
  }()), Ac;
}
process.env.NODE_ENV === "production" ? Fv.exports = IH() : Fv.exports = jH();
var $r = Fv.exports;
qe({});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var zv = function(e, t) {
  return zv = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
  }, zv(e, t);
};
function Rn(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  zv(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Qe = function() {
  return Qe = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Qe.apply(this, arguments);
};
function A0(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function RH(e, t, n, r) {
  function o(i) {
    return i instanceof n ? i : new n(function(s) {
      s(i);
    });
  }
  return new (n || (n = Promise))(function(i, s) {
    function a(c) {
      try {
        u(r.next(c));
      } catch (p) {
        s(p);
      }
    }
    function l(c) {
      try {
        u(r.throw(c));
      } catch (p) {
        s(p);
      }
    }
    function u(c) {
      c.done ? i(c.value) : o(c.value).then(a, l);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function NH(e, t) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, o, i, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(c) {
      return l([u, c]);
    };
  }
  function l(u) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, o && (i = u[0] & 2 ? o.return : u[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, u[1])).done) return i;
      switch (o = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
        case 0:
        case 1:
          i = u;
          break;
        case 4:
          return n.label++, { value: u[1], done: !1 };
        case 5:
          n.label++, o = u[1], u = [0];
          continue;
        case 7:
          u = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            n = 0;
            continue;
          }
          if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
            n.label = u[1];
            break;
          }
          if (u[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = u;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(u);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      u = t.call(e, n);
    } catch (c) {
      u = [6, c], o = 0;
    } finally {
      r = i = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function QA(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var FH = process.env.NODE_ENV, zH = function(e, t, n, r, o, i, s, a) {
  if (FH !== "production" && t === void 0)
    throw new Error("invariant requires an error message argument");
  if (!e) {
    var l;
    if (t === void 0)
      l = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var u = [n, r, o, i, s, a], c = 0;
      l = new Error(
        t.replace(/%s/g, function() {
          return u[c++];
        })
      ), l.name = "Invariant Violation";
    }
    throw l.framesToPop = 1, l;
  }
}, UH = zH, jr = /* @__PURE__ */ QA(UH), yt = qe(null);
function $H() {
  jr(!!Te, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Te(yt);
  return jr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function WH(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function HH(e, t) {
  Object.keys(e).forEach(function(n) {
    return t(e[n], n);
  });
}
function VH(e, t, n, r) {
  var o = {}, i = function(s, a) {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return HH(e, i), o;
}
function ZH(e, t, n) {
  var r = WH(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function qH(e) {
  google.maps.event.removeListener(e);
}
function zt(e) {
  e === void 0 && (e = []), e.forEach(qH);
}
function Pt(e) {
  var t = e.updaterMap, n = e.eventMap, r = e.prevProps, o = e.nextProps, i = e.instance, s = ZH(o, i, n);
  return VH(t, r, o, i), s;
}
var aL = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, lL = {
  extraMapTypes: function(e, t) {
    t.forEach(function(n, r) {
      e.mapTypes.set(String(r), n);
    });
  },
  center: function(e, t) {
    e.setCenter(t);
  },
  clickableIcons: function(e, t) {
    e.setClickableIcons(t);
  },
  heading: function(e, t) {
    e.setHeading(t);
  },
  mapTypeId: function(e, t) {
    e.setMapTypeId(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  streetView: function(e, t) {
    e.setStreetView(t);
  },
  tilt: function(e, t) {
    e.setTilt(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
function GH(e) {
  var t = e.children, n = e.options, r = e.id, o = e.mapContainerStyle, i = e.mapContainerClassName, s = e.center, a = e.onClick, l = e.onDblClick, u = e.onDrag, c = e.onDragEnd, p = e.onDragStart, d = e.onMouseMove, h = e.onMouseOut, y = e.onMouseOver, f = e.onMouseDown, g = e.onMouseUp, x = e.onRightClick, L = e.onCenterChanged, E = e.onLoad, T = e.onUnmount, b = k(null), C = b[0], M = b[1], S = it(null), F = k(null), D = F[0], Z = F[1], U = k(null), $ = U[0], N = U[1], V = k(null), J = V[0], j = V[1], K = k(null), te = K[0], O = K[1], P = k(null), H = P[0], I = P[1], W = k(null), X = W[0], w = W[1], R = k(null), z = R[0], _ = R[1], Y = k(null), Q = Y[0], A = Y[1], ae = k(null), ce = ae[0], ue = ae[1], de = k(null), be = de[0], ve = de[1], ge = k(null), se = ge[0], xe = ge[1], ne = k(null), Me = ne[0], ee = ne[1];
  return m(function() {
    n && C !== null && C.setOptions(n);
  }, [C, n]), m(function() {
    C !== null && typeof s < "u" && C.setCenter(s);
  }, [C, s]), m(function() {
    C && l && ($ !== null && google.maps.event.removeListener($), N(google.maps.event.addListener(C, "dblclick", l)));
  }, [l]), m(function() {
    C && c && (J !== null && google.maps.event.removeListener(J), j(google.maps.event.addListener(C, "dragend", c)));
  }, [c]), m(function() {
    C && p && (te !== null && google.maps.event.removeListener(te), O(google.maps.event.addListener(C, "dragstart", p)));
  }, [p]), m(function() {
    C && f && (H !== null && google.maps.event.removeListener(H), I(google.maps.event.addListener(C, "mousedown", f)));
  }, [f]), m(function() {
    C && d && (X !== null && google.maps.event.removeListener(X), w(google.maps.event.addListener(C, "mousemove", d)));
  }, [d]), m(function() {
    C && h && (z !== null && google.maps.event.removeListener(z), _(google.maps.event.addListener(C, "mouseout", h)));
  }, [h]), m(function() {
    C && y && (Q !== null && google.maps.event.removeListener(Q), A(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), m(function() {
    C && g && (ce !== null && google.maps.event.removeListener(ce), ue(google.maps.event.addListener(C, "mouseup", g)));
  }, [g]), m(function() {
    C && x && (be !== null && google.maps.event.removeListener(be), ve(google.maps.event.addListener(C, "rightclick", x)));
  }, [x]), m(function() {
    C && a && (se !== null && google.maps.event.removeListener(se), xe(google.maps.event.addListener(C, "click", a)));
  }, [a]), m(function() {
    C && u && (Me !== null && google.maps.event.removeListener(Me), ee(google.maps.event.addListener(C, "drag", u)));
  }, [u]), m(function() {
    C && L && (D !== null && google.maps.event.removeListener(D), Z(google.maps.event.addListener(C, "center_changed", L)));
  }, [a]), m(function() {
    var Ce = S.current === null ? null : new google.maps.Map(S.current, n);
    return M(Ce), Ce !== null && E && E(Ce), function() {
      Ce !== null && T && T(Ce);
    };
  }, []), $r.jsx("div", { id: r, ref: S, style: o, className: i, children: $r.jsx(yt.Provider, { value: C, children: C !== null ? t : null }) });
}
Ie(GH);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      map: null
    }, n.registeredEvents = [], n.mapRef = null, n.getInstance = function() {
      return n.mapRef === null ? null : new google.maps.Map(n.mapRef, n.props.options);
    }, n.panTo = function(r) {
      var o = n.getInstance();
      o && o.panTo(r);
    }, n.setMapCallback = function() {
      n.state.map !== null && n.props.onLoad && n.props.onLoad(n.state.map);
    }, n.getRef = function(r) {
      n.mapRef = r;
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.getInstance();
    this.registeredEvents = Pt({
      updaterMap: lL,
      eventMap: aL,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        map: n
      };
    }, this.setMapCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.map !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: lL,
      eventMap: aL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.map
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), zt(this.registeredEvents));
  }, t.prototype.render = function() {
    return $r.jsx("div", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName, children: $r.jsx(yt.Provider, { value: this.state.map, children: this.state.map !== null ? this.props.children : null }) });
  }, t;
})(Ee);
var fa = typeof document < "u";
function eB(e) {
  var t = e.url, n = e.id, r = e.nonce;
  return fa ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch(function(o) {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function uL(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function tB() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return uL(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return uL(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
function nB(e) {
  var t = e.googleMapsApiKey, n = e.googleMapsClientId, r = e.version, o = r === void 0 ? "weekly" : r, i = e.language, s = e.region, a = e.libraries, l = e.channel, u = e.mapIds, c = e.authReferrerPolicy, p = [];
  return jr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? p.push("key=".concat(t)) : n && p.push("client=".concat(n)), o && p.push("v=".concat(o)), i && p.push("language=".concat(i)), s && p.push("region=".concat(s)), a && a.length && p.push("libraries=".concat(a.sort().join(","))), l && p.push("channel=".concat(l)), u && u.length && p.push("map_ids=".concat(u.join(","))), c && p.push("auth_referrer_policy=".concat(c)), p.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(p.join("&"));
}
var xl = !1;
function rB() {
  return $r.jsx("div", { children: "Loading..." });
}
var Uv = {
  id: "script-loader",
  version: "weekly"
};
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.check = Rr(), n.state = {
      loaded: !1
    }, n.cleanupCallback = function() {
      delete window.google.maps, n.injectScript();
    }, n.isCleaningUp = function() {
      return RH(n, void 0, void 0, function() {
        function r(o) {
          if (!xl)
            o();
          else if (fa)
            var i = window.setInterval(function() {
              xl || (window.clearInterval(i), o());
            }, 1);
        }
        return NH(this, function(o) {
          return [2, new Promise(r)];
        });
      });
    }, n.cleanup = function() {
      xl = !0;
      var r = document.getElementById(n.props.id);
      r && r.parentNode && r.parentNode.removeChild(r), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(o) {
        return typeof o.src == "string" && o.src.includes("maps.googleapis");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(o) {
        return o.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(o) {
        return o.innerText !== void 0 && o.innerText.length > 0 && o.innerText.includes(".gm-");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      });
    }, n.injectScript = function() {
      n.props.preventGoogleFontsLoading && tB(), jr(!!n.props.id, 'LoadScript requires "id" prop to be a string: %s', n.props.id);
      var r = {
        id: n.props.id,
        nonce: n.props.nonce,
        url: nB(n.props)
      };
      eB(r).then(function() {
        n.props.onLoad && n.props.onLoad(), n.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch(function(o) {
        n.props.onError && n.props.onError(o), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(n.props.googleMapsApiKey || "-", ") or Client ID (").concat(n.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (fa) {
      if (window.google && window.google.maps && !xl) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.props.libraries !== n.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), fa && n.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }, t.prototype.componentWillUnmount = function() {
    var n = this;
    if (fa) {
      this.cleanup();
      var r = function() {
        n.check.current || (delete window.google, xl = !1);
      };
      window.setTimeout(r, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }, t.prototype.render = function() {
    return $r.jsxs($r.Fragment, { children: [$r.jsx("div", { ref: this.check }), this.state.loaded ? this.props.children : this.props.loadingElement || $r.jsx(rB, {})] });
  }, t.defaultProps = Uv, t;
})(Ee);
var cL;
function XH(e) {
  var t = e.id, n = t === void 0 ? Uv.id : t, r = e.version, o = r === void 0 ? Uv.version : r, i = e.nonce, s = e.googleMapsApiKey, a = e.googleMapsClientId, l = e.language, u = e.region, c = e.libraries, p = e.preventGoogleFontsLoading, d = e.channel, h = e.mapIds, y = e.authReferrerPolicy, f = it(!1), g = k(!1), x = g[0], L = g[1], E = k(void 0), T = E[0], b = E[1];
  m(function() {
    return f.current = !0, function() {
      f.current = !1;
    };
  }, []), m(function() {
    fa && p && tB();
  }, [p]), m(function() {
    x && jr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [x]);
  var C = nB({
    version: o,
    googleMapsApiKey: s,
    googleMapsClientId: a,
    language: l,
    region: u,
    libraries: c,
    channel: d,
    mapIds: h,
    authReferrerPolicy: y
  });
  m(function() {
    if (!fa)
      return;
    function S() {
      f.current && (L(!0), cL = C);
    }
    if (window.google && window.google.maps && cL === C) {
      S();
      return;
    }
    eB({ id: n, url: C, nonce: i }).then(S).catch(function(F) {
      f.current && b(F), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(s || "-", ") or Client ID (").concat(a || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(F);
    });
  }, [n, C, i]);
  var M = it();
  return m(function() {
    M.current && c !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = c;
  }, [c]), { isLoaded: x, loadError: T, url: C };
}
var YH = $r.jsx(rB, {});
function JH(e) {
  var t = e.loadingElement, n = e.onLoad, r = e.onError, o = e.onUnmount, i = e.children, s = A0(e, ["loadingElement", "onLoad", "onError", "onUnmount", "children"]), a = XH(s), l = a.isLoaded, u = a.loadError;
  return m(function() {
    l && typeof n == "function" && n();
  }, [l, n]), m(function() {
    u && typeof r == "function" && r(u);
  }, [u, r]), m(function() {
    return function() {
      o && o();
    };
  }, [o]), l ? i : t || YH;
}
Ie(JH);
var pL;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(pL || (pL = {}));
var dL = {}, fL = {
  options: function(e, t) {
    e.setOptions(t);
  }
};
function KH(e) {
  var t = e.options, n = e.onLoad, r = e.onUnmount, o = Te(yt), i = k(null), s = i[0], a = i[1];
  return m(function() {
    s !== null && s.setMap(o);
  }, [o]), m(function() {
    t && s !== null && s.setOptions(t);
  }, [s, t]), m(function() {
    var l = new google.maps.TrafficLayer(Qe(Qe({}, t || {}), { map: o }));
    return a(l), n && n(l), function() {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Ie(KH);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      trafficLayer: null
    }, n.setTrafficLayerCallback = function() {
      n.state.trafficLayer !== null && n.props.onLoad && n.props.onLoad(n.state.trafficLayer);
    }, n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TrafficLayer(Qe(Qe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Pt({
      updaterMap: fL,
      eventMap: dL,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        trafficLayer: n
      };
    }, this.setTrafficLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.trafficLayer !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: fL,
      eventMap: dL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), zt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = yt, t;
})(Ee);
function QH(e) {
  var t = e.onLoad, n = e.onUnmount, r = Te(yt), o = k(null), i = o[0], s = o[1];
  return m(function() {
    i !== null && i.setMap(r);
  }, [r]), m(function() {
    var a = new google.maps.BicyclingLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Ie(QH);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      bicyclingLayer: null
    }, n.setBicyclingLayerCallback = function() {
      n.state.bicyclingLayer !== null && (n.state.bicyclingLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.bicyclingLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.BicyclingLayer();
    this.setState(function() {
      return {
        bicyclingLayer: n
      };
    }, this.setBicyclingLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = yt, t;
})(Ee);
function eV(e) {
  var t = e.onLoad, n = e.onUnmount, r = Te(yt), o = k(null), i = o[0], s = o[1];
  return m(function() {
    i !== null && i.setMap(r);
  }, [r]), m(function() {
    var a = new google.maps.TransitLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      i !== null && (n && n(i), i.setMap(null));
    };
  }, []), null;
}
Ie(eV);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      transitLayer: null
    }, n.setTransitLayerCallback = function() {
      n.state.transitLayer !== null && (n.state.transitLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.transitLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: n
      };
    }, this.setTransitLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = yt, t;
})(Ee);
var hL = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, gL = {
  drawingMode: function(e, t) {
    e.setDrawingMode(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function tV(e) {
  var t = e.options, n = e.drawingMode, r = e.onCircleComplete, o = e.onMarkerComplete, i = e.onOverlayComplete, s = e.onPolygonComplete, a = e.onPolylineComplete, l = e.onRectangleComplete, u = e.onLoad, c = e.onUnmount, p = Te(yt), d = k(null), h = d[0], y = d[1], f = k(null), g = f[0], x = f[1], L = k(null), E = L[0], T = L[1], b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1];
  return m(function() {
    h !== null && h.setMap(p);
  }, [p]), m(function() {
    t && h !== null && h.setOptions(t);
  }, [h, t]), m(function() {
    h !== null && h.setDrawingMode(n ?? null);
  }, [h, n]), m(function() {
    h && r && (g !== null && google.maps.event.removeListener(g), x(google.maps.event.addListener(h, "circlecomplete", r)));
  }, [h, r]), m(function() {
    h && o && (E !== null && google.maps.event.removeListener(E), T(google.maps.event.addListener(h, "markercomplete", o)));
  }, [h, o]), m(function() {
    h && i && (C !== null && google.maps.event.removeListener(C), M(google.maps.event.addListener(h, "overlaycomplete", i)));
  }, [h, i]), m(function() {
    h && s && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(h, "polygoncomplete", s)));
  }, [h, s]), m(function() {
    h && a && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(h, "polylinecomplete", a)));
  }, [h, a]), m(function() {
    h && l && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(h, "rectanglecomplete", l)));
  }, [h, l]), m(function() {
    jr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var j = new google.maps.drawing.DrawingManager(Qe(Qe({}, t || {}), { map: p }));
    return n && j.setDrawingMode(n), r && x(google.maps.event.addListener(j, "circlecomplete", r)), o && T(google.maps.event.addListener(j, "markercomplete", o)), i && M(google.maps.event.addListener(j, "overlaycomplete", i)), s && D(google.maps.event.addListener(j, "polygoncomplete", s)), a && $(google.maps.event.addListener(j, "polylinecomplete", a)), l && J(google.maps.event.addListener(j, "rectanglecomplete", l)), y(j), u && u(j), function() {
      h !== null && (g && google.maps.event.removeListener(g), E && google.maps.event.removeListener(E), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), U && google.maps.event.removeListener(U), V && google.maps.event.removeListener(V), c && c(h), h.setMap(null));
    };
  }, []), null;
}
Ie(tV);
(function(e) {
  Rn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    return r.registeredEvents = [], r.state = {
      drawingManager: null
    }, r.setDrawingManagerCallback = function() {
      r.state.drawingManager !== null && r.props.onLoad && r.props.onLoad(r.state.drawingManager);
    }, jr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing), r;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.drawing.DrawingManager(Qe(Qe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Pt({
      updaterMap: gL,
      eventMap: hL,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        drawingManager: n
      };
    }, this.setDrawingManagerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.drawingManager !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: gL,
      eventMap: hL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), zt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = yt, t;
})(Ee);
var mL = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, vL = {
  animation: function(e, t) {
    e.setAnimation(t);
  },
  clickable: function(e, t) {
    e.setClickable(t);
  },
  cursor: function(e, t) {
    e.setCursor(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  icon: function(e, t) {
    e.setIcon(t);
  },
  label: function(e, t) {
    e.setLabel(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  opacity: function(e, t) {
    e.setOpacity(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  shape: function(e, t) {
    e.setShape(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, vd = {};
function nV(e) {
  var t = e.position, n = e.options, r = e.clusterer, o = e.noClustererRedraw, i = e.children, s = e.draggable, a = e.visible, l = e.animation, u = e.clickable, c = e.cursor, p = e.icon, d = e.label, h = e.opacity, y = e.shape, f = e.title, g = e.zIndex, x = e.onClick, L = e.onDblClick, E = e.onDrag, T = e.onDragEnd, b = e.onDragStart, C = e.onMouseOut, M = e.onMouseOver, S = e.onMouseUp, F = e.onMouseDown, D = e.onRightClick, Z = e.onClickableChanged, U = e.onCursorChanged, $ = e.onAnimationChanged, N = e.onDraggableChanged, V = e.onFlatChanged, J = e.onIconChanged, j = e.onPositionChanged, K = e.onShapeChanged, te = e.onTitleChanged, O = e.onVisibleChanged, P = e.onZindexChanged, H = e.onLoad, I = e.onUnmount, W = Te(yt), X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1], se = k(null), xe = se[0], ne = se[1], Me = k(null), ee = Me[0], Ce = Me[1], Be = k(null), _e = Be[0], $e = Be[1], he = k(null), Ge = he[0], We = he[1], Ut = k(null), ot = Ut[0], st = Ut[1], Zt = k(null), qt = Zt[0], Gt = Zt[1], Xt = k(null), et = Xt[0], bt = Xt[1], tt = k(null), ut = tt[0], Yt = tt[1], gn = k(null), Jt = gn[0], mn = gn[1], qn = k(null), wt = qn[0], vn = qn[1], Gn = k(null), Kt = Gn[0], yn = Gn[1], bn = k(null), Qt = bn[0], Xn = bn[1], Yn = k(null), en = Yn[0], v = Yn[1], B = k(null), G = B[0], oe = B[1], me = k(null), ye = me[0], fe = me[1], pe = k(null), De = pe[0], Le = pe[1], Oe = k(null), ze = Oe[0], nt = Oe[1];
  m(function() {
    w !== null && w.setMap(W);
  }, [W]), m(function() {
    typeof n < "u" && w !== null && w.setOptions(n);
  }, [w, n]), m(function() {
    typeof s < "u" && w !== null && w.setDraggable(s);
  }, [w, s]), m(function() {
    t && w !== null && w.setPosition(t);
  }, [w, t]), m(function() {
    typeof a < "u" && w !== null && w.setVisible(a);
  }, [w, a]), m(function() {
    w == null || w.setAnimation(l);
  }, [w, l]), m(function() {
    w && u !== void 0 && w.setClickable(u);
  }, [w, u]), m(function() {
    w && c !== void 0 && w.setCursor(c);
  }, [w, c]), m(function() {
    w && p !== void 0 && w.setIcon(p);
  }, [w, p]), m(function() {
    w && d !== void 0 && w.setLabel(d);
  }, [w, d]), m(function() {
    w && h !== void 0 && w.setOpacity(h);
  }, [w, h]), m(function() {
    w && y !== void 0 && w.setShape(y);
  }, [w, y]), m(function() {
    w && f !== void 0 && w.setTitle(f);
  }, [w, f]), m(function() {
    w && g !== void 0 && w.setZIndex(g);
  }, [w, g]), m(function() {
    w && L && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(w, "dblclick", L)));
  }, [L]), m(function() {
    w && T && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(w, "dragend", T)));
  }, [T]), m(function() {
    w && b && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(w, "dragstart", b)));
  }, [b]), m(function() {
    w && F && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(w, "mousedown", F)));
  }, [F]), m(function() {
    w && C && (xe !== null && google.maps.event.removeListener(xe), ne(google.maps.event.addListener(w, "mouseout", C)));
  }, [C]), m(function() {
    w && M && (ee !== null && google.maps.event.removeListener(ee), Ce(google.maps.event.addListener(w, "mouseover", M)));
  }, [M]), m(function() {
    w && S && (_e !== null && google.maps.event.removeListener(_e), $e(google.maps.event.addListener(w, "mouseup", S)));
  }, [S]), m(function() {
    w && D && (Ge !== null && google.maps.event.removeListener(Ge), We(google.maps.event.addListener(w, "rightclick", D)));
  }, [D]), m(function() {
    w && x && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(w, "click", x)));
  }, [x]), m(function() {
    w && E && (qt !== null && google.maps.event.removeListener(qt), Gt(google.maps.event.addListener(w, "drag", E)));
  }, [E]), m(function() {
    w && Z && (et !== null && google.maps.event.removeListener(et), bt(google.maps.event.addListener(w, "clickable_changed", Z)));
  }, [Z]), m(function() {
    w && U && (ut !== null && google.maps.event.removeListener(ut), Yt(google.maps.event.addListener(w, "cursor_changed", U)));
  }, [U]), m(function() {
    w && $ && (Jt !== null && google.maps.event.removeListener(Jt), mn(google.maps.event.addListener(w, "animation_changed", $)));
  }, [$]), m(function() {
    w && N && (wt !== null && google.maps.event.removeListener(wt), vn(google.maps.event.addListener(w, "draggable_changed", N)));
  }, [N]), m(function() {
    w && V && (Kt !== null && google.maps.event.removeListener(Kt), yn(google.maps.event.addListener(w, "flat_changed", V)));
  }, [V]), m(function() {
    w && J && (Qt !== null && google.maps.event.removeListener(Qt), Xn(google.maps.event.addListener(w, "icon_changed", J)));
  }, [J]), m(function() {
    w && j && (en !== null && google.maps.event.removeListener(en), v(google.maps.event.addListener(w, "position_changed", j)));
  }, [j]), m(function() {
    w && K && (G !== null && google.maps.event.removeListener(G), oe(google.maps.event.addListener(w, "shape_changed", K)));
  }, [K]), m(function() {
    w && te && (ye !== null && google.maps.event.removeListener(ye), fe(google.maps.event.addListener(w, "title_changed", te)));
  }, [te]), m(function() {
    w && O && (De !== null && google.maps.event.removeListener(De), Le(google.maps.event.addListener(w, "visible_changed", O)));
  }, [O]), m(function() {
    w && P && (ze !== null && google.maps.event.removeListener(ze), nt(google.maps.event.addListener(w, "zindex_changed", P)));
  }, [P]), m(function() {
    var Pe = Qe(Qe(Qe({}, n || vd), r ? vd : { map: W }), { position: t }), ie = new google.maps.Marker(Pe);
    return r ? r.addMarker(ie, !!o) : ie.setMap(W), t && ie.setPosition(t), typeof a < "u" && ie.setVisible(a), typeof s < "u" && ie.setDraggable(s), typeof u < "u" && ie.setClickable(u), typeof c == "string" && ie.setCursor(c), p && ie.setIcon(p), typeof d < "u" && ie.setLabel(d), typeof h < "u" && ie.setOpacity(h), y && ie.setShape(y), typeof f == "string" && ie.setTitle(f), typeof g == "number" && ie.setZIndex(g), L && Y(google.maps.event.addListener(ie, "dblclick", L)), T && ae(google.maps.event.addListener(ie, "dragend", T)), b && de(google.maps.event.addListener(ie, "dragstart", b)), F && ge(google.maps.event.addListener(ie, "mousedown", F)), C && ne(google.maps.event.addListener(ie, "mouseout", C)), M && Ce(google.maps.event.addListener(ie, "mouseover", M)), S && $e(google.maps.event.addListener(ie, "mouseup", S)), D && We(google.maps.event.addListener(ie, "rightclick", D)), x && st(google.maps.event.addListener(ie, "click", x)), E && Gt(google.maps.event.addListener(ie, "drag", E)), Z && bt(google.maps.event.addListener(ie, "clickable_changed", Z)), U && Yt(google.maps.event.addListener(ie, "cursor_changed", U)), $ && mn(google.maps.event.addListener(ie, "animation_changed", $)), N && vn(google.maps.event.addListener(ie, "draggable_changed", N)), V && yn(google.maps.event.addListener(ie, "flat_changed", V)), J && Xn(google.maps.event.addListener(ie, "icon_changed", J)), j && v(google.maps.event.addListener(ie, "position_changed", j)), K && oe(google.maps.event.addListener(ie, "shape_changed", K)), te && fe(google.maps.event.addListener(ie, "title_changed", te)), O && Le(google.maps.event.addListener(ie, "visible_changed", O)), P && nt(google.maps.event.addListener(ie, "zindex_changed", P)), R(ie), H && H(ie), function() {
      _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), ve !== null && google.maps.event.removeListener(ve), xe !== null && google.maps.event.removeListener(xe), ee !== null && google.maps.event.removeListener(ee), _e !== null && google.maps.event.removeListener(_e), Ge !== null && google.maps.event.removeListener(Ge), ot !== null && google.maps.event.removeListener(ot), et !== null && google.maps.event.removeListener(et), ut !== null && google.maps.event.removeListener(ut), Jt !== null && google.maps.event.removeListener(Jt), wt !== null && google.maps.event.removeListener(wt), Kt !== null && google.maps.event.removeListener(Kt), Qt !== null && google.maps.event.removeListener(Qt), en !== null && google.maps.event.removeListener(en), ye !== null && google.maps.event.removeListener(ye), De !== null && google.maps.event.removeListener(De), ze !== null && google.maps.event.removeListener(ze), I && I(ie), r ? r.removeMarker(ie, !!o) : ie && ie.setMap(null);
    };
  }, []);
  var rt = Zn(function() {
    return i ? at.map(i, function(Pe) {
      if (!ci(Pe))
        return Pe;
      var ie = Pe;
      return pi(ie, { anchor: w });
    }) : null;
  }, [i, w]);
  return $r.jsx($r.Fragment, { children: rt }) || null;
}
Ie(nV);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = Qe(Qe(Qe({}, this.props.options || vd), this.props.clusterer ? vd : { map: this.context }), { position: this.props.position });
    this.marker = new google.maps.Marker(n), this.props.clusterer ? this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw) : this.marker.setMap(this.context), this.registeredEvents = Pt({
      updaterMap: vL,
      eventMap: mL,
      prevProps: {},
      nextProps: this.props,
      instance: this.marker
    }), this.props.onLoad && this.props.onLoad(this.marker);
  }, t.prototype.componentDidUpdate = function(n) {
    this.marker && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: vL,
      eventMap: mL,
      prevProps: n,
      nextProps: this.props,
      instance: this.marker
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), zt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }, t.prototype.render = function() {
    var n = this, r = null;
    return this.props.children && (r = at.map(this.props.children, function(o) {
      if (!ci(o))
        return o;
      var i = o;
      return pi(i, { anchor: n.marker });
    })), r || null;
  }, t.contextType = yt, t;
})(Ee);
var rV = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var h = document.createElement("div");
        h.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (h.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (h.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(h), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), oV = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new rV(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function iV(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var sV = 2e3, aV = 500, lV = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", uV = "png", cV = [53, 56, 66, 78, 90], pV = "cluster", oB = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || lV, this.imageExtension = r.imageExtension || uV, this.imageSizes = r.imageSizes || cV, this.calculator = r.calculator || iV, this.batchSize = r.batchSize || sV, this.batchSizeIE = r.batchSizeIE || aV, this.clusterClass = r.clusterClass || pV, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [
        google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged),
        google.maps.event.addListener(t, "idle", this.onIdle)
      ]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new oV(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var h = d[p];
            h.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Ho = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, sn = {
  averageCenter: function(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE: function(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator: function(e, t) {
    e.setCalculator(t);
  },
  clusterClass: function(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons: function(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize: function(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden: function(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension: function(e, t) {
    e.setImageExtension(t);
  },
  imagePath: function(e, t) {
    e.setImagePath(t);
  },
  imageSizes: function(e, t) {
    e.setImageSizes(t);
  },
  maxZoom: function(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize: function(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles: function(e, t) {
    e.setStyles(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  zoomOnClick: function(e, t) {
    e.setZoomOnClick(t);
  }
}, dV = {};
function fV(e) {
  var t = e.children, n = e.options, r = e.averageCenter, o = e.batchSizeIE, i = e.calculator, s = e.clusterClass, a = e.enableRetinaIcons, l = e.gridSize, u = e.ignoreHidden, c = e.imageExtension, p = e.imagePath, d = e.imageSizes, h = e.maxZoom, y = e.minimumClusterSize, f = e.styles, g = e.title, x = e.zoomOnClick, L = e.onClick, E = e.onClusteringBegin, T = e.onClusteringEnd, b = e.onMouseOver, C = e.onMouseOut, M = e.onLoad, S = e.onUnmount, F = k(null), D = F[0], Z = F[1], U = Te(yt), $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1];
  return m(function() {
    D && C && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(D, Ho.onMouseOut, C)));
  }, [C]), m(function() {
    D && b && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(D, Ho.onMouseOver, b)));
  }, [b]), m(function() {
    D && L && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(D, Ho.onClick, L)));
  }, [L]), m(function() {
    D && E && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(D, Ho.onClusteringBegin, E)));
  }, [E]), m(function() {
    D && T && (O !== null && google.maps.event.removeListener(O), K(google.maps.event.addListener(D, Ho.onClusteringEnd, T)));
  }, [T]), m(function() {
    typeof r < "u" && D !== null && sn.averageCenter(D, r);
  }, [D, r]), m(function() {
    typeof o < "u" && D !== null && sn.batchSizeIE(D, o);
  }, [D, o]), m(function() {
    typeof i < "u" && D !== null && sn.calculator(D, i);
  }, [D, i]), m(function() {
    typeof s < "u" && D !== null && sn.clusterClass(D, s);
  }, [D, s]), m(function() {
    typeof a < "u" && D !== null && sn.enableRetinaIcons(D, a);
  }, [D, a]), m(function() {
    typeof l < "u" && D !== null && sn.gridSize(D, l);
  }, [D, l]), m(function() {
    typeof u < "u" && D !== null && sn.ignoreHidden(D, u);
  }, [D, u]), m(function() {
    typeof c < "u" && D !== null && sn.imageExtension(D, c);
  }, [D, c]), m(function() {
    typeof p < "u" && D !== null && sn.imagePath(D, p);
  }, [D, p]), m(function() {
    typeof d < "u" && D !== null && sn.imageSizes(D, d);
  }, [D, d]), m(function() {
    typeof h < "u" && D !== null && sn.maxZoom(D, h);
  }, [D, h]), m(function() {
    typeof y < "u" && D !== null && sn.minimumClusterSize(D, y);
  }, [D, y]), m(function() {
    typeof f < "u" && D !== null && sn.styles(D, f);
  }, [D, f]), m(function() {
    typeof g < "u" && D !== null && sn.title(D, g);
  }, [D, g]), m(function() {
    typeof x < "u" && D !== null && sn.zoomOnClick(D, x);
  }, [D, x]), m(function() {
    if (U) {
      var z = Qe({}, n || dV), _ = new oB(U, [], z);
      return r && sn.averageCenter(_, r), o && sn.batchSizeIE(_, o), i && sn.calculator(_, i), s && sn.clusterClass(_, s), a && sn.enableRetinaIcons(_, a), l && sn.gridSize(_, l), u && sn.ignoreHidden(_, u), c && sn.imageExtension(_, c), p && sn.imagePath(_, p), d && sn.imageSizes(_, d), h && sn.maxZoom(_, h), y && sn.minimumClusterSize(_, y), f && sn.styles(_, f), g && sn.title(_, g), x && sn.zoomOnClick(_, x), C && W(google.maps.event.addListener(_, Ho.onMouseOut, C)), b && R(google.maps.event.addListener(_, Ho.onMouseOver, b)), L && V(google.maps.event.addListener(_, Ho.onClick, L)), E && K(google.maps.event.addListener(_, Ho.onClusteringBegin, E)), T && P(google.maps.event.addListener(_, Ho.onClusteringEnd, T)), Z(_), M && M(_), function() {
        I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), S && S(_);
      };
    }
  }, []), D !== null && t(D) || null;
}
Ie(fV);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      markerClusterer: null
    }, n.setClustererCallback = function() {
      n.state.markerClusterer !== null && n.props.onLoad && n.props.onLoad(n.state.markerClusterer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context) {
      var n = new oB(this.context, [], this.props.options);
      this.registeredEvents = Pt({
        updaterMap: sn,
        eventMap: Ho,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          markerClusterer: n
        };
      }, this.setClustererCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.markerClusterer && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: sn,
      eventMap: Ho,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), zt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }, t.prototype.render = function() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }, t.contextType = yt, t;
})(Ee);
function yL(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var iB = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || yL(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = [
            "mousedown",
            "mouseover",
            "mouseout",
            "mouseup",
            "click",
            "dblclick",
            "touchstart",
            "touchend",
            "touchmove"
          ], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, yL));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, h = this.infoBoxClearance.width, y = this.infoBoxClearance.height, f = this.getProjection(), g = f.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + h ? r = g.x + u - h : g.x + p + u + h > a && (r = g.x + p + u + h - a), this.alignBottom ? g.y < -c + y + d ? o = g.y + c - y - d : g.y + c + y > l && (o = g.y + c + y - l) : g.y < -c + y ? o = g.y + c - y : g.y + d + c + y > l && (o = g.y + d + c + y - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = { top: 0, bottom: 0, left: 0, right: 0 };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), bL = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, wL = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, hV = {};
function gV(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, h = Te(yt), y = k(null), f = y[0], g = y[1], x = k(null), L = x[0], E = x[1], T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = it(null);
  return m(function() {
    h && f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), m(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), m(function() {
    if (o && f !== null) {
      var j = o instanceof google.maps.LatLng ? o : new google.maps.LatLng(o.lat, o.lng);
      f.setPosition(j);
    }
  }, [o]), m(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), m(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), E(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), m(function() {
    f && a && (b !== null && google.maps.event.removeListener(b), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), m(function() {
    f && l && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), m(function() {
    f && u && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), m(function() {
    f && c && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), m(function() {
    if (h) {
      var j = r || hV, K = j.position, te = A0(j, ["position"]), O = void 0;
      K && !(K instanceof google.maps.LatLng) && (O = new google.maps.LatLng(K.lat, K.lng));
      var P = new iB(Qe(Qe({}, te), O ? { position: O } : {}));
      J.current = document.createElement("div"), g(P), s && E(google.maps.event.addListener(P, "closeclick", s)), a && C(google.maps.event.addListener(P, "domready", a)), l && F(google.maps.event.addListener(P, "content_changed", l)), u && U(google.maps.event.addListener(P, "position_changed", u)), c && V(google.maps.event.addListener(P, "zindex_changed", c)), P.setContent(J.current), n ? P.open(h, n) : P.getPosition() ? P.open(h) : jr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(P);
    }
    return function() {
      f !== null && (L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), Z && google.maps.event.removeListener(Z), N && google.maps.event.removeListener(N), d && d(f), f.close());
    };
  }, []), J.current ? Nr(at.only(t), J.current) : null;
}
Ie(gV);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoBox: null
    }, n.open = function(r, o) {
      o ? n.context !== null && r.open(n.context, o) : r.getPosition() ? n.context !== null && r.open(n.context) : jr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }, n.setInfoBoxCallback = function() {
      n.state.infoBox !== null && n.containerElement !== null && (n.state.infoBox.setContent(n.containerElement), n.open(n.state.infoBox, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoBox));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.props.options || {}, r = n.position, o = A0(n, ["position"]), i;
    r && !(r instanceof google.maps.LatLng) && (i = new google.maps.LatLng(r.lat, r.lng));
    var s = new iB(Qe(Qe({}, o), i ? { position: i } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Pt({
      updaterMap: wL,
      eventMap: bL,
      prevProps: {},
      nextProps: this.props,
      instance: s
    }), this.setState({ infoBox: s }, this.setInfoBoxCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = this.state.infoBox;
    r !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: wL,
      eventMap: bL,
      prevProps: n,
      nextProps: this.props,
      instance: r
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n = this.props.onUnmount, r = this.state.infoBox;
    r !== null && (n && n(r), zt(this.registeredEvents), r.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Nr(at.only(this.props.children), this.containerElement) : null;
  }, t.contextType = yt, t;
})(Ee);
var mV = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, o, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
    for (o = r; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
    for (o = r; o-- !== 0; ) {
      var s = i[o];
      if (!e(t[s], n[s])) return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
}, CL = /* @__PURE__ */ QA(mV);
const xL = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], fg = 1, El = 8;
class B0 {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const o = r >> 4;
    if (o !== fg)
      throw new Error(`Got v${o} data when expected v${fg}.`);
    const i = xL[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new B0(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, o) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = xL.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, El, t), this.coords = new this.ArrayType(this.data, El + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(El + s + a + l), this.ids = new this.IndexArrayType(this.data, El, t), this.coords = new this.ArrayType(this.data, El + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (fg << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return $v(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: s, nodeSize: a } = this, l = [0, i.length - 1, 0], u = [];
    for (; l.length; ) {
      const c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (let g = d; g <= p; g++) {
          const x = s[2 * g], L = s[2 * g + 1];
          x >= t && x <= r && L >= n && L <= o && u.push(i[g]);
        }
        continue;
      }
      const h = d + p >> 1, y = s[2 * h], f = s[2 * h + 1];
      y >= t && y <= r && f >= n && f <= o && u.push(i[h]), (c === 0 ? t <= y : n <= f) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= y : o >= f) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: o, coords: i, nodeSize: s } = this, a = [0, o.length - 1, 0], l = [], u = r * r;
    for (; a.length; ) {
      const c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (let g = d; g <= p; g++)
          EL(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      const h = d + p >> 1, y = i[2 * h], f = i[2 * h + 1];
      EL(y, f, t, n) <= u && l.push(o[h]), (c === 0 ? t - r <= y : n - r <= f) && (a.push(d), a.push(h - 1), a.push(1 - c)), (c === 0 ? t + r >= y : n + r >= f) && (a.push(h + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function $v(e, t, n, r, o, i) {
  if (o - r <= n) return;
  const s = r + o >> 1;
  sB(e, t, s, r, o, i), $v(e, t, n, r, s - 1, 1 - i), $v(e, t, n, s + 1, o, 1 - i);
}
function sB(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      const u = o - r + 1, c = n - r + 1, p = Math.log(u), d = 0.5 * Math.exp(2 * p / 3), h = 0.5 * Math.sqrt(p * d * (u - d) / u) * (c - u / 2 < 0 ? -1 : 1), y = Math.max(r, Math.floor(n - c * d / u + h)), f = Math.min(o, Math.floor(n + (u - c) * d / u + h));
      sB(e, t, n, y, f, i);
    }
    const s = t[2 * n + i];
    let a = r, l = o;
    for (Ll(e, t, r, n), t[2 * o + i] > s && Ll(e, t, r, o); a < l; ) {
      for (Ll(e, t, a, l), a++, l--; t[2 * a + i] < s; ) a++;
      for (; t[2 * l + i] > s; ) l--;
    }
    t[2 * r + i] === s ? Ll(e, t, r, l) : (l++, Ll(e, t, l, o)), l <= n && (r = l + 1), n <= l && (o = l - 1);
  }
}
function Ll(e, t, n, r) {
  hg(e, n, r), hg(t, 2 * n, 2 * r), hg(t, 2 * n + 1, 2 * r + 1);
}
function hg(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function EL(e, t, n, r) {
  const o = e - n, i = t - r;
  return o * o + i * i;
}
const vV = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, LL = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Vs = 2, fs = 3, gg = 4, ls = 5, aB = 6;
class yV {
  constructor(t) {
    this.options = Object.assign(Object.create(vV), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    const { log: n, minZoom: r, maxZoom: o } = this.options;
    n && console.time("total time");
    const i = `prepare ${t.length} points`;
    n && console.time(i), this.points = t;
    const s = [];
    for (let l = 0; l < t.length; l++) {
      const u = t[l];
      if (!u.geometry) continue;
      const [c, p] = u.geometry.coordinates, d = LL(Bc(c)), h = LL(Ic(p));
      s.push(
        d,
        h,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        l,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && s.push(0);
    }
    let a = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (let l = o; l >= r; l--) {
      const u = +Date.now();
      a = this.trees[l] = this._createTree(this._cluster(a, l)), n && console.log("z%d: %d clusters in %dms", l, a.numItems, +Date.now() - u);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    let r = ((t[0] + 180) % 360 + 360) % 360 - 180;
    const o = Math.max(-90, Math.min(90, t[1]));
    let i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
    const s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      const p = this.getClusters([r, o, 180, s], n), d = this.getClusters([-180, o, i, s], n);
      return p.concat(d);
    }
    const a = this.trees[this._limitZoom(n)], l = a.range(Bc(r), Ic(s), Bc(i), Ic(o)), u = a.data, c = [];
    for (const p of l) {
      const d = this.stride * p;
      c.push(u[d + ls] > 1 ? kL(u, d, this.clusterProps) : this.points[u[d + fs]]);
    }
    return c;
  }
  getChildren(t) {
    const n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    const s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    const a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (const d of c) {
      const h = d * this.stride;
      s[h + gg] === t && p.push(s[h + ls] > 1 ? kL(s, h, this.clusterProps) : this.points[s[h + fs]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    const o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    const o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), { extent: s, radius: a } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(
      o.range((n - l) / i, u, (n + 1 + l) / i, c),
      o.data,
      n,
      r,
      i,
      p
    ), n === 0 && this._addTileFeatures(
      o.range(1 - l / i, u, 1, c),
      o.data,
      i,
      r,
      i,
      p
    ), n === i - 1 && this._addTileFeatures(
      o.range(0, u, l / i, c),
      o.data,
      -1,
      r,
      i,
      p
    ), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    let n = this._getOriginZoom(t) - 1;
    for (; n <= this.options.maxZoom; ) {
      const r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    const s = this.getChildren(n);
    for (const a of s) {
      const l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    const n = new B0(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (const a of t) {
      const l = a * this.stride, u = n[l + ls] > 1;
      let c, p, d;
      if (u)
        c = lB(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        const f = this.points[n[l + fs]];
        c = f.properties;
        const [g, x] = f.geometry.coordinates;
        p = Bc(g), d = Ic(x);
      }
      const h = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (p * i - r)),
          Math.round(this.options.extent * (d * i - o))
        ]],
        tags: c
      };
      let y;
      u || this.options.generateId ? y = n[l + fs] : y = this.points[n[l + fs]].id, y !== void 0 && (h.id = y), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    const { radius: r, extent: o, reduce: i, minPoints: s } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride;
    for (let p = 0; p < l.length; p += c) {
      if (l[p + Vs] <= n) continue;
      l[p + Vs] = n;
      const d = l[p], h = l[p + 1], y = t.within(l[p], l[p + 1], a), f = l[p + ls];
      let g = f;
      for (const x of y) {
        const L = x * c;
        l[L + Vs] > n && (g += l[L + ls]);
      }
      if (g > f && g >= s) {
        let x = d * f, L = h * f, E, T = -1;
        const b = ((p / c | 0) << 5) + (n + 1) + this.points.length;
        for (const C of y) {
          const M = C * c;
          if (l[M + Vs] <= n) continue;
          l[M + Vs] = n;
          const S = l[M + ls];
          x += l[M] * S, L += l[M + 1] * S, l[M + gg] = b, i && (E || (E = this._map(l, p, !0), T = this.clusterProps.length, this.clusterProps.push(E)), i(E, this._map(l, M)));
        }
        l[p + gg] = b, u.push(x / g, L / g, 1 / 0, b, -1, g), i && u.push(T);
      } else {
        for (let x = 0; x < c; x++) u.push(l[p + x]);
        if (g > 1)
          for (const x of y) {
            const L = x * c;
            if (!(l[L + Vs] <= n)) {
              l[L + Vs] = n;
              for (let E = 0; E < c; E++) u.push(l[L + E]);
            }
          }
      }
    }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ls] > 1) {
      const s = this.clusterProps[t[n + aB]];
      return r ? Object.assign({}, s) : s;
    }
    const o = this.points[t[n + fs]].properties, i = this.options.map(o);
    return r && i === o ? Object.assign({}, i) : i;
  }
}
function kL(e, t, n) {
  return {
    type: "Feature",
    id: e[t + fs],
    properties: lB(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [bV(e[t]), wV(e[t + 1])]
    }
  };
}
function lB(e, t, n) {
  const r = e[t + ls], o = r >= 1e4 ? `${Math.round(r / 1e3)}k` : r >= 1e3 ? `${Math.round(r / 100) / 10}k` : r, i = e[t + aB], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + fs],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Bc(e) {
  return e / 360 + 0.5;
}
function Ic(e) {
  const t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function bV(e) {
  return (e - 0.5) * 360;
}
function wV(e) {
  const t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function CV(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Mo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Wv {
  constructor({ markers: t, position: n }) {
    this.markers = t, n && (n instanceof google.maps.LatLng ? this._position = n : this._position = new google.maps.LatLng(n));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const t = new google.maps.LatLngBounds(this._position, this._position);
    for (const n of this.markers)
      t.extend(Mo.getPosition(n));
    return t;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Mo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Mo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class xV {
  constructor({ maxZoom: t = 16 }) {
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: t }) {
    return EV(t);
  }
}
const EV = (e) => e.map((t) => new Wv({
  position: Mo.getPosition(t),
  markers: [t]
}));
class LV extends xV {
  constructor(t) {
    var { maxZoom: n, radius: r = 60 } = t, o = CV(t, ["maxZoom", "radius"]);
    super({ maxZoom: n }), this.state = { zoom: -1 }, this.superCluster = new yV(Object.assign({ maxZoom: this.maxZoom, radius: r }, o));
  }
  calculate(t) {
    let n = !1;
    const r = { zoom: t.map.getZoom() };
    if (!CL(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      const o = this.markers.map((i) => {
        const s = Mo.getPosition(i);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [s.lng(), s.lat()]
          },
          properties: { marker: i }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !CL(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), { clusters: this.clusters, changed: n };
  }
  cluster({ map: t }) {
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t.getZoom())).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [t, n] }, properties: r }) {
    if (r.cluster)
      return new Wv({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((i) => i.properties.marker),
        position: { lat: n, lng: t }
      });
    const o = r.marker;
    return new Wv({
      markers: [o],
      position: Mo.getPosition(o)
    });
  }
}
class kV {
  constructor(t, n) {
    this.markers = { sum: t.length };
    const r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class OV {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: t, position: n }, r, o) {
    const i = `<svg fill="${t > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>
</svg>`, s = `Cluster of ${t} markers`, a = Number(google.maps.Marker.MAX_ZINDEX) + t;
    if (Mo.isAdvancedMarkerAvailable(o)) {
      const u = new DOMParser().parseFromString(i, "image/svg+xml").documentElement;
      u.setAttribute("transform", "translate(0 25)");
      const c = {
        map: o,
        position: n,
        zIndex: a,
        title: s,
        content: u
      };
      return new google.maps.marker.AdvancedMarkerElement(c);
    }
    const l = {
      position: n,
      zIndex: a,
      title: s,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(i)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(l);
  }
}
function MV(e, t) {
  for (let n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class I0 {
  constructor() {
    MV(I0, google.maps.OverlayView);
  }
}
var Vl;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Vl || (Vl = {}));
const SV = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class DV extends I0 {
  constructor({ map: t, markers: n = [], algorithmOptions: r = {}, algorithm: o = new LV(r), renderer: i = new OV(), onClusterClick: s = SV }) {
    super(), this.markers = [...n], this.clusters = [], this.algorithm = o, this.renderer = i, this.onClusterClick = s, t && this.setMap(t);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    const r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Mo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    let r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Vl.CLUSTERING_BEGIN, this);
      const { clusters: n, changed: r } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        const o = /* @__PURE__ */ new Set();
        for (const s of n)
          s.markers.length == 1 && o.add(s.markers[0]);
        const i = [];
        for (const s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Mo.setMap(s.marker, null) : i.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => i.forEach((s) => Mo.setMap(s, null)));
      }
      google.maps.event.trigger(this, Vl.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Mo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    const t = new kV(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Mo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Vl.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Mo.setMap(r.marker, n);
    });
  }
}
function PV(e) {
  var t = $H(), n = k(null), r = n[0], o = n[1];
  return m(function() {
    if (t && r === null) {
      var i = new DV(Qe(Qe({}, e), { map: t }));
      o(i);
    }
  }, [t]), r;
}
function TV(e) {
  var t = e.children, n = e.options, r = PV(n);
  return r !== null ? t(r) : null;
}
Ie(TV);
var OL = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, ML = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
function _V(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, h = Te(yt), y = k(null), f = y[0], g = y[1], x = k(null), L = x[0], E = x[1], T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = it(null);
  return m(function() {
    f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), m(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), m(function() {
    o && f !== null && f.setPosition(o);
  }, [o]), m(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), m(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), E(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), m(function() {
    f && a && (b !== null && google.maps.event.removeListener(b), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), m(function() {
    f && l && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), m(function() {
    f && u && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), m(function() {
    f && c && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), m(function() {
    var j = new google.maps.InfoWindow(Qe({}, r || {}));
    return g(j), J.current = document.createElement("div"), s && E(google.maps.event.addListener(j, "closeclick", s)), a && C(google.maps.event.addListener(j, "domready", a)), l && F(google.maps.event.addListener(j, "content_changed", l)), u && U(google.maps.event.addListener(j, "position_changed", u)), c && V(google.maps.event.addListener(j, "zindex_changed", c)), j.setContent(J.current), o && j.setPosition(o), i && j.setZIndex(i), n ? j.open(h, n) : j.getPosition() ? j.open(h) : jr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(j), function() {
      L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), Z && google.maps.event.removeListener(Z), N && google.maps.event.removeListener(N), d && d(j), j.close();
    };
  }, []), J.current ? Nr(at.only(t), J.current) : null;
}
Ie(_V);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoWindow: null
    }, n.open = function(r, o) {
      o ? r.open(n.context, o) : r.getPosition() ? r.open(n.context) : jr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }, n.setInfoWindowCallback = function() {
      n.state.infoWindow !== null && n.containerElement !== null && (n.state.infoWindow.setContent(n.containerElement), n.open(n.state.infoWindow, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoWindow));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.InfoWindow(Qe({}, this.props.options || {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Pt({
      updaterMap: ML,
      eventMap: OL,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        infoWindow: n
      };
    }, this.setInfoWindowCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.infoWindow !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: ML,
      eventMap: OL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.infoWindow !== null && (zt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Nr(at.only(this.props.children), this.containerElement) : null;
  }, t.contextType = yt, t;
})(Ee);
var SL = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, DL = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, AV = {};
function BV(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, h = e.onMouseUp, y = e.onRightClick, f = e.onClick, g = e.onDrag, x = e.onLoad, L = e.onUnmount, E = Te(yt), T = k(null), b = T[0], C = T[1], M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1];
  return m(function() {
    b !== null && b.setMap(E);
  }, [E]), m(function() {
    typeof t < "u" && b !== null && b.setOptions(t);
  }, [b, t]), m(function() {
    typeof n < "u" && b !== null && b.setDraggable(n);
  }, [b, n]), m(function() {
    typeof r < "u" && b !== null && b.setEditable(r);
  }, [b, r]), m(function() {
    typeof o < "u" && b !== null && b.setVisible(o);
  }, [b, o]), m(function() {
    typeof i < "u" && b !== null && b.setPath(i);
  }, [b, i]), m(function() {
    b && s && (S !== null && google.maps.event.removeListener(S), F(google.maps.event.addListener(b, "dblclick", s)));
  }, [s]), m(function() {
    b && a && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(b, "dragend", a)));
  }, [a]), m(function() {
    b && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(b, "dragstart", l)));
  }, [l]), m(function() {
    b && u && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(b, "mousedown", u)));
  }, [u]), m(function() {
    b && c && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(b, "mousemove", c)));
  }, [c]), m(function() {
    b && p && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(b, "mouseout", p)));
  }, [p]), m(function() {
    b && d && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(b, "mouseover", d)));
  }, [d]), m(function() {
    b && h && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(b, "mouseup", h)));
  }, [h]), m(function() {
    b && y && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(b, "rightclick", y)));
  }, [y]), m(function() {
    b && f && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(b, "click", f)));
  }, [f]), m(function() {
    b && g && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(b, "drag", g)));
  }, [g]), m(function() {
    var se = new google.maps.Polyline(Qe(Qe({}, t || AV), { map: E }));
    return i && se.setPath(i), typeof o < "u" && se.setVisible(o), typeof r < "u" && se.setEditable(r), typeof n < "u" && se.setDraggable(n), s && F(google.maps.event.addListener(se, "dblclick", s)), a && U(google.maps.event.addListener(se, "dragend", a)), l && V(google.maps.event.addListener(se, "dragstart", l)), u && K(google.maps.event.addListener(se, "mousedown", u)), c && P(google.maps.event.addListener(se, "mousemove", c)), p && W(google.maps.event.addListener(se, "mouseout", p)), d && R(google.maps.event.addListener(se, "mouseover", d)), h && Y(google.maps.event.addListener(se, "mouseup", h)), y && ae(google.maps.event.addListener(se, "rightclick", y)), f && de(google.maps.event.addListener(se, "click", f)), g && ge(google.maps.event.addListener(se, "drag", g)), C(se), x && x(se), function() {
      S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), L && L(se), se.setMap(null);
    };
  }, []), null;
}
Ie(BV);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polyline: null
    }, n.setPolylineCallback = function() {
      n.state.polyline !== null && n.props.onLoad && n.props.onLoad(n.state.polyline);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polyline(Qe(Qe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Pt({
      updaterMap: DL,
      eventMap: SL,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polyline: n
      };
    }, this.setPolylineCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polyline !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: DL,
      eventMap: SL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), zt(this.registeredEvents), this.state.polyline.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = yt, t;
})(Ee);
var PL = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, TL = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  paths: function(e, t) {
    e.setPaths(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function IV(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.paths, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, h = e.onMouseOver, y = e.onMouseUp, f = e.onRightClick, g = e.onClick, x = e.onDrag, L = e.onLoad, E = e.onUnmount, T = e.onEdit, b = Te(yt), C = k(null), M = C[0], S = C[1], F = k(null), D = F[0], Z = F[1], U = k(null), $ = U[0], N = U[1], V = k(null), J = V[0], j = V[1], K = k(null), te = K[0], O = K[1], P = k(null), H = P[0], I = P[1], W = k(null), X = W[0], w = W[1], R = k(null), z = R[0], _ = R[1], Y = k(null), Q = Y[0], A = Y[1], ae = k(null), ce = ae[0], ue = ae[1], de = k(null), be = de[0], ve = de[1], ge = k(null), se = ge[0], xe = ge[1];
  return m(function() {
    M !== null && M.setMap(b);
  }, [b]), m(function() {
    typeof t < "u" && M !== null && M.setOptions(t);
  }, [M, t]), m(function() {
    typeof n < "u" && M !== null && M.setDraggable(n);
  }, [M, n]), m(function() {
    typeof r < "u" && M !== null && M.setEditable(r);
  }, [M, r]), m(function() {
    typeof o < "u" && M !== null && M.setVisible(o);
  }, [M, o]), m(function() {
    typeof i < "u" && M !== null && M.setPath(i);
  }, [M, i]), m(function() {
    typeof s < "u" && M !== null && M.setPaths(s);
  }, [M, s]), m(function() {
    M && a && (D !== null && google.maps.event.removeListener(D), Z(google.maps.event.addListener(M, "dblclick", a)));
  }, [a]), m(function() {
    M && (google.maps.event.addListener(M.getPath(), "insert_at", function() {
      T == null || T(M);
    }), google.maps.event.addListener(M.getPath(), "set_at", function() {
      T == null || T(M);
    }));
  }, [M, T]), m(function() {
    M && l && ($ !== null && google.maps.event.removeListener($), N(google.maps.event.addListener(M, "dragend", l)));
  }, [l]), m(function() {
    M && u && (J !== null && google.maps.event.removeListener(J), j(google.maps.event.addListener(M, "dragstart", u)));
  }, [u]), m(function() {
    M && c && (te !== null && google.maps.event.removeListener(te), O(google.maps.event.addListener(M, "mousedown", c)));
  }, [c]), m(function() {
    M && p && (H !== null && google.maps.event.removeListener(H), I(google.maps.event.addListener(M, "mousemove", p)));
  }, [p]), m(function() {
    M && d && (X !== null && google.maps.event.removeListener(X), w(google.maps.event.addListener(M, "mouseout", d)));
  }, [d]), m(function() {
    M && h && (z !== null && google.maps.event.removeListener(z), _(google.maps.event.addListener(M, "mouseover", h)));
  }, [h]), m(function() {
    M && y && (Q !== null && google.maps.event.removeListener(Q), A(google.maps.event.addListener(M, "mouseup", y)));
  }, [y]), m(function() {
    M && f && (ce !== null && google.maps.event.removeListener(ce), ue(google.maps.event.addListener(M, "rightclick", f)));
  }, [f]), m(function() {
    M && g && (be !== null && google.maps.event.removeListener(be), ve(google.maps.event.addListener(M, "click", g)));
  }, [g]), m(function() {
    M && x && (se !== null && google.maps.event.removeListener(se), xe(google.maps.event.addListener(M, "drag", x)));
  }, [x]), m(function() {
    var ne = new google.maps.Polygon(Qe(Qe({}, t || {}), { map: b }));
    return i && ne.setPath(i), s && ne.setPaths(s), typeof o < "u" && ne.setVisible(o), typeof r < "u" && ne.setEditable(r), typeof n < "u" && ne.setDraggable(n), a && Z(google.maps.event.addListener(ne, "dblclick", a)), l && N(google.maps.event.addListener(ne, "dragend", l)), u && j(google.maps.event.addListener(ne, "dragstart", u)), c && O(google.maps.event.addListener(ne, "mousedown", c)), p && I(google.maps.event.addListener(ne, "mousemove", p)), d && w(google.maps.event.addListener(ne, "mouseout", d)), h && _(google.maps.event.addListener(ne, "mouseover", h)), y && A(google.maps.event.addListener(ne, "mouseup", y)), f && ue(google.maps.event.addListener(ne, "rightclick", f)), g && ve(google.maps.event.addListener(ne, "click", g)), x && xe(google.maps.event.addListener(ne, "drag", x)), S(ne), L && L(ne), function() {
      D !== null && google.maps.event.removeListener(D), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), H !== null && google.maps.event.removeListener(H), X !== null && google.maps.event.removeListener(X), z !== null && google.maps.event.removeListener(z), Q !== null && google.maps.event.removeListener(Q), ce !== null && google.maps.event.removeListener(ce), be !== null && google.maps.event.removeListener(be), E && E(ne), ne.setMap(null);
    };
  }, []), null;
}
Ie(IV);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polygon: null
    }, n.setPolygonCallback = function() {
      n.state.polygon !== null && n.props.onLoad && n.props.onLoad(n.state.polygon);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polygon(Qe(Qe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Pt({
      updaterMap: TL,
      eventMap: PL,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polygon: n
      };
    }, this.setPolygonCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polygon !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: TL,
      eventMap: PL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polygon
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polygon !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polygon), zt(this.registeredEvents), this.state.polygon && this.state.polygon.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = yt, t;
})(Ee);
var _L = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, AL = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function jV(e) {
  var t = e.options, n = e.bounds, r = e.draggable, o = e.editable, i = e.visible, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, h = e.onMouseUp, y = e.onRightClick, f = e.onClick, g = e.onDrag, x = e.onBoundsChanged, L = e.onLoad, E = e.onUnmount, T = Te(yt), b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1], j = k(null), K = j[0], te = j[1], O = k(null), P = O[0], H = O[1], I = k(null), W = I[0], X = I[1], w = k(null), R = w[0], z = w[1], _ = k(null), Y = _[0], Q = _[1], A = k(null), ae = A[0], ce = A[1], ue = k(null), de = ue[0], be = ue[1], ve = k(null), ge = ve[0], se = ve[1], xe = k(null), ne = xe[0], Me = xe[1];
  return m(function() {
    C !== null && C.setMap(T);
  }, [T]), m(function() {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), m(function() {
    typeof r < "u" && C !== null && C.setDraggable(r);
  }, [C, r]), m(function() {
    typeof o < "u" && C !== null && C.setEditable(o);
  }, [C, o]), m(function() {
    typeof i < "u" && C !== null && C.setVisible(i);
  }, [C, i]), m(function() {
    typeof n < "u" && C !== null && C.setBounds(n);
  }, [C, n]), m(function() {
    C && s && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), m(function() {
    C && a && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(C, "dragend", a)));
  }, [a]), m(function() {
    C && l && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(C, "dragstart", l)));
  }, [l]), m(function() {
    C && u && (K !== null && google.maps.event.removeListener(K), te(google.maps.event.addListener(C, "mousedown", u)));
  }, [u]), m(function() {
    C && c && (P !== null && google.maps.event.removeListener(P), H(google.maps.event.addListener(C, "mousemove", c)));
  }, [c]), m(function() {
    C && p && (W !== null && google.maps.event.removeListener(W), X(google.maps.event.addListener(C, "mouseout", p)));
  }, [p]), m(function() {
    C && d && (R !== null && google.maps.event.removeListener(R), z(google.maps.event.addListener(C, "mouseover", d)));
  }, [d]), m(function() {
    C && h && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(C, "mouseup", h)));
  }, [h]), m(function() {
    C && y && (ae !== null && google.maps.event.removeListener(ae), ce(google.maps.event.addListener(C, "rightclick", y)));
  }, [y]), m(function() {
    C && f && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(C, "click", f)));
  }, [f]), m(function() {
    C && g && (ge !== null && google.maps.event.removeListener(ge), se(google.maps.event.addListener(C, "drag", g)));
  }, [g]), m(function() {
    C && x && (ne !== null && google.maps.event.removeListener(ne), Me(google.maps.event.addListener(C, "bounds_changed", x)));
  }, [x]), m(function() {
    var ee = new google.maps.Rectangle(Qe(Qe({}, t || {}), { map: T }));
    return typeof i < "u" && ee.setVisible(i), typeof o < "u" && ee.setEditable(o), typeof r < "u" && ee.setDraggable(r), typeof n < "u" && ee.setBounds(n), s && D(google.maps.event.addListener(ee, "dblclick", s)), a && $(google.maps.event.addListener(ee, "dragend", a)), l && J(google.maps.event.addListener(ee, "dragstart", l)), u && te(google.maps.event.addListener(ee, "mousedown", u)), c && H(google.maps.event.addListener(ee, "mousemove", c)), p && X(google.maps.event.addListener(ee, "mouseout", p)), d && z(google.maps.event.addListener(ee, "mouseover", d)), h && Q(google.maps.event.addListener(ee, "mouseup", h)), y && ce(google.maps.event.addListener(ee, "rightclick", y)), f && be(google.maps.event.addListener(ee, "click", f)), g && se(google.maps.event.addListener(ee, "drag", g)), x && Me(google.maps.event.addListener(ee, "bounds_changed", x)), M(ee), L && L(ee), function() {
      F !== null && google.maps.event.removeListener(F), U !== null && google.maps.event.removeListener(U), V !== null && google.maps.event.removeListener(V), K !== null && google.maps.event.removeListener(K), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), R !== null && google.maps.event.removeListener(R), Y !== null && google.maps.event.removeListener(Y), ae !== null && google.maps.event.removeListener(ae), de !== null && google.maps.event.removeListener(de), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), E && E(ee), ee.setMap(null);
    };
  }, []), null;
}
Ie(jV);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      rectangle: null
    }, n.setRectangleCallback = function() {
      n.state.rectangle !== null && n.props.onLoad && n.props.onLoad(n.state.rectangle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Rectangle(Qe(Qe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Pt({
      updaterMap: AL,
      eventMap: _L,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        rectangle: n
      };
    }, this.setRectangleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.rectangle !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: AL,
      eventMap: _L,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), zt(this.registeredEvents), this.state.rectangle.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = yt, t;
})(Ee);
var BL = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, IL = {
  center: function(e, t) {
    e.setCenter(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  radius: function(e, t) {
    e.setRadius(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, RV = {};
function NV(e) {
  var t = e.options, n = e.center, r = e.radius, o = e.draggable, i = e.editable, s = e.visible, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, h = e.onMouseOver, y = e.onMouseUp, f = e.onRightClick, g = e.onClick, x = e.onDrag, L = e.onCenterChanged, E = e.onRadiusChanged, T = e.onLoad, b = e.onUnmount, C = Te(yt), M = k(null), S = M[0], F = M[1], D = k(null), Z = D[0], U = D[1], $ = k(null), N = $[0], V = $[1], J = k(null), j = J[0], K = J[1], te = k(null), O = te[0], P = te[1], H = k(null), I = H[0], W = H[1], X = k(null), w = X[0], R = X[1], z = k(null), _ = z[0], Y = z[1], Q = k(null), A = Q[0], ae = Q[1], ce = k(null), ue = ce[0], de = ce[1], be = k(null), ve = be[0], ge = be[1], se = k(null), xe = se[0], ne = se[1], Me = k(null), ee = Me[0], Ce = Me[1], Be = k(null), _e = Be[0], $e = Be[1];
  return m(function() {
    S !== null && S.setMap(C);
  }, [C]), m(function() {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), m(function() {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), m(function() {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), m(function() {
    typeof s < "u" && S !== null && S.setVisible(s);
  }, [S, s]), m(function() {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), m(function() {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), m(function() {
    S && a && (Z !== null && google.maps.event.removeListener(Z), U(google.maps.event.addListener(S, "dblclick", a)));
  }, [a]), m(function() {
    S && l && (N !== null && google.maps.event.removeListener(N), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), m(function() {
    S && u && (j !== null && google.maps.event.removeListener(j), K(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), m(function() {
    S && c && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), m(function() {
    S && p && (I !== null && google.maps.event.removeListener(I), W(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), m(function() {
    S && d && (w !== null && google.maps.event.removeListener(w), R(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), m(function() {
    S && h && (_ !== null && google.maps.event.removeListener(_), Y(google.maps.event.addListener(S, "mouseover", h)));
  }, [h]), m(function() {
    S && y && (A !== null && google.maps.event.removeListener(A), ae(google.maps.event.addListener(S, "mouseup", y)));
  }, [y]), m(function() {
    S && f && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(S, "rightclick", f)));
  }, [f]), m(function() {
    S && g && (ve !== null && google.maps.event.removeListener(ve), ge(google.maps.event.addListener(S, "click", g)));
  }, [g]), m(function() {
    S && x && (xe !== null && google.maps.event.removeListener(xe), ne(google.maps.event.addListener(S, "drag", x)));
  }, [x]), m(function() {
    S && L && (ee !== null && google.maps.event.removeListener(ee), Ce(google.maps.event.addListener(S, "center_changed", L)));
  }, [g]), m(function() {
    S && E && (_e !== null && google.maps.event.removeListener(_e), $e(google.maps.event.addListener(S, "radius_changed", E)));
  }, [E]), m(function() {
    var he = new google.maps.Circle(Qe(Qe({}, t || RV), { map: C }));
    return typeof r == "number" && he.setRadius(r), typeof n < "u" && he.setCenter(n), typeof r == "number" && he.setRadius(r), typeof s < "u" && he.setVisible(s), typeof i < "u" && he.setEditable(i), typeof o < "u" && he.setDraggable(o), a && U(google.maps.event.addListener(he, "dblclick", a)), l && V(google.maps.event.addListener(he, "dragend", l)), u && K(google.maps.event.addListener(he, "dragstart", u)), c && P(google.maps.event.addListener(he, "mousedown", c)), p && W(google.maps.event.addListener(he, "mousemove", p)), d && R(google.maps.event.addListener(he, "mouseout", d)), h && Y(google.maps.event.addListener(he, "mouseover", h)), y && ae(google.maps.event.addListener(he, "mouseup", y)), f && de(google.maps.event.addListener(he, "rightclick", f)), g && ge(google.maps.event.addListener(he, "click", g)), x && ne(google.maps.event.addListener(he, "drag", x)), L && Ce(google.maps.event.addListener(he, "center_changed", L)), E && $e(google.maps.event.addListener(he, "radius_changed", E)), F(he), T && T(he), function() {
      Z !== null && google.maps.event.removeListener(Z), N !== null && google.maps.event.removeListener(N), j !== null && google.maps.event.removeListener(j), O !== null && google.maps.event.removeListener(O), I !== null && google.maps.event.removeListener(I), w !== null && google.maps.event.removeListener(w), _ !== null && google.maps.event.removeListener(_), A !== null && google.maps.event.removeListener(A), ue !== null && google.maps.event.removeListener(ue), ve !== null && google.maps.event.removeListener(ve), ee !== null && google.maps.event.removeListener(ee), _e !== null && google.maps.event.removeListener(_e), b && b(he), he.setMap(null);
    };
  }, []), null;
}
Ie(NV);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      circle: null
    }, n.setCircleCallback = function() {
      n.state.circle !== null && n.props.onLoad && n.props.onLoad(n.state.circle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Circle(Qe(Qe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Pt({
      updaterMap: IL,
      eventMap: BL,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        circle: n
      };
    }, this.setCircleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.circle !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: IL,
      eventMap: BL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n;
    this.state.circle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.circle), zt(this.registeredEvents), (n = this.state.circle) === null || n === void 0 || n.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = yt, t;
})(Ee);
var jL = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, RL = {
  add: function(e, t) {
    e.add(t);
  },
  addgeojson: function(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains: function(e, t) {
    e.contains(t);
  },
  foreach: function(e, t) {
    e.forEach(t);
  },
  loadgeojson: function(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle: function(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove: function(e, t) {
    e.remove(t);
  },
  revertstyle: function(e, t) {
    e.revertStyle(t);
  },
  controlposition: function(e, t) {
    e.setControlPosition(t);
  },
  controls: function(e, t) {
    e.setControls(t);
  },
  drawingmode: function(e, t) {
    e.setDrawingMode(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  style: function(e, t) {
    e.setStyle(t);
  },
  togeojson: function(e, t) {
    e.toGeoJson(t);
  }
};
function FV(e) {
  var t = e.options, n = e.onClick, r = e.onDblClick, o = e.onMouseDown, i = e.onMouseMove, s = e.onMouseOut, a = e.onMouseOver, l = e.onMouseUp, u = e.onRightClick, c = e.onAddFeature, p = e.onRemoveFeature, d = e.onRemoveProperty, h = e.onSetGeometry, y = e.onSetProperty, f = e.onLoad, g = e.onUnmount, x = Te(yt), L = k(null), E = L[0], T = L[1], b = k(null), C = b[0], M = b[1], S = k(null), F = S[0], D = S[1], Z = k(null), U = Z[0], $ = Z[1], N = k(null), V = N[0], J = N[1], j = k(null), K = j[0], te = j[1], O = k(null), P = O[0], H = O[1], I = k(null), W = I[0], X = I[1], w = k(null), R = w[0], z = w[1], _ = k(null), Y = _[0], Q = _[1], A = k(null), ae = A[0], ce = A[1], ue = k(null), de = ue[0], be = ue[1], ve = k(null), ge = ve[0], se = ve[1], xe = k(null), ne = xe[0], Me = xe[1];
  return m(function() {
    E !== null && E.setMap(x);
  }, [x]), m(function() {
    E && r && (C !== null && google.maps.event.removeListener(C), M(google.maps.event.addListener(E, "dblclick", r)));
  }, [r]), m(function() {
    E && o && (F !== null && google.maps.event.removeListener(F), D(google.maps.event.addListener(E, "mousedown", o)));
  }, [o]), m(function() {
    E && i && (U !== null && google.maps.event.removeListener(U), $(google.maps.event.addListener(E, "mousemove", i)));
  }, [i]), m(function() {
    E && s && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(E, "mouseout", s)));
  }, [s]), m(function() {
    E && a && (K !== null && google.maps.event.removeListener(K), te(google.maps.event.addListener(E, "mouseover", a)));
  }, [a]), m(function() {
    E && l && (P !== null && google.maps.event.removeListener(P), H(google.maps.event.addListener(E, "mouseup", l)));
  }, [l]), m(function() {
    E && u && (W !== null && google.maps.event.removeListener(W), X(google.maps.event.addListener(E, "rightclick", u)));
  }, [u]), m(function() {
    E && n && (R !== null && google.maps.event.removeListener(R), z(google.maps.event.addListener(E, "click", n)));
  }, [n]), m(function() {
    E && c && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(E, "addfeature", c)));
  }, [c]), m(function() {
    E && p && (ae !== null && google.maps.event.removeListener(ae), ce(google.maps.event.addListener(E, "removefeature", p)));
  }, [p]), m(function() {
    E && d && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(E, "removeproperty", d)));
  }, [d]), m(function() {
    E && h && (ge !== null && google.maps.event.removeListener(ge), se(google.maps.event.addListener(E, "setgeometry", h)));
  }, [h]), m(function() {
    E && y && (ne !== null && google.maps.event.removeListener(ne), Me(google.maps.event.addListener(E, "setproperty", y)));
  }, [y]), m(function() {
    if (x !== null) {
      var ee = new google.maps.Data(Qe(Qe({}, t || {}), { map: x }));
      r && M(google.maps.event.addListener(ee, "dblclick", r)), o && D(google.maps.event.addListener(ee, "mousedown", o)), i && $(google.maps.event.addListener(ee, "mousemove", i)), s && J(google.maps.event.addListener(ee, "mouseout", s)), a && te(google.maps.event.addListener(ee, "mouseover", a)), l && H(google.maps.event.addListener(ee, "mouseup", l)), u && X(google.maps.event.addListener(ee, "rightclick", u)), n && z(google.maps.event.addListener(ee, "click", n)), c && Q(google.maps.event.addListener(ee, "addfeature", c)), p && ce(google.maps.event.addListener(ee, "removefeature", p)), d && be(google.maps.event.addListener(ee, "removeproperty", d)), h && se(google.maps.event.addListener(ee, "setgeometry", h)), y && Me(google.maps.event.addListener(ee, "setproperty", y)), T(ee), f && f(ee);
    }
    return function() {
      E && (C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), U !== null && google.maps.event.removeListener(U), V !== null && google.maps.event.removeListener(V), K !== null && google.maps.event.removeListener(K), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), R !== null && google.maps.event.removeListener(R), Y !== null && google.maps.event.removeListener(Y), ae !== null && google.maps.event.removeListener(ae), de !== null && google.maps.event.removeListener(de), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), g && g(E), E.setMap(null));
    };
  }, []), null;
}
Ie(FV);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      data: null
    }, n.setDataCallback = function() {
      n.state.data !== null && n.props.onLoad && n.props.onLoad(n.state.data);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context !== null) {
      var n = new google.maps.Data(Qe(Qe({}, this.props.options || {}), { map: this.context }));
      this.registeredEvents = Pt({
        updaterMap: RL,
        eventMap: jL,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          data: n
        };
      }, this.setDataCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.data !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: RL,
      eventMap: jL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.data
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), zt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = yt, t;
})(Ee);
var NL = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, FL = {
  options: function(e, t) {
    e.setOptions(t);
  },
  url: function(e, t) {
    e.setUrl(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      kmlLayer: null
    }, n.setKmlLayerCallback = function() {
      n.state.kmlLayer !== null && n.props.onLoad && n.props.onLoad(n.state.kmlLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.KmlLayer(Qe(Qe({}, this.props.options), { map: this.context }));
    this.registeredEvents = Pt({
      updaterMap: FL,
      eventMap: NL,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        kmlLayer: n
      };
    }, this.setKmlLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.kmlLayer !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: FL,
      eventMap: NL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), zt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = yt, t;
})(Ee);
function uB(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function zV(e, t) {
  return new t(e.lat, e.lng);
}
function UV(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function $V(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function WV(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function HV(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function VV(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var o = r.x, i = r.y;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function cB(e, t, n, r) {
  return n !== void 0 ? HV(e, t, WV(n, google.maps.LatLngBounds, UV)) : VV(e, t, $V(r, google.maps.LatLng, zV));
}
function ZV(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function qV(e, t, n, r, o) {
  var i = (
    /** @class */
    function(s) {
      Rn(a, s);
      function a(l, u, c, p) {
        var d = s.call(this) || this;
        return d.container = l, d.pane = u, d.position = c, d.bounds = p, d;
      }
      return a.prototype.onAdd = function() {
        var l, u = (l = this.getPanes()) === null || l === void 0 ? void 0 : l[this.pane];
        u == null || u.appendChild(this.container);
      }, a.prototype.draw = function() {
        for (var l = this.getProjection(), u = Qe({}, this.container ? uB(this.container, o) : {
          x: 0,
          y: 0
        }), c = cB(l, u, this.bounds, this.position), p = 0, d = Object.entries(c); p < d.length; p++) {
          var h = d[p], y = h[0], f = h[1];
          this.container.style[y] = f;
        }
      }, a.prototype.onRemove = function() {
        this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
      }, a;
    }(google.maps.OverlayView)
  );
  return new i(e, t, n, r);
}
function zL(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function UL(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function GV(e) {
  var t = e.position, n = e.bounds, r = e.mapPaneName, o = e.zIndex, i = e.onLoad, s = e.onUnmount, a = e.getPixelPositionOffset, l = e.children, u = Te(yt), c = Zn(function() {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Zn(function() {
    return qV(c, r, t, n, a);
  }, [c, r, t, n]);
  return m(function() {
    return i == null || i(p), p == null || p.setMap(u), function() {
      s == null || s(p), p == null || p.setMap(null);
    };
  }, [u, p]), m(function() {
    c.style.zIndex = "".concat(o);
  }, [o, c]), di.createPortal(l, c);
}
Ie(GV);
(function(e) {
  Rn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    r.state = {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }, r.updatePane = function() {
      var i = r.props.mapPaneName, s = r.overlayView.getPanes();
      jr(!!i, "OverlayView requires props.mapPaneName but got %s", i), s ? r.setState({
        paneEl: s[i]
      }) : r.setState({
        paneEl: null
      });
    }, r.onAdd = function() {
      var i, s;
      r.updatePane(), (s = (i = r.props).onLoad) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.onPositionElement = function() {
      var i = r.overlayView.getProjection(), s = Qe({ x: 0, y: 0 }, r.containerRef.current ? uB(r.containerRef.current, r.props.getPixelPositionOffset) : {}), a = cB(i, s, r.props.bounds, r.props.position), l = r.state.containerStyle, u = l.left, c = l.top, p = l.width, d = l.height;
      ZV(a, { left: u, top: c, width: p, height: d }) || r.setState({
        containerStyle: {
          top: a.top || 0,
          left: a.left || 0,
          width: a.width || 0,
          height: a.height || 0,
          position: "absolute"
        }
      });
    }, r.draw = function() {
      r.onPositionElement();
    }, r.onRemove = function() {
      var i, s;
      r.setState(function() {
        return {
          paneEl: null
        };
      }), (s = (i = r.props).onUnmount) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.containerRef = Rr();
    var o = new google.maps.OverlayView();
    return o.onAdd = r.onAdd, o.draw = r.draw, o.onRemove = r.onRemove, r.overlayView = o, r;
  }
  return t.prototype.componentDidMount = function() {
    this.overlayView.setMap(this.context);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = zL(n.position), o = zL(this.props.position), i = UL(n.bounds), s = UL(this.props.bounds);
    (r !== o || i !== s) && this.overlayView.draw(), n.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }, t.prototype.componentWillUnmount = function() {
    this.overlayView.setMap(null);
  }, t.prototype.render = function() {
    var n = this.state.paneEl;
    return n ? di.createPortal($r.jsx("div", { ref: this.containerRef, style: this.state.containerStyle, children: at.only(this.props.children) }), n) : null;
  }, t.FLOAT_PANE = "floatPane", t.MAP_PANE = "mapPane", t.MARKER_LAYER = "markerLayer", t.OVERLAY_LAYER = "overlayLayer", t.OVERLAY_MOUSE_TARGET = "overlayMouseTarget", t.contextType = yt, t;
})(Ee);
function XV() {
}
var $L = {
  onDblClick: "dblclick",
  onClick: "click"
}, WL = {
  opacity: function(e, t) {
    e.setOpacity(t);
  }
};
function YV(e) {
  var t = e.url, n = e.bounds, r = e.options, o = e.visible, i = Te(yt), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Zn(function() {
    var l = new google.maps.GroundOverlay(t, s, Qe({}, r));
    return l;
  }, []);
  return m(function() {
    a !== null && a.setMap(i);
  }, [i]), m(function() {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), m(function() {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), m(function() {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Ie(YV);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      groundOverlay: null
    }, n.setGroundOverlayCallback = function() {
      n.state.groundOverlay !== null && n.props.onLoad && n.props.onLoad(n.state.groundOverlay);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    jr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var n = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Qe(Qe({}, this.props.options), { map: this.context }));
    this.registeredEvents = Pt({
      updaterMap: WL,
      eventMap: $L,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        groundOverlay: n
      };
    }, this.setGroundOverlayCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.groundOverlay !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: WL,
      eventMap: $L,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.defaultProps = {
    onLoad: XV
  }, t.contextType = yt, t;
})(Ee);
var HL = {}, VL = {
  data: function(e, t) {
    e.setData(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function JV(e) {
  var t = e.data, n = e.onLoad, r = e.onUnmount, o = e.options, i = Te(yt), s = k(null), a = s[0], l = s[1];
  return m(function() {
    google.maps.visualization || jr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), m(function() {
    jr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), m(function() {
    a !== null && a.setMap(i);
  }, [i]), m(function() {
    o && a !== null && a.setOptions(o);
  }, [a, o]), m(function() {
    var u = new google.maps.visualization.HeatmapLayer(Qe(Qe({}, o || {}), { data: t, map: i }));
    return l(u), n && n(u), function() {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Ie(JV);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      heatmapLayer: null
    }, n.setHeatmapLayerCallback = function() {
      n.state.heatmapLayer !== null && n.props.onLoad && n.props.onLoad(n.state.heatmapLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    jr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), jr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var n = new google.maps.visualization.HeatmapLayer(Qe(Qe({}, this.props.options || {}), { data: this.props.data, map: this.context }));
    this.registeredEvents = Pt({
      updaterMap: VL,
      eventMap: HL,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        heatmapLayer: n
      };
    }, this.setHeatmapLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: VL,
      eventMap: HL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), zt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = yt, t;
})(Ee);
var ZL = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, qL = {
  register: function(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links: function(e, t) {
    e.setLinks(t);
  },
  motionTracking: function(e, t) {
    e.setMotionTracking(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  pano: function(e, t) {
    e.setPano(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  pov: function(e, t) {
    e.setPov(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      streetViewPanorama: null
    }, n.setStreetViewPanoramaCallback = function() {
      n.state.streetViewPanorama !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewPanorama);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n, r, o = (r = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && r !== void 0 ? r : null;
    this.registeredEvents = Pt({
      updaterMap: qL,
      eventMap: ZL,
      prevProps: {},
      nextProps: this.props,
      instance: o
    }), this.setState(function() {
      return {
        streetViewPanorama: o
      };
    }, this.setStreetViewPanoramaCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.streetViewPanorama !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: qL,
      eventMap: ZL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), zt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = yt, t;
})(Ee);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      streetViewService: null
    }, n.setStreetViewServiceCallback = function() {
      n.state.streetViewService !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: n
      };
    }, this.setStreetViewServiceCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = yt, t;
})(Ee);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      directionsService: null
    }, n.setDirectionsServiceCallback = function() {
      n.state.directionsService !== null && n.props.onLoad && n.props.onLoad(n.state.directionsService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    jr(!!this.props.options, "DirectionsService expected options object as parameter, but got %s", this.props.options);
    var n = new google.maps.DirectionsService();
    this.setState(function() {
      return {
        directionsService: n
      };
    }, this.setDirectionsServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.directionsService !== null && this.state.directionsService.route(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsService !== null && this.props.onUnmount && this.props.onUnmount(this.state.directionsService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Ee);
var GL = {
  onDirectionsChanged: "directions_changed"
}, XL = {
  directions: function(e, t) {
    e.setDirections(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  panel: function(e, t) {
    e.setPanel(t);
  },
  routeIndex: function(e, t) {
    e.setRouteIndex(t);
  }
};
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      directionsRenderer: null
    }, n.setDirectionsRendererCallback = function() {
      n.state.directionsRenderer !== null && (n.state.directionsRenderer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.directionsRenderer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Pt({
      updaterMap: XL,
      eventMap: GL,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        directionsRenderer: n
      };
    }, this.setDirectionsRendererCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.directionsRenderer !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: XL,
      eventMap: GL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), zt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }, t.prototype.render = function() {
    return $r.jsx($r.Fragment, {});
  }, t.contextType = yt, t;
})(Ee);
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      distanceMatrixService: null
    }, n.setDistanceMatrixServiceCallback = function() {
      n.state.distanceMatrixService !== null && n.props.onLoad && n.props.onLoad(n.state.distanceMatrixService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    jr(!!this.props.options, "DistanceMatrixService expected options object as parameter, but go %s", this.props.options);
    var n = new google.maps.DistanceMatrixService();
    this.setState(function() {
      return {
        distanceMatrixService: n
      };
    }, this.setDistanceMatrixServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.distanceMatrixService !== null && this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.distanceMatrixService !== null && this.props.onUnmount && this.props.onUnmount(this.state.distanceMatrixService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Ee);
var YL = {
  onPlacesChanged: "places_changed"
}, JL = {
  bounds: function(e, t) {
    e.setBounds(t);
  }
};
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = Rr(), n.state = {
      searchBox: null
    }, n.setSearchBoxCallback = function() {
      n.state.searchBox !== null && n.props.onLoad && n.props.onLoad(n.state.searchBox);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (jr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var n = this.containerElement.current.querySelector("input");
      if (n !== null) {
        var r = new google.maps.places.SearchBox(n, this.props.options);
        this.registeredEvents = Pt({
          updaterMap: JL,
          eventMap: YL,
          prevProps: {},
          nextProps: this.props,
          instance: r
        }), this.setState(function() {
          return {
            searchBox: r
          };
        }, this.setSearchBoxCallback);
      }
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.searchBox !== null && (zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: JL,
      eventMap: YL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), zt(this.registeredEvents));
  }, t.prototype.render = function() {
    return $r.jsx("div", { ref: this.containerElement, children: at.only(this.props.children) });
  }, t.contextType = yt, t;
})(Ee);
var KL = {
  onPlaceChanged: "place_changed"
}, QL = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  restrictions: function(e, t) {
    e.setComponentRestrictions(t);
  },
  fields: function(e, t) {
    e.setFields(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  types: function(e, t) {
    e.setTypes(t);
  }
};
(function(e) {
  Rn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = Rr(), n.state = {
      autocomplete: null
    }, n.setAutocompleteCallback = function() {
      n.state.autocomplete !== null && n.props.onLoad && n.props.onLoad(n.state.autocomplete);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n;
    jr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var r = (n = this.containerElement.current) === null || n === void 0 ? void 0 : n.querySelector("input");
    if (r) {
      var o = new google.maps.places.Autocomplete(r, this.props.options);
      this.registeredEvents = Pt({
        updaterMap: QL,
        eventMap: KL,
        prevProps: {},
        nextProps: this.props,
        instance: o
      }), this.setState(function() {
        return {
          autocomplete: o
        };
      }, this.setAutocompleteCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    zt(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: QL,
      eventMap: KL,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.autocomplete !== null && zt(this.registeredEvents);
  }, t.prototype.render = function() {
    return $r.jsx("div", { ref: this.containerElement, className: this.props.className, children: at.only(this.props.children) });
  }, t.defaultProps = {
    className: ""
  }, t.contextType = yt, t;
})(Ee);
qe({});
function KV(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const QV = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
KV(QV.CNPJ).length;
Ba((e, t) => /* @__PURE__ */ $r.jsx("input", { ref: t, ...e }));
qe({});
var $i = {};
Object.defineProperty($i, "__esModule", {
  value: !0
});
var e9 = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), mg = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, pB = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: e9 ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, j0 = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var jc = 1; jc < 20; jc++)
  j0["f" + jc] = 111 + jc;
function nf(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return dB(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return fB(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function t9(e, t) {
  return nf(e, t);
}
function n9(e, t) {
  return nf(e, { byKey: !0 }, t);
}
function dB(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in mg)
    r[mg[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, h = d.endsWith("?") && d.length > 1;
      h && (d = d.slice(0, -1));
      var y = R0(d), f = mg[y];
      if (d.length > 1 && !f && !pB[d] && !j0[y])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !f) && (n ? r.key = y : r.which = hB(d)), f && (r[f] = h ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function fB(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function hB(e) {
  e = R0(e);
  var t = j0[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function R0(e) {
  return e = e.toLowerCase(), e = pB[e] || e, e;
}
$i.default = nf;
var vg = $i.isHotkey = nf;
$i.isCodeHotkey = t9;
$i.isKeyHotkey = n9;
$i.parseHotkey = dB;
$i.compareHotkey = fB;
$i.toKeyCode = hB;
$i.toKeyName = R0;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function ek(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Gr(e) {
  var t, n;
  return ek(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(ek(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var gB = Symbol.for("immer-nothing"), tk = Symbol.for("immer-draftable"), Do = Symbol.for("immer-state"), r9 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function lo(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = r9[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var za = Object.getPrototypeOf;
function ba(e) {
  return !!e && !!e[Do];
}
function wa(e) {
  var t;
  return e ? mB(e) || Array.isArray(e) || !!e[tk] || !!((t = e.constructor) != null && t[tk]) || of(e) || sf(e) : !1;
}
var o9 = Object.prototype.constructor.toString();
function mB(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = za(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === o9;
}
function yd(e, t) {
  rf(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function rf(e) {
  const t = e[Do];
  return t ? t.type_ : Array.isArray(e) ? 1 : of(e) ? 2 : sf(e) ? 3 : 0;
}
function Hv(e, t) {
  return rf(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function vB(e, t, n) {
  const r = rf(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function i9(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function of(e) {
  return e instanceof Map;
}
function sf(e) {
  return e instanceof Set;
}
function Ks(e) {
  return e.copy_ || e.base_;
}
function Vv(e, t) {
  if (of(e))
    return new Map(e);
  if (sf(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = mB(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Do];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(za(e), r);
  } else {
    const r = za(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function N0(e, t = !1) {
  return af(e) || ba(e) || !wa(e) || (rf(e) > 1 && (e.set = e.add = e.clear = e.delete = s9), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => N0(r, !0))), e;
}
function s9() {
  lo(2);
}
function af(e) {
  return Object.isFrozen(e);
}
var a9 = {};
function Ca(e) {
  const t = a9[e];
  return t || lo(0, e), t;
}
var pu;
function yB() {
  return pu;
}
function l9(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function nk(e, t) {
  t && (Ca("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Zv(e) {
  qv(e), e.drafts_.forEach(u9), e.drafts_ = null;
}
function qv(e) {
  e === pu && (pu = e.parent_);
}
function rk(e) {
  return pu = l9(pu, e);
}
function u9(e) {
  const t = e[Do];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function ok(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Do].modified_ && (Zv(t), lo(4)), wa(e) && (e = bd(t, e), t.parent_ || wd(t, e)), t.patches_ && Ca("Patches").generateReplacementPatches_(
    n[Do].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = bd(t, n, []), Zv(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== gB ? e : void 0;
}
function bd(e, t, n) {
  if (af(t))
    return t;
  const r = t[Do];
  if (!r)
    return yd(
      t,
      (o, i) => ik(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return wd(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), yd(
      i,
      (a, l) => ik(e, r, o, a, l, n, s)
    ), wd(e, o, !1), n && e.patches_ && Ca("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function ik(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && lo(5), ba(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Hv(t.assigned_, r) ? i.concat(r) : void 0, l = bd(e, o, a);
    if (vB(n, r, l), ba(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (wa(o) && !af(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    bd(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && wd(e, o);
  }
}
function wd(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && N0(t, n);
}
function c9(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : yB(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = F0;
  n && (o = [r], i = du);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var F0 = {
  get(e, t) {
    if (t === Do)
      return e;
    const n = Ks(e);
    if (!Hv(n, t))
      return p9(e, n, t);
    const r = n[t];
    return e.finalized_ || !wa(r) ? r : r === yg(e.base_, t) ? (bg(e), e.copy_[t] = Xv(r, e)) : r;
  },
  has(e, t) {
    return t in Ks(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ks(e));
  },
  set(e, t, n) {
    const r = bB(Ks(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = yg(Ks(e), t), i = o == null ? void 0 : o[Do];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (i9(n, o) && (n !== void 0 || Hv(e.base_, t)))
        return !0;
      bg(e), Gv(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return yg(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, bg(e), Gv(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ks(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    lo(11);
  },
  getPrototypeOf(e) {
    return za(e.base_);
  },
  setPrototypeOf() {
    lo(12);
  }
}, du = {};
yd(F0, (e, t) => {
  du[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
du.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && lo(13), du.set.call(this, e, t, void 0);
};
du.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && lo(14), F0.set.call(this, e[0], t, n, e[0]);
};
function yg(e, t) {
  const n = e[Do];
  return (n ? Ks(n) : e)[t];
}
function p9(e, t, n) {
  var r;
  const o = bB(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function bB(e, t) {
  if (!(t in e))
    return;
  let n = za(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = za(n);
  }
}
function Gv(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Gv(e.parent_));
}
function bg(e) {
  e.copy_ || (e.copy_ = Vv(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var d9 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && lo(6), r !== void 0 && typeof r != "function" && lo(7);
      let o;
      if (wa(t)) {
        const i = rk(this), s = Xv(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? Zv(i) : qv(i);
        }
        return nk(i, r), ok(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === gB && (o = void 0), this.autoFreeze_ && N0(o, !0), r) {
          const i = [], s = [];
          Ca("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        lo(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    wa(e) || lo(8), ba(e) && (e = f9(e));
    const t = rk(this), n = Xv(e, void 0);
    return n[Do].isManual_ = !0, qv(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Do];
    (!n || !n.isManual_) && lo(9);
    const { scope_: r } = n;
    return nk(r, t), ok(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Ca("Patches").applyPatches_;
    return ba(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Xv(e, t) {
  const n = of(e) ? Ca("MapSet").proxyMap_(e, t) : sf(e) ? Ca("MapSet").proxySet_(e, t) : c9(e, t);
  return (t ? t.scope_ : yB()).drafts_.push(n), n;
}
function f9(e) {
  return ba(e) || lo(10, e), wB(e);
}
function wB(e) {
  if (!wa(e) || af(e))
    return e;
  const t = e[Do];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Vv(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Vv(e, !0);
  return yd(n, (r, o) => {
    vB(n, r, wB(o));
  }), t && (t.finalized_ = !1), n;
}
var Po = new d9(), z0 = Po.produce;
Po.produceWithPatches.bind(
  Po
);
Po.setAutoFreeze.bind(Po);
Po.setUseStrictShallowCopy.bind(Po);
Po.applyPatches.bind(Po);
var sk = Po.createDraft.bind(Po), ak = Po.finishDraft.bind(Po), je = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = je.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return je.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return je.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return je.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return je.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && je.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return je.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && je.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && je.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && je.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && je.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && je.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!je.isAncestor(t, e) && !je.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (je.equals(i, r) || je.endsBefore(i, r) || je.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (je.equals(s, r) || je.isAncestor(s, r))
          return null;
        je.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        je.equals(a, r) || je.endsBefore(a, r) ? r[a.length - 1] -= 1 : je.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (je.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else je.endsBefore(u, r) ? r[u.length - 1] += 1 : je.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (je.equals(p, d))
          return r;
        if (je.isAncestor(p, r) || je.equals(p, r)) {
          var h = d.slice();
          return je.endsBefore(p, d) && p.length < d.length && (h[p.length - 1] -= 1), h.concat(r.slice(p.length));
        } else je.isSibling(p, d) && (je.isAncestor(d, r) || je.equals(d, r)) ? je.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : je.endsBefore(d, r) || je.equals(d, r) || je.isAncestor(d, r) ? (je.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : je.endsBefore(p, r) && (je.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function fu(e) {
  "@babel/helpers - typeof";
  return fu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, fu(e);
}
function h9(e, t) {
  if (fu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (fu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function g9(e) {
  var t = h9(e, "string");
  return fu(t) === "symbol" ? t : String(t);
}
function Ga(e, t, n) {
  return t = g9(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function lk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lk(Object(n), !0).forEach(function(r) {
      Ga(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var m9 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = ct.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of Ct.points(t))
          t[l] = $n.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = ct.leaf(e, u), h = d.text.slice(0, c), y = d.text.slice(c);
      if (d.text = h + p + y, t)
        for (var [f, g] of Ct.points(t))
          t[g] = $n.transform(f, n);
      break;
    }
    case "merge_node": {
      var {
        path: x
      } = n, L = ct.get(e, x), E = je.previous(x), T = ct.get(e, E), b = ct.parent(e, x), C = x[x.length - 1];
      if (Er.isText(L) && Er.isText(T))
        T.text += L.text;
      else if (!Er.isText(L) && !Er.isText(T))
        T.children.push(...L.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(x, "] to nodes of different interfaces: ").concat(bo.stringify(L), " ").concat(bo.stringify(T)));
      if (b.children.splice(C, 1), t)
        for (var [M, S] of Ct.points(t))
          t[S] = $n.transform(M, n);
      break;
    }
    case "move_node": {
      var {
        path: F,
        newPath: D
      } = n;
      if (je.isAncestor(F, D))
        throw new Error("Cannot move a path [".concat(F, "] to new path [").concat(D, "] because the destination is inside itself."));
      var Z = ct.get(e, F), U = ct.parent(e, F), $ = F[F.length - 1];
      U.children.splice($, 1);
      var N = je.transform(F, n), V = ct.get(e, je.parent(N)), J = N[N.length - 1];
      if (V.children.splice(J, 0, Z), t)
        for (var [j, K] of Ct.points(t))
          t[K] = $n.transform(j, n);
      break;
    }
    case "remove_node": {
      var {
        path: te
      } = n, O = te[te.length - 1], P = ct.parent(e, te);
      if (P.children.splice(O, 1), t)
        for (var [H, I] of Ct.points(t)) {
          var W = $n.transform(H, n);
          if (t != null && W != null)
            t[I] = W;
          else {
            var X = void 0, w = void 0;
            for (var [R, z] of ct.texts(e))
              if (je.compare(z, te) === -1)
                X = [R, z];
              else {
                w = [R, z];
                break;
              }
            var _ = !1;
            X && w && (je.equals(w[1], te) ? _ = !je.hasPrevious(w[1]) : _ = je.common(X[1], te).length < je.common(w[1], te).length), X && !_ ? (H.path = X[1], H.offset = X[0].text.length) : w ? (H.path = w[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: Y,
        offset: Q,
        text: A
      } = n;
      if (A.length === 0) break;
      var ae = ct.leaf(e, Y), ce = ae.text.slice(0, Q), ue = ae.text.slice(Q + A.length);
      if (ae.text = ce + ue, t)
        for (var [de, be] of Ct.points(t))
          t[be] = $n.transform(de, n);
      break;
    }
    case "set_node": {
      var {
        path: ve,
        properties: ge,
        newProperties: se
      } = n;
      if (ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var xe = ct.get(e, ve);
      for (var ne in se) {
        if (ne === "children" || ne === "text")
          throw new Error('Cannot set the "'.concat(ne, '" property of nodes!'));
        var Me = se[ne];
        Me == null ? delete xe[ne] : xe[ne] = Me;
      }
      for (var ee in ge)
        se.hasOwnProperty(ee) || delete xe[ee];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Ce
      } = n;
      if (Ce == null)
        t = Ce;
      else {
        if (t == null) {
          if (!Ct.isRange(Ce))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(bo.stringify(Ce), " when there is no current selection."));
          t = kl({}, Ce);
        }
        for (var Be in Ce) {
          var _e = Ce[Be];
          if (_e == null) {
            if (Be === "anchor" || Be === "focus")
              throw new Error('Cannot remove the "'.concat(Be, '" selection property'));
            delete t[Be];
          } else
            t[Be] = _e;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: $e,
        position: he,
        properties: Ge
      } = n;
      if ($e.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat($e, "] because the root node cannot be split."));
      var We = ct.get(e, $e), Ut = ct.parent(e, $e), ot = $e[$e.length - 1], st;
      if (Er.isText(We)) {
        var Zt = We.text.slice(0, he), qt = We.text.slice(he);
        We.text = Zt, st = kl(kl({}, Ge), {}, {
          text: qt
        });
      } else {
        var Gt = We.children.slice(0, he), Xt = We.children.slice(he);
        We.children = Gt, st = kl(kl({}, Ge), {}, {
          children: Xt
        });
      }
      if (Ut.children.splice(ot + 1, 0, st), t)
        for (var [et, bt] of Ct.points(t))
          t[bt] = $n.transform(et, n);
      break;
    }
  }
  return t;
}, v9 = {
  transform(e, t) {
    e.children = sk(e.children);
    var n = e.selection && sk(e.selection);
    try {
      n = m9(e, n, t);
    } finally {
      e.children = ak(e.children), n ? e.selection = ba(n) ? ak(n) : n : e.selection = null;
    }
  }
}, y9 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, b9 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, CB = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Gr(r) && Gr(o)) {
      if (!CB(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function w9(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function hu(e, t) {
  if (e == null) return {};
  var n = w9(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var C9 = ["anchor", "focus"];
function uk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function x9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uk(Object(n), !0).forEach(function(r) {
      Ga(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ct = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Ct.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Ct.edges(e);
    return t;
  },
  equals(e, t) {
    return $n.equals(e.anchor, t.anchor) && $n.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Ct.isRange(t)) {
      if (Ct.includes(e, t.anchor) || Ct.includes(e, t.focus))
        return !0;
      var [n, r] = Ct.edges(e), [o, i] = Ct.edges(t);
      return $n.isBefore(n, o) && $n.isAfter(r, i);
    }
    var [s, a] = Ct.edges(e), l = !1, u = !1;
    return $n.isPoint(t) ? (l = $n.compare(t, s) >= 0, u = $n.compare(t, a) <= 0) : (l = je.compare(t, s.path) >= 0, u = je.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = hu(e, C9), [r, o] = Ct.edges(e), [i, s] = Ct.edges(t), a = $n.isBefore(r, i) ? i : r, l = $n.isBefore(o, s) ? o : s;
    return $n.isBefore(l, a) ? null : x9({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return $n.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return $n.equals(t, n);
  },
  isExpanded(e) {
    return !Ct.isCollapsed(e);
  },
  isForward(e) {
    return !Ct.isBackward(e);
  },
  isRange(e) {
    return Gr(e) && $n.isPoint(e.anchor) && $n.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Ct.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return z0(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = Ct.isCollapsed(r);
        Ct.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? Ct.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = $n.transform(r.anchor, t, {
        affinity: i
      }), u = $n.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, ck = (e) => Gr(e) && ct.isNodeList(e.children) && !Ln.isEditor(e), Pi = {
  isAncestor(e) {
    return Gr(e) && ct.isNodeList(e.children);
  },
  isElement: ck,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Pi.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return ck(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, E9 = ["children"], L9 = ["text"], pk = /* @__PURE__ */ new WeakMap(), ct = {
  ancestor(e, t) {
    var n = ct.get(e, t);
    if (Er.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(bo.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of je.ancestors(t, n)) {
        var o = ct.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Er.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(bo.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(bo.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = ct.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = ct.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = je.common(t, n), o = ct.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = ct.get(e, t);
    if (Ln.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(bo.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ct.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ct.nodes(e, t))
        Pi.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Pi.isAncestor(e)) {
      var t = hu(e, E9);
      return t;
    } else {
      var t = hu(e, L9);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = ct.get(e, n); r && !(Er.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Er.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(bo.stringify(e)));
    var n = z0({
      children: e.children
    }, (r) => {
      var [o, i] = Ct.edges(t), s = ct.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, h] = d;
          return !Ct.includes(t, h);
        }
      });
      for (var [, a] of s) {
        if (!Ct.includes(t, a)) {
          var l = ct.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (je.equals(a, i.path)) {
          var c = ct.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (je.equals(a, o.path)) {
          var p = ct.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      Ln.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Er.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(bo.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Er.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Er.isText(e) || Pi.isElement(e) || Ln.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = pk.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => ct.isNode(r));
    return pk.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = ct.get(e, n); r && !(Er.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = ct.get(e, t);
    if (!Er.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(bo.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of je.levels(t, n)) {
        var o = ct.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Pi.isElement(e) && Pi.isElementProps(t) && Pi.matches(e, t) || Er.isText(e) && Er.isTextProps(t) && Er.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? je.isBefore(a, i) : je.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Er.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          je.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = ct.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = je.next(a);
          if (ct.has(e, c)) {
            a = c, l = ct.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = je.previous(a);
          a = p, l = ct.get(e, a);
          continue;
        }
        a = je.parent(a), l = ct.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = je.parent(t), r = ct.get(e, n);
    if (Er.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Er.isText(e) ? e.text : e.children.map(ct.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ct.nodes(e, t))
        Er.isText(n) && (yield [n, r]);
    }();
  }
};
function dk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dk(Object(n), !0).forEach(function(r) {
      Ga(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _l = {
  isNodeOperation(e) {
    return _l.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Gr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return je.isPath(e.path) && ct.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && je.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && je.isPath(e.path) && Gr(e.properties);
      case "move_node":
        return je.isPath(e.path) && je.isPath(e.newPath);
      case "remove_node":
        return je.isPath(e.path) && ct.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && je.isPath(e.path);
      case "set_node":
        return je.isPath(e.path) && Gr(e.properties) && Gr(e.newProperties);
      case "set_selection":
        return e.properties === null && Ct.isRange(e.newProperties) || e.newProperties === null && Ct.isRange(e.properties) || Gr(e.properties) && Gr(e.newProperties);
      case "split_node":
        return je.isPath(e.path) && typeof e.position == "number" && Gr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => _l.isOperation(t));
  },
  isSelectionOperation(e) {
    return _l.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return _l.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Jn(Jn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Jn(Jn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Jn(Jn({}, e), {}, {
          type: "split_node",
          path: je.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (je.equals(t, n))
          return e;
        if (je.isSibling(n, t))
          return Jn(Jn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = je.transform(n, e), o = je.transform(je.next(n), e);
        return Jn(Jn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Jn(Jn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Jn(Jn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Jn(Jn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? Jn(Jn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Jn(Jn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : Jn(Jn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return Jn(Jn({}, e), {}, {
          type: "merge_node",
          path: je.next(e.path)
        });
    }
  }
}, fk = /* @__PURE__ */ new WeakMap(), k9 = (e) => {
  var t = fk.get(e);
  if (t !== void 0)
    return t;
  if (!Gr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Gr(e.marks)) && (e.selection === null || Ct.isRange(e.selection)) && ct.isNodeList(e.children) && _l.isOperationList(e.operations);
  return fk.set(e, n), n;
}, Ln = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return k9(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function hk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gk(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hk(Object(n), !0).forEach(function(r) {
      Ga(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $n = {
  compare(e, t) {
    var n = je.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return $n.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return $n.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && je.equals(e.path, t.path);
  },
  isPoint(e) {
    return Gr(e) && typeof e.offset == "number" && je.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return z0(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = je.transform(i, t, n);
          break;
        }
        case "insert_text": {
          je.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          je.equals(t.path, i) && (r.offset += t.position), r.path = je.transform(i, t, n);
          break;
        }
        case "remove_text": {
          je.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (je.equals(t.path, i) || je.isAncestor(t.path, i))
            return null;
          r.path = je.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (je.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = je.transform(i, t, gk(gk({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = je.transform(i, t, n);
          break;
        }
      }
    });
  }
}, mk = void 0, bo = {
  setScrubber(e) {
    mk = e;
  },
  stringify(e) {
    return JSON.stringify(e, mk);
  }
}, O9 = ["text"], M9 = ["anchor", "focus"];
function vk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vk(Object(n), !0).forEach(function(r) {
      Ga(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Er = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = hu(i, O9);
      return s;
    }
    return CB(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Gr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Er.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [wi({}, e)];
    for (var r of t) {
      var o = hu(r, M9), [i, s] = Ct.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, h = l;
        if (l += d, u <= h && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === h) || u > l || c < h || c === h && h !== 0) {
          a.push(p);
          continue;
        }
        var y = p, f = void 0, g = void 0;
        if (c < l) {
          var x = c - h;
          g = wi(wi({}, y), {}, {
            text: y.text.slice(x)
          }), y = wi(wi({}, y), {}, {
            text: y.text.slice(0, x)
          });
        }
        if (u > h) {
          var L = u - h;
          f = wi(wi({}, y), {}, {
            text: y.text.slice(0, L)
          }), y = wi(wi({}, y), {}, {
            text: y.text.slice(L)
          });
        }
        Object.assign(y, o), f && a.push(f), a.push(y), g && a.push(g);
      }
      n = a;
    }
    return n;
  }
}, S9 = (e) => e.selection ? e.selection : e.children.length > 0 ? Ln.end(e, []) : [0], Nn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Nn || (Nn = {}));
Nn.L, Nn.L | Nn.V | Nn.LV | Nn.LVT, Nn.LV | Nn.V, Nn.V | Nn.T, Nn.LVT | Nn.T, Nn.T, Nn.Any, Nn.Extend | Nn.ZWJ, Nn.Any, Nn.SpacingMark, Nn.Prepend, Nn.Any, Nn.ZWJ, Nn.ExtPict, Nn.RI, Nn.RI;
var D9 = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Ln.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = S9(e)
      } = n;
      if (je.isPath(o) && (o = Ln.range(e, o)), Ct.isRange(o))
        if (Ct.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Ct.end(o);
          if (!r && Ln.void(e, {
            at: i
          }))
            return;
          var s = Ct.start(o), a = Ln.pointRef(e, s), l = Ln.pointRef(e, i);
          Cd.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Cd.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Ln.void(e, {
        at: o
      }) || Ln.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function yk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yk(Object(n), !0).forEach(function(r) {
      Ga(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Cd = Rc(Rc(Rc(Rc({}, v9), y9), b9), D9), P9 = typeof _n == "object" && _n && _n.Object === Object && _n, T9 = P9, _9 = T9, A9 = typeof self == "object" && self && self.Object === Object && self, B9 = _9 || A9 || Function("return this")(), I9 = B9, j9 = I9, R9 = j9.Symbol, xB = R9, bk = xB;
bk && bk.toStringTag;
var wk = xB;
wk && wk.toStringTag;
var Ck;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Ck || (Ck = {}));
var U0 = function(e) {
  return Object.freeze(e);
}, N9 = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, U0(this);
  }
  return e;
}(), F9 = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, U0(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), xk = typeof window < "u" ? window : {};
/msie|trident/i.test(xk.navigator && xk.navigator.userAgent);
var wg = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new N9((n ? t : e) || 0, (n ? e : t) || 0);
};
U0({
  devicePixelContentBoxSize: wg(),
  borderBoxSize: wg(),
  contentBoxSize: wg(),
  contentRect: new F9(0, 0, 0, 0)
});
function gu(e) {
  "@babel/helpers - typeof";
  return gu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, gu(e);
}
function z9(e, t) {
  if (gu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (gu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function U9(e) {
  var t = z9(e, "string");
  return gu(t) === "symbol" ? t : String(t);
}
function Zl(e, t, n) {
  return t = U9(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var $9 = /* @__PURE__ */ qe(null), Cg, xg;
parseInt(Ae.version.split(".")[0], 10);
var Ek = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Eg = typeof navigator < "u" && /Android/.test(navigator.userAgent), Nc = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), W9 = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Cg = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Cg !== void 0 && Cg[1] && parseInt((xg = navigator.userAgent.match(/Version\/(\d+)/)) === null || xg === void 0 ? void 0 : xg[1], 10) < 17;
var H9 = /* @__PURE__ */ new WeakMap(), V9 = /* @__PURE__ */ new WeakMap(), Z9 = /* @__PURE__ */ new WeakMap(), q9 = /* @__PURE__ */ new WeakMap(), G9 = /* @__PURE__ */ new WeakMap(), Lk = /* @__PURE__ */ new WeakMap(), X9 = /* @__PURE__ */ new WeakMap(), kk = /* @__PURE__ */ new WeakMap(), Fc = /* @__PURE__ */ new WeakMap(), Y9 = /* @__PURE__ */ new WeakMap(), J9 = /* @__PURE__ */ new WeakMap(), K9 = /* @__PURE__ */ new WeakMap(), EB = globalThis.Node, Q9 = globalThis.Text, LB = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, e6 = (e) => xd(e) && e.nodeType === 8, si = (e) => xd(e) && e.nodeType === 1, xd = (e) => {
  var t = LB(e);
  return !!t && e instanceof t.Node;
}, Ok = (e) => {
  var t = e && e.anchorNode && LB(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, t6 = (e) => {
  var [t, n] = e;
  if (si(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = kB(t, o, r ? "backward" : "forward"), r = o < n; si(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = r6(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, n6 = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, kB = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (e6(o) || si(o) && o.childNodes.length === 0 || si(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, r6 = (e, t, n) => {
  var [r] = kB(e, t, n);
  return r;
}, Mk = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), OB = (e, t, n) => {
  var {
    target: r
  } = t;
  if (si(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = $t.getWindow(e);
  if (o.contains(r))
    return $t.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : OB(e, i, n);
}, Sk = (e, t) => !!(e.compareDocumentPosition(t) & EB.DOCUMENT_POSITION_PRECEDING), o6 = (e, t) => !!(e.compareDocumentPosition(t) & EB.DOCUMENT_POSITION_FOLLOWING), i6 = 0;
class s6 {
  constructor() {
    Zl(this, "id", void 0), this.id = "".concat(i6++);
  }
}
var $t = {
  androidPendingDiffs: (e) => K9.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = J9.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = $t.toDOMNode(e, e), n = $t.findDocumentOrShadowRoot(e);
    Fc.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = $t.findDocumentOrShadowRoot(e), r = Mk(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Cd.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = $t.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = $t.toSlateNode(e, t.target), s = $t.findPath(e, i);
    if (Pi.isElement(i) && Ln.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = Ln.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? Ln.before(e, u) : Ln.after(e, u);
      if (c) {
        var p = Ln.range(e, c);
        return p;
      }
    }
    var d, {
      document: h
    } = $t.getWindow(e);
    if (h.caretRangeFromPoint)
      d = h.caretRangeFromPoint(n, r);
    else {
      var y = h.caretPositionFromPoint(n, r);
      y && (d = h.createRange(), d.setStart(y.offsetNode, y.offset), d.setEnd(y.offsetNode, y.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var f = $t.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return f;
  },
  findKey: (e, t) => {
    var n = Lk.get(t);
    return n || (n = new s6(), Lk.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = V9.get(r);
      if (o == null) {
        if (Ln.isEditor(r))
          return n;
        break;
      }
      var i = H9.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(bo.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Fc.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          $t.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = $t.toDOMNode(e, e), r = $t.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = Mk(r), i = $t.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Cd.select(e, Ln.start(e, [])), Fc.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Z9.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = $t.toDOMNode(e, e), i;
    try {
      i = si(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => xd(t) && $t.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Ln.hasPath(e, n.path) && Ln.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => $t.hasEditableTarget(e, t) || $t.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => xd(t) && $t.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Y9.get(e),
  isFocused: (e) => !!Fc.get(e),
  isReadOnly: (e) => !!kk.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (kk.get(e)) return !1;
    var n = $t.hasTarget(e, t) && $t.toSlateNode(e, t);
    return Pi.isElement(n) && Ln.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = X9.get(e), r = Ln.isEditor(t) ? q9.get(e) : n == null ? void 0 : n.get($t.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(bo.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Ln.node(e, t.path), r = $t.toDOMNode(e, n), o;
    Ln.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), h = d == null ? p : parseInt(d, 10), y = a + h, f = s[l + 1];
        if (t.offset === y && f !== null && f !== void 0 && f.hasAttribute("data-slate-mark-placeholder")) {
          var g, x = f.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            x instanceof Q9 ? x : f,
            (g = f.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= y) {
          var L = Math.min(p, Math.max(0, t.offset - a));
          o = [c, L];
          break;
        }
        a = y;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(bo.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Ct.isBackward(t), i = $t.toDOMPoint(e, n), s = Ct.isCollapsed(t) ? i : $t.toDOMPoint(e, r), a = $t.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, h = si(u) ? u : u.parentElement, y = !!h.getAttribute("data-slate-zero-width"), f = si(p) ? p : p.parentElement, g = !!f.getAttribute("data-slate-zero-width");
    return l.setStart(u, y ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = si(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? G9.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : t6(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, h = $t.toDOMNode(e, e), y = l.closest('[data-slate-void="true"]'), f = y && h.contains(y) ? y : null, g = l.closest('[contenteditable="false"]'), x = g && h.contains(g) ? g : null, L = l.closest("[data-slate-leaf]"), E = null;
      if (L) {
        if (u = L.closest('[data-slate-node="text"]'), u) {
          var T = $t.getWindow(e), b = T.document.createRange();
          b.setStart(u, 0), b.setEnd(s, a);
          var C = b.cloneContents(), M = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          M.forEach((I) => {
            if (Eg && !r && I.hasAttribute("data-slate-zero-width") && I.textContent.length > 0 && I.textContext !== "\uFEFF") {
              I.textContent.startsWith("\uFEFF") && (I.textContent = I.textContent.slice(1));
              return;
            }
            I.parentNode.removeChild(I);
          }), c = C.textContent.length, E = u;
        }
      } else if (f) {
        for (var S = f.querySelectorAll("[data-slate-leaf]"), F = 0; F < S.length; F++) {
          var D = S[F];
          if ($t.hasDOMNode(e, D)) {
            L = D;
            break;
          }
        }
        L ? (u = L.closest('[data-slate-node="text"]'), E = L, c = E.textContent.length, E.querySelectorAll("[data-slate-zero-width]").forEach((I) => {
          c -= I.textContent.length;
        })) : c = 1;
      } else if (x) {
        var Z = (I) => I ? I.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], U = x.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, N = [...Z(U), ...Z(U == null ? void 0 : U.nextElementSibling)];
          L = ($ = N.find((I) => o6(x, I))) !== null && $ !== void 0 ? $ : null;
        } else {
          var V, J = [...Z(U == null ? void 0 : U.previousElementSibling), ...Z(U)];
          L = (V = J.findLast((I) => Sk(x, I))) !== null && V !== void 0 ? V : null;
        }
        L && (u = L.closest('[data-slate-node="text"]'), E = L, i === "forward" ? c = 0 : (c = E.textContent.length, E.querySelectorAll("[data-slate-zero-width]").forEach((I) => {
          c -= I.textContent.length;
        })));
      }
      E && c === E.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Eg && E.getAttribute("data-slate-zero-width") === "z" && (p = E.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Nc && (d = E.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Eg && !u && !r) {
      var j = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (j && $t.hasDOMNode(e, j, {
        editable: !0
      })) {
        var K = $t.toSlateNode(e, j), {
          path: te,
          offset: O
        } = Ln.start(e, $t.findPath(e, K));
        return j.querySelector("[data-slate-leaf]") || (O = a), {
          path: te,
          offset: O
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var P = $t.toSlateNode(e, u), H = $t.findPath(e, P);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = Ok(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (Ok(t)) {
        if (Nc && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), h = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && h.startContainer instanceof HTMLTableRowElement) {
            let C = function(M) {
              return M.childElementCount > 0 ? C(M.children[0]) : M;
            };
            var y = d.startContainer, f = h.startContainer, g = C(y.children[d.startOffset]), x = C(f.children[h.startOffset]);
            c = 0, x.childNodes.length > 0 ? a = x.childNodes[0] : a = x, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, x instanceof HTMLElement ? l = x.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = h.endContainer, l = h.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = h.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        W9 && n6(a) || Nc ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Nc && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var L = $t.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!L)
      return null;
    var E = Sk(a, u) || a === u && c < l, T = p ? L : $t.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: E ? "forward" : "backward"
    });
    if (!T)
      return null;
    var b = {
      anchor: L,
      focus: T
    };
    return Ct.isExpanded(b) && Ct.isForward(b) && si(u) && Ln.void(e, {
      at: b.focus,
      mode: "highest"
    }) && (b = Ln.unhangRange(e, b, {
      voids: !0
    })), b;
  }
}, a6 = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, l6 = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, u6 = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Kn = (e) => {
  var t = a6[e], n = l6[e], r = u6[e], o = t && vg(t), i = n && vg(n), s = r && vg(r);
  return (a) => !!(o && o(a) || Ek && i && i(a) || !Ek && s && s(a));
};
Kn("bold"), Kn("compose"), Kn("moveBackward"), Kn("moveForward"), Kn("deleteBackward"), Kn("deleteForward"), Kn("deleteLineBackward"), Kn("deleteLineForward"), Kn("deleteWordBackward"), Kn("deleteWordForward"), Kn("extendBackward"), Kn("extendForward"), Kn("extendLineBackward"), Kn("extendLineForward"), Kn("italic"), Kn("moveLineBackward"), Kn("moveLineForward"), Kn("moveWordBackward"), Kn("moveWordForward"), Kn("redo"), Kn("insertSoftBreak"), Kn("splitBlock"), Kn("transposeCharacter"), Kn("undo");
var c6 = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => OB(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, p6 = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class d6 extends Nu {
  constructor() {
    super(...arguments), Zl(this, "context", null), Zl(this, "manager", null), Zl(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, p6);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = c6(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Zl(d6, "contextType", $9);
var MB = {}, $0 = {}, W0 = {};
Object.defineProperty(W0, "__esModule", { value: !0 });
W0.default = m6;
var Dk = "html", Pk = "head", zc = "body", f6 = /<([a-zA-Z]+[0-9]?)/, Tk = /<head[^]*>/i, _k = /<body[^]*>/i, Ed = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Yv = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, Ak = typeof window == "object" && window.DOMParser;
if (typeof Ak == "function") {
  var h6 = new Ak(), g6 = "text/html";
  Yv = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), h6.parseFromString(e, g6);
  }, Ed = Yv;
}
if (typeof document == "object" && document.implementation) {
  var Uc = document.implementation.createHTMLDocument();
  Ed = function(e, t) {
    if (t) {
      var n = Uc.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Uc;
    }
    return Uc.documentElement.innerHTML = e, Uc;
  };
}
var $c = typeof document == "object" && document.createElement("template"), Jv;
$c && $c.content && (Jv = function(e) {
  return $c.innerHTML = e, $c.content.childNodes;
});
function m6(e) {
  var t, n, r = e.match(f6), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case Dk: {
      var i = Yv(e);
      if (!Tk.test(e)) {
        var s = i.querySelector(Pk);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!_k.test(e)) {
        var s = i.querySelector(zc);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(Dk);
    }
    case Pk:
    case zc: {
      var a = Ed(e).querySelectorAll(o);
      return _k.test(e) && Tk.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (Jv)
        return Jv(e);
      var s = Ed(e, zc).querySelector(zc);
      return s.childNodes;
    }
  }
}
var lf = {}, H0 = {}, V0 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(V0);
var Tt = {}, ks = _n && _n.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), ql = _n && _n.__assign || function() {
  return ql = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, ql.apply(this, arguments);
};
Object.defineProperty(Tt, "__esModule", { value: !0 });
Tt.cloneNode = Tt.hasChildren = Tt.isDocument = Tt.isDirective = Tt.isComment = Tt.isText = Tt.isCDATA = Tt.isTag = Tt.Element = Tt.Document = Tt.CDATA = Tt.NodeWithChildren = Tt.ProcessingInstruction = Tt.Comment = Tt.Text = Tt.DataNode = Tt.Node = void 0;
var ho = V0, Z0 = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), q0(this, t);
    }, e;
  }()
);
Tt.Node = Z0;
var uf = (
  /** @class */
  function(e) {
    ks(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Z0)
);
Tt.DataNode = uf;
var SB = (
  /** @class */
  function(e) {
    ks(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ho.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uf)
);
Tt.Text = SB;
var DB = (
  /** @class */
  function(e) {
    ks(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ho.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uf)
);
Tt.Comment = DB;
var PB = (
  /** @class */
  function(e) {
    ks(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = ho.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uf)
);
Tt.ProcessingInstruction = PB;
var cf = (
  /** @class */
  function(e) {
    ks(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Z0)
);
Tt.NodeWithChildren = cf;
var TB = (
  /** @class */
  function(e) {
    ks(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ho.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cf)
);
Tt.CDATA = TB;
var _B = (
  /** @class */
  function(e) {
    ks(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ho.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cf)
);
Tt.Document = _B;
var AB = (
  /** @class */
  function(e) {
    ks(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? ho.ElementType.Script : n === "style" ? ho.ElementType.Style : ho.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cf)
);
Tt.Element = AB;
function BB(e) {
  return (0, ho.isTag)(e);
}
Tt.isTag = BB;
function IB(e) {
  return e.type === ho.ElementType.CDATA;
}
Tt.isCDATA = IB;
function jB(e) {
  return e.type === ho.ElementType.Text;
}
Tt.isText = jB;
function RB(e) {
  return e.type === ho.ElementType.Comment;
}
Tt.isComment = RB;
function NB(e) {
  return e.type === ho.ElementType.Directive;
}
Tt.isDirective = NB;
function FB(e) {
  return e.type === ho.ElementType.Root;
}
Tt.isDocument = FB;
function v6(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Tt.hasChildren = v6;
function q0(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (jB(e))
    n = new SB(e.data);
  else if (RB(e))
    n = new DB(e.data);
  else if (BB(e)) {
    var r = t ? Lg(e.children) : [], o = new AB(e.name, ql({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = ql({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = ql({}, e["x-attribsPrefix"])), n = o;
  } else if (IB(e)) {
    var r = t ? Lg(e.children) : [], i = new TB(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (FB(e)) {
    var r = t ? Lg(e.children) : [], s = new _B(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (NB(e)) {
    var a = new PB(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Tt.cloneNode = q0;
function Lg(e) {
  for (var t = e.map(function(r) {
    return q0(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = _n && _n.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = _n && _n.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = V0, o = Tt;
  n(Tt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(H0);
var zB = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(zB);
Object.defineProperty(lf, "__esModule", { value: !0 });
lf.formatAttributes = UB;
lf.formatDOM = $B;
var Wc = H0, y6 = zB;
function b6(e) {
  return y6.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function UB(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function w6(e) {
  e = e.toLowerCase();
  var t = b6(e);
  return t || e;
}
function $B(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = w6(a.nodeName);
        o = new Wc.Element(l, UB(a.attributes)), o.children = $B(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Wc.Text(a.nodeValue);
        break;
      case 8:
        o = new Wc.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Wc.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var C6 = _n && _n.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty($0, "__esModule", { value: !0 });
$0.default = k6;
var x6 = C6(W0), E6 = lf, L6 = /<(![a-zA-Z\s]+)>/;
function k6(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(L6), n = t ? t[1] : void 0;
  return (0, E6.formatDOM)((0, x6.default)(e), null, n);
}
var pf = {}, Go = {}, df = {}, O6 = 0;
df.SAME = O6;
var M6 = 1;
df.CAMELCASE = M6;
df.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const WB = 0, Os = 1, ff = 2, hf = 3, G0 = 4, HB = 5, VB = 6;
function S6(e) {
  return Wr.hasOwnProperty(e) ? Wr[e] : null;
}
function to(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === ff || t === hf || t === G0, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const Wr = {}, D6 = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
D6.forEach((e) => {
  Wr[e] = new to(
    e,
    WB,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Wr[e] = new to(
    e,
    Os,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Wr[e] = new to(
    e,
    ff,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Wr[e] = new to(
    e,
    ff,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Wr[e] = new to(
    e,
    hf,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Wr[e] = new to(
    e,
    hf,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Wr[e] = new to(
    e,
    G0,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Wr[e] = new to(
    e,
    VB,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Wr[e] = new to(
    e,
    HB,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const X0 = /[\-\:]([a-z])/g, Y0 = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(X0, Y0);
  Wr[t] = new to(
    t,
    Os,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(X0, Y0);
  Wr[t] = new to(
    t,
    Os,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(X0, Y0);
  Wr[t] = new to(
    t,
    Os,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Wr[e] = new to(
    e,
    Os,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const P6 = "xlinkHref";
Wr[P6] = new to(
  "xlinkHref",
  Os,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Wr[e] = new to(
    e,
    Os,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: T6,
  SAME: _6,
  possibleStandardNames: Bk
} = df, A6 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", B6 = A6 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", I6 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + B6 + "]*$")
), j6 = Object.keys(
  Bk
).reduce((e, t) => {
  const n = Bk[t];
  return n === _6 ? e[t] = t : n === T6 ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Go.BOOLEAN = hf;
Go.BOOLEANISH_STRING = ff;
Go.NUMERIC = HB;
Go.OVERLOADED_BOOLEAN = G0;
Go.POSITIVE_NUMERIC = VB;
Go.RESERVED = WB;
Go.STRING = Os;
Go.getPropertyInfo = S6;
Go.isCustomAttribute = I6;
Go.possibleStandardNames = j6;
var J0 = {}, K0 = {}, Ik = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, R6 = /\n/g, N6 = /^\s*/, F6 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, z6 = /^:\s*/, U6 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, $6 = /^[;\s]*/, W6 = /^\s+|\s+$/g, H6 = `
`, jk = "/", Rk = "*", oa = "", V6 = "comment", Z6 = "declaration", q6 = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(y) {
    var f = y.match(R6);
    f && (n += f.length);
    var g = y.lastIndexOf(H6);
    r = ~g ? y.length - g : r + y.length;
  }
  function i() {
    var y = { line: n, column: r };
    return function(f) {
      return f.position = new s(y), u(), f;
    };
  }
  function s(y) {
    this.start = y, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(y) {
    var f = new Error(
      t.source + ":" + n + ":" + r + ": " + y
    );
    if (f.reason = y, f.filename = t.source, f.line = n, f.column = r, f.source = e, !t.silent) throw f;
  }
  function l(y) {
    var f = y.exec(e);
    if (f) {
      var g = f[0];
      return o(g), e = e.slice(g.length), f;
    }
  }
  function u() {
    l(N6);
  }
  function c(y) {
    var f;
    for (y = y || []; f = p(); )
      f !== !1 && y.push(f);
    return y;
  }
  function p() {
    var y = i();
    if (!(jk != e.charAt(0) || Rk != e.charAt(1))) {
      for (var f = 2; oa != e.charAt(f) && (Rk != e.charAt(f) || jk != e.charAt(f + 1)); )
        ++f;
      if (f += 2, oa === e.charAt(f - 1))
        return a("End of comment missing");
      var g = e.slice(2, f - 2);
      return r += 2, o(g), e = e.slice(f), r += 2, y({
        type: V6,
        comment: g
      });
    }
  }
  function d() {
    var y = i(), f = l(F6);
    if (f) {
      if (p(), !l(z6)) return a("property missing ':'");
      var g = l(U6), x = y({
        type: Z6,
        property: Nk(f[0].replace(Ik, oa)),
        value: g ? Nk(g[0].replace(Ik, oa)) : oa
      });
      return l($6), x;
    }
  }
  function h() {
    var y = [];
    c(y);
    for (var f; f = d(); )
      f !== !1 && (y.push(f), c(y));
    return y;
  }
  return u(), h();
};
function Nk(e) {
  return e ? e.replace(W6, oa) : oa;
}
var G6 = _n && _n.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(K0, "__esModule", { value: !0 });
K0.default = Y6;
var X6 = G6(q6);
function Y6(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, X6.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var gf = {};
Object.defineProperty(gf, "__esModule", { value: !0 });
gf.camelCase = void 0;
var J6 = /^--[a-zA-Z0-9-]+$/, K6 = /-([a-z])/g, Q6 = /^[^-]+$/, e8 = /^-(webkit|moz|ms|o|khtml)-/, t8 = /^-(ms)-/, n8 = function(e) {
  return !e || Q6.test(e) || J6.test(e);
}, r8 = function(e, t) {
  return t.toUpperCase();
}, Fk = function(e, t) {
  return "".concat(t, "-");
}, o8 = function(e, t) {
  return t === void 0 && (t = {}), n8(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(t8, Fk) : e = e.replace(e8, Fk), e.replace(K6, r8));
};
gf.camelCase = o8;
var i8 = _n && _n.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, s8 = i8(K0), a8 = gf;
function Kv(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, s8.default)(e, function(r, o) {
    r && o && (n[(0, a8.camelCase)(r, t)] = o);
  }), n;
}
Kv.default = Kv;
var l8 = Kv;
(function(e) {
  var t = _n && _n.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Ae, r = t(l8), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(J0);
Object.defineProperty(pf, "__esModule", { value: !0 });
pf.default = d8;
var Al = Go, zk = J0, u8 = ["checked", "value"], c8 = ["input", "select", "textarea"], p8 = {
  reset: !0,
  submit: !0
};
function d8(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && p8[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Al.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = Uk(s);
    if (a) {
      var l = (0, Al.getPropertyInfo)(a);
      switch (u8.includes(a) && c8.includes(t) && !r && (a = Uk("default" + s)), n[a] = i, l && l.type) {
        case Al.BOOLEAN:
          n[a] = !0;
          break;
        case Al.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    zk.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, zk.setStyleProp)(e.style, n), n;
}
function Uk(e) {
  return Al.possibleStandardNames[e];
}
var Q0 = {}, f8 = _n && _n.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Q0, "__esModule", { value: !0 });
Q0.default = ZB;
var kg = Ae, h8 = f8(pf), Gl = J0, g8 = {
  cloneElement: kg.cloneElement,
  createElement: kg.createElement,
  isValidElement: kg.isValidElement
};
function ZB(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Gl.returnFirstArg, i = t.library || g8, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var h = !p.data.trim().length;
      if (h && p.parent && !(0, Gl.canTextBeChildOfNode)(p.parent) || t.trim && h)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var y = p, f = {};
    m8(y) ? ((0, Gl.setStyleProp)(y.attribs.style, y.attribs), f = y.attribs) : y.attribs && (f = (0, h8.default)(y.attribs, y.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (f.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? f.defaultValue = p.children[0].data : p.children && p.children.length && (g = ZB(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (f.key = c), n.push(o(a(p.name, f, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function m8(e) {
  return Gl.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Gl.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = _n && _n.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t($0);
  e.htmlToDOM = n.default;
  var r = t(pf);
  e.attributesToProps = r.default;
  var o = t(Q0);
  e.domToReact = o.default;
  var i = H0;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(MB);
const v8 = /* @__PURE__ */ BH(MB);
v8.default;
qe({});
qe({});
qe({});
var Mr = {}, eb = {}, Fu = {}, zu = {}, qB = "Expected a function", $k = NaN, y8 = "[object Symbol]", b8 = /^\s+|\s+$/g, w8 = /^[-+]0x[0-9a-f]+$/i, C8 = /^0b[01]+$/i, x8 = /^0o[0-7]+$/i, E8 = parseInt, L8 = typeof _n == "object" && _n && _n.Object === Object && _n, k8 = typeof self == "object" && self && self.Object === Object && self, O8 = L8 || k8 || Function("return this")(), M8 = Object.prototype, S8 = M8.toString, D8 = Math.max, P8 = Math.min, Og = function() {
  return O8.Date.now();
};
function T8(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(qB);
  t = Wk(t) || 0, Ld(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? D8(Wk(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function h(C) {
    var M = r, S = o;
    return r = o = void 0, u = C, s = e.apply(S, M), s;
  }
  function y(C) {
    return u = C, a = setTimeout(x, t), c ? h(C) : s;
  }
  function f(C) {
    var M = C - l, S = C - u, F = t - M;
    return p ? P8(F, i - S) : F;
  }
  function g(C) {
    var M = C - l, S = C - u;
    return l === void 0 || M >= t || M < 0 || p && S >= i;
  }
  function x() {
    var C = Og();
    if (g(C))
      return L(C);
    a = setTimeout(x, f(C));
  }
  function L(C) {
    return a = void 0, d && r ? h(C) : (r = o = void 0, s);
  }
  function E() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function T() {
    return a === void 0 ? s : L(Og());
  }
  function b() {
    var C = Og(), M = g(C);
    if (r = arguments, o = this, l = C, M) {
      if (a === void 0)
        return y(l);
      if (p)
        return a = setTimeout(x, t), h(l);
    }
    return a === void 0 && (a = setTimeout(x, t)), s;
  }
  return b.cancel = E, b.flush = T, b;
}
function _8(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(qB);
  return Ld(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), T8(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Ld(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function A8(e) {
  return !!e && typeof e == "object";
}
function B8(e) {
  return typeof e == "symbol" || A8(e) && S8.call(e) == y8;
}
function Wk(e) {
  if (typeof e == "number")
    return e;
  if (B8(e))
    return $k;
  if (Ld(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Ld(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(b8, "");
  var n = C8.test(e);
  return n || x8.test(e) ? E8(e.slice(2), n ? 2 : 8) : w8.test(e) ? $k : +e;
}
var I8 = _8, Uu = {};
Object.defineProperty(Uu, "__esModule", {
  value: !0
});
Uu.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Qp.has(t) || Qp.set(t, /* @__PURE__ */ new Set());
  var o = Qp.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Uu.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Qp.get(t).delete(n.name || t);
};
var Qp = /* @__PURE__ */ new Map();
Object.defineProperty(zu, "__esModule", {
  value: !0
});
var j8 = I8, R8 = F8(j8), N8 = Uu;
function F8(e) {
  return e && e.__esModule ? e : { default: e };
}
var z8 = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, R8.default)(e, t);
}, fr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = z8(function(r) {
        fr.scrollHandler(e);
      }, t);
      fr.scrollSpyContainers.push(e), (0, N8.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return fr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = fr.scrollSpyContainers[fr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(fr.currentPositionX(e), fr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    fr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = fr.scrollSpyContainers[fr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(fr.currentPositionX(t), fr.currentPositionY(t));
  },
  updateStates: function() {
    fr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    fr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), fr.spySetState && fr.spySetState.length && fr.spySetState.indexOf(e) > -1 && fr.spySetState.splice(fr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", fr.scrollHandler);
  },
  update: function() {
    return fr.scrollSpyContainers.forEach(function(e) {
      return fr.scrollHandler(e);
    });
  }
};
zu.default = fr;
var Xa = {}, $u = {};
Object.defineProperty($u, "__esModule", {
  value: !0
});
var U8 = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, $8 = function() {
  return window.location.hash.replace(/^#/, "");
}, W8 = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, H8 = function(e) {
  return getComputedStyle(e).position !== "static";
}, Mg = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, V8 = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (H8(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Mg(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return Mg(t, a).offsetTop - Mg(e, a).offsetTop;
};
$u.default = {
  updateHash: U8,
  getHash: $8,
  filterElementInContainer: W8,
  scrollOffset: V8
};
var mf = {}, tb = {};
Object.defineProperty(tb, "__esModule", {
  value: !0
});
tb.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var nb = {};
Object.defineProperty(nb, "__esModule", {
  value: !0
});
var Z8 = Uu, q8 = ["mousedown", "mousewheel", "touchmove", "keydown"];
nb.default = {
  subscribe: function(e) {
    return typeof document < "u" && q8.forEach(function(t) {
      return (0, Z8.addPassiveEventListener)(document, t, e);
    });
  }
};
var Wu = {};
Object.defineProperty(Wu, "__esModule", {
  value: !0
});
var Qv = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Qv.registered[e] = t;
    },
    remove: function(e) {
      Qv.registered[e] = null;
    }
  }
};
Wu.default = Qv;
Object.defineProperty(mf, "__esModule", {
  value: !0
});
var G8 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, X8 = $u;
vf(X8);
var Y8 = tb, Hk = vf(Y8), J8 = nb, K8 = vf(J8), Q8 = Wu, ti = vf(Q8);
function vf(e) {
  return e && e.__esModule ? e : { default: e };
}
var GB = function(e) {
  return Hk.default[e.smooth] || Hk.default.defaultEasing;
}, e5 = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, t5 = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, ey = function() {
  return t5() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), XB = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, YB = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, JB = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, n5 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, r5 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, o5 = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    ti.default.registered.end && ti.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    ey.call(window, i);
    return;
  }
  ti.default.registered.end && ti.default.registered.end(o.to, o.target, o.currentPosition);
}, rb = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Hu = function(e, t, n, r) {
  t.data = t.data || XB(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (K8.default.subscribe(o), rb(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? YB(t) : JB(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    ti.default.registered.end && ti.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = e5(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = GB(t), s = o5.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      ti.default.registered.begin && ti.default.registered.begin(t.data.to, t.data.target), ey.call(window, s);
    }, t.delay);
    return;
  }
  ti.default.registered.begin && ti.default.registered.begin(t.data.to, t.data.target), ey.call(window, s);
}, yf = function(e) {
  return e = G8({}, e), e.data = e.data || XB(), e.absolute = !0, e;
}, i5 = function(e) {
  Hu(0, yf(e));
}, s5 = function(e, t) {
  Hu(e, yf(t));
}, a5 = function(e) {
  e = yf(e), rb(e), Hu(e.horizontal ? n5(e) : r5(e), e);
}, l5 = function(e, t) {
  t = yf(t), rb(t);
  var n = t.horizontal ? YB(t) : JB(t);
  Hu(e + n, t);
};
mf.default = {
  animateTopScroll: Hu,
  getAnimationType: GB,
  scrollToTop: i5,
  scrollToBottom: a5,
  scrollTo: s5,
  scrollMore: l5
};
Object.defineProperty(Xa, "__esModule", {
  value: !0
});
var u5 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, c5 = $u, p5 = ob(c5), d5 = mf, f5 = ob(d5), h5 = Wu, Hc = ob(h5);
function ob(e) {
  return e && e.__esModule ? e : { default: e };
}
var Vc = {}, Vk = void 0;
Xa.default = {
  unmount: function() {
    Vc = {};
  },
  register: function(e, t) {
    Vc[e] = t;
  },
  unregister: function(e) {
    delete Vc[e];
  },
  get: function(e) {
    return Vc[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return Vk = e;
  },
  getActiveLink: function() {
    return Vk;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = u5({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = p5.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      Hc.default.registered.begin && Hc.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, Hc.default.registered.end && Hc.default.registered.end(e, n);
      return;
    }
    f5.default.animateTopScroll(a, t, e, n);
  }
};
var ty = { exports: {} }, Sg = { exports: {} }, ln = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Zk;
function g5() {
  if (Zk) return ln;
  Zk = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
  function E(b) {
    if (typeof b == "object" && b !== null) {
      var C = b.$$typeof;
      switch (C) {
        case t:
          switch (b = b.type, b) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case a:
                case c:
                case y:
                case h:
                case s:
                  return b;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function T(b) {
    return E(b) === u;
  }
  return ln.AsyncMode = l, ln.ConcurrentMode = u, ln.ContextConsumer = a, ln.ContextProvider = s, ln.Element = t, ln.ForwardRef = c, ln.Fragment = r, ln.Lazy = y, ln.Memo = h, ln.Portal = n, ln.Profiler = i, ln.StrictMode = o, ln.Suspense = p, ln.isAsyncMode = function(b) {
    return T(b) || E(b) === l;
  }, ln.isConcurrentMode = T, ln.isContextConsumer = function(b) {
    return E(b) === a;
  }, ln.isContextProvider = function(b) {
    return E(b) === s;
  }, ln.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === t;
  }, ln.isForwardRef = function(b) {
    return E(b) === c;
  }, ln.isFragment = function(b) {
    return E(b) === r;
  }, ln.isLazy = function(b) {
    return E(b) === y;
  }, ln.isMemo = function(b) {
    return E(b) === h;
  }, ln.isPortal = function(b) {
    return E(b) === n;
  }, ln.isProfiler = function(b) {
    return E(b) === i;
  }, ln.isStrictMode = function(b) {
    return E(b) === o;
  }, ln.isSuspense = function(b) {
    return E(b) === p;
  }, ln.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === r || b === u || b === i || b === o || b === p || b === d || typeof b == "object" && b !== null && (b.$$typeof === y || b.$$typeof === h || b.$$typeof === s || b.$$typeof === a || b.$$typeof === c || b.$$typeof === g || b.$$typeof === x || b.$$typeof === L || b.$$typeof === f);
  }, ln.typeOf = E, ln;
}
var wn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qk;
function m5() {
  return qk || (qk = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
    function E(A) {
      return typeof A == "string" || typeof A == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      A === r || A === u || A === i || A === o || A === p || A === d || typeof A == "object" && A !== null && (A.$$typeof === y || A.$$typeof === h || A.$$typeof === s || A.$$typeof === a || A.$$typeof === c || A.$$typeof === g || A.$$typeof === x || A.$$typeof === L || A.$$typeof === f);
    }
    function T(A) {
      if (typeof A == "object" && A !== null) {
        var ae = A.$$typeof;
        switch (ae) {
          case t:
            var ce = A.type;
            switch (ce) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ce;
              default:
                var ue = ce && ce.$$typeof;
                switch (ue) {
                  case a:
                  case c:
                  case y:
                  case h:
                  case s:
                    return ue;
                  default:
                    return ae;
                }
            }
          case n:
            return ae;
        }
      }
    }
    var b = l, C = u, M = a, S = s, F = t, D = c, Z = r, U = y, $ = h, N = n, V = i, J = o, j = p, K = !1;
    function te(A) {
      return K || (K = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), O(A) || T(A) === l;
    }
    function O(A) {
      return T(A) === u;
    }
    function P(A) {
      return T(A) === a;
    }
    function H(A) {
      return T(A) === s;
    }
    function I(A) {
      return typeof A == "object" && A !== null && A.$$typeof === t;
    }
    function W(A) {
      return T(A) === c;
    }
    function X(A) {
      return T(A) === r;
    }
    function w(A) {
      return T(A) === y;
    }
    function R(A) {
      return T(A) === h;
    }
    function z(A) {
      return T(A) === n;
    }
    function _(A) {
      return T(A) === i;
    }
    function Y(A) {
      return T(A) === o;
    }
    function Q(A) {
      return T(A) === p;
    }
    wn.AsyncMode = b, wn.ConcurrentMode = C, wn.ContextConsumer = M, wn.ContextProvider = S, wn.Element = F, wn.ForwardRef = D, wn.Fragment = Z, wn.Lazy = U, wn.Memo = $, wn.Portal = N, wn.Profiler = V, wn.StrictMode = J, wn.Suspense = j, wn.isAsyncMode = te, wn.isConcurrentMode = O, wn.isContextConsumer = P, wn.isContextProvider = H, wn.isElement = I, wn.isForwardRef = W, wn.isFragment = X, wn.isLazy = w, wn.isMemo = R, wn.isPortal = z, wn.isProfiler = _, wn.isStrictMode = Y, wn.isSuspense = Q, wn.isValidElementType = E, wn.typeOf = T;
  }()), wn;
}
var Gk;
function KB() {
  return Gk || (Gk = 1, process.env.NODE_ENV === "production" ? Sg.exports = g5() : Sg.exports = m5()), Sg.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Dg, Xk;
function v5() {
  if (Xk) return Dg;
  Xk = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Dg = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, Dg;
}
var Pg, Yk;
function ib() {
  if (Yk) return Pg;
  Yk = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Pg = e, Pg;
}
var Jk, Kk;
function QB() {
  return Kk || (Kk = 1, Jk = Function.call.bind(Object.prototype.hasOwnProperty)), Jk;
}
var Tg, Qk;
function y5() {
  if (Qk) return Tg;
  Qk = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = ib(), n = {}, r = QB();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (y) {
            p = y;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var h = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (h ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Tg = o, Tg;
}
var _g, eO;
function b5() {
  if (eO) return _g;
  eO = 1;
  var e = KB(), t = v5(), n = ib(), r = QB(), o = y5(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return _g = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(O) {
      var P = O && (u && O[u] || O[c]);
      if (typeof P == "function")
        return P;
    }
    var d = "<<anonymous>>", h = {
      array: x("array"),
      bigint: x("bigint"),
      bool: x("boolean"),
      func: x("function"),
      number: x("number"),
      object: x("object"),
      string: x("string"),
      symbol: x("symbol"),
      any: L(),
      arrayOf: E,
      element: T(),
      elementType: b(),
      instanceOf: C,
      node: D(),
      objectOf: S,
      oneOf: M,
      oneOfType: F,
      shape: U,
      exact: $
    };
    function y(O, P) {
      return O === P ? O !== 0 || 1 / O === 1 / P : O !== O && P !== P;
    }
    function f(O, P) {
      this.message = O, this.data = P && typeof P == "object" ? P : {}, this.stack = "";
    }
    f.prototype = Error.prototype;
    function g(O) {
      if (process.env.NODE_ENV !== "production")
        var P = {}, H = 0;
      function I(X, w, R, z, _, Y, Q) {
        if (z = z || d, Y = Y || R, Q !== n) {
          if (l) {
            var A = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw A.name = "Invariant Violation", A;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ae = z + ":" + R;
            !P[ae] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + Y + "` prop on `" + z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), P[ae] = !0, H++);
          }
        }
        return w[R] == null ? X ? w[R] === null ? new f("The " + _ + " `" + Y + "` is marked as required " + ("in `" + z + "`, but its value is `null`.")) : new f("The " + _ + " `" + Y + "` is marked as required in " + ("`" + z + "`, but its value is `undefined`.")) : null : O(w, R, z, _, Y);
      }
      var W = I.bind(null, !1);
      return W.isRequired = I.bind(null, !0), W;
    }
    function x(O) {
      function P(H, I, W, X, w, R) {
        var z = H[I], _ = J(z);
        if (_ !== O) {
          var Y = j(z);
          return new f(
            "Invalid " + X + " `" + w + "` of type " + ("`" + Y + "` supplied to `" + W + "`, expected ") + ("`" + O + "`."),
            { expectedType: O }
          );
        }
        return null;
      }
      return g(P);
    }
    function L() {
      return g(s);
    }
    function E(O) {
      function P(H, I, W, X, w) {
        if (typeof O != "function")
          return new f("Property `" + w + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var R = H[I];
        if (!Array.isArray(R)) {
          var z = J(R);
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected an array."));
        }
        for (var _ = 0; _ < R.length; _++) {
          var Y = O(R, _, W, X, w + "[" + _ + "]", n);
          if (Y instanceof Error)
            return Y;
        }
        return null;
      }
      return g(P);
    }
    function T() {
      function O(P, H, I, W, X) {
        var w = P[H];
        if (!a(w)) {
          var R = J(w);
          return new f("Invalid " + W + " `" + X + "` of type " + ("`" + R + "` supplied to `" + I + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(O);
    }
    function b() {
      function O(P, H, I, W, X) {
        var w = P[H];
        if (!e.isValidElementType(w)) {
          var R = J(w);
          return new f("Invalid " + W + " `" + X + "` of type " + ("`" + R + "` supplied to `" + I + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(O);
    }
    function C(O) {
      function P(H, I, W, X, w) {
        if (!(H[I] instanceof O)) {
          var R = O.name || d, z = te(H[I]);
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected ") + ("instance of `" + R + "`."));
        }
        return null;
      }
      return g(P);
    }
    function M(O) {
      if (!Array.isArray(O))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function P(H, I, W, X, w) {
        for (var R = H[I], z = 0; z < O.length; z++)
          if (y(R, O[z]))
            return null;
        var _ = JSON.stringify(O, function(Y, Q) {
          var A = j(Q);
          return A === "symbol" ? String(Q) : Q;
        });
        return new f("Invalid " + X + " `" + w + "` of value `" + String(R) + "` " + ("supplied to `" + W + "`, expected one of " + _ + "."));
      }
      return g(P);
    }
    function S(O) {
      function P(H, I, W, X, w) {
        if (typeof O != "function")
          return new f("Property `" + w + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected an object."));
        for (var _ in R)
          if (r(R, _)) {
            var Y = O(R, _, W, X, w + "." + _, n);
            if (Y instanceof Error)
              return Y;
          }
        return null;
      }
      return g(P);
    }
    function F(O) {
      if (!Array.isArray(O))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var P = 0; P < O.length; P++) {
        var H = O[P];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + K(H) + " at index " + P + "."
          ), s;
      }
      function I(W, X, w, R, z) {
        for (var _ = [], Y = 0; Y < O.length; Y++) {
          var Q = O[Y], A = Q(W, X, w, R, z, n);
          if (A == null)
            return null;
          A.data && r(A.data, "expectedType") && _.push(A.data.expectedType);
        }
        var ae = _.length > 0 ? ", expected one of type [" + _.join(", ") + "]" : "";
        return new f("Invalid " + R + " `" + z + "` supplied to " + ("`" + w + "`" + ae + "."));
      }
      return g(I);
    }
    function D() {
      function O(P, H, I, W, X) {
        return N(P[H]) ? null : new f("Invalid " + W + " `" + X + "` supplied to " + ("`" + I + "`, expected a ReactNode."));
      }
      return g(O);
    }
    function Z(O, P, H, I, W) {
      return new f(
        (O || "React class") + ": " + P + " type `" + H + "." + I + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function U(O) {
      function P(H, I, W, X, w) {
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type `" + z + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var _ in O) {
          var Y = O[_];
          if (typeof Y != "function")
            return Z(W, X, w, _, j(Y));
          var Q = Y(R, _, W, X, w + "." + _, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return g(P);
    }
    function $(O) {
      function P(H, I, W, X, w) {
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type `" + z + "` " + ("supplied to `" + W + "`, expected `object`."));
        var _ = t({}, H[I], O);
        for (var Y in _) {
          var Q = O[Y];
          if (r(O, Y) && typeof Q != "function")
            return Z(W, X, w, Y, j(Q));
          if (!Q)
            return new f(
              "Invalid " + X + " `" + w + "` key `" + Y + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(H[I], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(O), null, "  ")
            );
          var A = Q(R, Y, W, X, w + "." + Y, n);
          if (A)
            return A;
        }
        return null;
      }
      return g(P);
    }
    function N(O) {
      switch (typeof O) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !O;
        case "object":
          if (Array.isArray(O))
            return O.every(N);
          if (O === null || a(O))
            return !0;
          var P = p(O);
          if (P) {
            var H = P.call(O), I;
            if (P !== O.entries) {
              for (; !(I = H.next()).done; )
                if (!N(I.value))
                  return !1;
            } else
              for (; !(I = H.next()).done; ) {
                var W = I.value;
                if (W && !N(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function V(O, P) {
      return O === "symbol" ? !0 : P ? P["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && P instanceof Symbol : !1;
    }
    function J(O) {
      var P = typeof O;
      return Array.isArray(O) ? "array" : O instanceof RegExp ? "object" : V(P, O) ? "symbol" : P;
    }
    function j(O) {
      if (typeof O > "u" || O === null)
        return "" + O;
      var P = J(O);
      if (P === "object") {
        if (O instanceof Date)
          return "date";
        if (O instanceof RegExp)
          return "regexp";
      }
      return P;
    }
    function K(O) {
      var P = j(O);
      switch (P) {
        case "array":
        case "object":
          return "an " + P;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + P;
        default:
          return P;
      }
    }
    function te(O) {
      return !O.constructor || !O.constructor.name ? d : O.constructor.name;
    }
    return h.checkPropTypes = o, h.resetWarningCache = o.resetWarningCache, h.PropTypes = h, h;
  }, _g;
}
var Ag, tO;
function w5() {
  if (tO) return Ag;
  tO = 1;
  var e = ib();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Ag = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Ag;
}
if (process.env.NODE_ENV !== "production") {
  var C5 = KB(), x5 = !0;
  ty.exports = b5()(C5.isElement, x5);
} else
  ty.exports = w5()();
var bf = ty.exports, wf = {};
Object.defineProperty(wf, "__esModule", {
  value: !0
});
var E5 = $u, Bg = L5(E5);
function L5(e) {
  return e && e.__esModule ? e : { default: e };
}
var k5 = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Bg.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Bg.default.getHash() !== e && Bg.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
wf.default = k5;
Object.defineProperty(Fu, "__esModule", {
  value: !0
});
var Zc = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, O5 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), M5 = Ae, nO = Vu(M5), S5 = zu, qc = Vu(S5), D5 = Xa, P5 = Vu(D5), T5 = bf, Qn = Vu(T5), _5 = wf, qi = Vu(_5);
function Vu(e) {
  return e && e.__esModule ? e : { default: e };
}
function A5(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function B5(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function I5(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var rO = {
  to: Qn.default.string.isRequired,
  containerId: Qn.default.string,
  container: Qn.default.object,
  activeClass: Qn.default.string,
  activeStyle: Qn.default.object,
  spy: Qn.default.bool,
  horizontal: Qn.default.bool,
  smooth: Qn.default.oneOfType([Qn.default.bool, Qn.default.string]),
  offset: Qn.default.number,
  delay: Qn.default.number,
  isDynamic: Qn.default.bool,
  onClick: Qn.default.func,
  duration: Qn.default.oneOfType([Qn.default.number, Qn.default.func]),
  absolute: Qn.default.bool,
  onSetActive: Qn.default.func,
  onSetInactive: Qn.default.func,
  ignoreCancelEvents: Qn.default.bool,
  hashSpy: Qn.default.bool,
  saveHashHistory: Qn.default.bool,
  spyThrottle: Qn.default.number
};
Fu.default = function(e, t) {
  var n = t || P5.default, r = function(i) {
    I5(s, i);
    function s(a) {
      A5(this, s);
      var l = B5(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return O5(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          qc.default.isMounted(a) || qc.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (qi.default.isMounted() || qi.default.mount(n), qi.default.mapContainer(this.props.to, a)), qc.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        qc.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Zc({}, this.props.style, this.props.activeStyle) : l = Zc({}, this.props.style);
        var u = Zc({}, this.props);
        for (var c in rO)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, nO.default.createElement(e, u);
      }
    }]), s;
  }(nO.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, Zc({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(qi.default.isMounted() && !qi.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, h = void 0;
        if (u) {
          var y = 0, f = 0, g = 0;
          if (l.getBoundingClientRect) {
            var x = l.getBoundingClientRect();
            g = x.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var L = p.getBoundingClientRect();
            y = L.left - g + s, f = y + L.width;
          }
          var E = s - i.props.offset;
          d = E >= Math.floor(y) && E < Math.floor(f), h = E < Math.floor(y) || E >= Math.floor(f);
        } else {
          var T = 0, b = 0, C = 0;
          if (l.getBoundingClientRect) {
            var M = l.getBoundingClientRect();
            C = M.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var S = p.getBoundingClientRect();
            T = S.top - C + a, b = T + S.height;
          }
          var F = a - i.props.offset;
          d = F >= Math.floor(T) && F < Math.floor(b), h = F < Math.floor(T) || F >= Math.floor(b);
        }
        var D = n.getActiveLink();
        if (h) {
          if (c === D && n.setActiveLink(void 0), i.props.hashSpy && qi.default.getHash() === c) {
            var Z = i.props.saveHashHistory, U = Z === void 0 ? !1 : Z;
            qi.default.changeHash("", U);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (D !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, N = $ === void 0 ? !1 : $;
          i.props.hashSpy && qi.default.changeHash(c, N), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = rO, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(eb, "__esModule", {
  value: !0
});
var j5 = Ae, oO = eI(j5), R5 = Fu, N5 = eI(R5);
function eI(e) {
  return e && e.__esModule ? e : { default: e };
}
function F5(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function iO(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function z5(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var U5 = function(e) {
  z5(t, e);
  function t() {
    var n, r, o, i;
    F5(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = iO(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return oO.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), iO(o, i);
  }
  return t;
}(oO.default.Component);
eb.default = (0, N5.default)(U5);
var sb = {};
Object.defineProperty(sb, "__esModule", {
  value: !0
});
var $5 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), W5 = Ae, sO = tI(W5), H5 = Fu, V5 = tI(H5);
function tI(e) {
  return e && e.__esModule ? e : { default: e };
}
function Z5(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function q5(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function G5(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var X5 = function(e) {
  G5(t, e);
  function t() {
    return Z5(this, t), q5(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return $5(t, [{
    key: "render",
    value: function() {
      return sO.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(sO.default.Component);
sb.default = (0, V5.default)(X5);
var ab = {}, Cf = {};
Object.defineProperty(Cf, "__esModule", {
  value: !0
});
var Y5 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, J5 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), K5 = Ae, aO = xf(K5), Q5 = qa;
xf(Q5);
var e4 = Xa, lO = xf(e4), t4 = bf, uO = xf(t4);
function xf(e) {
  return e && e.__esModule ? e : { default: e };
}
function n4(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function r4(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function o4(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Cf.default = function(e) {
  var t = function(n) {
    o4(r, n);
    function r(o) {
      n4(this, r);
      var i = r4(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return J5(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        lO.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        lO.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return aO.default.createElement(e, Y5({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(aO.default.Component);
  return t.propTypes = {
    name: uO.default.string,
    id: uO.default.string
  }, t;
};
Object.defineProperty(ab, "__esModule", {
  value: !0
});
var cO = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, i4 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), s4 = Ae, pO = lb(s4), a4 = Cf, l4 = lb(a4), u4 = bf, dO = lb(u4);
function lb(e) {
  return e && e.__esModule ? e : { default: e };
}
function c4(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function p4(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function d4(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var nI = function(e) {
  d4(t, e);
  function t() {
    return c4(this, t), p4(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return i4(t, [{
    key: "render",
    value: function() {
      var n = this, r = cO({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, pO.default.createElement(
        "div",
        cO({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(pO.default.Component);
nI.propTypes = {
  name: dO.default.string,
  id: dO.default.string
};
ab.default = (0, l4.default)(nI);
var Ig = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, fO = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function hO(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function gO(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function mO(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Gc = Ae, Zs = zu, jg = Xa, yr = bf, Gi = wf, vO = {
  to: yr.string.isRequired,
  containerId: yr.string,
  container: yr.object,
  activeClass: yr.string,
  spy: yr.bool,
  smooth: yr.oneOfType([yr.bool, yr.string]),
  offset: yr.number,
  delay: yr.number,
  isDynamic: yr.bool,
  onClick: yr.func,
  duration: yr.oneOfType([yr.number, yr.func]),
  absolute: yr.bool,
  onSetActive: yr.func,
  onSetInactive: yr.func,
  ignoreCancelEvents: yr.bool,
  hashSpy: yr.bool,
  spyThrottle: yr.number
}, f4 = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || jg, r = function(i) {
      mO(s, i);
      function s(a) {
        hO(this, s);
        var l = gO(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return fO(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            Zs.isMounted(a) || Zs.mount(a, this.props.spyThrottle), this.props.hashSpy && (Gi.isMounted() || Gi.mount(n), Gi.mapContainer(this.props.to, a)), this.props.spy && Zs.addStateHandler(this.stateHandler), Zs.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Zs.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = Ig({}, this.props);
          for (var u in vO)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, Gc.createElement(e, l);
        }
      }]), s;
    }(Gc.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, Ig({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(Gi.isMounted() && !Gi.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var h = a.getBoundingClientRect();
            d = h.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var y = u.getBoundingClientRect();
            c = y.top - d + s, p = c + y.height;
          }
          var f = s - i.props.offset, g = f >= Math.floor(c) && f < Math.floor(p), x = f < Math.floor(c) || f >= Math.floor(p), L = n.getActiveLink();
          if (x)
            return l === L && n.setActiveLink(void 0), i.props.hashSpy && Gi.getHash() === l && Gi.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Zs.updateStates();
          if (g && L !== l)
            return n.setActiveLink(l), i.props.hashSpy && Gi.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Zs.updateStates();
        }
      };
    };
    return r.propTypes = vO, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      mO(r, n);
      function r(o) {
        hO(this, r);
        var i = gO(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return fO(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          jg.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          jg.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Gc.createElement(e, Ig({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Gc.Component);
    return t.propTypes = {
      name: yr.string,
      id: yr.string
    }, t;
  }
}, h4 = f4;
Object.defineProperty(Mr, "__esModule", {
  value: !0
});
Mr.Helpers = Mr.ScrollElement = Mr.ScrollLink = Mr.animateScroll = Mr.scrollSpy = Mr.Events = Mr.scroller = Mr.Element = Mr.Button = Mr.Link = void 0;
var g4 = eb, rI = fi(g4), m4 = sb, oI = fi(m4), v4 = ab, iI = fi(v4), y4 = Xa, sI = fi(y4), b4 = Wu, aI = fi(b4), w4 = zu, lI = fi(w4), C4 = mf, uI = fi(C4), x4 = Fu, cI = fi(x4), E4 = Cf, pI = fi(E4), L4 = h4, dI = fi(L4);
function fi(e) {
  return e && e.__esModule ? e : { default: e };
}
Mr.Link = rI.default;
Mr.Button = oI.default;
Mr.Element = iI.default;
Mr.scroller = sI.default;
Mr.Events = aI.default;
Mr.scrollSpy = lI.default;
Mr.animateScroll = uI.default;
Mr.ScrollLink = cI.default;
Mr.ScrollElement = pI.default;
Mr.Helpers = dI.default;
Mr.default = { Link: rI.default, Button: oI.default, Element: iI.default, scroller: sI.default, Events: aI.default, scrollSpy: lI.default, animateScroll: uI.default, ScrollLink: cI.default, ScrollElement: pI.default, Helpers: dI.default };
qe({});
qe({});
qe({});
let k4 = { data: "" }, O4 = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || k4, M4 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, S4 = /\/\*[^]*?\*\/|  +/g, yO = /\n+/g, ms = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? ms(s, i) : i + "{" + ms(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += ms(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ms.p ? ms.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ci = {}, fI = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + fI(e[n]);
    return t;
  }
  return e;
}, D4 = (e, t, n, r, o) => {
  let i = fI(e), s = Ci[i] || (Ci[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ci[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = M4.exec(u.replace(S4, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(yO, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(yO, " ").trim();
      return d[0];
    })(e);
    Ci[s] = ms(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Ci.g ? Ci.g : null;
  return n && (Ci.g = Ci[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ci[s], t, r, a), s;
}, P4 = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : ms(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function Ef(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return D4(n.unshift ? n.raw ? P4(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, O4(t.target), t.g, t.o, t.k);
}
let hI, ny, ry;
Ef.bind({ g: 1 });
let Ii = Ef.bind({ k: 1 });
function T4(e, t, n, r) {
  ms.p = t, hI = e, ny = n, ry = r;
}
function Ms(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: ny && ny() }, a), n.o = / *go\d+/.test(l), a.className = Ef.apply(n, r) + (l ? " " + l : ""), t && (a.ref = s);
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), ry && u[0] && ry(a), hI(u, a);
    }
    return t ? t(o) : o;
  };
}
var _4 = (e) => typeof e == "function", A4 = (e, t) => _4(e) ? e(t) : e, B4 = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), I4 = Ii`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, j4 = Ii`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, R4 = Ii`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, N4 = Ms("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${I4} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${j4} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${R4} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, F4 = Ii`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, z4 = Ms("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${F4} 1s linear infinite;
`, U4 = Ii`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, $4 = Ii`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, W4 = Ms("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${U4} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${$4} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, H4 = Ms("div")`
  position: absolute;
`, V4 = Ms("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Z4 = Ii`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, q4 = Ms("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Z4} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, G4 = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? He.createElement(q4, null, t) : t : n === "blank" ? null : He.createElement(V4, null, He.createElement(z4, { ...r }), n !== "loading" && He.createElement(H4, null, n === "error" ? He.createElement(N4, { ...r }) : He.createElement(W4, { ...r })));
}, X4 = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Y4 = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, J4 = "0%{opacity:0;} 100%{opacity:1;}", K4 = "0%{opacity:1;} 100%{opacity:0;}", Q4 = Ms("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, e7 = Ms("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, t7 = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = B4() ? [J4, K4] : [X4(n), Y4(n)];
  return { animation: t ? `${Ii(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ii(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
He.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? t7(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = He.createElement(G4, { toast: e }), s = He.createElement(e7, { ...e.ariaProps }, A4(e.message, e));
  return He.createElement(Q4, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : He.createElement(He.Fragment, null, i, s));
});
T4(He.createElement);
Ef`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
qe({});
var Wi = {};
Object.defineProperty(Wi, "__esModule", {
  value: !0
});
var n7 = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Rg = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, gI = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: n7 ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, ub = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Xc = 1; Xc < 20; Xc++)
  ub["f" + Xc] = 111 + Xc;
function Lf(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return mI(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return vI(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function r7(e, t) {
  return Lf(e, t);
}
function o7(e, t) {
  return Lf(e, { byKey: !0 }, t);
}
function mI(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Rg)
    r[Rg[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, h = d.endsWith("?") && d.length > 1;
      h && (d = d.slice(0, -1));
      var y = cb(d), f = Rg[y];
      if (d.length > 1 && !f && !gI[d] && !ub[y])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !f) && (n ? r.key = y : r.which = yI(d)), f && (r[f] = h ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function vI(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function yI(e) {
  e = cb(e);
  var t = ub[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function cb(e) {
  return e = e.toLowerCase(), e = gI[e] || e, e;
}
Wi.default = Lf;
var Ng = Wi.isHotkey = Lf;
Wi.isCodeHotkey = r7;
Wi.isKeyHotkey = o7;
Wi.parseHotkey = mI;
Wi.compareHotkey = vI;
Wi.toKeyCode = yI;
Wi.toKeyName = cb;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function bO(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Xr(e) {
  var t, n;
  return bO(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(bO(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var bI = Symbol.for("immer-nothing"), wO = Symbol.for("immer-draftable"), To = Symbol.for("immer-state"), i7 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function uo(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = i7[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Ua = Object.getPrototypeOf;
function xa(e) {
  return !!e && !!e[To];
}
function Ea(e) {
  var t;
  return e ? wI(e) || Array.isArray(e) || !!e[wO] || !!((t = e.constructor) != null && t[wO]) || Of(e) || Mf(e) : !1;
}
var s7 = Object.prototype.constructor.toString();
function wI(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Ua(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === s7;
}
function kd(e, t) {
  kf(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function kf(e) {
  const t = e[To];
  return t ? t.type_ : Array.isArray(e) ? 1 : Of(e) ? 2 : Mf(e) ? 3 : 0;
}
function oy(e, t) {
  return kf(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function CI(e, t, n) {
  const r = kf(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function a7(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Of(e) {
  return e instanceof Map;
}
function Mf(e) {
  return e instanceof Set;
}
function Qs(e) {
  return e.copy_ || e.base_;
}
function iy(e, t) {
  if (Of(e))
    return new Map(e);
  if (Mf(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = wI(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[To];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(Ua(e), r);
  } else {
    const r = Ua(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function pb(e, t = !1) {
  return Sf(e) || xa(e) || !Ea(e) || (kf(e) > 1 && (e.set = e.add = e.clear = e.delete = l7), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => pb(r, !0))), e;
}
function l7() {
  uo(2);
}
function Sf(e) {
  return Object.isFrozen(e);
}
var u7 = {};
function La(e) {
  const t = u7[e];
  return t || uo(0, e), t;
}
var mu;
function xI() {
  return mu;
}
function c7(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function CO(e, t) {
  t && (La("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function sy(e) {
  ay(e), e.drafts_.forEach(p7), e.drafts_ = null;
}
function ay(e) {
  e === mu && (mu = e.parent_);
}
function xO(e) {
  return mu = c7(mu, e);
}
function p7(e) {
  const t = e[To];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function EO(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[To].modified_ && (sy(t), uo(4)), Ea(e) && (e = Od(t, e), t.parent_ || Md(t, e)), t.patches_ && La("Patches").generateReplacementPatches_(
    n[To].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Od(t, n, []), sy(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== bI ? e : void 0;
}
function Od(e, t, n) {
  if (Sf(t))
    return t;
  const r = t[To];
  if (!r)
    return kd(
      t,
      (o, i) => LO(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Md(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), kd(
      i,
      (a, l) => LO(e, r, o, a, l, n, s)
    ), Md(e, o, !1), n && e.patches_ && La("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function LO(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && uo(5), xa(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !oy(t.assigned_, r) ? i.concat(r) : void 0, l = Od(e, o, a);
    if (CI(n, r, l), xa(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (Ea(o) && !Sf(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Od(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Md(e, o);
  }
}
function Md(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && pb(t, n);
}
function d7(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : xI(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = db;
  n && (o = [r], i = vu);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var db = {
  get(e, t) {
    if (t === To)
      return e;
    const n = Qs(e);
    if (!oy(n, t))
      return f7(e, n, t);
    const r = n[t];
    return e.finalized_ || !Ea(r) ? r : r === Fg(e.base_, t) ? (zg(e), e.copy_[t] = uy(r, e)) : r;
  },
  has(e, t) {
    return t in Qs(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Qs(e));
  },
  set(e, t, n) {
    const r = EI(Qs(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Fg(Qs(e), t), i = o == null ? void 0 : o[To];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (a7(n, o) && (n !== void 0 || oy(e.base_, t)))
        return !0;
      zg(e), ly(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Fg(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, zg(e), ly(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Qs(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    uo(11);
  },
  getPrototypeOf(e) {
    return Ua(e.base_);
  },
  setPrototypeOf() {
    uo(12);
  }
}, vu = {};
kd(db, (e, t) => {
  vu[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
vu.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && uo(13), vu.set.call(this, e, t, void 0);
};
vu.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && uo(14), db.set.call(this, e[0], t, n, e[0]);
};
function Fg(e, t) {
  const n = e[To];
  return (n ? Qs(n) : e)[t];
}
function f7(e, t, n) {
  var r;
  const o = EI(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function EI(e, t) {
  if (!(t in e))
    return;
  let n = Ua(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Ua(n);
  }
}
function ly(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && ly(e.parent_));
}
function zg(e) {
  e.copy_ || (e.copy_ = iy(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var h7 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && uo(6), r !== void 0 && typeof r != "function" && uo(7);
      let o;
      if (Ea(t)) {
        const i = xO(this), s = uy(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? sy(i) : ay(i);
        }
        return CO(i, r), EO(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === bI && (o = void 0), this.autoFreeze_ && pb(o, !0), r) {
          const i = [], s = [];
          La("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        uo(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Ea(e) || uo(8), xa(e) && (e = g7(e));
    const t = xO(this), n = uy(e, void 0);
    return n[To].isManual_ = !0, ay(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[To];
    (!n || !n.isManual_) && uo(9);
    const { scope_: r } = n;
    return CO(r, t), EO(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = La("Patches").applyPatches_;
    return xa(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function uy(e, t) {
  const n = Of(e) ? La("MapSet").proxyMap_(e, t) : Mf(e) ? La("MapSet").proxySet_(e, t) : d7(e, t);
  return (t ? t.scope_ : xI()).drafts_.push(n), n;
}
function g7(e) {
  return xa(e) || uo(10, e), LI(e);
}
function LI(e) {
  if (!Ea(e) || Sf(e))
    return e;
  const t = e[To];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = iy(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = iy(e, !0);
  return kd(n, (r, o) => {
    CI(n, r, LI(o));
  }), t && (t.finalized_ = !1), n;
}
var _o = new h7(), fb = _o.produce;
_o.produceWithPatches.bind(
  _o
);
_o.setAutoFreeze.bind(_o);
_o.setUseStrictShallowCopy.bind(_o);
_o.applyPatches.bind(_o);
var kO = _o.createDraft.bind(_o), OO = _o.finishDraft.bind(_o), Re = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Re.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Re.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Re.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Re.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Re.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Re.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Re.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Re.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Re.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Re.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Re.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Re.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Re.isAncestor(t, e) && !Re.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Re.equals(i, r) || Re.endsBefore(i, r) || Re.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (Re.equals(s, r) || Re.isAncestor(s, r))
          return null;
        Re.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        Re.equals(a, r) || Re.endsBefore(a, r) ? r[a.length - 1] -= 1 : Re.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Re.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Re.endsBefore(u, r) ? r[u.length - 1] += 1 : Re.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Re.equals(p, d))
          return r;
        if (Re.isAncestor(p, r) || Re.equals(p, r)) {
          var h = d.slice();
          return Re.endsBefore(p, d) && p.length < d.length && (h[p.length - 1] -= 1), h.concat(r.slice(p.length));
        } else Re.isSibling(p, d) && (Re.isAncestor(d, r) || Re.equals(d, r)) ? Re.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Re.endsBefore(d, r) || Re.equals(d, r) || Re.isAncestor(d, r) ? (Re.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Re.endsBefore(p, r) && (Re.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function yu(e) {
  "@babel/helpers - typeof";
  return yu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, yu(e);
}
function m7(e, t) {
  if (yu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (yu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function v7(e) {
  var t = m7(e, "string");
  return yu(t) === "symbol" ? t : String(t);
}
function Ya(e, t, n) {
  return t = v7(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function MO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ol(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MO(Object(n), !0).forEach(function(r) {
      Ya(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var y7 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = pt.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of xt.points(t))
          t[l] = Wn.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = pt.leaf(e, u), h = d.text.slice(0, c), y = d.text.slice(c);
      if (d.text = h + p + y, t)
        for (var [f, g] of xt.points(t))
          t[g] = Wn.transform(f, n);
      break;
    }
    case "merge_node": {
      var {
        path: x
      } = n, L = pt.get(e, x), E = Re.previous(x), T = pt.get(e, E), b = pt.parent(e, x), C = x[x.length - 1];
      if (Lr.isText(L) && Lr.isText(T))
        T.text += L.text;
      else if (!Lr.isText(L) && !Lr.isText(T))
        T.children.push(...L.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(x, "] to nodes of different interfaces: ").concat(wo.stringify(L), " ").concat(wo.stringify(T)));
      if (b.children.splice(C, 1), t)
        for (var [M, S] of xt.points(t))
          t[S] = Wn.transform(M, n);
      break;
    }
    case "move_node": {
      var {
        path: F,
        newPath: D
      } = n;
      if (Re.isAncestor(F, D))
        throw new Error("Cannot move a path [".concat(F, "] to new path [").concat(D, "] because the destination is inside itself."));
      var Z = pt.get(e, F), U = pt.parent(e, F), $ = F[F.length - 1];
      U.children.splice($, 1);
      var N = Re.transform(F, n), V = pt.get(e, Re.parent(N)), J = N[N.length - 1];
      if (V.children.splice(J, 0, Z), t)
        for (var [j, K] of xt.points(t))
          t[K] = Wn.transform(j, n);
      break;
    }
    case "remove_node": {
      var {
        path: te
      } = n, O = te[te.length - 1], P = pt.parent(e, te);
      if (P.children.splice(O, 1), t)
        for (var [H, I] of xt.points(t)) {
          var W = Wn.transform(H, n);
          if (t != null && W != null)
            t[I] = W;
          else {
            var X = void 0, w = void 0;
            for (var [R, z] of pt.texts(e))
              if (Re.compare(z, te) === -1)
                X = [R, z];
              else {
                w = [R, z];
                break;
              }
            var _ = !1;
            X && w && (Re.equals(w[1], te) ? _ = !Re.hasPrevious(w[1]) : _ = Re.common(X[1], te).length < Re.common(w[1], te).length), X && !_ ? (H.path = X[1], H.offset = X[0].text.length) : w ? (H.path = w[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: Y,
        offset: Q,
        text: A
      } = n;
      if (A.length === 0) break;
      var ae = pt.leaf(e, Y), ce = ae.text.slice(0, Q), ue = ae.text.slice(Q + A.length);
      if (ae.text = ce + ue, t)
        for (var [de, be] of xt.points(t))
          t[be] = Wn.transform(de, n);
      break;
    }
    case "set_node": {
      var {
        path: ve,
        properties: ge,
        newProperties: se
      } = n;
      if (ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var xe = pt.get(e, ve);
      for (var ne in se) {
        if (ne === "children" || ne === "text")
          throw new Error('Cannot set the "'.concat(ne, '" property of nodes!'));
        var Me = se[ne];
        Me == null ? delete xe[ne] : xe[ne] = Me;
      }
      for (var ee in ge)
        se.hasOwnProperty(ee) || delete xe[ee];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Ce
      } = n;
      if (Ce == null)
        t = Ce;
      else {
        if (t == null) {
          if (!xt.isRange(Ce))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(wo.stringify(Ce), " when there is no current selection."));
          t = Ol({}, Ce);
        }
        for (var Be in Ce) {
          var _e = Ce[Be];
          if (_e == null) {
            if (Be === "anchor" || Be === "focus")
              throw new Error('Cannot remove the "'.concat(Be, '" selection property'));
            delete t[Be];
          } else
            t[Be] = _e;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: $e,
        position: he,
        properties: Ge
      } = n;
      if ($e.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat($e, "] because the root node cannot be split."));
      var We = pt.get(e, $e), Ut = pt.parent(e, $e), ot = $e[$e.length - 1], st;
      if (Lr.isText(We)) {
        var Zt = We.text.slice(0, he), qt = We.text.slice(he);
        We.text = Zt, st = Ol(Ol({}, Ge), {}, {
          text: qt
        });
      } else {
        var Gt = We.children.slice(0, he), Xt = We.children.slice(he);
        We.children = Gt, st = Ol(Ol({}, Ge), {}, {
          children: Xt
        });
      }
      if (Ut.children.splice(ot + 1, 0, st), t)
        for (var [et, bt] of xt.points(t))
          t[bt] = Wn.transform(et, n);
      break;
    }
  }
  return t;
}, b7 = {
  transform(e, t) {
    e.children = kO(e.children);
    var n = e.selection && kO(e.selection);
    try {
      n = y7(e, n, t);
    } finally {
      e.children = OO(e.children), n ? e.selection = xa(n) ? OO(n) : n : e.selection = null;
    }
  }
}, w7 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, C7 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, kI = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Xr(r) && Xr(o)) {
      if (!kI(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function x7(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function bu(e, t) {
  if (e == null) return {};
  var n = x7(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var E7 = ["anchor", "focus"];
function SO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function L7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SO(Object(n), !0).forEach(function(r) {
      Ya(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return xt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = xt.edges(e);
    return t;
  },
  equals(e, t) {
    return Wn.equals(e.anchor, t.anchor) && Wn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (xt.isRange(t)) {
      if (xt.includes(e, t.anchor) || xt.includes(e, t.focus))
        return !0;
      var [n, r] = xt.edges(e), [o, i] = xt.edges(t);
      return Wn.isBefore(n, o) && Wn.isAfter(r, i);
    }
    var [s, a] = xt.edges(e), l = !1, u = !1;
    return Wn.isPoint(t) ? (l = Wn.compare(t, s) >= 0, u = Wn.compare(t, a) <= 0) : (l = Re.compare(t, s.path) >= 0, u = Re.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = bu(e, E7), [r, o] = xt.edges(e), [i, s] = xt.edges(t), a = Wn.isBefore(r, i) ? i : r, l = Wn.isBefore(o, s) ? o : s;
    return Wn.isBefore(l, a) ? null : L7({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Wn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Wn.equals(t, n);
  },
  isExpanded(e) {
    return !xt.isCollapsed(e);
  },
  isForward(e) {
    return !xt.isBackward(e);
  },
  isRange(e) {
    return Xr(e) && Wn.isPoint(e.anchor) && Wn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = xt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fb(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = xt.isCollapsed(r);
        xt.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? xt.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = Wn.transform(r.anchor, t, {
        affinity: i
      }), u = Wn.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, DO = (e) => Xr(e) && pt.isNodeList(e.children) && !kn.isEditor(e), Ti = {
  isAncestor(e) {
    return Xr(e) && pt.isNodeList(e.children);
  },
  isElement: DO,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Ti.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return DO(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, k7 = ["children"], O7 = ["text"], PO = /* @__PURE__ */ new WeakMap(), pt = {
  ancestor(e, t) {
    var n = pt.get(e, t);
    if (Lr.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(wo.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Re.ancestors(t, n)) {
        var o = pt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Lr.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(wo.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(wo.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = pt.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = pt.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Re.common(t, n), o = pt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = pt.get(e, t);
    if (kn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(wo.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of pt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of pt.nodes(e, t))
        Ti.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Ti.isAncestor(e)) {
      var t = bu(e, k7);
      return t;
    } else {
      var t = bu(e, O7);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = pt.get(e, n); r && !(Lr.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Lr.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(wo.stringify(e)));
    var n = fb({
      children: e.children
    }, (r) => {
      var [o, i] = xt.edges(t), s = pt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, h] = d;
          return !xt.includes(t, h);
        }
      });
      for (var [, a] of s) {
        if (!xt.includes(t, a)) {
          var l = pt.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (Re.equals(a, i.path)) {
          var c = pt.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (Re.equals(a, o.path)) {
          var p = pt.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      kn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Lr.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(wo.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Lr.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Lr.isText(e) || Ti.isElement(e) || kn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = PO.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => pt.isNode(r));
    return PO.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = pt.get(e, n); r && !(Lr.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = pt.get(e, t);
    if (!Lr.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(wo.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Re.levels(t, n)) {
        var o = pt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Ti.isElement(e) && Ti.isElementProps(t) && Ti.matches(e, t) || Lr.isText(e) && Lr.isTextProps(t) && Lr.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? Re.isBefore(a, i) : Re.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Lr.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          Re.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = pt.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = Re.next(a);
          if (pt.has(e, c)) {
            a = c, l = pt.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = Re.previous(a);
          a = p, l = pt.get(e, a);
          continue;
        }
        a = Re.parent(a), l = pt.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Re.parent(t), r = pt.get(e, n);
    if (Lr.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Lr.isText(e) ? e.text : e.children.map(pt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of pt.nodes(e, t))
        Lr.isText(n) && (yield [n, r]);
    }();
  }
};
function TO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function er(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TO(Object(n), !0).forEach(function(r) {
      Ya(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bl = {
  isNodeOperation(e) {
    return Bl.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Xr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Re.isPath(e.path) && pt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Re.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Re.isPath(e.path) && Xr(e.properties);
      case "move_node":
        return Re.isPath(e.path) && Re.isPath(e.newPath);
      case "remove_node":
        return Re.isPath(e.path) && pt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Re.isPath(e.path);
      case "set_node":
        return Re.isPath(e.path) && Xr(e.properties) && Xr(e.newProperties);
      case "set_selection":
        return e.properties === null && xt.isRange(e.newProperties) || e.newProperties === null && xt.isRange(e.properties) || Xr(e.properties) && Xr(e.newProperties);
      case "split_node":
        return Re.isPath(e.path) && typeof e.position == "number" && Xr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Bl.isOperation(t));
  },
  isSelectionOperation(e) {
    return Bl.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Bl.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return er(er({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return er(er({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return er(er({}, e), {}, {
          type: "split_node",
          path: Re.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Re.equals(t, n))
          return e;
        if (Re.isSibling(n, t))
          return er(er({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Re.transform(n, e), o = Re.transform(Re.next(n), e);
        return er(er({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return er(er({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return er(er({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return er(er({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? er(er({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? er(er({}, e), {}, {
          properties: null,
          newProperties: a
        }) : er(er({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return er(er({}, e), {}, {
          type: "merge_node",
          path: Re.next(e.path)
        });
    }
  }
}, _O = /* @__PURE__ */ new WeakMap(), M7 = (e) => {
  var t = _O.get(e);
  if (t !== void 0)
    return t;
  if (!Xr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Xr(e.marks)) && (e.selection === null || xt.isRange(e.selection)) && pt.isNodeList(e.children) && Bl.isOperationList(e.operations);
  return _O.set(e, n), n;
}, kn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return M7(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function AO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function BO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AO(Object(n), !0).forEach(function(r) {
      Ya(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wn = {
  compare(e, t) {
    var n = Re.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Wn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Wn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Re.equals(e.path, t.path);
  },
  isPoint(e) {
    return Xr(e) && typeof e.offset == "number" && Re.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fb(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Re.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Re.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Re.equals(t.path, i) && (r.offset += t.position), r.path = Re.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Re.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Re.equals(t.path, i) || Re.isAncestor(t.path, i))
            return null;
          r.path = Re.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Re.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = Re.transform(i, t, BO(BO({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Re.transform(i, t, n);
          break;
        }
      }
    });
  }
}, IO = void 0, wo = {
  setScrubber(e) {
    IO = e;
  },
  stringify(e) {
    return JSON.stringify(e, IO);
  }
}, S7 = ["text"], D7 = ["anchor", "focus"];
function jO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jO(Object(n), !0).forEach(function(r) {
      Ya(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Lr = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = bu(i, S7);
      return s;
    }
    return kI(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Xr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Lr.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [xi({}, e)];
    for (var r of t) {
      var o = bu(r, D7), [i, s] = xt.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, h = l;
        if (l += d, u <= h && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === h) || u > l || c < h || c === h && h !== 0) {
          a.push(p);
          continue;
        }
        var y = p, f = void 0, g = void 0;
        if (c < l) {
          var x = c - h;
          g = xi(xi({}, y), {}, {
            text: y.text.slice(x)
          }), y = xi(xi({}, y), {}, {
            text: y.text.slice(0, x)
          });
        }
        if (u > h) {
          var L = u - h;
          f = xi(xi({}, y), {}, {
            text: y.text.slice(0, L)
          }), y = xi(xi({}, y), {}, {
            text: y.text.slice(L)
          });
        }
        Object.assign(y, o), f && a.push(f), a.push(y), g && a.push(g);
      }
      n = a;
    }
    return n;
  }
}, P7 = (e) => e.selection ? e.selection : e.children.length > 0 ? kn.end(e, []) : [0], Fn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Fn || (Fn = {}));
Fn.L, Fn.L | Fn.V | Fn.LV | Fn.LVT, Fn.LV | Fn.V, Fn.V | Fn.T, Fn.LVT | Fn.T, Fn.T, Fn.Any, Fn.Extend | Fn.ZWJ, Fn.Any, Fn.SpacingMark, Fn.Prepend, Fn.Any, Fn.ZWJ, Fn.ExtPict, Fn.RI, Fn.RI;
var T7 = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    kn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = P7(e)
      } = n;
      if (Re.isPath(o) && (o = kn.range(e, o)), xt.isRange(o))
        if (xt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = xt.end(o);
          if (!r && kn.void(e, {
            at: i
          }))
            return;
          var s = xt.start(o), a = kn.pointRef(e, s), l = kn.pointRef(e, i);
          Sd.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Sd.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && kn.void(e, {
        at: o
      }) || kn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function RO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RO(Object(n), !0).forEach(function(r) {
      Ya(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Sd = Yc(Yc(Yc(Yc({}, b7), w7), C7), T7), _7 = typeof Tn == "object" && Tn && Tn.Object === Object && Tn, A7 = _7, B7 = A7, I7 = typeof self == "object" && self && self.Object === Object && self, j7 = B7 || I7 || Function("return this")(), R7 = j7, N7 = R7, F7 = N7.Symbol, OI = F7, NO = OI;
NO && NO.toStringTag;
var FO = OI;
FO && FO.toStringTag;
var zO;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(zO || (zO = {}));
var hb = function(e) {
  return Object.freeze(e);
}, z7 = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, hb(this);
  }
  return e;
}(), U7 = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, hb(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), UO = typeof window < "u" ? window : {};
/msie|trident/i.test(UO.navigator && UO.navigator.userAgent);
var Ug = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new z7((n ? t : e) || 0, (n ? e : t) || 0);
};
hb({
  devicePixelContentBoxSize: Ug(),
  borderBoxSize: Ug(),
  contentBoxSize: Ug(),
  contentRect: new U7(0, 0, 0, 0)
});
function wu(e) {
  "@babel/helpers - typeof";
  return wu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, wu(e);
}
function $7(e, t) {
  if (wu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (wu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function W7(e) {
  var t = $7(e, "string");
  return wu(t) === "symbol" ? t : String(t);
}
function Xl(e, t, n) {
  return t = W7(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var H7 = /* @__PURE__ */ qe(null), $g, Wg;
parseInt(Ae.version.split(".")[0], 10);
var $O = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Hg = typeof navigator < "u" && /Android/.test(navigator.userAgent), Jc = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), V7 = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ($g = navigator.userAgent.match(/Version\/(\d+)/)) !== null && $g !== void 0 && $g[1] && parseInt((Wg = navigator.userAgent.match(/Version\/(\d+)/)) === null || Wg === void 0 ? void 0 : Wg[1], 10) < 17;
var Z7 = /* @__PURE__ */ new WeakMap(), q7 = /* @__PURE__ */ new WeakMap(), G7 = /* @__PURE__ */ new WeakMap(), X7 = /* @__PURE__ */ new WeakMap(), Y7 = /* @__PURE__ */ new WeakMap(), WO = /* @__PURE__ */ new WeakMap(), J7 = /* @__PURE__ */ new WeakMap(), HO = /* @__PURE__ */ new WeakMap(), Kc = /* @__PURE__ */ new WeakMap(), K7 = /* @__PURE__ */ new WeakMap(), Q7 = /* @__PURE__ */ new WeakMap(), eZ = /* @__PURE__ */ new WeakMap(), MI = globalThis.Node, tZ = globalThis.Text, SI = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, nZ = (e) => Dd(e) && e.nodeType === 8, ai = (e) => Dd(e) && e.nodeType === 1, Dd = (e) => {
  var t = SI(e);
  return !!t && e instanceof t.Node;
}, VO = (e) => {
  var t = e && e.anchorNode && SI(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, rZ = (e) => {
  var [t, n] = e;
  if (ai(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = DI(t, o, r ? "backward" : "forward"), r = o < n; ai(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = iZ(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, oZ = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, DI = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (nZ(o) || ai(o) && o.childNodes.length === 0 || ai(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, iZ = (e, t, n) => {
  var [r] = DI(e, t, n);
  return r;
}, ZO = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), PI = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ai(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Wt.getWindow(e);
  if (o.contains(r))
    return Wt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : PI(e, i, n);
}, qO = (e, t) => !!(e.compareDocumentPosition(t) & MI.DOCUMENT_POSITION_PRECEDING), sZ = (e, t) => !!(e.compareDocumentPosition(t) & MI.DOCUMENT_POSITION_FOLLOWING), aZ = 0;
class lZ {
  constructor() {
    Xl(this, "id", void 0), this.id = "".concat(aZ++);
  }
}
var Wt = {
  androidPendingDiffs: (e) => eZ.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = Q7.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Wt.toDOMNode(e, e), n = Wt.findDocumentOrShadowRoot(e);
    Kc.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Wt.findDocumentOrShadowRoot(e), r = ZO(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Sd.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Wt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Wt.toSlateNode(e, t.target), s = Wt.findPath(e, i);
    if (Ti.isElement(i) && kn.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = kn.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? kn.before(e, u) : kn.after(e, u);
      if (c) {
        var p = kn.range(e, c);
        return p;
      }
    }
    var d, {
      document: h
    } = Wt.getWindow(e);
    if (h.caretRangeFromPoint)
      d = h.caretRangeFromPoint(n, r);
    else {
      var y = h.caretPositionFromPoint(n, r);
      y && (d = h.createRange(), d.setStart(y.offsetNode, y.offset), d.setEnd(y.offsetNode, y.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var f = Wt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return f;
  },
  findKey: (e, t) => {
    var n = WO.get(t);
    return n || (n = new lZ(), WO.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = q7.get(r);
      if (o == null) {
        if (kn.isEditor(r))
          return n;
        break;
      }
      var i = Z7.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(wo.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Kc.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Wt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Wt.toDOMNode(e, e), r = Wt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = ZO(r), i = Wt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Sd.select(e, kn.start(e, [])), Kc.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = G7.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Wt.toDOMNode(e, e), i;
    try {
      i = ai(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Dd(t) && Wt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return kn.hasPath(e, n.path) && kn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Wt.hasEditableTarget(e, t) || Wt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Dd(t) && Wt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!K7.get(e),
  isFocused: (e) => !!Kc.get(e),
  isReadOnly: (e) => !!HO.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (HO.get(e)) return !1;
    var n = Wt.hasTarget(e, t) && Wt.toSlateNode(e, t);
    return Ti.isElement(n) && kn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = J7.get(e), r = kn.isEditor(t) ? X7.get(e) : n == null ? void 0 : n.get(Wt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(wo.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = kn.node(e, t.path), r = Wt.toDOMNode(e, n), o;
    kn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), h = d == null ? p : parseInt(d, 10), y = a + h, f = s[l + 1];
        if (t.offset === y && f !== null && f !== void 0 && f.hasAttribute("data-slate-mark-placeholder")) {
          var g, x = f.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            x instanceof tZ ? x : f,
            (g = f.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= y) {
          var L = Math.min(p, Math.max(0, t.offset - a));
          o = [c, L];
          break;
        }
        a = y;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(wo.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = xt.isBackward(t), i = Wt.toDOMPoint(e, n), s = xt.isCollapsed(t) ? i : Wt.toDOMPoint(e, r), a = Wt.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, h = ai(u) ? u : u.parentElement, y = !!h.getAttribute("data-slate-zero-width"), f = ai(p) ? p : p.parentElement, g = !!f.getAttribute("data-slate-zero-width");
    return l.setStart(u, y ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ai(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Y7.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : rZ(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, h = Wt.toDOMNode(e, e), y = l.closest('[data-slate-void="true"]'), f = y && h.contains(y) ? y : null, g = l.closest('[contenteditable="false"]'), x = g && h.contains(g) ? g : null, L = l.closest("[data-slate-leaf]"), E = null;
      if (L) {
        if (u = L.closest('[data-slate-node="text"]'), u) {
          var T = Wt.getWindow(e), b = T.document.createRange();
          b.setStart(u, 0), b.setEnd(s, a);
          var C = b.cloneContents(), M = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          M.forEach((I) => {
            if (Hg && !r && I.hasAttribute("data-slate-zero-width") && I.textContent.length > 0 && I.textContext !== "\uFEFF") {
              I.textContent.startsWith("\uFEFF") && (I.textContent = I.textContent.slice(1));
              return;
            }
            I.parentNode.removeChild(I);
          }), c = C.textContent.length, E = u;
        }
      } else if (f) {
        for (var S = f.querySelectorAll("[data-slate-leaf]"), F = 0; F < S.length; F++) {
          var D = S[F];
          if (Wt.hasDOMNode(e, D)) {
            L = D;
            break;
          }
        }
        L ? (u = L.closest('[data-slate-node="text"]'), E = L, c = E.textContent.length, E.querySelectorAll("[data-slate-zero-width]").forEach((I) => {
          c -= I.textContent.length;
        })) : c = 1;
      } else if (x) {
        var Z = (I) => I ? I.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], U = x.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, N = [...Z(U), ...Z(U == null ? void 0 : U.nextElementSibling)];
          L = ($ = N.find((I) => sZ(x, I))) !== null && $ !== void 0 ? $ : null;
        } else {
          var V, J = [...Z(U == null ? void 0 : U.previousElementSibling), ...Z(U)];
          L = (V = J.findLast((I) => qO(x, I))) !== null && V !== void 0 ? V : null;
        }
        L && (u = L.closest('[data-slate-node="text"]'), E = L, i === "forward" ? c = 0 : (c = E.textContent.length, E.querySelectorAll("[data-slate-zero-width]").forEach((I) => {
          c -= I.textContent.length;
        })));
      }
      E && c === E.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Hg && E.getAttribute("data-slate-zero-width") === "z" && (p = E.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Jc && (d = E.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Hg && !u && !r) {
      var j = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (j && Wt.hasDOMNode(e, j, {
        editable: !0
      })) {
        var K = Wt.toSlateNode(e, j), {
          path: te,
          offset: O
        } = kn.start(e, Wt.findPath(e, K));
        return j.querySelector("[data-slate-leaf]") || (O = a), {
          path: te,
          offset: O
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var P = Wt.toSlateNode(e, u), H = Wt.findPath(e, P);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = VO(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (VO(t)) {
        if (Jc && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), h = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && h.startContainer instanceof HTMLTableRowElement) {
            let C = function(M) {
              return M.childElementCount > 0 ? C(M.children[0]) : M;
            };
            var y = d.startContainer, f = h.startContainer, g = C(y.children[d.startOffset]), x = C(f.children[h.startOffset]);
            c = 0, x.childNodes.length > 0 ? a = x.childNodes[0] : a = x, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, x instanceof HTMLElement ? l = x.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = h.endContainer, l = h.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = h.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        V7 && oZ(a) || Jc ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Jc && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var L = Wt.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!L)
      return null;
    var E = qO(a, u) || a === u && c < l, T = p ? L : Wt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: E ? "forward" : "backward"
    });
    if (!T)
      return null;
    var b = {
      anchor: L,
      focus: T
    };
    return xt.isExpanded(b) && xt.isForward(b) && ai(u) && kn.void(e, {
      at: b.focus,
      mode: "highest"
    }) && (b = kn.unhangRange(e, b, {
      voids: !0
    })), b;
  }
}, uZ = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, cZ = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, pZ = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, tr = (e) => {
  var t = uZ[e], n = cZ[e], r = pZ[e], o = t && Ng(t), i = n && Ng(n), s = r && Ng(r);
  return (a) => !!(o && o(a) || $O && i && i(a) || !$O && s && s(a));
};
tr("bold"), tr("compose"), tr("moveBackward"), tr("moveForward"), tr("deleteBackward"), tr("deleteForward"), tr("deleteLineBackward"), tr("deleteLineForward"), tr("deleteWordBackward"), tr("deleteWordForward"), tr("extendBackward"), tr("extendForward"), tr("extendLineBackward"), tr("extendLineForward"), tr("italic"), tr("moveLineBackward"), tr("moveLineForward"), tr("moveWordBackward"), tr("moveWordForward"), tr("redo"), tr("insertSoftBreak"), tr("splitBlock"), tr("transposeCharacter"), tr("undo");
var dZ = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => PI(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, fZ = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class hZ extends Nu {
  constructor() {
    super(...arguments), Xl(this, "context", null), Xl(this, "manager", null), Xl(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, fZ);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = dZ(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Xl(hZ, "contextType", H7);
var TI = {}, gb = {}, mb = {};
Object.defineProperty(mb, "__esModule", { value: !0 });
mb.default = yZ;
var GO = "html", XO = "head", Qc = "body", gZ = /<([a-zA-Z]+[0-9]?)/, YO = /<head[^]*>/i, JO = /<body[^]*>/i, Pd = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, cy = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, KO = typeof window == "object" && window.DOMParser;
if (typeof KO == "function") {
  var mZ = new KO(), vZ = "text/html";
  cy = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), mZ.parseFromString(e, vZ);
  }, Pd = cy;
}
if (typeof document == "object" && document.implementation) {
  var ep = document.implementation.createHTMLDocument();
  Pd = function(e, t) {
    if (t) {
      var n = ep.documentElement.querySelector(t);
      return n && (n.innerHTML = e), ep;
    }
    return ep.documentElement.innerHTML = e, ep;
  };
}
var tp = typeof document == "object" && document.createElement("template"), py;
tp && tp.content && (py = function(e) {
  return tp.innerHTML = e, tp.content.childNodes;
});
function yZ(e) {
  var t, n, r = e.match(gZ), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case GO: {
      var i = cy(e);
      if (!YO.test(e)) {
        var s = i.querySelector(XO);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!JO.test(e)) {
        var s = i.querySelector(Qc);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(GO);
    }
    case XO:
    case Qc: {
      var a = Pd(e).querySelectorAll(o);
      return JO.test(e) && YO.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (py)
        return py(e);
      var s = Pd(e, Qc).querySelector(Qc);
      return s.childNodes;
    }
  }
}
var Df = {}, vb = {}, yb = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(yb);
var _t = {}, Ss = Tn && Tn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Yl = Tn && Tn.__assign || function() {
  return Yl = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Yl.apply(this, arguments);
};
Object.defineProperty(_t, "__esModule", { value: !0 });
_t.cloneNode = _t.hasChildren = _t.isDocument = _t.isDirective = _t.isComment = _t.isText = _t.isCDATA = _t.isTag = _t.Element = _t.Document = _t.CDATA = _t.NodeWithChildren = _t.ProcessingInstruction = _t.Comment = _t.Text = _t.DataNode = _t.Node = void 0;
var go = yb, bb = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), wb(this, t);
    }, e;
  }()
);
_t.Node = bb;
var Pf = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bb)
);
_t.DataNode = Pf;
var _I = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = go.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Pf)
);
_t.Text = _I;
var AI = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = go.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Pf)
);
_t.Comment = AI;
var BI = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = go.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Pf)
);
_t.ProcessingInstruction = BI;
var Tf = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bb)
);
_t.NodeWithChildren = Tf;
var II = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = go.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tf)
);
_t.CDATA = II;
var jI = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = go.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tf)
);
_t.Document = jI;
var RI = (
  /** @class */
  function(e) {
    Ss(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? go.ElementType.Script : n === "style" ? go.ElementType.Style : go.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tf)
);
_t.Element = RI;
function NI(e) {
  return (0, go.isTag)(e);
}
_t.isTag = NI;
function FI(e) {
  return e.type === go.ElementType.CDATA;
}
_t.isCDATA = FI;
function zI(e) {
  return e.type === go.ElementType.Text;
}
_t.isText = zI;
function UI(e) {
  return e.type === go.ElementType.Comment;
}
_t.isComment = UI;
function $I(e) {
  return e.type === go.ElementType.Directive;
}
_t.isDirective = $I;
function WI(e) {
  return e.type === go.ElementType.Root;
}
_t.isDocument = WI;
function bZ(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
_t.hasChildren = bZ;
function wb(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (zI(e))
    n = new _I(e.data);
  else if (UI(e))
    n = new AI(e.data);
  else if (NI(e)) {
    var r = t ? Vg(e.children) : [], o = new RI(e.name, Yl({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Yl({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Yl({}, e["x-attribsPrefix"])), n = o;
  } else if (FI(e)) {
    var r = t ? Vg(e.children) : [], i = new II(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (WI(e)) {
    var r = t ? Vg(e.children) : [], s = new jI(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if ($I(e)) {
    var a = new BI(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
_t.cloneNode = wb;
function Vg(e) {
  for (var t = e.map(function(r) {
    return wb(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Tn && Tn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = Tn && Tn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = yb, o = _t;
  n(_t, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(vb);
var HI = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(HI);
Object.defineProperty(Df, "__esModule", { value: !0 });
Df.formatAttributes = VI;
Df.formatDOM = ZI;
var np = vb, wZ = HI;
function CZ(e) {
  return wZ.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function VI(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function xZ(e) {
  e = e.toLowerCase();
  var t = CZ(e);
  return t || e;
}
function ZI(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = xZ(a.nodeName);
        o = new np.Element(l, VI(a.attributes)), o.children = ZI(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new np.Text(a.nodeValue);
        break;
      case 8:
        o = new np.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new np.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var EZ = Tn && Tn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(gb, "__esModule", { value: !0 });
gb.default = MZ;
var LZ = EZ(mb), kZ = Df, OZ = /<(![a-zA-Z\s]+)>/;
function MZ(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(OZ), n = t ? t[1] : void 0;
  return (0, kZ.formatDOM)((0, LZ.default)(e), null, n);
}
var _f = {}, Xo = {}, Af = {}, SZ = 0;
Af.SAME = SZ;
var DZ = 1;
Af.CAMELCASE = DZ;
Af.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const qI = 0, Ds = 1, Bf = 2, If = 3, Cb = 4, GI = 5, XI = 6;
function PZ(e) {
  return Hr.hasOwnProperty(e) ? Hr[e] : null;
}
function no(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === Bf || t === If || t === Cb, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const Hr = {}, TZ = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
TZ.forEach((e) => {
  Hr[e] = new no(
    e,
    qI,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Hr[e] = new no(
    e,
    Ds,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Hr[e] = new no(
    e,
    Bf,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Hr[e] = new no(
    e,
    Bf,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Hr[e] = new no(
    e,
    If,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Hr[e] = new no(
    e,
    If,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Hr[e] = new no(
    e,
    Cb,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Hr[e] = new no(
    e,
    XI,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Hr[e] = new no(
    e,
    GI,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const xb = /[\-\:]([a-z])/g, Eb = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(xb, Eb);
  Hr[t] = new no(
    t,
    Ds,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(xb, Eb);
  Hr[t] = new no(
    t,
    Ds,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(xb, Eb);
  Hr[t] = new no(
    t,
    Ds,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Hr[e] = new no(
    e,
    Ds,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const _Z = "xlinkHref";
Hr[_Z] = new no(
  "xlinkHref",
  Ds,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Hr[e] = new no(
    e,
    Ds,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: AZ,
  SAME: BZ,
  possibleStandardNames: QO
} = Af, IZ = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", jZ = IZ + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", RZ = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + jZ + "]*$")
), NZ = Object.keys(
  QO
).reduce((e, t) => {
  const n = QO[t];
  return n === BZ ? e[t] = t : n === AZ ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Xo.BOOLEAN = If;
Xo.BOOLEANISH_STRING = Bf;
Xo.NUMERIC = GI;
Xo.OVERLOADED_BOOLEAN = Cb;
Xo.POSITIVE_NUMERIC = XI;
Xo.RESERVED = qI;
Xo.STRING = Ds;
Xo.getPropertyInfo = PZ;
Xo.isCustomAttribute = RZ;
Xo.possibleStandardNames = NZ;
var Lb = {}, kb = {}, eM = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, FZ = /\n/g, zZ = /^\s*/, UZ = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, $Z = /^:\s*/, WZ = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, HZ = /^[;\s]*/, VZ = /^\s+|\s+$/g, ZZ = `
`, tM = "/", nM = "*", ia = "", qZ = "comment", GZ = "declaration", XZ = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(y) {
    var f = y.match(FZ);
    f && (n += f.length);
    var g = y.lastIndexOf(ZZ);
    r = ~g ? y.length - g : r + y.length;
  }
  function i() {
    var y = { line: n, column: r };
    return function(f) {
      return f.position = new s(y), u(), f;
    };
  }
  function s(y) {
    this.start = y, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(y) {
    var f = new Error(
      t.source + ":" + n + ":" + r + ": " + y
    );
    if (f.reason = y, f.filename = t.source, f.line = n, f.column = r, f.source = e, !t.silent) throw f;
  }
  function l(y) {
    var f = y.exec(e);
    if (f) {
      var g = f[0];
      return o(g), e = e.slice(g.length), f;
    }
  }
  function u() {
    l(zZ);
  }
  function c(y) {
    var f;
    for (y = y || []; f = p(); )
      f !== !1 && y.push(f);
    return y;
  }
  function p() {
    var y = i();
    if (!(tM != e.charAt(0) || nM != e.charAt(1))) {
      for (var f = 2; ia != e.charAt(f) && (nM != e.charAt(f) || tM != e.charAt(f + 1)); )
        ++f;
      if (f += 2, ia === e.charAt(f - 1))
        return a("End of comment missing");
      var g = e.slice(2, f - 2);
      return r += 2, o(g), e = e.slice(f), r += 2, y({
        type: qZ,
        comment: g
      });
    }
  }
  function d() {
    var y = i(), f = l(UZ);
    if (f) {
      if (p(), !l($Z)) return a("property missing ':'");
      var g = l(WZ), x = y({
        type: GZ,
        property: rM(f[0].replace(eM, ia)),
        value: g ? rM(g[0].replace(eM, ia)) : ia
      });
      return l(HZ), x;
    }
  }
  function h() {
    var y = [];
    c(y);
    for (var f; f = d(); )
      f !== !1 && (y.push(f), c(y));
    return y;
  }
  return u(), h();
};
function rM(e) {
  return e ? e.replace(VZ, ia) : ia;
}
var YZ = Tn && Tn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(kb, "__esModule", { value: !0 });
kb.default = KZ;
var JZ = YZ(XZ);
function KZ(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, JZ.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var jf = {};
Object.defineProperty(jf, "__esModule", { value: !0 });
jf.camelCase = void 0;
var QZ = /^--[a-zA-Z0-9-]+$/, eq = /-([a-z])/g, tq = /^[^-]+$/, nq = /^-(webkit|moz|ms|o|khtml)-/, rq = /^-(ms)-/, oq = function(e) {
  return !e || tq.test(e) || QZ.test(e);
}, iq = function(e, t) {
  return t.toUpperCase();
}, oM = function(e, t) {
  return "".concat(t, "-");
}, sq = function(e, t) {
  return t === void 0 && (t = {}), oq(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(rq, oM) : e = e.replace(nq, oM), e.replace(eq, iq));
};
jf.camelCase = sq;
var aq = Tn && Tn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, lq = aq(kb), uq = jf;
function dy(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, lq.default)(e, function(r, o) {
    r && o && (n[(0, uq.camelCase)(r, t)] = o);
  }), n;
}
dy.default = dy;
var cq = dy;
(function(e) {
  var t = Tn && Tn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Ae, r = t(cq), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Lb);
Object.defineProperty(_f, "__esModule", { value: !0 });
_f.default = hq;
var Il = Xo, iM = Lb, pq = ["checked", "value"], dq = ["input", "select", "textarea"], fq = {
  reset: !0,
  submit: !0
};
function hq(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && fq[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Il.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = sM(s);
    if (a) {
      var l = (0, Il.getPropertyInfo)(a);
      switch (pq.includes(a) && dq.includes(t) && !r && (a = sM("default" + s)), n[a] = i, l && l.type) {
        case Il.BOOLEAN:
          n[a] = !0;
          break;
        case Il.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    iM.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, iM.setStyleProp)(e.style, n), n;
}
function sM(e) {
  return Il.possibleStandardNames[e];
}
var Ob = {}, gq = Tn && Tn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ob, "__esModule", { value: !0 });
Ob.default = YI;
var Zg = Ae, mq = gq(_f), Jl = Lb, vq = {
  cloneElement: Zg.cloneElement,
  createElement: Zg.createElement,
  isValidElement: Zg.isValidElement
};
function YI(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Jl.returnFirstArg, i = t.library || vq, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var h = !p.data.trim().length;
      if (h && p.parent && !(0, Jl.canTextBeChildOfNode)(p.parent) || t.trim && h)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var y = p, f = {};
    yq(y) ? ((0, Jl.setStyleProp)(y.attribs.style, y.attribs), f = y.attribs) : y.attribs && (f = (0, mq.default)(y.attribs, y.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (f.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? f.defaultValue = p.children[0].data : p.children && p.children.length && (g = YI(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (f.key = c), n.push(o(a(p.name, f, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function yq(e) {
  return Jl.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Jl.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Tn && Tn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(gb);
  e.htmlToDOM = n.default;
  var r = t(_f);
  e.attributesToProps = r.default;
  var o = t(Ob);
  e.domToReact = o.default;
  var i = vb;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(TI);
const bq = /* @__PURE__ */ hW(TI);
bq.default;
qe({});
qe({});
qe({});
var Sr = {}, Mb = {}, Zu = {}, qu = {}, JI = "Expected a function", aM = NaN, wq = "[object Symbol]", Cq = /^\s+|\s+$/g, xq = /^[-+]0x[0-9a-f]+$/i, Eq = /^0b[01]+$/i, Lq = /^0o[0-7]+$/i, kq = parseInt, Oq = typeof Tn == "object" && Tn && Tn.Object === Object && Tn, Mq = typeof self == "object" && self && self.Object === Object && self, Sq = Oq || Mq || Function("return this")(), Dq = Object.prototype, Pq = Dq.toString, Tq = Math.max, _q = Math.min, qg = function() {
  return Sq.Date.now();
};
function Aq(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(JI);
  t = lM(t) || 0, Td(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Tq(lM(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function h(C) {
    var M = r, S = o;
    return r = o = void 0, u = C, s = e.apply(S, M), s;
  }
  function y(C) {
    return u = C, a = setTimeout(x, t), c ? h(C) : s;
  }
  function f(C) {
    var M = C - l, S = C - u, F = t - M;
    return p ? _q(F, i - S) : F;
  }
  function g(C) {
    var M = C - l, S = C - u;
    return l === void 0 || M >= t || M < 0 || p && S >= i;
  }
  function x() {
    var C = qg();
    if (g(C))
      return L(C);
    a = setTimeout(x, f(C));
  }
  function L(C) {
    return a = void 0, d && r ? h(C) : (r = o = void 0, s);
  }
  function E() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function T() {
    return a === void 0 ? s : L(qg());
  }
  function b() {
    var C = qg(), M = g(C);
    if (r = arguments, o = this, l = C, M) {
      if (a === void 0)
        return y(l);
      if (p)
        return a = setTimeout(x, t), h(l);
    }
    return a === void 0 && (a = setTimeout(x, t)), s;
  }
  return b.cancel = E, b.flush = T, b;
}
function Bq(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(JI);
  return Td(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Aq(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Td(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Iq(e) {
  return !!e && typeof e == "object";
}
function jq(e) {
  return typeof e == "symbol" || Iq(e) && Pq.call(e) == wq;
}
function lM(e) {
  if (typeof e == "number")
    return e;
  if (jq(e))
    return aM;
  if (Td(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Td(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Cq, "");
  var n = Eq.test(e);
  return n || Lq.test(e) ? kq(e.slice(2), n ? 2 : 8) : xq.test(e) ? aM : +e;
}
var Rq = Bq, Gu = {};
Object.defineProperty(Gu, "__esModule", {
  value: !0
});
Gu.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), ed.has(t) || ed.set(t, /* @__PURE__ */ new Set());
  var o = ed.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Gu.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), ed.get(t).delete(n.name || t);
};
var ed = /* @__PURE__ */ new Map();
Object.defineProperty(qu, "__esModule", {
  value: !0
});
var Nq = Rq, Fq = Uq(Nq), zq = Gu;
function Uq(e) {
  return e && e.__esModule ? e : { default: e };
}
var $q = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Fq.default)(e, t);
}, hr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = $q(function(r) {
        hr.scrollHandler(e);
      }, t);
      hr.scrollSpyContainers.push(e), (0, zq.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return hr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = hr.scrollSpyContainers[hr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(hr.currentPositionX(e), hr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    hr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = hr.scrollSpyContainers[hr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(hr.currentPositionX(t), hr.currentPositionY(t));
  },
  updateStates: function() {
    hr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    hr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), hr.spySetState && hr.spySetState.length && hr.spySetState.indexOf(e) > -1 && hr.spySetState.splice(hr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", hr.scrollHandler);
  },
  update: function() {
    return hr.scrollSpyContainers.forEach(function(e) {
      return hr.scrollHandler(e);
    });
  }
};
qu.default = hr;
var Ja = {}, Xu = {};
Object.defineProperty(Xu, "__esModule", {
  value: !0
});
var Wq = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, Hq = function() {
  return window.location.hash.replace(/^#/, "");
}, Vq = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Zq = function(e) {
  return getComputedStyle(e).position !== "static";
}, Gg = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, qq = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Zq(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Gg(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return Gg(t, a).offsetTop - Gg(e, a).offsetTop;
};
Xu.default = {
  updateHash: Wq,
  getHash: Hq,
  filterElementInContainer: Vq,
  scrollOffset: qq
};
var Rf = {}, Sb = {};
Object.defineProperty(Sb, "__esModule", {
  value: !0
});
Sb.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Db = {};
Object.defineProperty(Db, "__esModule", {
  value: !0
});
var Gq = Gu, Xq = ["mousedown", "mousewheel", "touchmove", "keydown"];
Db.default = {
  subscribe: function(e) {
    return typeof document < "u" && Xq.forEach(function(t) {
      return (0, Gq.addPassiveEventListener)(document, t, e);
    });
  }
};
var Yu = {};
Object.defineProperty(Yu, "__esModule", {
  value: !0
});
var fy = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      fy.registered[e] = t;
    },
    remove: function(e) {
      fy.registered[e] = null;
    }
  }
};
Yu.default = fy;
Object.defineProperty(Rf, "__esModule", {
  value: !0
});
var Yq = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Jq = Xu;
Nf(Jq);
var Kq = Sb, uM = Nf(Kq), Qq = Db, eG = Nf(Qq), tG = Yu, ni = Nf(tG);
function Nf(e) {
  return e && e.__esModule ? e : { default: e };
}
var KI = function(e) {
  return uM.default[e.smooth] || uM.default.defaultEasing;
}, nG = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, rG = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, hy = function() {
  return rG() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), QI = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, ej = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, tj = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, oG = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, iG = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, sG = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    ni.default.registered.end && ni.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    hy.call(window, i);
    return;
  }
  ni.default.registered.end && ni.default.registered.end(o.to, o.target, o.currentPosition);
}, Pb = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Ju = function(e, t, n, r) {
  t.data = t.data || QI(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (eG.default.subscribe(o), Pb(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? ej(t) : tj(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    ni.default.registered.end && ni.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = nG(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = KI(t), s = sG.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      ni.default.registered.begin && ni.default.registered.begin(t.data.to, t.data.target), hy.call(window, s);
    }, t.delay);
    return;
  }
  ni.default.registered.begin && ni.default.registered.begin(t.data.to, t.data.target), hy.call(window, s);
}, Ff = function(e) {
  return e = Yq({}, e), e.data = e.data || QI(), e.absolute = !0, e;
}, aG = function(e) {
  Ju(0, Ff(e));
}, lG = function(e, t) {
  Ju(e, Ff(t));
}, uG = function(e) {
  e = Ff(e), Pb(e), Ju(e.horizontal ? oG(e) : iG(e), e);
}, cG = function(e, t) {
  t = Ff(t), Pb(t);
  var n = t.horizontal ? ej(t) : tj(t);
  Ju(e + n, t);
};
Rf.default = {
  animateTopScroll: Ju,
  getAnimationType: KI,
  scrollToTop: aG,
  scrollToBottom: uG,
  scrollTo: lG,
  scrollMore: cG
};
Object.defineProperty(Ja, "__esModule", {
  value: !0
});
var pG = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, dG = Xu, fG = Tb(dG), hG = Rf, gG = Tb(hG), mG = Yu, rp = Tb(mG);
function Tb(e) {
  return e && e.__esModule ? e : { default: e };
}
var op = {}, cM = void 0;
Ja.default = {
  unmount: function() {
    op = {};
  },
  register: function(e, t) {
    op[e] = t;
  },
  unregister: function(e) {
    delete op[e];
  },
  get: function(e) {
    return op[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return cM = e;
  },
  getActiveLink: function() {
    return cM;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = pG({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = fG.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      rp.default.registered.begin && rp.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, rp.default.registered.end && rp.default.registered.end(e, n);
      return;
    }
    gG.default.animateTopScroll(a, t, e, n);
  }
};
var gy = { exports: {} }, Xg = { exports: {} }, un = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pM;
function vG() {
  if (pM) return un;
  pM = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
  function E(b) {
    if (typeof b == "object" && b !== null) {
      var C = b.$$typeof;
      switch (C) {
        case t:
          switch (b = b.type, b) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case a:
                case c:
                case y:
                case h:
                case s:
                  return b;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function T(b) {
    return E(b) === u;
  }
  return un.AsyncMode = l, un.ConcurrentMode = u, un.ContextConsumer = a, un.ContextProvider = s, un.Element = t, un.ForwardRef = c, un.Fragment = r, un.Lazy = y, un.Memo = h, un.Portal = n, un.Profiler = i, un.StrictMode = o, un.Suspense = p, un.isAsyncMode = function(b) {
    return T(b) || E(b) === l;
  }, un.isConcurrentMode = T, un.isContextConsumer = function(b) {
    return E(b) === a;
  }, un.isContextProvider = function(b) {
    return E(b) === s;
  }, un.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === t;
  }, un.isForwardRef = function(b) {
    return E(b) === c;
  }, un.isFragment = function(b) {
    return E(b) === r;
  }, un.isLazy = function(b) {
    return E(b) === y;
  }, un.isMemo = function(b) {
    return E(b) === h;
  }, un.isPortal = function(b) {
    return E(b) === n;
  }, un.isProfiler = function(b) {
    return E(b) === i;
  }, un.isStrictMode = function(b) {
    return E(b) === o;
  }, un.isSuspense = function(b) {
    return E(b) === p;
  }, un.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === r || b === u || b === i || b === o || b === p || b === d || typeof b == "object" && b !== null && (b.$$typeof === y || b.$$typeof === h || b.$$typeof === s || b.$$typeof === a || b.$$typeof === c || b.$$typeof === g || b.$$typeof === x || b.$$typeof === L || b.$$typeof === f);
  }, un.typeOf = E, un;
}
var Cn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dM;
function yG() {
  return dM || (dM = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
    function E(A) {
      return typeof A == "string" || typeof A == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      A === r || A === u || A === i || A === o || A === p || A === d || typeof A == "object" && A !== null && (A.$$typeof === y || A.$$typeof === h || A.$$typeof === s || A.$$typeof === a || A.$$typeof === c || A.$$typeof === g || A.$$typeof === x || A.$$typeof === L || A.$$typeof === f);
    }
    function T(A) {
      if (typeof A == "object" && A !== null) {
        var ae = A.$$typeof;
        switch (ae) {
          case t:
            var ce = A.type;
            switch (ce) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ce;
              default:
                var ue = ce && ce.$$typeof;
                switch (ue) {
                  case a:
                  case c:
                  case y:
                  case h:
                  case s:
                    return ue;
                  default:
                    return ae;
                }
            }
          case n:
            return ae;
        }
      }
    }
    var b = l, C = u, M = a, S = s, F = t, D = c, Z = r, U = y, $ = h, N = n, V = i, J = o, j = p, K = !1;
    function te(A) {
      return K || (K = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), O(A) || T(A) === l;
    }
    function O(A) {
      return T(A) === u;
    }
    function P(A) {
      return T(A) === a;
    }
    function H(A) {
      return T(A) === s;
    }
    function I(A) {
      return typeof A == "object" && A !== null && A.$$typeof === t;
    }
    function W(A) {
      return T(A) === c;
    }
    function X(A) {
      return T(A) === r;
    }
    function w(A) {
      return T(A) === y;
    }
    function R(A) {
      return T(A) === h;
    }
    function z(A) {
      return T(A) === n;
    }
    function _(A) {
      return T(A) === i;
    }
    function Y(A) {
      return T(A) === o;
    }
    function Q(A) {
      return T(A) === p;
    }
    Cn.AsyncMode = b, Cn.ConcurrentMode = C, Cn.ContextConsumer = M, Cn.ContextProvider = S, Cn.Element = F, Cn.ForwardRef = D, Cn.Fragment = Z, Cn.Lazy = U, Cn.Memo = $, Cn.Portal = N, Cn.Profiler = V, Cn.StrictMode = J, Cn.Suspense = j, Cn.isAsyncMode = te, Cn.isConcurrentMode = O, Cn.isContextConsumer = P, Cn.isContextProvider = H, Cn.isElement = I, Cn.isForwardRef = W, Cn.isFragment = X, Cn.isLazy = w, Cn.isMemo = R, Cn.isPortal = z, Cn.isProfiler = _, Cn.isStrictMode = Y, Cn.isSuspense = Q, Cn.isValidElementType = E, Cn.typeOf = T;
  }()), Cn;
}
var fM;
function nj() {
  return fM || (fM = 1, process.env.NODE_ENV === "production" ? Xg.exports = vG() : Xg.exports = yG()), Xg.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Yg, hM;
function bG() {
  if (hM) return Yg;
  hM = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Yg = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, Yg;
}
var Jg, gM;
function _b() {
  if (gM) return Jg;
  gM = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Jg = e, Jg;
}
var mM, vM;
function rj() {
  return vM || (vM = 1, mM = Function.call.bind(Object.prototype.hasOwnProperty)), mM;
}
var Kg, yM;
function wG() {
  if (yM) return Kg;
  yM = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = _b(), n = {}, r = rj();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (y) {
            p = y;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var h = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (h ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Kg = o, Kg;
}
var Qg, bM;
function CG() {
  if (bM) return Qg;
  bM = 1;
  var e = nj(), t = bG(), n = _b(), r = rj(), o = wG(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return Qg = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(O) {
      var P = O && (u && O[u] || O[c]);
      if (typeof P == "function")
        return P;
    }
    var d = "<<anonymous>>", h = {
      array: x("array"),
      bigint: x("bigint"),
      bool: x("boolean"),
      func: x("function"),
      number: x("number"),
      object: x("object"),
      string: x("string"),
      symbol: x("symbol"),
      any: L(),
      arrayOf: E,
      element: T(),
      elementType: b(),
      instanceOf: C,
      node: D(),
      objectOf: S,
      oneOf: M,
      oneOfType: F,
      shape: U,
      exact: $
    };
    function y(O, P) {
      return O === P ? O !== 0 || 1 / O === 1 / P : O !== O && P !== P;
    }
    function f(O, P) {
      this.message = O, this.data = P && typeof P == "object" ? P : {}, this.stack = "";
    }
    f.prototype = Error.prototype;
    function g(O) {
      if (process.env.NODE_ENV !== "production")
        var P = {}, H = 0;
      function I(X, w, R, z, _, Y, Q) {
        if (z = z || d, Y = Y || R, Q !== n) {
          if (l) {
            var A = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw A.name = "Invariant Violation", A;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ae = z + ":" + R;
            !P[ae] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + Y + "` prop on `" + z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), P[ae] = !0, H++);
          }
        }
        return w[R] == null ? X ? w[R] === null ? new f("The " + _ + " `" + Y + "` is marked as required " + ("in `" + z + "`, but its value is `null`.")) : new f("The " + _ + " `" + Y + "` is marked as required in " + ("`" + z + "`, but its value is `undefined`.")) : null : O(w, R, z, _, Y);
      }
      var W = I.bind(null, !1);
      return W.isRequired = I.bind(null, !0), W;
    }
    function x(O) {
      function P(H, I, W, X, w, R) {
        var z = H[I], _ = J(z);
        if (_ !== O) {
          var Y = j(z);
          return new f(
            "Invalid " + X + " `" + w + "` of type " + ("`" + Y + "` supplied to `" + W + "`, expected ") + ("`" + O + "`."),
            { expectedType: O }
          );
        }
        return null;
      }
      return g(P);
    }
    function L() {
      return g(s);
    }
    function E(O) {
      function P(H, I, W, X, w) {
        if (typeof O != "function")
          return new f("Property `" + w + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var R = H[I];
        if (!Array.isArray(R)) {
          var z = J(R);
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected an array."));
        }
        for (var _ = 0; _ < R.length; _++) {
          var Y = O(R, _, W, X, w + "[" + _ + "]", n);
          if (Y instanceof Error)
            return Y;
        }
        return null;
      }
      return g(P);
    }
    function T() {
      function O(P, H, I, W, X) {
        var w = P[H];
        if (!a(w)) {
          var R = J(w);
          return new f("Invalid " + W + " `" + X + "` of type " + ("`" + R + "` supplied to `" + I + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(O);
    }
    function b() {
      function O(P, H, I, W, X) {
        var w = P[H];
        if (!e.isValidElementType(w)) {
          var R = J(w);
          return new f("Invalid " + W + " `" + X + "` of type " + ("`" + R + "` supplied to `" + I + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(O);
    }
    function C(O) {
      function P(H, I, W, X, w) {
        if (!(H[I] instanceof O)) {
          var R = O.name || d, z = te(H[I]);
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected ") + ("instance of `" + R + "`."));
        }
        return null;
      }
      return g(P);
    }
    function M(O) {
      if (!Array.isArray(O))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function P(H, I, W, X, w) {
        for (var R = H[I], z = 0; z < O.length; z++)
          if (y(R, O[z]))
            return null;
        var _ = JSON.stringify(O, function(Y, Q) {
          var A = j(Q);
          return A === "symbol" ? String(Q) : Q;
        });
        return new f("Invalid " + X + " `" + w + "` of value `" + String(R) + "` " + ("supplied to `" + W + "`, expected one of " + _ + "."));
      }
      return g(P);
    }
    function S(O) {
      function P(H, I, W, X, w) {
        if (typeof O != "function")
          return new f("Property `" + w + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected an object."));
        for (var _ in R)
          if (r(R, _)) {
            var Y = O(R, _, W, X, w + "." + _, n);
            if (Y instanceof Error)
              return Y;
          }
        return null;
      }
      return g(P);
    }
    function F(O) {
      if (!Array.isArray(O))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var P = 0; P < O.length; P++) {
        var H = O[P];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + K(H) + " at index " + P + "."
          ), s;
      }
      function I(W, X, w, R, z) {
        for (var _ = [], Y = 0; Y < O.length; Y++) {
          var Q = O[Y], A = Q(W, X, w, R, z, n);
          if (A == null)
            return null;
          A.data && r(A.data, "expectedType") && _.push(A.data.expectedType);
        }
        var ae = _.length > 0 ? ", expected one of type [" + _.join(", ") + "]" : "";
        return new f("Invalid " + R + " `" + z + "` supplied to " + ("`" + w + "`" + ae + "."));
      }
      return g(I);
    }
    function D() {
      function O(P, H, I, W, X) {
        return N(P[H]) ? null : new f("Invalid " + W + " `" + X + "` supplied to " + ("`" + I + "`, expected a ReactNode."));
      }
      return g(O);
    }
    function Z(O, P, H, I, W) {
      return new f(
        (O || "React class") + ": " + P + " type `" + H + "." + I + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function U(O) {
      function P(H, I, W, X, w) {
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type `" + z + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var _ in O) {
          var Y = O[_];
          if (typeof Y != "function")
            return Z(W, X, w, _, j(Y));
          var Q = Y(R, _, W, X, w + "." + _, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return g(P);
    }
    function $(O) {
      function P(H, I, W, X, w) {
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type `" + z + "` " + ("supplied to `" + W + "`, expected `object`."));
        var _ = t({}, H[I], O);
        for (var Y in _) {
          var Q = O[Y];
          if (r(O, Y) && typeof Q != "function")
            return Z(W, X, w, Y, j(Q));
          if (!Q)
            return new f(
              "Invalid " + X + " `" + w + "` key `" + Y + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(H[I], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(O), null, "  ")
            );
          var A = Q(R, Y, W, X, w + "." + Y, n);
          if (A)
            return A;
        }
        return null;
      }
      return g(P);
    }
    function N(O) {
      switch (typeof O) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !O;
        case "object":
          if (Array.isArray(O))
            return O.every(N);
          if (O === null || a(O))
            return !0;
          var P = p(O);
          if (P) {
            var H = P.call(O), I;
            if (P !== O.entries) {
              for (; !(I = H.next()).done; )
                if (!N(I.value))
                  return !1;
            } else
              for (; !(I = H.next()).done; ) {
                var W = I.value;
                if (W && !N(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function V(O, P) {
      return O === "symbol" ? !0 : P ? P["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && P instanceof Symbol : !1;
    }
    function J(O) {
      var P = typeof O;
      return Array.isArray(O) ? "array" : O instanceof RegExp ? "object" : V(P, O) ? "symbol" : P;
    }
    function j(O) {
      if (typeof O > "u" || O === null)
        return "" + O;
      var P = J(O);
      if (P === "object") {
        if (O instanceof Date)
          return "date";
        if (O instanceof RegExp)
          return "regexp";
      }
      return P;
    }
    function K(O) {
      var P = j(O);
      switch (P) {
        case "array":
        case "object":
          return "an " + P;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + P;
        default:
          return P;
      }
    }
    function te(O) {
      return !O.constructor || !O.constructor.name ? d : O.constructor.name;
    }
    return h.checkPropTypes = o, h.resetWarningCache = o.resetWarningCache, h.PropTypes = h, h;
  }, Qg;
}
var em, wM;
function xG() {
  if (wM) return em;
  wM = 1;
  var e = _b();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, em = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, em;
}
if (process.env.NODE_ENV !== "production") {
  var EG = nj(), LG = !0;
  gy.exports = CG()(EG.isElement, LG);
} else
  gy.exports = xG()();
var zf = gy.exports, Uf = {};
Object.defineProperty(Uf, "__esModule", {
  value: !0
});
var kG = Xu, tm = OG(kG);
function OG(e) {
  return e && e.__esModule ? e : { default: e };
}
var MG = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return tm.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && tm.default.getHash() !== e && tm.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Uf.default = MG;
Object.defineProperty(Zu, "__esModule", {
  value: !0
});
var ip = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, SG = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), DG = Ae, CM = Ku(DG), PG = qu, sp = Ku(PG), TG = Ja, _G = Ku(TG), AG = zf, nr = Ku(AG), BG = Uf, Xi = Ku(BG);
function Ku(e) {
  return e && e.__esModule ? e : { default: e };
}
function IG(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function jG(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function RG(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var xM = {
  to: nr.default.string.isRequired,
  containerId: nr.default.string,
  container: nr.default.object,
  activeClass: nr.default.string,
  activeStyle: nr.default.object,
  spy: nr.default.bool,
  horizontal: nr.default.bool,
  smooth: nr.default.oneOfType([nr.default.bool, nr.default.string]),
  offset: nr.default.number,
  delay: nr.default.number,
  isDynamic: nr.default.bool,
  onClick: nr.default.func,
  duration: nr.default.oneOfType([nr.default.number, nr.default.func]),
  absolute: nr.default.bool,
  onSetActive: nr.default.func,
  onSetInactive: nr.default.func,
  ignoreCancelEvents: nr.default.bool,
  hashSpy: nr.default.bool,
  saveHashHistory: nr.default.bool,
  spyThrottle: nr.default.number
};
Zu.default = function(e, t) {
  var n = t || _G.default, r = function(i) {
    RG(s, i);
    function s(a) {
      IG(this, s);
      var l = jG(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return SG(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          sp.default.isMounted(a) || sp.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (Xi.default.isMounted() || Xi.default.mount(n), Xi.default.mapContainer(this.props.to, a)), sp.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        sp.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = ip({}, this.props.style, this.props.activeStyle) : l = ip({}, this.props.style);
        var u = ip({}, this.props);
        for (var c in xM)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, CM.default.createElement(e, u);
      }
    }]), s;
  }(CM.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, ip({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Xi.default.isMounted() && !Xi.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, h = void 0;
        if (u) {
          var y = 0, f = 0, g = 0;
          if (l.getBoundingClientRect) {
            var x = l.getBoundingClientRect();
            g = x.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var L = p.getBoundingClientRect();
            y = L.left - g + s, f = y + L.width;
          }
          var E = s - i.props.offset;
          d = E >= Math.floor(y) && E < Math.floor(f), h = E < Math.floor(y) || E >= Math.floor(f);
        } else {
          var T = 0, b = 0, C = 0;
          if (l.getBoundingClientRect) {
            var M = l.getBoundingClientRect();
            C = M.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var S = p.getBoundingClientRect();
            T = S.top - C + a, b = T + S.height;
          }
          var F = a - i.props.offset;
          d = F >= Math.floor(T) && F < Math.floor(b), h = F < Math.floor(T) || F >= Math.floor(b);
        }
        var D = n.getActiveLink();
        if (h) {
          if (c === D && n.setActiveLink(void 0), i.props.hashSpy && Xi.default.getHash() === c) {
            var Z = i.props.saveHashHistory, U = Z === void 0 ? !1 : Z;
            Xi.default.changeHash("", U);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (D !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, N = $ === void 0 ? !1 : $;
          i.props.hashSpy && Xi.default.changeHash(c, N), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = xM, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Mb, "__esModule", {
  value: !0
});
var NG = Ae, EM = oj(NG), FG = Zu, zG = oj(FG);
function oj(e) {
  return e && e.__esModule ? e : { default: e };
}
function UG(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function LM(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function $G(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var WG = function(e) {
  $G(t, e);
  function t() {
    var n, r, o, i;
    UG(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = LM(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return EM.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), LM(o, i);
  }
  return t;
}(EM.default.Component);
Mb.default = (0, zG.default)(WG);
var Ab = {};
Object.defineProperty(Ab, "__esModule", {
  value: !0
});
var HG = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), VG = Ae, kM = ij(VG), ZG = Zu, qG = ij(ZG);
function ij(e) {
  return e && e.__esModule ? e : { default: e };
}
function GG(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function XG(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function YG(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var JG = function(e) {
  YG(t, e);
  function t() {
    return GG(this, t), XG(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return HG(t, [{
    key: "render",
    value: function() {
      return kM.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(kM.default.Component);
Ab.default = (0, qG.default)(JG);
var Bb = {}, $f = {};
Object.defineProperty($f, "__esModule", {
  value: !0
});
var KG = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, QG = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), eX = Ae, OM = Wf(eX), tX = qa;
Wf(tX);
var nX = Ja, MM = Wf(nX), rX = zf, SM = Wf(rX);
function Wf(e) {
  return e && e.__esModule ? e : { default: e };
}
function oX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function iX(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function sX(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
$f.default = function(e) {
  var t = function(n) {
    sX(r, n);
    function r(o) {
      oX(this, r);
      var i = iX(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return QG(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        MM.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        MM.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return OM.default.createElement(e, KG({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(OM.default.Component);
  return t.propTypes = {
    name: SM.default.string,
    id: SM.default.string
  }, t;
};
Object.defineProperty(Bb, "__esModule", {
  value: !0
});
var DM = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, aX = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), lX = Ae, PM = Ib(lX), uX = $f, cX = Ib(uX), pX = zf, TM = Ib(pX);
function Ib(e) {
  return e && e.__esModule ? e : { default: e };
}
function dX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fX(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function hX(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var sj = function(e) {
  hX(t, e);
  function t() {
    return dX(this, t), fX(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return aX(t, [{
    key: "render",
    value: function() {
      var n = this, r = DM({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, PM.default.createElement(
        "div",
        DM({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(PM.default.Component);
sj.propTypes = {
  name: TM.default.string,
  id: TM.default.string
};
Bb.default = (0, cX.default)(sj);
var nm = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, _M = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function AM(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function BM(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function IM(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ap = Ae, qs = qu, rm = Ja, br = zf, Yi = Uf, jM = {
  to: br.string.isRequired,
  containerId: br.string,
  container: br.object,
  activeClass: br.string,
  spy: br.bool,
  smooth: br.oneOfType([br.bool, br.string]),
  offset: br.number,
  delay: br.number,
  isDynamic: br.bool,
  onClick: br.func,
  duration: br.oneOfType([br.number, br.func]),
  absolute: br.bool,
  onSetActive: br.func,
  onSetInactive: br.func,
  ignoreCancelEvents: br.bool,
  hashSpy: br.bool,
  spyThrottle: br.number
}, gX = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || rm, r = function(i) {
      IM(s, i);
      function s(a) {
        AM(this, s);
        var l = BM(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return _M(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            qs.isMounted(a) || qs.mount(a, this.props.spyThrottle), this.props.hashSpy && (Yi.isMounted() || Yi.mount(n), Yi.mapContainer(this.props.to, a)), this.props.spy && qs.addStateHandler(this.stateHandler), qs.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          qs.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = nm({}, this.props);
          for (var u in jM)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, ap.createElement(e, l);
        }
      }]), s;
    }(ap.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, nm({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(Yi.isMounted() && !Yi.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var h = a.getBoundingClientRect();
            d = h.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var y = u.getBoundingClientRect();
            c = y.top - d + s, p = c + y.height;
          }
          var f = s - i.props.offset, g = f >= Math.floor(c) && f < Math.floor(p), x = f < Math.floor(c) || f >= Math.floor(p), L = n.getActiveLink();
          if (x)
            return l === L && n.setActiveLink(void 0), i.props.hashSpy && Yi.getHash() === l && Yi.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), qs.updateStates();
          if (g && L !== l)
            return n.setActiveLink(l), i.props.hashSpy && Yi.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), qs.updateStates();
        }
      };
    };
    return r.propTypes = jM, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      IM(r, n);
      function r(o) {
        AM(this, r);
        var i = BM(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return _M(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          rm.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          rm.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return ap.createElement(e, nm({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(ap.Component);
    return t.propTypes = {
      name: br.string,
      id: br.string
    }, t;
  }
}, mX = gX;
Object.defineProperty(Sr, "__esModule", {
  value: !0
});
Sr.Helpers = Sr.ScrollElement = Sr.ScrollLink = Sr.animateScroll = Sr.scrollSpy = Sr.Events = Sr.scroller = Sr.Element = Sr.Button = Sr.Link = void 0;
var vX = Mb, aj = hi(vX), yX = Ab, lj = hi(yX), bX = Bb, uj = hi(bX), wX = Ja, cj = hi(wX), CX = Yu, pj = hi(CX), xX = qu, dj = hi(xX), EX = Rf, fj = hi(EX), LX = Zu, hj = hi(LX), kX = $f, gj = hi(kX), OX = mX, mj = hi(OX);
function hi(e) {
  return e && e.__esModule ? e : { default: e };
}
Sr.Link = aj.default;
Sr.Button = lj.default;
Sr.Element = uj.default;
Sr.scroller = cj.default;
Sr.Events = pj.default;
Sr.scrollSpy = dj.default;
Sr.animateScroll = fj.default;
Sr.ScrollLink = hj.default;
Sr.ScrollElement = gj.default;
Sr.Helpers = mj.default;
Sr.default = { Link: aj.default, Button: lj.default, Element: uj.default, scroller: cj.default, Events: pj.default, scrollSpy: dj.default, animateScroll: fj.default, ScrollLink: hj.default, ScrollElement: gj.default, Helpers: mj.default };
qe({});
qe({});
qe({});
let MX = { data: "" }, SX = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || MX, DX = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, PX = /\/\*[^]*?\*\/|  +/g, RM = /\n+/g, vs = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? vs(s, i) : i + "{" + vs(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += vs(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += vs.p ? vs.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ei = {}, vj = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + vj(e[n]);
    return t;
  }
  return e;
}, TX = (e, t, n, r, o) => {
  let i = vj(e), s = Ei[i] || (Ei[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ei[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = DX.exec(u.replace(PX, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(RM, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(RM, " ").trim();
      return d[0];
    })(e);
    Ei[s] = vs(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Ei.g ? Ei.g : null;
  return n && (Ei.g = Ei[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ei[s], t, r, a), s;
}, _X = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : vs(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function Hf(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return TX(n.unshift ? n.raw ? _X(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, SX(t.target), t.g, t.o, t.k);
}
let yj, my, vy;
Hf.bind({ g: 1 });
let ji = Hf.bind({ k: 1 });
function AX(e, t, n, r) {
  vs.p = t, yj = e, my = n, vy = r;
}
function Ps(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: my && my() }, a), n.o = / *go\d+/.test(l), a.className = Hf.apply(n, r) + (l ? " " + l : ""), t && (a.ref = s);
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), vy && u[0] && vy(a), yj(u, a);
    }
    return t ? t(o) : o;
  };
}
var BX = (e) => typeof e == "function", IX = (e, t) => BX(e) ? e(t) : e, jX = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), RX = ji`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, NX = ji`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, FX = ji`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, zX = Ps("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${RX} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${NX} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${FX} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, UX = ji`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, $X = Ps("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${UX} 1s linear infinite;
`, WX = ji`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, HX = ji`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, VX = Ps("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${WX} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${HX} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, ZX = Ps("div")`
  position: absolute;
`, qX = Ps("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, GX = ji`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, XX = Ps("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${GX} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, YX = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? He.createElement(XX, null, t) : t : n === "blank" ? null : He.createElement(qX, null, He.createElement($X, { ...r }), n !== "loading" && He.createElement(ZX, null, n === "error" ? He.createElement(zX, { ...r }) : He.createElement(VX, { ...r })));
}, JX = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, KX = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, QX = "0%{opacity:0;} 100%{opacity:1;}", eY = "0%{opacity:1;} 100%{opacity:0;}", tY = Ps("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, nY = Ps("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, rY = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = jX() ? [QX, eY] : [JX(n), KX(n)];
  return { animation: t ? `${ji(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ji(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
He.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? rY(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = He.createElement(YX, { toast: e }), s = He.createElement(nY, { ...e.ariaProps }, IX(e.message, e));
  return He.createElement(tY, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : He.createElement(He.Fragment, null, i, s));
});
AX(He.createElement);
Hf`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
qe({});
var Hi = {};
Object.defineProperty(Hi, "__esModule", {
  value: !0
});
var oY = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), om = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, bj = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: oY ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, jb = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var lp = 1; lp < 20; lp++)
  jb["f" + lp] = 111 + lp;
function Vf(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return wj(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return Cj(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function iY(e, t) {
  return Vf(e, t);
}
function sY(e, t) {
  return Vf(e, { byKey: !0 }, t);
}
function wj(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in om)
    r[om[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, h = d.endsWith("?") && d.length > 1;
      h && (d = d.slice(0, -1));
      var y = Rb(d), f = om[y];
      if (d.length > 1 && !f && !bj[d] && !jb[y])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !f) && (n ? r.key = y : r.which = xj(d)), f && (r[f] = h ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Cj(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function xj(e) {
  e = Rb(e);
  var t = jb[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function Rb(e) {
  return e = e.toLowerCase(), e = bj[e] || e, e;
}
Hi.default = Vf;
var im = Hi.isHotkey = Vf;
Hi.isCodeHotkey = iY;
Hi.isKeyHotkey = sY;
Hi.parseHotkey = wj;
Hi.compareHotkey = Cj;
Hi.toKeyCode = xj;
Hi.toKeyName = Rb;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function NM(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Yr(e) {
  var t, n;
  return NM(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(NM(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Ej = Symbol.for("immer-nothing"), FM = Symbol.for("immer-draftable"), Ao = Symbol.for("immer-state"), aY = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function co(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = aY[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var $a = Object.getPrototypeOf;
function ka(e) {
  return !!e && !!e[Ao];
}
function Oa(e) {
  var t;
  return e ? Lj(e) || Array.isArray(e) || !!e[FM] || !!((t = e.constructor) != null && t[FM]) || qf(e) || Gf(e) : !1;
}
var lY = Object.prototype.constructor.toString();
function Lj(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = $a(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === lY;
}
function _d(e, t) {
  Zf(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Zf(e) {
  const t = e[Ao];
  return t ? t.type_ : Array.isArray(e) ? 1 : qf(e) ? 2 : Gf(e) ? 3 : 0;
}
function yy(e, t) {
  return Zf(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function kj(e, t, n) {
  const r = Zf(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function uY(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function qf(e) {
  return e instanceof Map;
}
function Gf(e) {
  return e instanceof Set;
}
function ea(e) {
  return e.copy_ || e.base_;
}
function by(e, t) {
  if (qf(e))
    return new Map(e);
  if (Gf(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Lj(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ao];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create($a(e), r);
  } else {
    const r = $a(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Nb(e, t = !1) {
  return Xf(e) || ka(e) || !Oa(e) || (Zf(e) > 1 && (e.set = e.add = e.clear = e.delete = cY), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Nb(r, !0))), e;
}
function cY() {
  co(2);
}
function Xf(e) {
  return Object.isFrozen(e);
}
var pY = {};
function Ma(e) {
  const t = pY[e];
  return t || co(0, e), t;
}
var Cu;
function Oj() {
  return Cu;
}
function dY(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function zM(e, t) {
  t && (Ma("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function wy(e) {
  Cy(e), e.drafts_.forEach(fY), e.drafts_ = null;
}
function Cy(e) {
  e === Cu && (Cu = e.parent_);
}
function UM(e) {
  return Cu = dY(Cu, e);
}
function fY(e) {
  const t = e[Ao];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function $M(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ao].modified_ && (wy(t), co(4)), Oa(e) && (e = Ad(t, e), t.parent_ || Bd(t, e)), t.patches_ && Ma("Patches").generateReplacementPatches_(
    n[Ao].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Ad(t, n, []), wy(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== Ej ? e : void 0;
}
function Ad(e, t, n) {
  if (Xf(t))
    return t;
  const r = t[Ao];
  if (!r)
    return _d(
      t,
      (o, i) => WM(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Bd(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), _d(
      i,
      (a, l) => WM(e, r, o, a, l, n, s)
    ), Bd(e, o, !1), n && e.patches_ && Ma("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function WM(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && co(5), ka(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !yy(t.assigned_, r) ? i.concat(r) : void 0, l = Ad(e, o, a);
    if (kj(n, r, l), ka(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (Oa(o) && !Xf(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Ad(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Bd(e, o);
  }
}
function Bd(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Nb(t, n);
}
function hY(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Oj(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Fb;
  n && (o = [r], i = xu);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var Fb = {
  get(e, t) {
    if (t === Ao)
      return e;
    const n = ea(e);
    if (!yy(n, t))
      return gY(e, n, t);
    const r = n[t];
    return e.finalized_ || !Oa(r) ? r : r === sm(e.base_, t) ? (am(e), e.copy_[t] = Ey(r, e)) : r;
  },
  has(e, t) {
    return t in ea(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(ea(e));
  },
  set(e, t, n) {
    const r = Mj(ea(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = sm(ea(e), t), i = o == null ? void 0 : o[Ao];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (uY(n, o) && (n !== void 0 || yy(e.base_, t)))
        return !0;
      am(e), xy(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return sm(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, am(e), xy(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = ea(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    co(11);
  },
  getPrototypeOf(e) {
    return $a(e.base_);
  },
  setPrototypeOf() {
    co(12);
  }
}, xu = {};
_d(Fb, (e, t) => {
  xu[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
xu.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && co(13), xu.set.call(this, e, t, void 0);
};
xu.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && co(14), Fb.set.call(this, e[0], t, n, e[0]);
};
function sm(e, t) {
  const n = e[Ao];
  return (n ? ea(n) : e)[t];
}
function gY(e, t, n) {
  var r;
  const o = Mj(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Mj(e, t) {
  if (!(t in e))
    return;
  let n = $a(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = $a(n);
  }
}
function xy(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && xy(e.parent_));
}
function am(e) {
  e.copy_ || (e.copy_ = by(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var mY = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && co(6), r !== void 0 && typeof r != "function" && co(7);
      let o;
      if (Oa(t)) {
        const i = UM(this), s = Ey(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? wy(i) : Cy(i);
        }
        return zM(i, r), $M(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === Ej && (o = void 0), this.autoFreeze_ && Nb(o, !0), r) {
          const i = [], s = [];
          Ma("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        co(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Oa(e) || co(8), ka(e) && (e = vY(e));
    const t = UM(this), n = Ey(e, void 0);
    return n[Ao].isManual_ = !0, Cy(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ao];
    (!n || !n.isManual_) && co(9);
    const { scope_: r } = n;
    return zM(r, t), $M(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Ma("Patches").applyPatches_;
    return ka(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Ey(e, t) {
  const n = qf(e) ? Ma("MapSet").proxyMap_(e, t) : Gf(e) ? Ma("MapSet").proxySet_(e, t) : hY(e, t);
  return (t ? t.scope_ : Oj()).drafts_.push(n), n;
}
function vY(e) {
  return ka(e) || co(10, e), Sj(e);
}
function Sj(e) {
  if (!Oa(e) || Xf(e))
    return e;
  const t = e[Ao];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = by(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = by(e, !0);
  return _d(n, (r, o) => {
    kj(n, r, Sj(o));
  }), t && (t.finalized_ = !1), n;
}
var Bo = new mY(), zb = Bo.produce;
Bo.produceWithPatches.bind(
  Bo
);
Bo.setAutoFreeze.bind(Bo);
Bo.setUseStrictShallowCopy.bind(Bo);
Bo.applyPatches.bind(Bo);
var HM = Bo.createDraft.bind(Bo), VM = Bo.finishDraft.bind(Bo), Ne = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ne.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Ne.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ne.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Ne.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ne.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ne.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ne.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ne.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ne.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ne.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ne.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ne.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ne.isAncestor(t, e) && !Ne.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ne.equals(i, r) || Ne.endsBefore(i, r) || Ne.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (Ne.equals(s, r) || Ne.isAncestor(s, r))
          return null;
        Ne.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        Ne.equals(a, r) || Ne.endsBefore(a, r) ? r[a.length - 1] -= 1 : Ne.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ne.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ne.endsBefore(u, r) ? r[u.length - 1] += 1 : Ne.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ne.equals(p, d))
          return r;
        if (Ne.isAncestor(p, r) || Ne.equals(p, r)) {
          var h = d.slice();
          return Ne.endsBefore(p, d) && p.length < d.length && (h[p.length - 1] -= 1), h.concat(r.slice(p.length));
        } else Ne.isSibling(p, d) && (Ne.isAncestor(d, r) || Ne.equals(d, r)) ? Ne.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ne.endsBefore(d, r) || Ne.equals(d, r) || Ne.isAncestor(d, r) ? (Ne.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ne.endsBefore(p, r) && (Ne.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Eu(e) {
  "@babel/helpers - typeof";
  return Eu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Eu(e);
}
function yY(e, t) {
  if (Eu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Eu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function bY(e) {
  var t = yY(e, "string");
  return Eu(t) === "symbol" ? t : String(t);
}
function Ka(e, t, n) {
  return t = bY(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function ZM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ml(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZM(Object(n), !0).forEach(function(r) {
      Ka(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wY = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = dt.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of Et.points(t))
          t[l] = Hn.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = dt.leaf(e, u), h = d.text.slice(0, c), y = d.text.slice(c);
      if (d.text = h + p + y, t)
        for (var [f, g] of Et.points(t))
          t[g] = Hn.transform(f, n);
      break;
    }
    case "merge_node": {
      var {
        path: x
      } = n, L = dt.get(e, x), E = Ne.previous(x), T = dt.get(e, E), b = dt.parent(e, x), C = x[x.length - 1];
      if (kr.isText(L) && kr.isText(T))
        T.text += L.text;
      else if (!kr.isText(L) && !kr.isText(T))
        T.children.push(...L.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(x, "] to nodes of different interfaces: ").concat(Co.stringify(L), " ").concat(Co.stringify(T)));
      if (b.children.splice(C, 1), t)
        for (var [M, S] of Et.points(t))
          t[S] = Hn.transform(M, n);
      break;
    }
    case "move_node": {
      var {
        path: F,
        newPath: D
      } = n;
      if (Ne.isAncestor(F, D))
        throw new Error("Cannot move a path [".concat(F, "] to new path [").concat(D, "] because the destination is inside itself."));
      var Z = dt.get(e, F), U = dt.parent(e, F), $ = F[F.length - 1];
      U.children.splice($, 1);
      var N = Ne.transform(F, n), V = dt.get(e, Ne.parent(N)), J = N[N.length - 1];
      if (V.children.splice(J, 0, Z), t)
        for (var [j, K] of Et.points(t))
          t[K] = Hn.transform(j, n);
      break;
    }
    case "remove_node": {
      var {
        path: te
      } = n, O = te[te.length - 1], P = dt.parent(e, te);
      if (P.children.splice(O, 1), t)
        for (var [H, I] of Et.points(t)) {
          var W = Hn.transform(H, n);
          if (t != null && W != null)
            t[I] = W;
          else {
            var X = void 0, w = void 0;
            for (var [R, z] of dt.texts(e))
              if (Ne.compare(z, te) === -1)
                X = [R, z];
              else {
                w = [R, z];
                break;
              }
            var _ = !1;
            X && w && (Ne.equals(w[1], te) ? _ = !Ne.hasPrevious(w[1]) : _ = Ne.common(X[1], te).length < Ne.common(w[1], te).length), X && !_ ? (H.path = X[1], H.offset = X[0].text.length) : w ? (H.path = w[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: Y,
        offset: Q,
        text: A
      } = n;
      if (A.length === 0) break;
      var ae = dt.leaf(e, Y), ce = ae.text.slice(0, Q), ue = ae.text.slice(Q + A.length);
      if (ae.text = ce + ue, t)
        for (var [de, be] of Et.points(t))
          t[be] = Hn.transform(de, n);
      break;
    }
    case "set_node": {
      var {
        path: ve,
        properties: ge,
        newProperties: se
      } = n;
      if (ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var xe = dt.get(e, ve);
      for (var ne in se) {
        if (ne === "children" || ne === "text")
          throw new Error('Cannot set the "'.concat(ne, '" property of nodes!'));
        var Me = se[ne];
        Me == null ? delete xe[ne] : xe[ne] = Me;
      }
      for (var ee in ge)
        se.hasOwnProperty(ee) || delete xe[ee];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Ce
      } = n;
      if (Ce == null)
        t = Ce;
      else {
        if (t == null) {
          if (!Et.isRange(Ce))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Co.stringify(Ce), " when there is no current selection."));
          t = Ml({}, Ce);
        }
        for (var Be in Ce) {
          var _e = Ce[Be];
          if (_e == null) {
            if (Be === "anchor" || Be === "focus")
              throw new Error('Cannot remove the "'.concat(Be, '" selection property'));
            delete t[Be];
          } else
            t[Be] = _e;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: $e,
        position: he,
        properties: Ge
      } = n;
      if ($e.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat($e, "] because the root node cannot be split."));
      var We = dt.get(e, $e), Ut = dt.parent(e, $e), ot = $e[$e.length - 1], st;
      if (kr.isText(We)) {
        var Zt = We.text.slice(0, he), qt = We.text.slice(he);
        We.text = Zt, st = Ml(Ml({}, Ge), {}, {
          text: qt
        });
      } else {
        var Gt = We.children.slice(0, he), Xt = We.children.slice(he);
        We.children = Gt, st = Ml(Ml({}, Ge), {}, {
          children: Xt
        });
      }
      if (Ut.children.splice(ot + 1, 0, st), t)
        for (var [et, bt] of Et.points(t))
          t[bt] = Hn.transform(et, n);
      break;
    }
  }
  return t;
}, CY = {
  transform(e, t) {
    e.children = HM(e.children);
    var n = e.selection && HM(e.selection);
    try {
      n = wY(e, n, t);
    } finally {
      e.children = VM(e.children), n ? e.selection = ka(n) ? VM(n) : n : e.selection = null;
    }
  }
}, xY = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, EY = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Dj = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Yr(r) && Yr(o)) {
      if (!Dj(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function LY(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Lu(e, t) {
  if (e == null) return {};
  var n = LY(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var kY = ["anchor", "focus"];
function qM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function OY(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qM(Object(n), !0).forEach(function(r) {
      Ka(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Et = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Et.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Et.edges(e);
    return t;
  },
  equals(e, t) {
    return Hn.equals(e.anchor, t.anchor) && Hn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Et.isRange(t)) {
      if (Et.includes(e, t.anchor) || Et.includes(e, t.focus))
        return !0;
      var [n, r] = Et.edges(e), [o, i] = Et.edges(t);
      return Hn.isBefore(n, o) && Hn.isAfter(r, i);
    }
    var [s, a] = Et.edges(e), l = !1, u = !1;
    return Hn.isPoint(t) ? (l = Hn.compare(t, s) >= 0, u = Hn.compare(t, a) <= 0) : (l = Ne.compare(t, s.path) >= 0, u = Ne.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Lu(e, kY), [r, o] = Et.edges(e), [i, s] = Et.edges(t), a = Hn.isBefore(r, i) ? i : r, l = Hn.isBefore(o, s) ? o : s;
    return Hn.isBefore(l, a) ? null : OY({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Hn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Hn.equals(t, n);
  },
  isExpanded(e) {
    return !Et.isCollapsed(e);
  },
  isForward(e) {
    return !Et.isBackward(e);
  },
  isRange(e) {
    return Yr(e) && Hn.isPoint(e.anchor) && Hn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Et.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return zb(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = Et.isCollapsed(r);
        Et.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? Et.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = Hn.transform(r.anchor, t, {
        affinity: i
      }), u = Hn.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, GM = (e) => Yr(e) && dt.isNodeList(e.children) && !On.isEditor(e), _i = {
  isAncestor(e) {
    return Yr(e) && dt.isNodeList(e.children);
  },
  isElement: GM,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => _i.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return GM(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, MY = ["children"], SY = ["text"], XM = /* @__PURE__ */ new WeakMap(), dt = {
  ancestor(e, t) {
    var n = dt.get(e, t);
    if (kr.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Co.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ne.ancestors(t, n)) {
        var o = dt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (kr.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Co.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Co.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = dt.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = dt.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ne.common(t, n), o = dt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = dt.get(e, t);
    if (On.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Co.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of dt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of dt.nodes(e, t))
        _i.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (_i.isAncestor(e)) {
      var t = Lu(e, MY);
      return t;
    } else {
      var t = Lu(e, SY);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = dt.get(e, n); r && !(kr.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (kr.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Co.stringify(e)));
    var n = zb({
      children: e.children
    }, (r) => {
      var [o, i] = Et.edges(t), s = dt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, h] = d;
          return !Et.includes(t, h);
        }
      });
      for (var [, a] of s) {
        if (!Et.includes(t, a)) {
          var l = dt.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (Ne.equals(a, i.path)) {
          var c = dt.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ne.equals(a, o.path)) {
          var p = dt.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      On.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (kr.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Co.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (kr.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return kr.isText(e) || _i.isElement(e) || On.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = XM.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => dt.isNode(r));
    return XM.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = dt.get(e, n); r && !(kr.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = dt.get(e, t);
    if (!kr.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Co.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ne.levels(t, n)) {
        var o = dt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return _i.isElement(e) && _i.isElementProps(t) && _i.matches(e, t) || kr.isText(e) && kr.isTextProps(t) && kr.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? Ne.isBefore(a, i) : Ne.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !kr.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ne.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = dt.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = Ne.next(a);
          if (dt.has(e, c)) {
            a = c, l = dt.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = Ne.previous(a);
          a = p, l = dt.get(e, a);
          continue;
        }
        a = Ne.parent(a), l = dt.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ne.parent(t), r = dt.get(e, n);
    if (kr.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return kr.isText(e) ? e.text : e.children.map(dt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of dt.nodes(e, t))
        kr.isText(n) && (yield [n, r]);
    }();
  }
};
function YM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YM(Object(n), !0).forEach(function(r) {
      Ka(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jl = {
  isNodeOperation(e) {
    return jl.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Yr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ne.isPath(e.path) && dt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ne.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ne.isPath(e.path) && Yr(e.properties);
      case "move_node":
        return Ne.isPath(e.path) && Ne.isPath(e.newPath);
      case "remove_node":
        return Ne.isPath(e.path) && dt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ne.isPath(e.path);
      case "set_node":
        return Ne.isPath(e.path) && Yr(e.properties) && Yr(e.newProperties);
      case "set_selection":
        return e.properties === null && Et.isRange(e.newProperties) || e.newProperties === null && Et.isRange(e.properties) || Yr(e.properties) && Yr(e.newProperties);
      case "split_node":
        return Ne.isPath(e.path) && typeof e.position == "number" && Yr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => jl.isOperation(t));
  },
  isSelectionOperation(e) {
    return jl.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return jl.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return rr(rr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return rr(rr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return rr(rr({}, e), {}, {
          type: "split_node",
          path: Ne.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ne.equals(t, n))
          return e;
        if (Ne.isSibling(n, t))
          return rr(rr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ne.transform(n, e), o = Ne.transform(Ne.next(n), e);
        return rr(rr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return rr(rr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return rr(rr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return rr(rr({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? rr(rr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? rr(rr({}, e), {}, {
          properties: null,
          newProperties: a
        }) : rr(rr({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return rr(rr({}, e), {}, {
          type: "merge_node",
          path: Ne.next(e.path)
        });
    }
  }
}, JM = /* @__PURE__ */ new WeakMap(), DY = (e) => {
  var t = JM.get(e);
  if (t !== void 0)
    return t;
  if (!Yr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Yr(e.marks)) && (e.selection === null || Et.isRange(e.selection)) && dt.isNodeList(e.children) && jl.isOperationList(e.operations);
  return JM.set(e, n), n;
}, On = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return DY(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function KM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function QM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KM(Object(n), !0).forEach(function(r) {
      Ka(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Hn = {
  compare(e, t) {
    var n = Ne.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Hn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Hn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ne.equals(e.path, t.path);
  },
  isPoint(e) {
    return Yr(e) && typeof e.offset == "number" && Ne.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return zb(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ne.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ne.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ne.equals(t.path, i) && (r.offset += t.position), r.path = Ne.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ne.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ne.equals(t.path, i) || Ne.isAncestor(t.path, i))
            return null;
          r.path = Ne.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ne.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = Ne.transform(i, t, QM(QM({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ne.transform(i, t, n);
          break;
        }
      }
    });
  }
}, eS = void 0, Co = {
  setScrubber(e) {
    eS = e;
  },
  stringify(e) {
    return JSON.stringify(e, eS);
  }
}, PY = ["text"], TY = ["anchor", "focus"];
function tS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Li(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tS(Object(n), !0).forEach(function(r) {
      Ka(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kr = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = Lu(i, PY);
      return s;
    }
    return Dj(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Yr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => kr.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Li({}, e)];
    for (var r of t) {
      var o = Lu(r, TY), [i, s] = Et.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, h = l;
        if (l += d, u <= h && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === h) || u > l || c < h || c === h && h !== 0) {
          a.push(p);
          continue;
        }
        var y = p, f = void 0, g = void 0;
        if (c < l) {
          var x = c - h;
          g = Li(Li({}, y), {}, {
            text: y.text.slice(x)
          }), y = Li(Li({}, y), {}, {
            text: y.text.slice(0, x)
          });
        }
        if (u > h) {
          var L = u - h;
          f = Li(Li({}, y), {}, {
            text: y.text.slice(0, L)
          }), y = Li(Li({}, y), {}, {
            text: y.text.slice(L)
          });
        }
        Object.assign(y, o), f && a.push(f), a.push(y), g && a.push(g);
      }
      n = a;
    }
    return n;
  }
}, _Y = (e) => e.selection ? e.selection : e.children.length > 0 ? On.end(e, []) : [0], zn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(zn || (zn = {}));
zn.L, zn.L | zn.V | zn.LV | zn.LVT, zn.LV | zn.V, zn.V | zn.T, zn.LVT | zn.T, zn.T, zn.Any, zn.Extend | zn.ZWJ, zn.Any, zn.SpacingMark, zn.Prepend, zn.Any, zn.ZWJ, zn.ExtPict, zn.RI, zn.RI;
var AY = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    On.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = _Y(e)
      } = n;
      if (Ne.isPath(o) && (o = On.range(e, o)), Et.isRange(o))
        if (Et.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Et.end(o);
          if (!r && On.void(e, {
            at: i
          }))
            return;
          var s = Et.start(o), a = On.pointRef(e, s), l = On.pointRef(e, i);
          Id.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Id.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && On.void(e, {
        at: o
      }) || On.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function nS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function up(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nS(Object(n), !0).forEach(function(r) {
      Ka(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Id = up(up(up(up({}, CY), xY), EY), AY), BY = typeof Pn == "object" && Pn && Pn.Object === Object && Pn, IY = BY, jY = IY, RY = typeof self == "object" && self && self.Object === Object && self, NY = jY || RY || Function("return this")(), FY = NY, zY = FY, UY = zY.Symbol, Pj = UY, rS = Pj;
rS && rS.toStringTag;
var oS = Pj;
oS && oS.toStringTag;
var iS;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(iS || (iS = {}));
var Ub = function(e) {
  return Object.freeze(e);
}, $Y = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Ub(this);
  }
  return e;
}(), WY = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Ub(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), sS = typeof window < "u" ? window : {};
/msie|trident/i.test(sS.navigator && sS.navigator.userAgent);
var lm = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new $Y((n ? t : e) || 0, (n ? e : t) || 0);
};
Ub({
  devicePixelContentBoxSize: lm(),
  borderBoxSize: lm(),
  contentBoxSize: lm(),
  contentRect: new WY(0, 0, 0, 0)
});
function ku(e) {
  "@babel/helpers - typeof";
  return ku = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ku(e);
}
function HY(e, t) {
  if (ku(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (ku(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function VY(e) {
  var t = HY(e, "string");
  return ku(t) === "symbol" ? t : String(t);
}
function Kl(e, t, n) {
  return t = VY(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var ZY = /* @__PURE__ */ qe(null), um, cm;
parseInt(Ae.version.split(".")[0], 10);
var aS = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), pm = typeof navigator < "u" && /Android/.test(navigator.userAgent), cp = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), qY = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (um = navigator.userAgent.match(/Version\/(\d+)/)) !== null && um !== void 0 && um[1] && parseInt((cm = navigator.userAgent.match(/Version\/(\d+)/)) === null || cm === void 0 ? void 0 : cm[1], 10) < 17;
var GY = /* @__PURE__ */ new WeakMap(), XY = /* @__PURE__ */ new WeakMap(), YY = /* @__PURE__ */ new WeakMap(), JY = /* @__PURE__ */ new WeakMap(), KY = /* @__PURE__ */ new WeakMap(), lS = /* @__PURE__ */ new WeakMap(), QY = /* @__PURE__ */ new WeakMap(), uS = /* @__PURE__ */ new WeakMap(), pp = /* @__PURE__ */ new WeakMap(), eJ = /* @__PURE__ */ new WeakMap(), tJ = /* @__PURE__ */ new WeakMap(), nJ = /* @__PURE__ */ new WeakMap(), Tj = globalThis.Node, rJ = globalThis.Text, _j = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, oJ = (e) => jd(e) && e.nodeType === 8, li = (e) => jd(e) && e.nodeType === 1, jd = (e) => {
  var t = _j(e);
  return !!t && e instanceof t.Node;
}, cS = (e) => {
  var t = e && e.anchorNode && _j(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, iJ = (e) => {
  var [t, n] = e;
  if (li(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Aj(t, o, r ? "backward" : "forward"), r = o < n; li(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = aJ(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, sJ = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Aj = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (oJ(o) || li(o) && o.childNodes.length === 0 || li(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, aJ = (e, t, n) => {
  var [r] = Aj(e, t, n);
  return r;
}, pS = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Bj = (e, t, n) => {
  var {
    target: r
  } = t;
  if (li(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Ht.getWindow(e);
  if (o.contains(r))
    return Ht.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Bj(e, i, n);
}, dS = (e, t) => !!(e.compareDocumentPosition(t) & Tj.DOCUMENT_POSITION_PRECEDING), lJ = (e, t) => !!(e.compareDocumentPosition(t) & Tj.DOCUMENT_POSITION_FOLLOWING), uJ = 0;
class cJ {
  constructor() {
    Kl(this, "id", void 0), this.id = "".concat(uJ++);
  }
}
var Ht = {
  androidPendingDiffs: (e) => nJ.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = tJ.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Ht.toDOMNode(e, e), n = Ht.findDocumentOrShadowRoot(e);
    pp.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Ht.findDocumentOrShadowRoot(e), r = pS(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Id.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Ht.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Ht.toSlateNode(e, t.target), s = Ht.findPath(e, i);
    if (_i.isElement(i) && On.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = On.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? On.before(e, u) : On.after(e, u);
      if (c) {
        var p = On.range(e, c);
        return p;
      }
    }
    var d, {
      document: h
    } = Ht.getWindow(e);
    if (h.caretRangeFromPoint)
      d = h.caretRangeFromPoint(n, r);
    else {
      var y = h.caretPositionFromPoint(n, r);
      y && (d = h.createRange(), d.setStart(y.offsetNode, y.offset), d.setEnd(y.offsetNode, y.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var f = Ht.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return f;
  },
  findKey: (e, t) => {
    var n = lS.get(t);
    return n || (n = new cJ(), lS.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = XY.get(r);
      if (o == null) {
        if (On.isEditor(r))
          return n;
        break;
      }
      var i = GY.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Co.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!pp.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Ht.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Ht.toDOMNode(e, e), r = Ht.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = pS(r), i = Ht.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Id.select(e, On.start(e, [])), pp.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = YY.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Ht.toDOMNode(e, e), i;
    try {
      i = li(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => jd(t) && Ht.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return On.hasPath(e, n.path) && On.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Ht.hasEditableTarget(e, t) || Ht.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => jd(t) && Ht.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!eJ.get(e),
  isFocused: (e) => !!pp.get(e),
  isReadOnly: (e) => !!uS.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (uS.get(e)) return !1;
    var n = Ht.hasTarget(e, t) && Ht.toSlateNode(e, t);
    return _i.isElement(n) && On.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = QY.get(e), r = On.isEditor(t) ? JY.get(e) : n == null ? void 0 : n.get(Ht.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Co.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = On.node(e, t.path), r = Ht.toDOMNode(e, n), o;
    On.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), h = d == null ? p : parseInt(d, 10), y = a + h, f = s[l + 1];
        if (t.offset === y && f !== null && f !== void 0 && f.hasAttribute("data-slate-mark-placeholder")) {
          var g, x = f.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            x instanceof rJ ? x : f,
            (g = f.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= y) {
          var L = Math.min(p, Math.max(0, t.offset - a));
          o = [c, L];
          break;
        }
        a = y;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Co.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Et.isBackward(t), i = Ht.toDOMPoint(e, n), s = Et.isCollapsed(t) ? i : Ht.toDOMPoint(e, r), a = Ht.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, h = li(u) ? u : u.parentElement, y = !!h.getAttribute("data-slate-zero-width"), f = li(p) ? p : p.parentElement, g = !!f.getAttribute("data-slate-zero-width");
    return l.setStart(u, y ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = li(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? KY.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : iJ(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, h = Ht.toDOMNode(e, e), y = l.closest('[data-slate-void="true"]'), f = y && h.contains(y) ? y : null, g = l.closest('[contenteditable="false"]'), x = g && h.contains(g) ? g : null, L = l.closest("[data-slate-leaf]"), E = null;
      if (L) {
        if (u = L.closest('[data-slate-node="text"]'), u) {
          var T = Ht.getWindow(e), b = T.document.createRange();
          b.setStart(u, 0), b.setEnd(s, a);
          var C = b.cloneContents(), M = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          M.forEach((I) => {
            if (pm && !r && I.hasAttribute("data-slate-zero-width") && I.textContent.length > 0 && I.textContext !== "\uFEFF") {
              I.textContent.startsWith("\uFEFF") && (I.textContent = I.textContent.slice(1));
              return;
            }
            I.parentNode.removeChild(I);
          }), c = C.textContent.length, E = u;
        }
      } else if (f) {
        for (var S = f.querySelectorAll("[data-slate-leaf]"), F = 0; F < S.length; F++) {
          var D = S[F];
          if (Ht.hasDOMNode(e, D)) {
            L = D;
            break;
          }
        }
        L ? (u = L.closest('[data-slate-node="text"]'), E = L, c = E.textContent.length, E.querySelectorAll("[data-slate-zero-width]").forEach((I) => {
          c -= I.textContent.length;
        })) : c = 1;
      } else if (x) {
        var Z = (I) => I ? I.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], U = x.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, N = [...Z(U), ...Z(U == null ? void 0 : U.nextElementSibling)];
          L = ($ = N.find((I) => lJ(x, I))) !== null && $ !== void 0 ? $ : null;
        } else {
          var V, J = [...Z(U == null ? void 0 : U.previousElementSibling), ...Z(U)];
          L = (V = J.findLast((I) => dS(x, I))) !== null && V !== void 0 ? V : null;
        }
        L && (u = L.closest('[data-slate-node="text"]'), E = L, i === "forward" ? c = 0 : (c = E.textContent.length, E.querySelectorAll("[data-slate-zero-width]").forEach((I) => {
          c -= I.textContent.length;
        })));
      }
      E && c === E.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      pm && E.getAttribute("data-slate-zero-width") === "z" && (p = E.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      cp && (d = E.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (pm && !u && !r) {
      var j = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (j && Ht.hasDOMNode(e, j, {
        editable: !0
      })) {
        var K = Ht.toSlateNode(e, j), {
          path: te,
          offset: O
        } = On.start(e, Ht.findPath(e, K));
        return j.querySelector("[data-slate-leaf]") || (O = a), {
          path: te,
          offset: O
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var P = Ht.toSlateNode(e, u), H = Ht.findPath(e, P);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = cS(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (cS(t)) {
        if (cp && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), h = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && h.startContainer instanceof HTMLTableRowElement) {
            let C = function(M) {
              return M.childElementCount > 0 ? C(M.children[0]) : M;
            };
            var y = d.startContainer, f = h.startContainer, g = C(y.children[d.startOffset]), x = C(f.children[h.startOffset]);
            c = 0, x.childNodes.length > 0 ? a = x.childNodes[0] : a = x, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, x instanceof HTMLElement ? l = x.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = h.endContainer, l = h.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = h.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        qY && sJ(a) || cp ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    cp && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var L = Ht.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!L)
      return null;
    var E = dS(a, u) || a === u && c < l, T = p ? L : Ht.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: E ? "forward" : "backward"
    });
    if (!T)
      return null;
    var b = {
      anchor: L,
      focus: T
    };
    return Et.isExpanded(b) && Et.isForward(b) && li(u) && On.void(e, {
      at: b.focus,
      mode: "highest"
    }) && (b = On.unhangRange(e, b, {
      voids: !0
    })), b;
  }
}, pJ = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, dJ = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, fJ = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, or = (e) => {
  var t = pJ[e], n = dJ[e], r = fJ[e], o = t && im(t), i = n && im(n), s = r && im(r);
  return (a) => !!(o && o(a) || aS && i && i(a) || !aS && s && s(a));
};
or("bold"), or("compose"), or("moveBackward"), or("moveForward"), or("deleteBackward"), or("deleteForward"), or("deleteLineBackward"), or("deleteLineForward"), or("deleteWordBackward"), or("deleteWordForward"), or("extendBackward"), or("extendForward"), or("extendLineBackward"), or("extendLineForward"), or("italic"), or("moveLineBackward"), or("moveLineForward"), or("moveWordBackward"), or("moveWordForward"), or("redo"), or("insertSoftBreak"), or("splitBlock"), or("transposeCharacter"), or("undo");
var hJ = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => Bj(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, gJ = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class mJ extends Nu {
  constructor() {
    super(...arguments), Kl(this, "context", null), Kl(this, "manager", null), Kl(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, gJ);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = hJ(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Kl(mJ, "contextType", ZY);
var Ij = {}, $b = {}, Wb = {};
Object.defineProperty(Wb, "__esModule", { value: !0 });
Wb.default = wJ;
var fS = "html", hS = "head", dp = "body", vJ = /<([a-zA-Z]+[0-9]?)/, gS = /<head[^]*>/i, mS = /<body[^]*>/i, Rd = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Ly = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, vS = typeof window == "object" && window.DOMParser;
if (typeof vS == "function") {
  var yJ = new vS(), bJ = "text/html";
  Ly = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), yJ.parseFromString(e, bJ);
  }, Rd = Ly;
}
if (typeof document == "object" && document.implementation) {
  var fp = document.implementation.createHTMLDocument();
  Rd = function(e, t) {
    if (t) {
      var n = fp.documentElement.querySelector(t);
      return n && (n.innerHTML = e), fp;
    }
    return fp.documentElement.innerHTML = e, fp;
  };
}
var hp = typeof document == "object" && document.createElement("template"), ky;
hp && hp.content && (ky = function(e) {
  return hp.innerHTML = e, hp.content.childNodes;
});
function wJ(e) {
  var t, n, r = e.match(vJ), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case fS: {
      var i = Ly(e);
      if (!gS.test(e)) {
        var s = i.querySelector(hS);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!mS.test(e)) {
        var s = i.querySelector(dp);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(fS);
    }
    case hS:
    case dp: {
      var a = Rd(e).querySelectorAll(o);
      return mS.test(e) && gS.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (ky)
        return ky(e);
      var s = Rd(e, dp).querySelector(dp);
      return s.childNodes;
    }
  }
}
var Yf = {}, Hb = {}, Vb = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Vb);
var At = {}, Ts = Pn && Pn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Ql = Pn && Pn.__assign || function() {
  return Ql = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ql.apply(this, arguments);
};
Object.defineProperty(At, "__esModule", { value: !0 });
At.cloneNode = At.hasChildren = At.isDocument = At.isDirective = At.isComment = At.isText = At.isCDATA = At.isTag = At.Element = At.Document = At.CDATA = At.NodeWithChildren = At.ProcessingInstruction = At.Comment = At.Text = At.DataNode = At.Node = void 0;
var mo = Vb, Zb = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), qb(this, t);
    }, e;
  }()
);
At.Node = Zb;
var Jf = (
  /** @class */
  function(e) {
    Ts(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zb)
);
At.DataNode = Jf;
var jj = (
  /** @class */
  function(e) {
    Ts(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = mo.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Jf)
);
At.Text = jj;
var Rj = (
  /** @class */
  function(e) {
    Ts(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = mo.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Jf)
);
At.Comment = Rj;
var Nj = (
  /** @class */
  function(e) {
    Ts(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = mo.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Jf)
);
At.ProcessingInstruction = Nj;
var Kf = (
  /** @class */
  function(e) {
    Ts(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zb)
);
At.NodeWithChildren = Kf;
var Fj = (
  /** @class */
  function(e) {
    Ts(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = mo.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Kf)
);
At.CDATA = Fj;
var zj = (
  /** @class */
  function(e) {
    Ts(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = mo.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Kf)
);
At.Document = zj;
var Uj = (
  /** @class */
  function(e) {
    Ts(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? mo.ElementType.Script : n === "style" ? mo.ElementType.Style : mo.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Kf)
);
At.Element = Uj;
function $j(e) {
  return (0, mo.isTag)(e);
}
At.isTag = $j;
function Wj(e) {
  return e.type === mo.ElementType.CDATA;
}
At.isCDATA = Wj;
function Hj(e) {
  return e.type === mo.ElementType.Text;
}
At.isText = Hj;
function Vj(e) {
  return e.type === mo.ElementType.Comment;
}
At.isComment = Vj;
function Zj(e) {
  return e.type === mo.ElementType.Directive;
}
At.isDirective = Zj;
function qj(e) {
  return e.type === mo.ElementType.Root;
}
At.isDocument = qj;
function CJ(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
At.hasChildren = CJ;
function qb(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (Hj(e))
    n = new jj(e.data);
  else if (Vj(e))
    n = new Rj(e.data);
  else if ($j(e)) {
    var r = t ? dm(e.children) : [], o = new Uj(e.name, Ql({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Ql({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Ql({}, e["x-attribsPrefix"])), n = o;
  } else if (Wj(e)) {
    var r = t ? dm(e.children) : [], i = new Fj(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (qj(e)) {
    var r = t ? dm(e.children) : [], s = new zj(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (Zj(e)) {
    var a = new Nj(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
At.cloneNode = qb;
function dm(e) {
  for (var t = e.map(function(r) {
    return qb(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Pn && Pn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = Pn && Pn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Vb, o = At;
  n(At, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(Hb);
var Gj = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(Gj);
Object.defineProperty(Yf, "__esModule", { value: !0 });
Yf.formatAttributes = Xj;
Yf.formatDOM = Yj;
var gp = Hb, xJ = Gj;
function EJ(e) {
  return xJ.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function Xj(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function LJ(e) {
  e = e.toLowerCase();
  var t = EJ(e);
  return t || e;
}
function Yj(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = LJ(a.nodeName);
        o = new gp.Element(l, Xj(a.attributes)), o.children = Yj(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new gp.Text(a.nodeValue);
        break;
      case 8:
        o = new gp.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new gp.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var kJ = Pn && Pn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty($b, "__esModule", { value: !0 });
$b.default = DJ;
var OJ = kJ(Wb), MJ = Yf, SJ = /<(![a-zA-Z\s]+)>/;
function DJ(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(SJ), n = t ? t[1] : void 0;
  return (0, MJ.formatDOM)((0, OJ.default)(e), null, n);
}
var Qf = {}, Yo = {}, eh = {}, PJ = 0;
eh.SAME = PJ;
var TJ = 1;
eh.CAMELCASE = TJ;
eh.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const Jj = 0, _s = 1, th = 2, nh = 3, Gb = 4, Kj = 5, Qj = 6;
function _J(e) {
  return Vr.hasOwnProperty(e) ? Vr[e] : null;
}
function ro(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === th || t === nh || t === Gb, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const Vr = {}, AJ = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
AJ.forEach((e) => {
  Vr[e] = new ro(
    e,
    Jj,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Vr[e] = new ro(
    e,
    _s,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Vr[e] = new ro(
    e,
    th,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Vr[e] = new ro(
    e,
    th,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Vr[e] = new ro(
    e,
    nh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Vr[e] = new ro(
    e,
    nh,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Vr[e] = new ro(
    e,
    Gb,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Vr[e] = new ro(
    e,
    Qj,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Vr[e] = new ro(
    e,
    Kj,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Xb = /[\-\:]([a-z])/g, Yb = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Xb, Yb);
  Vr[t] = new ro(
    t,
    _s,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Xb, Yb);
  Vr[t] = new ro(
    t,
    _s,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Xb, Yb);
  Vr[t] = new ro(
    t,
    _s,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Vr[e] = new ro(
    e,
    _s,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const BJ = "xlinkHref";
Vr[BJ] = new ro(
  "xlinkHref",
  _s,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Vr[e] = new ro(
    e,
    _s,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: IJ,
  SAME: jJ,
  possibleStandardNames: yS
} = eh, RJ = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", NJ = RJ + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", FJ = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + NJ + "]*$")
), zJ = Object.keys(
  yS
).reduce((e, t) => {
  const n = yS[t];
  return n === jJ ? e[t] = t : n === IJ ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Yo.BOOLEAN = nh;
Yo.BOOLEANISH_STRING = th;
Yo.NUMERIC = Kj;
Yo.OVERLOADED_BOOLEAN = Gb;
Yo.POSITIVE_NUMERIC = Qj;
Yo.RESERVED = Jj;
Yo.STRING = _s;
Yo.getPropertyInfo = _J;
Yo.isCustomAttribute = FJ;
Yo.possibleStandardNames = zJ;
var Jb = {}, Kb = {}, bS = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, UJ = /\n/g, $J = /^\s*/, WJ = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, HJ = /^:\s*/, VJ = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, ZJ = /^[;\s]*/, qJ = /^\s+|\s+$/g, GJ = `
`, wS = "/", CS = "*", sa = "", XJ = "comment", YJ = "declaration", JJ = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(y) {
    var f = y.match(UJ);
    f && (n += f.length);
    var g = y.lastIndexOf(GJ);
    r = ~g ? y.length - g : r + y.length;
  }
  function i() {
    var y = { line: n, column: r };
    return function(f) {
      return f.position = new s(y), u(), f;
    };
  }
  function s(y) {
    this.start = y, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(y) {
    var f = new Error(
      t.source + ":" + n + ":" + r + ": " + y
    );
    if (f.reason = y, f.filename = t.source, f.line = n, f.column = r, f.source = e, !t.silent) throw f;
  }
  function l(y) {
    var f = y.exec(e);
    if (f) {
      var g = f[0];
      return o(g), e = e.slice(g.length), f;
    }
  }
  function u() {
    l($J);
  }
  function c(y) {
    var f;
    for (y = y || []; f = p(); )
      f !== !1 && y.push(f);
    return y;
  }
  function p() {
    var y = i();
    if (!(wS != e.charAt(0) || CS != e.charAt(1))) {
      for (var f = 2; sa != e.charAt(f) && (CS != e.charAt(f) || wS != e.charAt(f + 1)); )
        ++f;
      if (f += 2, sa === e.charAt(f - 1))
        return a("End of comment missing");
      var g = e.slice(2, f - 2);
      return r += 2, o(g), e = e.slice(f), r += 2, y({
        type: XJ,
        comment: g
      });
    }
  }
  function d() {
    var y = i(), f = l(WJ);
    if (f) {
      if (p(), !l(HJ)) return a("property missing ':'");
      var g = l(VJ), x = y({
        type: YJ,
        property: xS(f[0].replace(bS, sa)),
        value: g ? xS(g[0].replace(bS, sa)) : sa
      });
      return l(ZJ), x;
    }
  }
  function h() {
    var y = [];
    c(y);
    for (var f; f = d(); )
      f !== !1 && (y.push(f), c(y));
    return y;
  }
  return u(), h();
};
function xS(e) {
  return e ? e.replace(qJ, sa) : sa;
}
var KJ = Pn && Pn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Kb, "__esModule", { value: !0 });
Kb.default = eK;
var QJ = KJ(JJ);
function eK(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, QJ.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var rh = {};
Object.defineProperty(rh, "__esModule", { value: !0 });
rh.camelCase = void 0;
var tK = /^--[a-zA-Z0-9-]+$/, nK = /-([a-z])/g, rK = /^[^-]+$/, oK = /^-(webkit|moz|ms|o|khtml)-/, iK = /^-(ms)-/, sK = function(e) {
  return !e || rK.test(e) || tK.test(e);
}, aK = function(e, t) {
  return t.toUpperCase();
}, ES = function(e, t) {
  return "".concat(t, "-");
}, lK = function(e, t) {
  return t === void 0 && (t = {}), sK(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(iK, ES) : e = e.replace(oK, ES), e.replace(nK, aK));
};
rh.camelCase = lK;
var uK = Pn && Pn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, cK = uK(Kb), pK = rh;
function Oy(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, cK.default)(e, function(r, o) {
    r && o && (n[(0, pK.camelCase)(r, t)] = o);
  }), n;
}
Oy.default = Oy;
var dK = Oy;
(function(e) {
  var t = Pn && Pn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Ae, r = t(dK), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Jb);
Object.defineProperty(Qf, "__esModule", { value: !0 });
Qf.default = mK;
var Rl = Yo, LS = Jb, fK = ["checked", "value"], hK = ["input", "select", "textarea"], gK = {
  reset: !0,
  submit: !0
};
function mK(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && gK[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Rl.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = kS(s);
    if (a) {
      var l = (0, Rl.getPropertyInfo)(a);
      switch (fK.includes(a) && hK.includes(t) && !r && (a = kS("default" + s)), n[a] = i, l && l.type) {
        case Rl.BOOLEAN:
          n[a] = !0;
          break;
        case Rl.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    LS.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, LS.setStyleProp)(e.style, n), n;
}
function kS(e) {
  return Rl.possibleStandardNames[e];
}
var Qb = {}, vK = Pn && Pn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Qb, "__esModule", { value: !0 });
Qb.default = eR;
var fm = Ae, yK = vK(Qf), eu = Jb, bK = {
  cloneElement: fm.cloneElement,
  createElement: fm.createElement,
  isValidElement: fm.isValidElement
};
function eR(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || eu.returnFirstArg, i = t.library || bK, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var h = !p.data.trim().length;
      if (h && p.parent && !(0, eu.canTextBeChildOfNode)(p.parent) || t.trim && h)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var y = p, f = {};
    wK(y) ? ((0, eu.setStyleProp)(y.attribs.style, y.attribs), f = y.attribs) : y.attribs && (f = (0, yK.default)(y.attribs, y.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (f.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? f.defaultValue = p.children[0].data : p.children && p.children.length && (g = eR(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (f.key = c), n.push(o(a(p.name, f, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function wK(e) {
  return eu.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, eu.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Pn && Pn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t($b);
  e.htmlToDOM = n.default;
  var r = t(Qf);
  e.attributesToProps = r.default;
  var o = t(Qb);
  e.domToReact = o.default;
  var i = Hb;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(Ij);
const CK = /* @__PURE__ */ G$(Ij);
CK.default;
qe({});
qe({});
qe({});
var Dr = {}, e1 = {}, Qu = {}, ec = {}, tR = "Expected a function", OS = NaN, xK = "[object Symbol]", EK = /^\s+|\s+$/g, LK = /^[-+]0x[0-9a-f]+$/i, kK = /^0b[01]+$/i, OK = /^0o[0-7]+$/i, MK = parseInt, SK = typeof Pn == "object" && Pn && Pn.Object === Object && Pn, DK = typeof self == "object" && self && self.Object === Object && self, PK = SK || DK || Function("return this")(), TK = Object.prototype, _K = TK.toString, AK = Math.max, BK = Math.min, hm = function() {
  return PK.Date.now();
};
function IK(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(tR);
  t = MS(t) || 0, Nd(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? AK(MS(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function h(C) {
    var M = r, S = o;
    return r = o = void 0, u = C, s = e.apply(S, M), s;
  }
  function y(C) {
    return u = C, a = setTimeout(x, t), c ? h(C) : s;
  }
  function f(C) {
    var M = C - l, S = C - u, F = t - M;
    return p ? BK(F, i - S) : F;
  }
  function g(C) {
    var M = C - l, S = C - u;
    return l === void 0 || M >= t || M < 0 || p && S >= i;
  }
  function x() {
    var C = hm();
    if (g(C))
      return L(C);
    a = setTimeout(x, f(C));
  }
  function L(C) {
    return a = void 0, d && r ? h(C) : (r = o = void 0, s);
  }
  function E() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function T() {
    return a === void 0 ? s : L(hm());
  }
  function b() {
    var C = hm(), M = g(C);
    if (r = arguments, o = this, l = C, M) {
      if (a === void 0)
        return y(l);
      if (p)
        return a = setTimeout(x, t), h(l);
    }
    return a === void 0 && (a = setTimeout(x, t)), s;
  }
  return b.cancel = E, b.flush = T, b;
}
function jK(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(tR);
  return Nd(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), IK(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Nd(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function RK(e) {
  return !!e && typeof e == "object";
}
function NK(e) {
  return typeof e == "symbol" || RK(e) && _K.call(e) == xK;
}
function MS(e) {
  if (typeof e == "number")
    return e;
  if (NK(e))
    return OS;
  if (Nd(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Nd(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(EK, "");
  var n = kK.test(e);
  return n || OK.test(e) ? MK(e.slice(2), n ? 2 : 8) : LK.test(e) ? OS : +e;
}
var FK = jK, tc = {};
Object.defineProperty(tc, "__esModule", {
  value: !0
});
tc.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), td.has(t) || td.set(t, /* @__PURE__ */ new Set());
  var o = td.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
tc.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), td.get(t).delete(n.name || t);
};
var td = /* @__PURE__ */ new Map();
Object.defineProperty(ec, "__esModule", {
  value: !0
});
var zK = FK, UK = WK(zK), $K = tc;
function WK(e) {
  return e && e.__esModule ? e : { default: e };
}
var HK = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, UK.default)(e, t);
}, gr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = HK(function(r) {
        gr.scrollHandler(e);
      }, t);
      gr.scrollSpyContainers.push(e), (0, $K.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return gr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = gr.scrollSpyContainers[gr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(gr.currentPositionX(e), gr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    gr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = gr.scrollSpyContainers[gr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(gr.currentPositionX(t), gr.currentPositionY(t));
  },
  updateStates: function() {
    gr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    gr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), gr.spySetState && gr.spySetState.length && gr.spySetState.indexOf(e) > -1 && gr.spySetState.splice(gr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", gr.scrollHandler);
  },
  update: function() {
    return gr.scrollSpyContainers.forEach(function(e) {
      return gr.scrollHandler(e);
    });
  }
};
ec.default = gr;
var Qa = {}, nc = {};
Object.defineProperty(nc, "__esModule", {
  value: !0
});
var VK = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, ZK = function() {
  return window.location.hash.replace(/^#/, "");
}, qK = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, GK = function(e) {
  return getComputedStyle(e).position !== "static";
}, gm = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, XK = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (GK(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = gm(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return gm(t, a).offsetTop - gm(e, a).offsetTop;
};
nc.default = {
  updateHash: VK,
  getHash: ZK,
  filterElementInContainer: qK,
  scrollOffset: XK
};
var oh = {}, t1 = {};
Object.defineProperty(t1, "__esModule", {
  value: !0
});
t1.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var n1 = {};
Object.defineProperty(n1, "__esModule", {
  value: !0
});
var YK = tc, JK = ["mousedown", "mousewheel", "touchmove", "keydown"];
n1.default = {
  subscribe: function(e) {
    return typeof document < "u" && JK.forEach(function(t) {
      return (0, YK.addPassiveEventListener)(document, t, e);
    });
  }
};
var rc = {};
Object.defineProperty(rc, "__esModule", {
  value: !0
});
var My = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      My.registered[e] = t;
    },
    remove: function(e) {
      My.registered[e] = null;
    }
  }
};
rc.default = My;
Object.defineProperty(oh, "__esModule", {
  value: !0
});
var KK = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, QK = nc;
ih(QK);
var eQ = t1, SS = ih(eQ), tQ = n1, nQ = ih(tQ), rQ = rc, ri = ih(rQ);
function ih(e) {
  return e && e.__esModule ? e : { default: e };
}
var nR = function(e) {
  return SS.default[e.smooth] || SS.default.defaultEasing;
}, oQ = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, iQ = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Sy = function() {
  return iQ() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), rR = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, oR = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, iR = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, sQ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, aQ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, lQ = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    ri.default.registered.end && ri.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Sy.call(window, i);
    return;
  }
  ri.default.registered.end && ri.default.registered.end(o.to, o.target, o.currentPosition);
}, r1 = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, oc = function(e, t, n, r) {
  t.data = t.data || rR(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (nQ.default.subscribe(o), r1(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? oR(t) : iR(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    ri.default.registered.end && ri.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = oQ(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = nR(t), s = lQ.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      ri.default.registered.begin && ri.default.registered.begin(t.data.to, t.data.target), Sy.call(window, s);
    }, t.delay);
    return;
  }
  ri.default.registered.begin && ri.default.registered.begin(t.data.to, t.data.target), Sy.call(window, s);
}, sh = function(e) {
  return e = KK({}, e), e.data = e.data || rR(), e.absolute = !0, e;
}, uQ = function(e) {
  oc(0, sh(e));
}, cQ = function(e, t) {
  oc(e, sh(t));
}, pQ = function(e) {
  e = sh(e), r1(e), oc(e.horizontal ? sQ(e) : aQ(e), e);
}, dQ = function(e, t) {
  t = sh(t), r1(t);
  var n = t.horizontal ? oR(t) : iR(t);
  oc(e + n, t);
};
oh.default = {
  animateTopScroll: oc,
  getAnimationType: nR,
  scrollToTop: uQ,
  scrollToBottom: pQ,
  scrollTo: cQ,
  scrollMore: dQ
};
Object.defineProperty(Qa, "__esModule", {
  value: !0
});
var fQ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, hQ = nc, gQ = o1(hQ), mQ = oh, vQ = o1(mQ), yQ = rc, mp = o1(yQ);
function o1(e) {
  return e && e.__esModule ? e : { default: e };
}
var vp = {}, DS = void 0;
Qa.default = {
  unmount: function() {
    vp = {};
  },
  register: function(e, t) {
    vp[e] = t;
  },
  unregister: function(e) {
    delete vp[e];
  },
  get: function(e) {
    return vp[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return DS = e;
  },
  getActiveLink: function() {
    return DS;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = fQ({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = gQ.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      mp.default.registered.begin && mp.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, mp.default.registered.end && mp.default.registered.end(e, n);
      return;
    }
    vQ.default.animateTopScroll(a, t, e, n);
  }
};
var Dy = { exports: {} }, mm = { exports: {} }, cn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var PS;
function bQ() {
  if (PS) return cn;
  PS = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
  function E(b) {
    if (typeof b == "object" && b !== null) {
      var C = b.$$typeof;
      switch (C) {
        case t:
          switch (b = b.type, b) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case a:
                case c:
                case y:
                case h:
                case s:
                  return b;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function T(b) {
    return E(b) === u;
  }
  return cn.AsyncMode = l, cn.ConcurrentMode = u, cn.ContextConsumer = a, cn.ContextProvider = s, cn.Element = t, cn.ForwardRef = c, cn.Fragment = r, cn.Lazy = y, cn.Memo = h, cn.Portal = n, cn.Profiler = i, cn.StrictMode = o, cn.Suspense = p, cn.isAsyncMode = function(b) {
    return T(b) || E(b) === l;
  }, cn.isConcurrentMode = T, cn.isContextConsumer = function(b) {
    return E(b) === a;
  }, cn.isContextProvider = function(b) {
    return E(b) === s;
  }, cn.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === t;
  }, cn.isForwardRef = function(b) {
    return E(b) === c;
  }, cn.isFragment = function(b) {
    return E(b) === r;
  }, cn.isLazy = function(b) {
    return E(b) === y;
  }, cn.isMemo = function(b) {
    return E(b) === h;
  }, cn.isPortal = function(b) {
    return E(b) === n;
  }, cn.isProfiler = function(b) {
    return E(b) === i;
  }, cn.isStrictMode = function(b) {
    return E(b) === o;
  }, cn.isSuspense = function(b) {
    return E(b) === p;
  }, cn.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === r || b === u || b === i || b === o || b === p || b === d || typeof b == "object" && b !== null && (b.$$typeof === y || b.$$typeof === h || b.$$typeof === s || b.$$typeof === a || b.$$typeof === c || b.$$typeof === g || b.$$typeof === x || b.$$typeof === L || b.$$typeof === f);
  }, cn.typeOf = E, cn;
}
var xn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TS;
function wQ() {
  return TS || (TS = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
    function E(A) {
      return typeof A == "string" || typeof A == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      A === r || A === u || A === i || A === o || A === p || A === d || typeof A == "object" && A !== null && (A.$$typeof === y || A.$$typeof === h || A.$$typeof === s || A.$$typeof === a || A.$$typeof === c || A.$$typeof === g || A.$$typeof === x || A.$$typeof === L || A.$$typeof === f);
    }
    function T(A) {
      if (typeof A == "object" && A !== null) {
        var ae = A.$$typeof;
        switch (ae) {
          case t:
            var ce = A.type;
            switch (ce) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ce;
              default:
                var ue = ce && ce.$$typeof;
                switch (ue) {
                  case a:
                  case c:
                  case y:
                  case h:
                  case s:
                    return ue;
                  default:
                    return ae;
                }
            }
          case n:
            return ae;
        }
      }
    }
    var b = l, C = u, M = a, S = s, F = t, D = c, Z = r, U = y, $ = h, N = n, V = i, J = o, j = p, K = !1;
    function te(A) {
      return K || (K = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), O(A) || T(A) === l;
    }
    function O(A) {
      return T(A) === u;
    }
    function P(A) {
      return T(A) === a;
    }
    function H(A) {
      return T(A) === s;
    }
    function I(A) {
      return typeof A == "object" && A !== null && A.$$typeof === t;
    }
    function W(A) {
      return T(A) === c;
    }
    function X(A) {
      return T(A) === r;
    }
    function w(A) {
      return T(A) === y;
    }
    function R(A) {
      return T(A) === h;
    }
    function z(A) {
      return T(A) === n;
    }
    function _(A) {
      return T(A) === i;
    }
    function Y(A) {
      return T(A) === o;
    }
    function Q(A) {
      return T(A) === p;
    }
    xn.AsyncMode = b, xn.ConcurrentMode = C, xn.ContextConsumer = M, xn.ContextProvider = S, xn.Element = F, xn.ForwardRef = D, xn.Fragment = Z, xn.Lazy = U, xn.Memo = $, xn.Portal = N, xn.Profiler = V, xn.StrictMode = J, xn.Suspense = j, xn.isAsyncMode = te, xn.isConcurrentMode = O, xn.isContextConsumer = P, xn.isContextProvider = H, xn.isElement = I, xn.isForwardRef = W, xn.isFragment = X, xn.isLazy = w, xn.isMemo = R, xn.isPortal = z, xn.isProfiler = _, xn.isStrictMode = Y, xn.isSuspense = Q, xn.isValidElementType = E, xn.typeOf = T;
  }()), xn;
}
var _S;
function sR() {
  return _S || (_S = 1, process.env.NODE_ENV === "production" ? mm.exports = bQ() : mm.exports = wQ()), mm.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var vm, AS;
function CQ() {
  if (AS) return vm;
  AS = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return vm = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, vm;
}
var ym, BS;
function i1() {
  if (BS) return ym;
  BS = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ym = e, ym;
}
var IS, jS;
function aR() {
  return jS || (jS = 1, IS = Function.call.bind(Object.prototype.hasOwnProperty)), IS;
}
var bm, RS;
function xQ() {
  if (RS) return bm;
  RS = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = i1(), n = {}, r = aR();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (y) {
            p = y;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var h = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (h ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, bm = o, bm;
}
var wm, NS;
function EQ() {
  if (NS) return wm;
  NS = 1;
  var e = sR(), t = CQ(), n = i1(), r = aR(), o = xQ(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return wm = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(O) {
      var P = O && (u && O[u] || O[c]);
      if (typeof P == "function")
        return P;
    }
    var d = "<<anonymous>>", h = {
      array: x("array"),
      bigint: x("bigint"),
      bool: x("boolean"),
      func: x("function"),
      number: x("number"),
      object: x("object"),
      string: x("string"),
      symbol: x("symbol"),
      any: L(),
      arrayOf: E,
      element: T(),
      elementType: b(),
      instanceOf: C,
      node: D(),
      objectOf: S,
      oneOf: M,
      oneOfType: F,
      shape: U,
      exact: $
    };
    function y(O, P) {
      return O === P ? O !== 0 || 1 / O === 1 / P : O !== O && P !== P;
    }
    function f(O, P) {
      this.message = O, this.data = P && typeof P == "object" ? P : {}, this.stack = "";
    }
    f.prototype = Error.prototype;
    function g(O) {
      if (process.env.NODE_ENV !== "production")
        var P = {}, H = 0;
      function I(X, w, R, z, _, Y, Q) {
        if (z = z || d, Y = Y || R, Q !== n) {
          if (l) {
            var A = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw A.name = "Invariant Violation", A;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ae = z + ":" + R;
            !P[ae] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + Y + "` prop on `" + z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), P[ae] = !0, H++);
          }
        }
        return w[R] == null ? X ? w[R] === null ? new f("The " + _ + " `" + Y + "` is marked as required " + ("in `" + z + "`, but its value is `null`.")) : new f("The " + _ + " `" + Y + "` is marked as required in " + ("`" + z + "`, but its value is `undefined`.")) : null : O(w, R, z, _, Y);
      }
      var W = I.bind(null, !1);
      return W.isRequired = I.bind(null, !0), W;
    }
    function x(O) {
      function P(H, I, W, X, w, R) {
        var z = H[I], _ = J(z);
        if (_ !== O) {
          var Y = j(z);
          return new f(
            "Invalid " + X + " `" + w + "` of type " + ("`" + Y + "` supplied to `" + W + "`, expected ") + ("`" + O + "`."),
            { expectedType: O }
          );
        }
        return null;
      }
      return g(P);
    }
    function L() {
      return g(s);
    }
    function E(O) {
      function P(H, I, W, X, w) {
        if (typeof O != "function")
          return new f("Property `" + w + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var R = H[I];
        if (!Array.isArray(R)) {
          var z = J(R);
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected an array."));
        }
        for (var _ = 0; _ < R.length; _++) {
          var Y = O(R, _, W, X, w + "[" + _ + "]", n);
          if (Y instanceof Error)
            return Y;
        }
        return null;
      }
      return g(P);
    }
    function T() {
      function O(P, H, I, W, X) {
        var w = P[H];
        if (!a(w)) {
          var R = J(w);
          return new f("Invalid " + W + " `" + X + "` of type " + ("`" + R + "` supplied to `" + I + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(O);
    }
    function b() {
      function O(P, H, I, W, X) {
        var w = P[H];
        if (!e.isValidElementType(w)) {
          var R = J(w);
          return new f("Invalid " + W + " `" + X + "` of type " + ("`" + R + "` supplied to `" + I + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(O);
    }
    function C(O) {
      function P(H, I, W, X, w) {
        if (!(H[I] instanceof O)) {
          var R = O.name || d, z = te(H[I]);
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected ") + ("instance of `" + R + "`."));
        }
        return null;
      }
      return g(P);
    }
    function M(O) {
      if (!Array.isArray(O))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function P(H, I, W, X, w) {
        for (var R = H[I], z = 0; z < O.length; z++)
          if (y(R, O[z]))
            return null;
        var _ = JSON.stringify(O, function(Y, Q) {
          var A = j(Q);
          return A === "symbol" ? String(Q) : Q;
        });
        return new f("Invalid " + X + " `" + w + "` of value `" + String(R) + "` " + ("supplied to `" + W + "`, expected one of " + _ + "."));
      }
      return g(P);
    }
    function S(O) {
      function P(H, I, W, X, w) {
        if (typeof O != "function")
          return new f("Property `" + w + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected an object."));
        for (var _ in R)
          if (r(R, _)) {
            var Y = O(R, _, W, X, w + "." + _, n);
            if (Y instanceof Error)
              return Y;
          }
        return null;
      }
      return g(P);
    }
    function F(O) {
      if (!Array.isArray(O))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var P = 0; P < O.length; P++) {
        var H = O[P];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + K(H) + " at index " + P + "."
          ), s;
      }
      function I(W, X, w, R, z) {
        for (var _ = [], Y = 0; Y < O.length; Y++) {
          var Q = O[Y], A = Q(W, X, w, R, z, n);
          if (A == null)
            return null;
          A.data && r(A.data, "expectedType") && _.push(A.data.expectedType);
        }
        var ae = _.length > 0 ? ", expected one of type [" + _.join(", ") + "]" : "";
        return new f("Invalid " + R + " `" + z + "` supplied to " + ("`" + w + "`" + ae + "."));
      }
      return g(I);
    }
    function D() {
      function O(P, H, I, W, X) {
        return N(P[H]) ? null : new f("Invalid " + W + " `" + X + "` supplied to " + ("`" + I + "`, expected a ReactNode."));
      }
      return g(O);
    }
    function Z(O, P, H, I, W) {
      return new f(
        (O || "React class") + ": " + P + " type `" + H + "." + I + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function U(O) {
      function P(H, I, W, X, w) {
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type `" + z + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var _ in O) {
          var Y = O[_];
          if (typeof Y != "function")
            return Z(W, X, w, _, j(Y));
          var Q = Y(R, _, W, X, w + "." + _, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return g(P);
    }
    function $(O) {
      function P(H, I, W, X, w) {
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type `" + z + "` " + ("supplied to `" + W + "`, expected `object`."));
        var _ = t({}, H[I], O);
        for (var Y in _) {
          var Q = O[Y];
          if (r(O, Y) && typeof Q != "function")
            return Z(W, X, w, Y, j(Q));
          if (!Q)
            return new f(
              "Invalid " + X + " `" + w + "` key `" + Y + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(H[I], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(O), null, "  ")
            );
          var A = Q(R, Y, W, X, w + "." + Y, n);
          if (A)
            return A;
        }
        return null;
      }
      return g(P);
    }
    function N(O) {
      switch (typeof O) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !O;
        case "object":
          if (Array.isArray(O))
            return O.every(N);
          if (O === null || a(O))
            return !0;
          var P = p(O);
          if (P) {
            var H = P.call(O), I;
            if (P !== O.entries) {
              for (; !(I = H.next()).done; )
                if (!N(I.value))
                  return !1;
            } else
              for (; !(I = H.next()).done; ) {
                var W = I.value;
                if (W && !N(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function V(O, P) {
      return O === "symbol" ? !0 : P ? P["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && P instanceof Symbol : !1;
    }
    function J(O) {
      var P = typeof O;
      return Array.isArray(O) ? "array" : O instanceof RegExp ? "object" : V(P, O) ? "symbol" : P;
    }
    function j(O) {
      if (typeof O > "u" || O === null)
        return "" + O;
      var P = J(O);
      if (P === "object") {
        if (O instanceof Date)
          return "date";
        if (O instanceof RegExp)
          return "regexp";
      }
      return P;
    }
    function K(O) {
      var P = j(O);
      switch (P) {
        case "array":
        case "object":
          return "an " + P;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + P;
        default:
          return P;
      }
    }
    function te(O) {
      return !O.constructor || !O.constructor.name ? d : O.constructor.name;
    }
    return h.checkPropTypes = o, h.resetWarningCache = o.resetWarningCache, h.PropTypes = h, h;
  }, wm;
}
var Cm, FS;
function LQ() {
  if (FS) return Cm;
  FS = 1;
  var e = i1();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Cm = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Cm;
}
if (process.env.NODE_ENV !== "production") {
  var kQ = sR(), OQ = !0;
  Dy.exports = EQ()(kQ.isElement, OQ);
} else
  Dy.exports = LQ()();
var ah = Dy.exports, lh = {};
Object.defineProperty(lh, "__esModule", {
  value: !0
});
var MQ = nc, xm = SQ(MQ);
function SQ(e) {
  return e && e.__esModule ? e : { default: e };
}
var DQ = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return xm.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && xm.default.getHash() !== e && xm.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
lh.default = DQ;
Object.defineProperty(Qu, "__esModule", {
  value: !0
});
var yp = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, PQ = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), TQ = Ae, zS = ic(TQ), _Q = ec, bp = ic(_Q), AQ = Qa, BQ = ic(AQ), IQ = ah, ir = ic(IQ), jQ = lh, Ji = ic(jQ);
function ic(e) {
  return e && e.__esModule ? e : { default: e };
}
function RQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function NQ(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function FQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var US = {
  to: ir.default.string.isRequired,
  containerId: ir.default.string,
  container: ir.default.object,
  activeClass: ir.default.string,
  activeStyle: ir.default.object,
  spy: ir.default.bool,
  horizontal: ir.default.bool,
  smooth: ir.default.oneOfType([ir.default.bool, ir.default.string]),
  offset: ir.default.number,
  delay: ir.default.number,
  isDynamic: ir.default.bool,
  onClick: ir.default.func,
  duration: ir.default.oneOfType([ir.default.number, ir.default.func]),
  absolute: ir.default.bool,
  onSetActive: ir.default.func,
  onSetInactive: ir.default.func,
  ignoreCancelEvents: ir.default.bool,
  hashSpy: ir.default.bool,
  saveHashHistory: ir.default.bool,
  spyThrottle: ir.default.number
};
Qu.default = function(e, t) {
  var n = t || BQ.default, r = function(i) {
    FQ(s, i);
    function s(a) {
      RQ(this, s);
      var l = NQ(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return PQ(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          bp.default.isMounted(a) || bp.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (Ji.default.isMounted() || Ji.default.mount(n), Ji.default.mapContainer(this.props.to, a)), bp.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        bp.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = yp({}, this.props.style, this.props.activeStyle) : l = yp({}, this.props.style);
        var u = yp({}, this.props);
        for (var c in US)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, zS.default.createElement(e, u);
      }
    }]), s;
  }(zS.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, yp({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Ji.default.isMounted() && !Ji.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, h = void 0;
        if (u) {
          var y = 0, f = 0, g = 0;
          if (l.getBoundingClientRect) {
            var x = l.getBoundingClientRect();
            g = x.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var L = p.getBoundingClientRect();
            y = L.left - g + s, f = y + L.width;
          }
          var E = s - i.props.offset;
          d = E >= Math.floor(y) && E < Math.floor(f), h = E < Math.floor(y) || E >= Math.floor(f);
        } else {
          var T = 0, b = 0, C = 0;
          if (l.getBoundingClientRect) {
            var M = l.getBoundingClientRect();
            C = M.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var S = p.getBoundingClientRect();
            T = S.top - C + a, b = T + S.height;
          }
          var F = a - i.props.offset;
          d = F >= Math.floor(T) && F < Math.floor(b), h = F < Math.floor(T) || F >= Math.floor(b);
        }
        var D = n.getActiveLink();
        if (h) {
          if (c === D && n.setActiveLink(void 0), i.props.hashSpy && Ji.default.getHash() === c) {
            var Z = i.props.saveHashHistory, U = Z === void 0 ? !1 : Z;
            Ji.default.changeHash("", U);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (D !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, N = $ === void 0 ? !1 : $;
          i.props.hashSpy && Ji.default.changeHash(c, N), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = US, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(e1, "__esModule", {
  value: !0
});
var zQ = Ae, $S = lR(zQ), UQ = Qu, $Q = lR(UQ);
function lR(e) {
  return e && e.__esModule ? e : { default: e };
}
function WQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function WS(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function HQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var VQ = function(e) {
  HQ(t, e);
  function t() {
    var n, r, o, i;
    WQ(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = WS(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return $S.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), WS(o, i);
  }
  return t;
}($S.default.Component);
e1.default = (0, $Q.default)(VQ);
var s1 = {};
Object.defineProperty(s1, "__esModule", {
  value: !0
});
var ZQ = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), qQ = Ae, HS = uR(qQ), GQ = Qu, XQ = uR(GQ);
function uR(e) {
  return e && e.__esModule ? e : { default: e };
}
function YQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function JQ(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function KQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var QQ = function(e) {
  KQ(t, e);
  function t() {
    return YQ(this, t), JQ(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return ZQ(t, [{
    key: "render",
    value: function() {
      return HS.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(HS.default.Component);
s1.default = (0, XQ.default)(QQ);
var a1 = {}, uh = {};
Object.defineProperty(uh, "__esModule", {
  value: !0
});
var eee = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, tee = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), nee = Ae, VS = ch(nee), ree = qa;
ch(ree);
var oee = Qa, ZS = ch(oee), iee = ah, qS = ch(iee);
function ch(e) {
  return e && e.__esModule ? e : { default: e };
}
function see(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function aee(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function lee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
uh.default = function(e) {
  var t = function(n) {
    lee(r, n);
    function r(o) {
      see(this, r);
      var i = aee(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return tee(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        ZS.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        ZS.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return VS.default.createElement(e, eee({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(VS.default.Component);
  return t.propTypes = {
    name: qS.default.string,
    id: qS.default.string
  }, t;
};
Object.defineProperty(a1, "__esModule", {
  value: !0
});
var GS = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, uee = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), cee = Ae, XS = l1(cee), pee = uh, dee = l1(pee), fee = ah, YS = l1(fee);
function l1(e) {
  return e && e.__esModule ? e : { default: e };
}
function hee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function gee(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function mee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var cR = function(e) {
  mee(t, e);
  function t() {
    return hee(this, t), gee(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return uee(t, [{
    key: "render",
    value: function() {
      var n = this, r = GS({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, XS.default.createElement(
        "div",
        GS({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(XS.default.Component);
cR.propTypes = {
  name: YS.default.string,
  id: YS.default.string
};
a1.default = (0, dee.default)(cR);
var Em = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, JS = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function KS(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function QS(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function eD(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var wp = Ae, Gs = ec, Lm = Qa, wr = ah, Ki = lh, tD = {
  to: wr.string.isRequired,
  containerId: wr.string,
  container: wr.object,
  activeClass: wr.string,
  spy: wr.bool,
  smooth: wr.oneOfType([wr.bool, wr.string]),
  offset: wr.number,
  delay: wr.number,
  isDynamic: wr.bool,
  onClick: wr.func,
  duration: wr.oneOfType([wr.number, wr.func]),
  absolute: wr.bool,
  onSetActive: wr.func,
  onSetInactive: wr.func,
  ignoreCancelEvents: wr.bool,
  hashSpy: wr.bool,
  spyThrottle: wr.number
}, vee = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Lm, r = function(i) {
      eD(s, i);
      function s(a) {
        KS(this, s);
        var l = QS(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return JS(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            Gs.isMounted(a) || Gs.mount(a, this.props.spyThrottle), this.props.hashSpy && (Ki.isMounted() || Ki.mount(n), Ki.mapContainer(this.props.to, a)), this.props.spy && Gs.addStateHandler(this.stateHandler), Gs.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Gs.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = Em({}, this.props);
          for (var u in tD)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, wp.createElement(e, l);
        }
      }]), s;
    }(wp.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, Em({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(Ki.isMounted() && !Ki.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var h = a.getBoundingClientRect();
            d = h.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var y = u.getBoundingClientRect();
            c = y.top - d + s, p = c + y.height;
          }
          var f = s - i.props.offset, g = f >= Math.floor(c) && f < Math.floor(p), x = f < Math.floor(c) || f >= Math.floor(p), L = n.getActiveLink();
          if (x)
            return l === L && n.setActiveLink(void 0), i.props.hashSpy && Ki.getHash() === l && Ki.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Gs.updateStates();
          if (g && L !== l)
            return n.setActiveLink(l), i.props.hashSpy && Ki.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Gs.updateStates();
        }
      };
    };
    return r.propTypes = tD, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      eD(r, n);
      function r(o) {
        KS(this, r);
        var i = QS(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return JS(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Lm.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Lm.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return wp.createElement(e, Em({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(wp.Component);
    return t.propTypes = {
      name: wr.string,
      id: wr.string
    }, t;
  }
}, yee = vee;
Object.defineProperty(Dr, "__esModule", {
  value: !0
});
Dr.Helpers = Dr.ScrollElement = Dr.ScrollLink = Dr.animateScroll = Dr.scrollSpy = Dr.Events = Dr.scroller = Dr.Element = Dr.Button = Dr.Link = void 0;
var bee = e1, pR = gi(bee), wee = s1, dR = gi(wee), Cee = a1, fR = gi(Cee), xee = Qa, hR = gi(xee), Eee = rc, gR = gi(Eee), Lee = ec, mR = gi(Lee), kee = oh, vR = gi(kee), Oee = Qu, yR = gi(Oee), Mee = uh, bR = gi(Mee), See = yee, wR = gi(See);
function gi(e) {
  return e && e.__esModule ? e : { default: e };
}
Dr.Link = pR.default;
Dr.Button = dR.default;
Dr.Element = fR.default;
Dr.scroller = hR.default;
Dr.Events = gR.default;
Dr.scrollSpy = mR.default;
Dr.animateScroll = vR.default;
Dr.ScrollLink = yR.default;
Dr.ScrollElement = bR.default;
Dr.Helpers = wR.default;
Dr.default = { Link: pR.default, Button: dR.default, Element: fR.default, scroller: hR.default, Events: gR.default, scrollSpy: mR.default, animateScroll: vR.default, ScrollLink: yR.default, ScrollElement: bR.default, Helpers: wR.default };
qe({});
qe({});
qe({});
let Dee = { data: "" }, Pee = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Dee, Tee = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, _ee = /\/\*[^]*?\*\/|  +/g, nD = /\n+/g, ys = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? ys(s, i) : i + "{" + ys(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += ys(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ys.p ? ys.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, ki = {}, CR = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + CR(e[n]);
    return t;
  }
  return e;
}, Aee = (e, t, n, r, o) => {
  let i = CR(e), s = ki[i] || (ki[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!ki[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Tee.exec(u.replace(_ee, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(nD, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(nD, " ").trim();
      return d[0];
    })(e);
    ki[s] = ys(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && ki.g ? ki.g : null;
  return n && (ki.g = ki[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(ki[s], t, r, a), s;
}, Bee = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : ys(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function ph(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Aee(n.unshift ? n.raw ? Bee(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Pee(t.target), t.g, t.o, t.k);
}
let xR, Py, Ty;
ph.bind({ g: 1 });
let Ri = ph.bind({ k: 1 });
function Iee(e, t, n, r) {
  ys.p = t, xR = e, Py = n, Ty = r;
}
function As(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: Py && Py() }, a), n.o = / *go\d+/.test(l), a.className = ph.apply(n, r) + (l ? " " + l : ""), t && (a.ref = s);
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Ty && u[0] && Ty(a), xR(u, a);
    }
    return t ? t(o) : o;
  };
}
var jee = (e) => typeof e == "function", Ree = (e, t) => jee(e) ? e(t) : e, Nee = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Fee = Ri`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, zee = Ri`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Uee = Ri`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, $ee = As("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Fee} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${zee} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Uee} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Wee = Ri`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Hee = As("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Wee} 1s linear infinite;
`, Vee = Ri`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Zee = Ri`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, qee = As("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Vee} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Zee} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Gee = As("div")`
  position: absolute;
`, Xee = As("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Yee = Ri`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Jee = As("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Yee} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, Kee = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? He.createElement(Jee, null, t) : t : n === "blank" ? null : He.createElement(Xee, null, He.createElement(Hee, { ...r }), n !== "loading" && He.createElement(Gee, null, n === "error" ? He.createElement($ee, { ...r }) : He.createElement(qee, { ...r })));
}, Qee = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ete = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, tte = "0%{opacity:0;} 100%{opacity:1;}", nte = "0%{opacity:1;} 100%{opacity:0;}", rte = As("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, ote = As("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, ite = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Nee() ? [tte, nte] : [Qee(n), ete(n)];
  return { animation: t ? `${Ri(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ri(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
He.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? ite(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = He.createElement(Kee, { toast: e }), s = He.createElement(ote, { ...e.ariaProps }, Ree(e.message, e));
  return He.createElement(rte, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : He.createElement(He.Fragment, null, i, s));
});
Iee(He.createElement);
ph`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
qe({});
var Vi = {};
Object.defineProperty(Vi, "__esModule", {
  value: !0
});
var ste = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), km = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, ER = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: ste ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, u1 = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Cp = 1; Cp < 20; Cp++)
  u1["f" + Cp] = 111 + Cp;
function dh(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return LR(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return kR(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function ate(e, t) {
  return dh(e, t);
}
function lte(e, t) {
  return dh(e, { byKey: !0 }, t);
}
function LR(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in km)
    r[km[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, h = d.endsWith("?") && d.length > 1;
      h && (d = d.slice(0, -1));
      var y = c1(d), f = km[y];
      if (d.length > 1 && !f && !ER[d] && !u1[y])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !f) && (n ? r.key = y : r.which = OR(d)), f && (r[f] = h ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function kR(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function OR(e) {
  e = c1(e);
  var t = u1[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function c1(e) {
  return e = e.toLowerCase(), e = ER[e] || e, e;
}
Vi.default = dh;
var Om = Vi.isHotkey = dh;
Vi.isCodeHotkey = ate;
Vi.isKeyHotkey = lte;
Vi.parseHotkey = LR;
Vi.compareHotkey = kR;
Vi.toKeyCode = OR;
Vi.toKeyName = c1;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function rD(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Jr(e) {
  var t, n;
  return rD(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(rD(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var MR = Symbol.for("immer-nothing"), oD = Symbol.for("immer-draftable"), Io = Symbol.for("immer-state"), ute = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function po(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = ute[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Wa = Object.getPrototypeOf;
function Sa(e) {
  return !!e && !!e[Io];
}
function Da(e) {
  var t;
  return e ? SR(e) || Array.isArray(e) || !!e[oD] || !!((t = e.constructor) != null && t[oD]) || hh(e) || gh(e) : !1;
}
var cte = Object.prototype.constructor.toString();
function SR(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Wa(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === cte;
}
function Fd(e, t) {
  fh(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function fh(e) {
  const t = e[Io];
  return t ? t.type_ : Array.isArray(e) ? 1 : hh(e) ? 2 : gh(e) ? 3 : 0;
}
function _y(e, t) {
  return fh(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function DR(e, t, n) {
  const r = fh(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function pte(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function hh(e) {
  return e instanceof Map;
}
function gh(e) {
  return e instanceof Set;
}
function ta(e) {
  return e.copy_ || e.base_;
}
function Ay(e, t) {
  if (hh(e))
    return new Map(e);
  if (gh(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = SR(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Io];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(Wa(e), r);
  } else {
    const r = Wa(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function p1(e, t = !1) {
  return mh(e) || Sa(e) || !Da(e) || (fh(e) > 1 && (e.set = e.add = e.clear = e.delete = dte), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => p1(r, !0))), e;
}
function dte() {
  po(2);
}
function mh(e) {
  return Object.isFrozen(e);
}
var fte = {};
function Pa(e) {
  const t = fte[e];
  return t || po(0, e), t;
}
var Ou;
function PR() {
  return Ou;
}
function hte(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function iD(e, t) {
  t && (Pa("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function By(e) {
  Iy(e), e.drafts_.forEach(gte), e.drafts_ = null;
}
function Iy(e) {
  e === Ou && (Ou = e.parent_);
}
function sD(e) {
  return Ou = hte(Ou, e);
}
function gte(e) {
  const t = e[Io];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function aD(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Io].modified_ && (By(t), po(4)), Da(e) && (e = zd(t, e), t.parent_ || Ud(t, e)), t.patches_ && Pa("Patches").generateReplacementPatches_(
    n[Io].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = zd(t, n, []), By(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== MR ? e : void 0;
}
function zd(e, t, n) {
  if (mh(t))
    return t;
  const r = t[Io];
  if (!r)
    return Fd(
      t,
      (o, i) => lD(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Ud(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Fd(
      i,
      (a, l) => lD(e, r, o, a, l, n, s)
    ), Ud(e, o, !1), n && e.patches_ && Pa("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function lD(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && po(5), Sa(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !_y(t.assigned_, r) ? i.concat(r) : void 0, l = zd(e, o, a);
    if (DR(n, r, l), Sa(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (Da(o) && !mh(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    zd(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Ud(e, o);
  }
}
function Ud(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && p1(t, n);
}
function mte(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : PR(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = d1;
  n && (o = [r], i = Mu);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var d1 = {
  get(e, t) {
    if (t === Io)
      return e;
    const n = ta(e);
    if (!_y(n, t))
      return vte(e, n, t);
    const r = n[t];
    return e.finalized_ || !Da(r) ? r : r === Mm(e.base_, t) ? (Sm(e), e.copy_[t] = Ry(r, e)) : r;
  },
  has(e, t) {
    return t in ta(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(ta(e));
  },
  set(e, t, n) {
    const r = TR(ta(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Mm(ta(e), t), i = o == null ? void 0 : o[Io];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (pte(n, o) && (n !== void 0 || _y(e.base_, t)))
        return !0;
      Sm(e), jy(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Mm(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Sm(e), jy(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = ta(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    po(11);
  },
  getPrototypeOf(e) {
    return Wa(e.base_);
  },
  setPrototypeOf() {
    po(12);
  }
}, Mu = {};
Fd(d1, (e, t) => {
  Mu[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Mu.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && po(13), Mu.set.call(this, e, t, void 0);
};
Mu.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && po(14), d1.set.call(this, e[0], t, n, e[0]);
};
function Mm(e, t) {
  const n = e[Io];
  return (n ? ta(n) : e)[t];
}
function vte(e, t, n) {
  var r;
  const o = TR(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function TR(e, t) {
  if (!(t in e))
    return;
  let n = Wa(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Wa(n);
  }
}
function jy(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && jy(e.parent_));
}
function Sm(e) {
  e.copy_ || (e.copy_ = Ay(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var yte = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && po(6), r !== void 0 && typeof r != "function" && po(7);
      let o;
      if (Da(t)) {
        const i = sD(this), s = Ry(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? By(i) : Iy(i);
        }
        return iD(i, r), aD(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === MR && (o = void 0), this.autoFreeze_ && p1(o, !0), r) {
          const i = [], s = [];
          Pa("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        po(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Da(e) || po(8), Sa(e) && (e = bte(e));
    const t = sD(this), n = Ry(e, void 0);
    return n[Io].isManual_ = !0, Iy(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Io];
    (!n || !n.isManual_) && po(9);
    const { scope_: r } = n;
    return iD(r, t), aD(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Pa("Patches").applyPatches_;
    return Sa(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Ry(e, t) {
  const n = hh(e) ? Pa("MapSet").proxyMap_(e, t) : gh(e) ? Pa("MapSet").proxySet_(e, t) : mte(e, t);
  return (t ? t.scope_ : PR()).drafts_.push(n), n;
}
function bte(e) {
  return Sa(e) || po(10, e), _R(e);
}
function _R(e) {
  if (!Da(e) || mh(e))
    return e;
  const t = e[Io];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Ay(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Ay(e, !0);
  return Fd(n, (r, o) => {
    DR(n, r, _R(o));
  }), t && (t.finalized_ = !1), n;
}
var jo = new yte(), f1 = jo.produce;
jo.produceWithPatches.bind(
  jo
);
jo.setAutoFreeze.bind(jo);
jo.setUseStrictShallowCopy.bind(jo);
jo.applyPatches.bind(jo);
var uD = jo.createDraft.bind(jo), cD = jo.finishDraft.bind(jo), Fe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Fe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Fe.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Fe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Fe.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Fe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Fe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Fe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Fe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Fe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Fe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Fe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Fe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Fe.isAncestor(t, e) && !Fe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Fe.equals(i, r) || Fe.endsBefore(i, r) || Fe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (Fe.equals(s, r) || Fe.isAncestor(s, r))
          return null;
        Fe.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        Fe.equals(a, r) || Fe.endsBefore(a, r) ? r[a.length - 1] -= 1 : Fe.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Fe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Fe.endsBefore(u, r) ? r[u.length - 1] += 1 : Fe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Fe.equals(p, d))
          return r;
        if (Fe.isAncestor(p, r) || Fe.equals(p, r)) {
          var h = d.slice();
          return Fe.endsBefore(p, d) && p.length < d.length && (h[p.length - 1] -= 1), h.concat(r.slice(p.length));
        } else Fe.isSibling(p, d) && (Fe.isAncestor(d, r) || Fe.equals(d, r)) ? Fe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Fe.endsBefore(d, r) || Fe.equals(d, r) || Fe.isAncestor(d, r) ? (Fe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Fe.endsBefore(p, r) && (Fe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Su(e) {
  "@babel/helpers - typeof";
  return Su = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Su(e);
}
function wte(e, t) {
  if (Su(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Su(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Cte(e) {
  var t = wte(e, "string");
  return Su(t) === "symbol" ? t : String(t);
}
function el(e, t, n) {
  return t = Cte(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function pD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pD(Object(n), !0).forEach(function(r) {
      el(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xte = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = ft.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of Lt.points(t))
          t[l] = Vn.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = ft.leaf(e, u), h = d.text.slice(0, c), y = d.text.slice(c);
      if (d.text = h + p + y, t)
        for (var [f, g] of Lt.points(t))
          t[g] = Vn.transform(f, n);
      break;
    }
    case "merge_node": {
      var {
        path: x
      } = n, L = ft.get(e, x), E = Fe.previous(x), T = ft.get(e, E), b = ft.parent(e, x), C = x[x.length - 1];
      if (Or.isText(L) && Or.isText(T))
        T.text += L.text;
      else if (!Or.isText(L) && !Or.isText(T))
        T.children.push(...L.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(x, "] to nodes of different interfaces: ").concat(xo.stringify(L), " ").concat(xo.stringify(T)));
      if (b.children.splice(C, 1), t)
        for (var [M, S] of Lt.points(t))
          t[S] = Vn.transform(M, n);
      break;
    }
    case "move_node": {
      var {
        path: F,
        newPath: D
      } = n;
      if (Fe.isAncestor(F, D))
        throw new Error("Cannot move a path [".concat(F, "] to new path [").concat(D, "] because the destination is inside itself."));
      var Z = ft.get(e, F), U = ft.parent(e, F), $ = F[F.length - 1];
      U.children.splice($, 1);
      var N = Fe.transform(F, n), V = ft.get(e, Fe.parent(N)), J = N[N.length - 1];
      if (V.children.splice(J, 0, Z), t)
        for (var [j, K] of Lt.points(t))
          t[K] = Vn.transform(j, n);
      break;
    }
    case "remove_node": {
      var {
        path: te
      } = n, O = te[te.length - 1], P = ft.parent(e, te);
      if (P.children.splice(O, 1), t)
        for (var [H, I] of Lt.points(t)) {
          var W = Vn.transform(H, n);
          if (t != null && W != null)
            t[I] = W;
          else {
            var X = void 0, w = void 0;
            for (var [R, z] of ft.texts(e))
              if (Fe.compare(z, te) === -1)
                X = [R, z];
              else {
                w = [R, z];
                break;
              }
            var _ = !1;
            X && w && (Fe.equals(w[1], te) ? _ = !Fe.hasPrevious(w[1]) : _ = Fe.common(X[1], te).length < Fe.common(w[1], te).length), X && !_ ? (H.path = X[1], H.offset = X[0].text.length) : w ? (H.path = w[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: Y,
        offset: Q,
        text: A
      } = n;
      if (A.length === 0) break;
      var ae = ft.leaf(e, Y), ce = ae.text.slice(0, Q), ue = ae.text.slice(Q + A.length);
      if (ae.text = ce + ue, t)
        for (var [de, be] of Lt.points(t))
          t[be] = Vn.transform(de, n);
      break;
    }
    case "set_node": {
      var {
        path: ve,
        properties: ge,
        newProperties: se
      } = n;
      if (ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var xe = ft.get(e, ve);
      for (var ne in se) {
        if (ne === "children" || ne === "text")
          throw new Error('Cannot set the "'.concat(ne, '" property of nodes!'));
        var Me = se[ne];
        Me == null ? delete xe[ne] : xe[ne] = Me;
      }
      for (var ee in ge)
        se.hasOwnProperty(ee) || delete xe[ee];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Ce
      } = n;
      if (Ce == null)
        t = Ce;
      else {
        if (t == null) {
          if (!Lt.isRange(Ce))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(xo.stringify(Ce), " when there is no current selection."));
          t = Sl({}, Ce);
        }
        for (var Be in Ce) {
          var _e = Ce[Be];
          if (_e == null) {
            if (Be === "anchor" || Be === "focus")
              throw new Error('Cannot remove the "'.concat(Be, '" selection property'));
            delete t[Be];
          } else
            t[Be] = _e;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: $e,
        position: he,
        properties: Ge
      } = n;
      if ($e.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat($e, "] because the root node cannot be split."));
      var We = ft.get(e, $e), Ut = ft.parent(e, $e), ot = $e[$e.length - 1], st;
      if (Or.isText(We)) {
        var Zt = We.text.slice(0, he), qt = We.text.slice(he);
        We.text = Zt, st = Sl(Sl({}, Ge), {}, {
          text: qt
        });
      } else {
        var Gt = We.children.slice(0, he), Xt = We.children.slice(he);
        We.children = Gt, st = Sl(Sl({}, Ge), {}, {
          children: Xt
        });
      }
      if (Ut.children.splice(ot + 1, 0, st), t)
        for (var [et, bt] of Lt.points(t))
          t[bt] = Vn.transform(et, n);
      break;
    }
  }
  return t;
}, Ete = {
  transform(e, t) {
    e.children = uD(e.children);
    var n = e.selection && uD(e.selection);
    try {
      n = xte(e, n, t);
    } finally {
      e.children = cD(e.children), n ? e.selection = Sa(n) ? cD(n) : n : e.selection = null;
    }
  }
}, Lte = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, kte = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, AR = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Jr(r) && Jr(o)) {
      if (!AR(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function Ote(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Du(e, t) {
  if (e == null) return {};
  var n = Ote(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Mte = ["anchor", "focus"];
function dD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ste(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dD(Object(n), !0).forEach(function(r) {
      el(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Lt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Lt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Lt.edges(e);
    return t;
  },
  equals(e, t) {
    return Vn.equals(e.anchor, t.anchor) && Vn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Lt.isRange(t)) {
      if (Lt.includes(e, t.anchor) || Lt.includes(e, t.focus))
        return !0;
      var [n, r] = Lt.edges(e), [o, i] = Lt.edges(t);
      return Vn.isBefore(n, o) && Vn.isAfter(r, i);
    }
    var [s, a] = Lt.edges(e), l = !1, u = !1;
    return Vn.isPoint(t) ? (l = Vn.compare(t, s) >= 0, u = Vn.compare(t, a) <= 0) : (l = Fe.compare(t, s.path) >= 0, u = Fe.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Du(e, Mte), [r, o] = Lt.edges(e), [i, s] = Lt.edges(t), a = Vn.isBefore(r, i) ? i : r, l = Vn.isBefore(o, s) ? o : s;
    return Vn.isBefore(l, a) ? null : Ste({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Vn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Vn.equals(t, n);
  },
  isExpanded(e) {
    return !Lt.isCollapsed(e);
  },
  isForward(e) {
    return !Lt.isBackward(e);
  },
  isRange(e) {
    return Jr(e) && Vn.isPoint(e.anchor) && Vn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Lt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return f1(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = Lt.isCollapsed(r);
        Lt.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? Lt.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = Vn.transform(r.anchor, t, {
        affinity: i
      }), u = Vn.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, fD = (e) => Jr(e) && ft.isNodeList(e.children) && !Mn.isEditor(e), Ai = {
  isAncestor(e) {
    return Jr(e) && ft.isNodeList(e.children);
  },
  isElement: fD,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Ai.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return fD(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Dte = ["children"], Pte = ["text"], hD = /* @__PURE__ */ new WeakMap(), ft = {
  ancestor(e, t) {
    var n = ft.get(e, t);
    if (Or.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(xo.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Fe.ancestors(t, n)) {
        var o = ft.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Or.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(xo.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(xo.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = ft.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = ft.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Fe.common(t, n), o = ft.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = ft.get(e, t);
    if (Mn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(xo.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ft.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ft.nodes(e, t))
        Ai.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Ai.isAncestor(e)) {
      var t = Du(e, Dte);
      return t;
    } else {
      var t = Du(e, Pte);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = ft.get(e, n); r && !(Or.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Or.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(xo.stringify(e)));
    var n = f1({
      children: e.children
    }, (r) => {
      var [o, i] = Lt.edges(t), s = ft.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, h] = d;
          return !Lt.includes(t, h);
        }
      });
      for (var [, a] of s) {
        if (!Lt.includes(t, a)) {
          var l = ft.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (Fe.equals(a, i.path)) {
          var c = ft.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (Fe.equals(a, o.path)) {
          var p = ft.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      Mn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Or.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(xo.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Or.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Or.isText(e) || Ai.isElement(e) || Mn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = hD.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => ft.isNode(r));
    return hD.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = ft.get(e, n); r && !(Or.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = ft.get(e, t);
    if (!Or.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(xo.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Fe.levels(t, n)) {
        var o = ft.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Ai.isElement(e) && Ai.isElementProps(t) && Ai.matches(e, t) || Or.isText(e) && Or.isTextProps(t) && Or.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? Fe.isBefore(a, i) : Fe.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Or.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          Fe.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = ft.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = Fe.next(a);
          if (ft.has(e, c)) {
            a = c, l = ft.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = Fe.previous(a);
          a = p, l = ft.get(e, a);
          continue;
        }
        a = Fe.parent(a), l = ft.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Fe.parent(t), r = ft.get(e, n);
    if (Or.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Or.isText(e) ? e.text : e.children.map(ft.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ft.nodes(e, t))
        Or.isText(n) && (yield [n, r]);
    }();
  }
};
function gD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gD(Object(n), !0).forEach(function(r) {
      el(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nl = {
  isNodeOperation(e) {
    return Nl.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Jr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Fe.isPath(e.path) && ft.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Fe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Fe.isPath(e.path) && Jr(e.properties);
      case "move_node":
        return Fe.isPath(e.path) && Fe.isPath(e.newPath);
      case "remove_node":
        return Fe.isPath(e.path) && ft.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Fe.isPath(e.path);
      case "set_node":
        return Fe.isPath(e.path) && Jr(e.properties) && Jr(e.newProperties);
      case "set_selection":
        return e.properties === null && Lt.isRange(e.newProperties) || e.newProperties === null && Lt.isRange(e.properties) || Jr(e.properties) && Jr(e.newProperties);
      case "split_node":
        return Fe.isPath(e.path) && typeof e.position == "number" && Jr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Nl.isOperation(t));
  },
  isSelectionOperation(e) {
    return Nl.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Nl.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return sr(sr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return sr(sr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return sr(sr({}, e), {}, {
          type: "split_node",
          path: Fe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Fe.equals(t, n))
          return e;
        if (Fe.isSibling(n, t))
          return sr(sr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Fe.transform(n, e), o = Fe.transform(Fe.next(n), e);
        return sr(sr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return sr(sr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return sr(sr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return sr(sr({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? sr(sr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? sr(sr({}, e), {}, {
          properties: null,
          newProperties: a
        }) : sr(sr({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return sr(sr({}, e), {}, {
          type: "merge_node",
          path: Fe.next(e.path)
        });
    }
  }
}, mD = /* @__PURE__ */ new WeakMap(), Tte = (e) => {
  var t = mD.get(e);
  if (t !== void 0)
    return t;
  if (!Jr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Jr(e.marks)) && (e.selection === null || Lt.isRange(e.selection)) && ft.isNodeList(e.children) && Nl.isOperationList(e.operations);
  return mD.set(e, n), n;
}, Mn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Tte(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function vD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vD(Object(n), !0).forEach(function(r) {
      el(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Vn = {
  compare(e, t) {
    var n = Fe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Vn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Vn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Fe.equals(e.path, t.path);
  },
  isPoint(e) {
    return Jr(e) && typeof e.offset == "number" && Fe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return f1(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Fe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Fe.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Fe.equals(t.path, i) && (r.offset += t.position), r.path = Fe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Fe.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Fe.equals(t.path, i) || Fe.isAncestor(t.path, i))
            return null;
          r.path = Fe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Fe.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = Fe.transform(i, t, yD(yD({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Fe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, bD = void 0, xo = {
  setScrubber(e) {
    bD = e;
  },
  stringify(e) {
    return JSON.stringify(e, bD);
  }
}, _te = ["text"], Ate = ["anchor", "focus"];
function wD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Oi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wD(Object(n), !0).forEach(function(r) {
      el(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Or = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = Du(i, _te);
      return s;
    }
    return AR(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Jr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Or.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Oi({}, e)];
    for (var r of t) {
      var o = Du(r, Ate), [i, s] = Lt.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, h = l;
        if (l += d, u <= h && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === h) || u > l || c < h || c === h && h !== 0) {
          a.push(p);
          continue;
        }
        var y = p, f = void 0, g = void 0;
        if (c < l) {
          var x = c - h;
          g = Oi(Oi({}, y), {}, {
            text: y.text.slice(x)
          }), y = Oi(Oi({}, y), {}, {
            text: y.text.slice(0, x)
          });
        }
        if (u > h) {
          var L = u - h;
          f = Oi(Oi({}, y), {}, {
            text: y.text.slice(0, L)
          }), y = Oi(Oi({}, y), {}, {
            text: y.text.slice(L)
          });
        }
        Object.assign(y, o), f && a.push(f), a.push(y), g && a.push(g);
      }
      n = a;
    }
    return n;
  }
}, Bte = (e) => e.selection ? e.selection : e.children.length > 0 ? Mn.end(e, []) : [0], Un;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Un || (Un = {}));
Un.L, Un.L | Un.V | Un.LV | Un.LVT, Un.LV | Un.V, Un.V | Un.T, Un.LVT | Un.T, Un.T, Un.Any, Un.Extend | Un.ZWJ, Un.Any, Un.SpacingMark, Un.Prepend, Un.Any, Un.ZWJ, Un.ExtPict, Un.RI, Un.RI;
var Ite = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Mn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Bte(e)
      } = n;
      if (Fe.isPath(o) && (o = Mn.range(e, o)), Lt.isRange(o))
        if (Lt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Lt.end(o);
          if (!r && Mn.void(e, {
            at: i
          }))
            return;
          var s = Lt.start(o), a = Mn.pointRef(e, s), l = Mn.pointRef(e, i);
          $d.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, $d.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Mn.void(e, {
        at: o
      }) || Mn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function CD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CD(Object(n), !0).forEach(function(r) {
      el(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $d = xp(xp(xp(xp({}, Ete), Lte), kte), Ite), jte = typeof Dn == "object" && Dn && Dn.Object === Object && Dn, Rte = jte, Nte = Rte, Fte = typeof self == "object" && self && self.Object === Object && self, zte = Nte || Fte || Function("return this")(), Ute = zte, $te = Ute, Wte = $te.Symbol, BR = Wte, xD = BR;
xD && xD.toStringTag;
var ED = BR;
ED && ED.toStringTag;
var LD;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(LD || (LD = {}));
var h1 = function(e) {
  return Object.freeze(e);
}, Hte = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, h1(this);
  }
  return e;
}(), Vte = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, h1(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), kD = typeof window < "u" ? window : {};
/msie|trident/i.test(kD.navigator && kD.navigator.userAgent);
var Dm = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Hte((n ? t : e) || 0, (n ? e : t) || 0);
};
h1({
  devicePixelContentBoxSize: Dm(),
  borderBoxSize: Dm(),
  contentBoxSize: Dm(),
  contentRect: new Vte(0, 0, 0, 0)
});
function Pu(e) {
  "@babel/helpers - typeof";
  return Pu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Pu(e);
}
function Zte(e, t) {
  if (Pu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Pu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function qte(e) {
  var t = Zte(e, "string");
  return Pu(t) === "symbol" ? t : String(t);
}
function tu(e, t, n) {
  return t = qte(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Gte = /* @__PURE__ */ qe(null), Pm, Tm;
parseInt(Ae.version.split(".")[0], 10);
var OD = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), _m = typeof navigator < "u" && /Android/.test(navigator.userAgent), Ep = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Xte = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Pm = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Pm !== void 0 && Pm[1] && parseInt((Tm = navigator.userAgent.match(/Version\/(\d+)/)) === null || Tm === void 0 ? void 0 : Tm[1], 10) < 17;
var Yte = /* @__PURE__ */ new WeakMap(), Jte = /* @__PURE__ */ new WeakMap(), Kte = /* @__PURE__ */ new WeakMap(), Qte = /* @__PURE__ */ new WeakMap(), ene = /* @__PURE__ */ new WeakMap(), MD = /* @__PURE__ */ new WeakMap(), tne = /* @__PURE__ */ new WeakMap(), SD = /* @__PURE__ */ new WeakMap(), Lp = /* @__PURE__ */ new WeakMap(), nne = /* @__PURE__ */ new WeakMap(), rne = /* @__PURE__ */ new WeakMap(), one = /* @__PURE__ */ new WeakMap(), IR = globalThis.Node, ine = globalThis.Text, jR = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, sne = (e) => Wd(e) && e.nodeType === 8, ui = (e) => Wd(e) && e.nodeType === 1, Wd = (e) => {
  var t = jR(e);
  return !!t && e instanceof t.Node;
}, DD = (e) => {
  var t = e && e.anchorNode && jR(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, ane = (e) => {
  var [t, n] = e;
  if (ui(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = RR(t, o, r ? "backward" : "forward"), r = o < n; ui(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = une(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, lne = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, RR = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (sne(o) || ui(o) && o.childNodes.length === 0 || ui(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, une = (e, t, n) => {
  var [r] = RR(e, t, n);
  return r;
}, PD = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), NR = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ui(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Vt.getWindow(e);
  if (o.contains(r))
    return Vt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : NR(e, i, n);
}, TD = (e, t) => !!(e.compareDocumentPosition(t) & IR.DOCUMENT_POSITION_PRECEDING), cne = (e, t) => !!(e.compareDocumentPosition(t) & IR.DOCUMENT_POSITION_FOLLOWING), pne = 0;
class dne {
  constructor() {
    tu(this, "id", void 0), this.id = "".concat(pne++);
  }
}
var Vt = {
  androidPendingDiffs: (e) => one.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = rne.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Vt.toDOMNode(e, e), n = Vt.findDocumentOrShadowRoot(e);
    Lp.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Vt.findDocumentOrShadowRoot(e), r = PD(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && $d.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Vt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Vt.toSlateNode(e, t.target), s = Vt.findPath(e, i);
    if (Ai.isElement(i) && Mn.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = Mn.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? Mn.before(e, u) : Mn.after(e, u);
      if (c) {
        var p = Mn.range(e, c);
        return p;
      }
    }
    var d, {
      document: h
    } = Vt.getWindow(e);
    if (h.caretRangeFromPoint)
      d = h.caretRangeFromPoint(n, r);
    else {
      var y = h.caretPositionFromPoint(n, r);
      y && (d = h.createRange(), d.setStart(y.offsetNode, y.offset), d.setEnd(y.offsetNode, y.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var f = Vt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return f;
  },
  findKey: (e, t) => {
    var n = MD.get(t);
    return n || (n = new dne(), MD.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = Jte.get(r);
      if (o == null) {
        if (Mn.isEditor(r))
          return n;
        break;
      }
      var i = Yte.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(xo.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Lp.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Vt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Vt.toDOMNode(e, e), r = Vt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = PD(r), i = Vt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || $d.select(e, Mn.start(e, [])), Lp.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Kte.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Vt.toDOMNode(e, e), i;
    try {
      i = ui(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Wd(t) && Vt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Mn.hasPath(e, n.path) && Mn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Vt.hasEditableTarget(e, t) || Vt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Wd(t) && Vt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!nne.get(e),
  isFocused: (e) => !!Lp.get(e),
  isReadOnly: (e) => !!SD.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (SD.get(e)) return !1;
    var n = Vt.hasTarget(e, t) && Vt.toSlateNode(e, t);
    return Ai.isElement(n) && Mn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = tne.get(e), r = Mn.isEditor(t) ? Qte.get(e) : n == null ? void 0 : n.get(Vt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(xo.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Mn.node(e, t.path), r = Vt.toDOMNode(e, n), o;
    Mn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), h = d == null ? p : parseInt(d, 10), y = a + h, f = s[l + 1];
        if (t.offset === y && f !== null && f !== void 0 && f.hasAttribute("data-slate-mark-placeholder")) {
          var g, x = f.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            x instanceof ine ? x : f,
            (g = f.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= y) {
          var L = Math.min(p, Math.max(0, t.offset - a));
          o = [c, L];
          break;
        }
        a = y;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(xo.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Lt.isBackward(t), i = Vt.toDOMPoint(e, n), s = Lt.isCollapsed(t) ? i : Vt.toDOMPoint(e, r), a = Vt.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, h = ui(u) ? u : u.parentElement, y = !!h.getAttribute("data-slate-zero-width"), f = ui(p) ? p : p.parentElement, g = !!f.getAttribute("data-slate-zero-width");
    return l.setStart(u, y ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ui(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? ene.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : ane(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, h = Vt.toDOMNode(e, e), y = l.closest('[data-slate-void="true"]'), f = y && h.contains(y) ? y : null, g = l.closest('[contenteditable="false"]'), x = g && h.contains(g) ? g : null, L = l.closest("[data-slate-leaf]"), E = null;
      if (L) {
        if (u = L.closest('[data-slate-node="text"]'), u) {
          var T = Vt.getWindow(e), b = T.document.createRange();
          b.setStart(u, 0), b.setEnd(s, a);
          var C = b.cloneContents(), M = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          M.forEach((I) => {
            if (_m && !r && I.hasAttribute("data-slate-zero-width") && I.textContent.length > 0 && I.textContext !== "\uFEFF") {
              I.textContent.startsWith("\uFEFF") && (I.textContent = I.textContent.slice(1));
              return;
            }
            I.parentNode.removeChild(I);
          }), c = C.textContent.length, E = u;
        }
      } else if (f) {
        for (var S = f.querySelectorAll("[data-slate-leaf]"), F = 0; F < S.length; F++) {
          var D = S[F];
          if (Vt.hasDOMNode(e, D)) {
            L = D;
            break;
          }
        }
        L ? (u = L.closest('[data-slate-node="text"]'), E = L, c = E.textContent.length, E.querySelectorAll("[data-slate-zero-width]").forEach((I) => {
          c -= I.textContent.length;
        })) : c = 1;
      } else if (x) {
        var Z = (I) => I ? I.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], U = x.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, N = [...Z(U), ...Z(U == null ? void 0 : U.nextElementSibling)];
          L = ($ = N.find((I) => cne(x, I))) !== null && $ !== void 0 ? $ : null;
        } else {
          var V, J = [...Z(U == null ? void 0 : U.previousElementSibling), ...Z(U)];
          L = (V = J.findLast((I) => TD(x, I))) !== null && V !== void 0 ? V : null;
        }
        L && (u = L.closest('[data-slate-node="text"]'), E = L, i === "forward" ? c = 0 : (c = E.textContent.length, E.querySelectorAll("[data-slate-zero-width]").forEach((I) => {
          c -= I.textContent.length;
        })));
      }
      E && c === E.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      _m && E.getAttribute("data-slate-zero-width") === "z" && (p = E.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Ep && (d = E.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (_m && !u && !r) {
      var j = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (j && Vt.hasDOMNode(e, j, {
        editable: !0
      })) {
        var K = Vt.toSlateNode(e, j), {
          path: te,
          offset: O
        } = Mn.start(e, Vt.findPath(e, K));
        return j.querySelector("[data-slate-leaf]") || (O = a), {
          path: te,
          offset: O
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var P = Vt.toSlateNode(e, u), H = Vt.findPath(e, P);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = DD(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (DD(t)) {
        if (Ep && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), h = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && h.startContainer instanceof HTMLTableRowElement) {
            let C = function(M) {
              return M.childElementCount > 0 ? C(M.children[0]) : M;
            };
            var y = d.startContainer, f = h.startContainer, g = C(y.children[d.startOffset]), x = C(f.children[h.startOffset]);
            c = 0, x.childNodes.length > 0 ? a = x.childNodes[0] : a = x, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, x instanceof HTMLElement ? l = x.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = h.endContainer, l = h.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = h.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Xte && lne(a) || Ep ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Ep && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var L = Vt.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!L)
      return null;
    var E = TD(a, u) || a === u && c < l, T = p ? L : Vt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: E ? "forward" : "backward"
    });
    if (!T)
      return null;
    var b = {
      anchor: L,
      focus: T
    };
    return Lt.isExpanded(b) && Lt.isForward(b) && ui(u) && Mn.void(e, {
      at: b.focus,
      mode: "highest"
    }) && (b = Mn.unhangRange(e, b, {
      voids: !0
    })), b;
  }
}, fne = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, hne = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, gne = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, ar = (e) => {
  var t = fne[e], n = hne[e], r = gne[e], o = t && Om(t), i = n && Om(n), s = r && Om(r);
  return (a) => !!(o && o(a) || OD && i && i(a) || !OD && s && s(a));
};
ar("bold"), ar("compose"), ar("moveBackward"), ar("moveForward"), ar("deleteBackward"), ar("deleteForward"), ar("deleteLineBackward"), ar("deleteLineForward"), ar("deleteWordBackward"), ar("deleteWordForward"), ar("extendBackward"), ar("extendForward"), ar("extendLineBackward"), ar("extendLineForward"), ar("italic"), ar("moveLineBackward"), ar("moveLineForward"), ar("moveWordBackward"), ar("moveWordForward"), ar("redo"), ar("insertSoftBreak"), ar("splitBlock"), ar("transposeCharacter"), ar("undo");
var mne = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => NR(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, vne = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class yne extends Nu {
  constructor() {
    super(...arguments), tu(this, "context", null), tu(this, "manager", null), tu(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, vne);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = mne(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
tu(yne, "contextType", Gte);
var FR = {}, g1 = {}, m1 = {};
Object.defineProperty(m1, "__esModule", { value: !0 });
m1.default = xne;
var _D = "html", AD = "head", kp = "body", bne = /<([a-zA-Z]+[0-9]?)/, BD = /<head[^]*>/i, ID = /<body[^]*>/i, Hd = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Ny = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, jD = typeof window == "object" && window.DOMParser;
if (typeof jD == "function") {
  var wne = new jD(), Cne = "text/html";
  Ny = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), wne.parseFromString(e, Cne);
  }, Hd = Ny;
}
if (typeof document == "object" && document.implementation) {
  var Op = document.implementation.createHTMLDocument();
  Hd = function(e, t) {
    if (t) {
      var n = Op.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Op;
    }
    return Op.documentElement.innerHTML = e, Op;
  };
}
var Mp = typeof document == "object" && document.createElement("template"), Fy;
Mp && Mp.content && (Fy = function(e) {
  return Mp.innerHTML = e, Mp.content.childNodes;
});
function xne(e) {
  var t, n, r = e.match(bne), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case _D: {
      var i = Ny(e);
      if (!BD.test(e)) {
        var s = i.querySelector(AD);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!ID.test(e)) {
        var s = i.querySelector(kp);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(_D);
    }
    case AD:
    case kp: {
      var a = Hd(e).querySelectorAll(o);
      return ID.test(e) && BD.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (Fy)
        return Fy(e);
      var s = Hd(e, kp).querySelector(kp);
      return s.childNodes;
    }
  }
}
var vh = {}, v1 = {}, y1 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(y1);
var Bt = {}, Bs = Dn && Dn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), nu = Dn && Dn.__assign || function() {
  return nu = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, nu.apply(this, arguments);
};
Object.defineProperty(Bt, "__esModule", { value: !0 });
Bt.cloneNode = Bt.hasChildren = Bt.isDocument = Bt.isDirective = Bt.isComment = Bt.isText = Bt.isCDATA = Bt.isTag = Bt.Element = Bt.Document = Bt.CDATA = Bt.NodeWithChildren = Bt.ProcessingInstruction = Bt.Comment = Bt.Text = Bt.DataNode = Bt.Node = void 0;
var vo = y1, b1 = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), w1(this, t);
    }, e;
  }()
);
Bt.Node = b1;
var yh = (
  /** @class */
  function(e) {
    Bs(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(b1)
);
Bt.DataNode = yh;
var zR = (
  /** @class */
  function(e) {
    Bs(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = vo.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(yh)
);
Bt.Text = zR;
var UR = (
  /** @class */
  function(e) {
    Bs(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = vo.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(yh)
);
Bt.Comment = UR;
var $R = (
  /** @class */
  function(e) {
    Bs(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = vo.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(yh)
);
Bt.ProcessingInstruction = $R;
var bh = (
  /** @class */
  function(e) {
    Bs(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(b1)
);
Bt.NodeWithChildren = bh;
var WR = (
  /** @class */
  function(e) {
    Bs(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = vo.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bh)
);
Bt.CDATA = WR;
var HR = (
  /** @class */
  function(e) {
    Bs(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = vo.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bh)
);
Bt.Document = HR;
var VR = (
  /** @class */
  function(e) {
    Bs(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? vo.ElementType.Script : n === "style" ? vo.ElementType.Style : vo.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bh)
);
Bt.Element = VR;
function ZR(e) {
  return (0, vo.isTag)(e);
}
Bt.isTag = ZR;
function qR(e) {
  return e.type === vo.ElementType.CDATA;
}
Bt.isCDATA = qR;
function GR(e) {
  return e.type === vo.ElementType.Text;
}
Bt.isText = GR;
function XR(e) {
  return e.type === vo.ElementType.Comment;
}
Bt.isComment = XR;
function YR(e) {
  return e.type === vo.ElementType.Directive;
}
Bt.isDirective = YR;
function JR(e) {
  return e.type === vo.ElementType.Root;
}
Bt.isDocument = JR;
function Ene(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Bt.hasChildren = Ene;
function w1(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (GR(e))
    n = new zR(e.data);
  else if (XR(e))
    n = new UR(e.data);
  else if (ZR(e)) {
    var r = t ? Am(e.children) : [], o = new VR(e.name, nu({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = nu({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = nu({}, e["x-attribsPrefix"])), n = o;
  } else if (qR(e)) {
    var r = t ? Am(e.children) : [], i = new WR(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (JR(e)) {
    var r = t ? Am(e.children) : [], s = new HR(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (YR(e)) {
    var a = new $R(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Bt.cloneNode = w1;
function Am(e) {
  for (var t = e.map(function(r) {
    return w1(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Dn && Dn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = Dn && Dn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = y1, o = Bt;
  n(Bt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(v1);
var KR = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(KR);
Object.defineProperty(vh, "__esModule", { value: !0 });
vh.formatAttributes = QR;
vh.formatDOM = eN;
var Sp = v1, Lne = KR;
function kne(e) {
  return Lne.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function QR(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function One(e) {
  e = e.toLowerCase();
  var t = kne(e);
  return t || e;
}
function eN(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = One(a.nodeName);
        o = new Sp.Element(l, QR(a.attributes)), o.children = eN(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Sp.Text(a.nodeValue);
        break;
      case 8:
        o = new Sp.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Sp.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var Mne = Dn && Dn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(g1, "__esModule", { value: !0 });
g1.default = Tne;
var Sne = Mne(m1), Dne = vh, Pne = /<(![a-zA-Z\s]+)>/;
function Tne(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Pne), n = t ? t[1] : void 0;
  return (0, Dne.formatDOM)((0, Sne.default)(e), null, n);
}
var wh = {}, Jo = {}, Ch = {}, _ne = 0;
Ch.SAME = _ne;
var Ane = 1;
Ch.CAMELCASE = Ane;
Ch.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const tN = 0, Is = 1, xh = 2, Eh = 3, C1 = 4, nN = 5, rN = 6;
function Bne(e) {
  return Zr.hasOwnProperty(e) ? Zr[e] : null;
}
function oo(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === xh || t === Eh || t === C1, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const Zr = {}, Ine = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Ine.forEach((e) => {
  Zr[e] = new oo(
    e,
    tN,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Zr[e] = new oo(
    e,
    Is,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Zr[e] = new oo(
    e,
    xh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Zr[e] = new oo(
    e,
    xh,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Zr[e] = new oo(
    e,
    Eh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Zr[e] = new oo(
    e,
    Eh,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Zr[e] = new oo(
    e,
    C1,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Zr[e] = new oo(
    e,
    rN,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Zr[e] = new oo(
    e,
    nN,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const x1 = /[\-\:]([a-z])/g, E1 = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(x1, E1);
  Zr[t] = new oo(
    t,
    Is,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(x1, E1);
  Zr[t] = new oo(
    t,
    Is,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(x1, E1);
  Zr[t] = new oo(
    t,
    Is,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Zr[e] = new oo(
    e,
    Is,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const jne = "xlinkHref";
Zr[jne] = new oo(
  "xlinkHref",
  Is,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Zr[e] = new oo(
    e,
    Is,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Rne,
  SAME: Nne,
  possibleStandardNames: RD
} = Ch, Fne = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", zne = Fne + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Une = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + zne + "]*$")
), $ne = Object.keys(
  RD
).reduce((e, t) => {
  const n = RD[t];
  return n === Nne ? e[t] = t : n === Rne ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Jo.BOOLEAN = Eh;
Jo.BOOLEANISH_STRING = xh;
Jo.NUMERIC = nN;
Jo.OVERLOADED_BOOLEAN = C1;
Jo.POSITIVE_NUMERIC = rN;
Jo.RESERVED = tN;
Jo.STRING = Is;
Jo.getPropertyInfo = Bne;
Jo.isCustomAttribute = Une;
Jo.possibleStandardNames = $ne;
var L1 = {}, k1 = {}, ND = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Wne = /\n/g, Hne = /^\s*/, Vne = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Zne = /^:\s*/, qne = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Gne = /^[;\s]*/, Xne = /^\s+|\s+$/g, Yne = `
`, FD = "/", zD = "*", aa = "", Jne = "comment", Kne = "declaration", Qne = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(y) {
    var f = y.match(Wne);
    f && (n += f.length);
    var g = y.lastIndexOf(Yne);
    r = ~g ? y.length - g : r + y.length;
  }
  function i() {
    var y = { line: n, column: r };
    return function(f) {
      return f.position = new s(y), u(), f;
    };
  }
  function s(y) {
    this.start = y, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(y) {
    var f = new Error(
      t.source + ":" + n + ":" + r + ": " + y
    );
    if (f.reason = y, f.filename = t.source, f.line = n, f.column = r, f.source = e, !t.silent) throw f;
  }
  function l(y) {
    var f = y.exec(e);
    if (f) {
      var g = f[0];
      return o(g), e = e.slice(g.length), f;
    }
  }
  function u() {
    l(Hne);
  }
  function c(y) {
    var f;
    for (y = y || []; f = p(); )
      f !== !1 && y.push(f);
    return y;
  }
  function p() {
    var y = i();
    if (!(FD != e.charAt(0) || zD != e.charAt(1))) {
      for (var f = 2; aa != e.charAt(f) && (zD != e.charAt(f) || FD != e.charAt(f + 1)); )
        ++f;
      if (f += 2, aa === e.charAt(f - 1))
        return a("End of comment missing");
      var g = e.slice(2, f - 2);
      return r += 2, o(g), e = e.slice(f), r += 2, y({
        type: Jne,
        comment: g
      });
    }
  }
  function d() {
    var y = i(), f = l(Vne);
    if (f) {
      if (p(), !l(Zne)) return a("property missing ':'");
      var g = l(qne), x = y({
        type: Kne,
        property: UD(f[0].replace(ND, aa)),
        value: g ? UD(g[0].replace(ND, aa)) : aa
      });
      return l(Gne), x;
    }
  }
  function h() {
    var y = [];
    c(y);
    for (var f; f = d(); )
      f !== !1 && (y.push(f), c(y));
    return y;
  }
  return u(), h();
};
function UD(e) {
  return e ? e.replace(Xne, aa) : aa;
}
var ere = Dn && Dn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(k1, "__esModule", { value: !0 });
k1.default = nre;
var tre = ere(Qne);
function nre(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, tre.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Lh = {};
Object.defineProperty(Lh, "__esModule", { value: !0 });
Lh.camelCase = void 0;
var rre = /^--[a-zA-Z0-9-]+$/, ore = /-([a-z])/g, ire = /^[^-]+$/, sre = /^-(webkit|moz|ms|o|khtml)-/, are = /^-(ms)-/, lre = function(e) {
  return !e || ire.test(e) || rre.test(e);
}, ure = function(e, t) {
  return t.toUpperCase();
}, $D = function(e, t) {
  return "".concat(t, "-");
}, cre = function(e, t) {
  return t === void 0 && (t = {}), lre(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(are, $D) : e = e.replace(sre, $D), e.replace(ore, ure));
};
Lh.camelCase = cre;
var pre = Dn && Dn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, dre = pre(k1), fre = Lh;
function zy(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, dre.default)(e, function(r, o) {
    r && o && (n[(0, fre.camelCase)(r, t)] = o);
  }), n;
}
zy.default = zy;
var hre = zy;
(function(e) {
  var t = Dn && Dn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Ae, r = t(hre), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(L1);
Object.defineProperty(wh, "__esModule", { value: !0 });
wh.default = yre;
var Fl = Jo, WD = L1, gre = ["checked", "value"], mre = ["input", "select", "textarea"], vre = {
  reset: !0,
  submit: !0
};
function yre(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && vre[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Fl.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = HD(s);
    if (a) {
      var l = (0, Fl.getPropertyInfo)(a);
      switch (gre.includes(a) && mre.includes(t) && !r && (a = HD("default" + s)), n[a] = i, l && l.type) {
        case Fl.BOOLEAN:
          n[a] = !0;
          break;
        case Fl.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    WD.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, WD.setStyleProp)(e.style, n), n;
}
function HD(e) {
  return Fl.possibleStandardNames[e];
}
var O1 = {}, bre = Dn && Dn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(O1, "__esModule", { value: !0 });
O1.default = oN;
var Bm = Ae, wre = bre(wh), ru = L1, Cre = {
  cloneElement: Bm.cloneElement,
  createElement: Bm.createElement,
  isValidElement: Bm.isValidElement
};
function oN(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || ru.returnFirstArg, i = t.library || Cre, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var h = !p.data.trim().length;
      if (h && p.parent && !(0, ru.canTextBeChildOfNode)(p.parent) || t.trim && h)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var y = p, f = {};
    xre(y) ? ((0, ru.setStyleProp)(y.attribs.style, y.attribs), f = y.attribs) : y.attribs && (f = (0, wre.default)(y.attribs, y.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (f.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? f.defaultValue = p.children[0].data : p.children && p.children.length && (g = oN(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (f.key = c), n.push(o(a(p.name, f, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function xre(e) {
  return ru.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, ru.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Dn && Dn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(g1);
  e.htmlToDOM = n.default;
  var r = t(wh);
  e.attributesToProps = r.default;
  var o = t(O1);
  e.domToReact = o.default;
  var i = v1;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(FR);
const VD = /* @__PURE__ */ OU(FR);
VD.default;
qe({});
qe({});
qe({});
function Ere(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...s
  } = e, a = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ an.jsxs("div", { className: a.trim(), ...s, children: [
    r,
    /* @__PURE__ */ an.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
var Pr = {}, M1 = {}, sc = {}, ac = {}, iN = "Expected a function", ZD = NaN, Lre = "[object Symbol]", kre = /^\s+|\s+$/g, Ore = /^[-+]0x[0-9a-f]+$/i, Mre = /^0b[01]+$/i, Sre = /^0o[0-7]+$/i, Dre = parseInt, Pre = typeof Dn == "object" && Dn && Dn.Object === Object && Dn, Tre = typeof self == "object" && self && self.Object === Object && self, _re = Pre || Tre || Function("return this")(), Are = Object.prototype, Bre = Are.toString, Ire = Math.max, jre = Math.min, Im = function() {
  return _re.Date.now();
};
function Rre(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(iN);
  t = qD(t) || 0, Vd(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Ire(qD(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function h(C) {
    var M = r, S = o;
    return r = o = void 0, u = C, s = e.apply(S, M), s;
  }
  function y(C) {
    return u = C, a = setTimeout(x, t), c ? h(C) : s;
  }
  function f(C) {
    var M = C - l, S = C - u, F = t - M;
    return p ? jre(F, i - S) : F;
  }
  function g(C) {
    var M = C - l, S = C - u;
    return l === void 0 || M >= t || M < 0 || p && S >= i;
  }
  function x() {
    var C = Im();
    if (g(C))
      return L(C);
    a = setTimeout(x, f(C));
  }
  function L(C) {
    return a = void 0, d && r ? h(C) : (r = o = void 0, s);
  }
  function E() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function T() {
    return a === void 0 ? s : L(Im());
  }
  function b() {
    var C = Im(), M = g(C);
    if (r = arguments, o = this, l = C, M) {
      if (a === void 0)
        return y(l);
      if (p)
        return a = setTimeout(x, t), h(l);
    }
    return a === void 0 && (a = setTimeout(x, t)), s;
  }
  return b.cancel = E, b.flush = T, b;
}
function Nre(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(iN);
  return Vd(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Rre(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Vd(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Fre(e) {
  return !!e && typeof e == "object";
}
function zre(e) {
  return typeof e == "symbol" || Fre(e) && Bre.call(e) == Lre;
}
function qD(e) {
  if (typeof e == "number")
    return e;
  if (zre(e))
    return ZD;
  if (Vd(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Vd(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(kre, "");
  var n = Mre.test(e);
  return n || Sre.test(e) ? Dre(e.slice(2), n ? 2 : 8) : Ore.test(e) ? ZD : +e;
}
var Ure = Nre, lc = {};
Object.defineProperty(lc, "__esModule", {
  value: !0
});
lc.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), nd.has(t) || nd.set(t, /* @__PURE__ */ new Set());
  var o = nd.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
lc.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), nd.get(t).delete(n.name || t);
};
var nd = /* @__PURE__ */ new Map();
Object.defineProperty(ac, "__esModule", {
  value: !0
});
var $re = Ure, Wre = Vre($re), Hre = lc;
function Vre(e) {
  return e && e.__esModule ? e : { default: e };
}
var Zre = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Wre.default)(e, t);
}, mr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = Zre(function(r) {
        mr.scrollHandler(e);
      }, t);
      mr.scrollSpyContainers.push(e), (0, Hre.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return mr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = mr.scrollSpyContainers[mr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(mr.currentPositionX(e), mr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    mr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = mr.scrollSpyContainers[mr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(mr.currentPositionX(t), mr.currentPositionY(t));
  },
  updateStates: function() {
    mr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    mr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), mr.spySetState && mr.spySetState.length && mr.spySetState.indexOf(e) > -1 && mr.spySetState.splice(mr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", mr.scrollHandler);
  },
  update: function() {
    return mr.scrollSpyContainers.forEach(function(e) {
      return mr.scrollHandler(e);
    });
  }
};
ac.default = mr;
var tl = {}, uc = {};
Object.defineProperty(uc, "__esModule", {
  value: !0
});
var qre = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, Gre = function() {
  return window.location.hash.replace(/^#/, "");
}, Xre = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Yre = function(e) {
  return getComputedStyle(e).position !== "static";
}, jm = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, Jre = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Yre(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = jm(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return jm(t, a).offsetTop - jm(e, a).offsetTop;
};
uc.default = {
  updateHash: qre,
  getHash: Gre,
  filterElementInContainer: Xre,
  scrollOffset: Jre
};
var kh = {}, S1 = {};
Object.defineProperty(S1, "__esModule", {
  value: !0
});
S1.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var D1 = {};
Object.defineProperty(D1, "__esModule", {
  value: !0
});
var Kre = lc, Qre = ["mousedown", "mousewheel", "touchmove", "keydown"];
D1.default = {
  subscribe: function(e) {
    return typeof document < "u" && Qre.forEach(function(t) {
      return (0, Kre.addPassiveEventListener)(document, t, e);
    });
  }
};
var cc = {};
Object.defineProperty(cc, "__esModule", {
  value: !0
});
var Uy = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Uy.registered[e] = t;
    },
    remove: function(e) {
      Uy.registered[e] = null;
    }
  }
};
cc.default = Uy;
Object.defineProperty(kh, "__esModule", {
  value: !0
});
var eoe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, toe = uc;
Oh(toe);
var noe = S1, GD = Oh(noe), roe = D1, ooe = Oh(roe), ioe = cc, oi = Oh(ioe);
function Oh(e) {
  return e && e.__esModule ? e : { default: e };
}
var sN = function(e) {
  return GD.default[e.smooth] || GD.default.defaultEasing;
}, soe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, aoe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, $y = function() {
  return aoe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), aN = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, lN = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, uN = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, loe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, uoe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, coe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    oi.default.registered.end && oi.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    $y.call(window, i);
    return;
  }
  oi.default.registered.end && oi.default.registered.end(o.to, o.target, o.currentPosition);
}, P1 = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, pc = function(e, t, n, r) {
  t.data = t.data || aN(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (ooe.default.subscribe(o), P1(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? lN(t) : uN(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    oi.default.registered.end && oi.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = soe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = sN(t), s = coe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      oi.default.registered.begin && oi.default.registered.begin(t.data.to, t.data.target), $y.call(window, s);
    }, t.delay);
    return;
  }
  oi.default.registered.begin && oi.default.registered.begin(t.data.to, t.data.target), $y.call(window, s);
}, Mh = function(e) {
  return e = eoe({}, e), e.data = e.data || aN(), e.absolute = !0, e;
}, poe = function(e) {
  pc(0, Mh(e));
}, doe = function(e, t) {
  pc(e, Mh(t));
}, foe = function(e) {
  e = Mh(e), P1(e), pc(e.horizontal ? loe(e) : uoe(e), e);
}, hoe = function(e, t) {
  t = Mh(t), P1(t);
  var n = t.horizontal ? lN(t) : uN(t);
  pc(e + n, t);
};
kh.default = {
  animateTopScroll: pc,
  getAnimationType: sN,
  scrollToTop: poe,
  scrollToBottom: foe,
  scrollTo: doe,
  scrollMore: hoe
};
Object.defineProperty(tl, "__esModule", {
  value: !0
});
var goe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, moe = uc, voe = T1(moe), yoe = kh, boe = T1(yoe), woe = cc, Dp = T1(woe);
function T1(e) {
  return e && e.__esModule ? e : { default: e };
}
var Pp = {}, XD = void 0;
tl.default = {
  unmount: function() {
    Pp = {};
  },
  register: function(e, t) {
    Pp[e] = t;
  },
  unregister: function(e) {
    delete Pp[e];
  },
  get: function(e) {
    return Pp[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return XD = e;
  },
  getActiveLink: function() {
    return XD;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = goe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = voe.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      Dp.default.registered.begin && Dp.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, Dp.default.registered.end && Dp.default.registered.end(e, n);
      return;
    }
    boe.default.animateTopScroll(a, t, e, n);
  }
};
var Wy = { exports: {} }, Rm = { exports: {} }, pn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var YD;
function Coe() {
  if (YD) return pn;
  YD = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
  function E(b) {
    if (typeof b == "object" && b !== null) {
      var C = b.$$typeof;
      switch (C) {
        case t:
          switch (b = b.type, b) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case a:
                case c:
                case y:
                case h:
                case s:
                  return b;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function T(b) {
    return E(b) === u;
  }
  return pn.AsyncMode = l, pn.ConcurrentMode = u, pn.ContextConsumer = a, pn.ContextProvider = s, pn.Element = t, pn.ForwardRef = c, pn.Fragment = r, pn.Lazy = y, pn.Memo = h, pn.Portal = n, pn.Profiler = i, pn.StrictMode = o, pn.Suspense = p, pn.isAsyncMode = function(b) {
    return T(b) || E(b) === l;
  }, pn.isConcurrentMode = T, pn.isContextConsumer = function(b) {
    return E(b) === a;
  }, pn.isContextProvider = function(b) {
    return E(b) === s;
  }, pn.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === t;
  }, pn.isForwardRef = function(b) {
    return E(b) === c;
  }, pn.isFragment = function(b) {
    return E(b) === r;
  }, pn.isLazy = function(b) {
    return E(b) === y;
  }, pn.isMemo = function(b) {
    return E(b) === h;
  }, pn.isPortal = function(b) {
    return E(b) === n;
  }, pn.isProfiler = function(b) {
    return E(b) === i;
  }, pn.isStrictMode = function(b) {
    return E(b) === o;
  }, pn.isSuspense = function(b) {
    return E(b) === p;
  }, pn.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === r || b === u || b === i || b === o || b === p || b === d || typeof b == "object" && b !== null && (b.$$typeof === y || b.$$typeof === h || b.$$typeof === s || b.$$typeof === a || b.$$typeof === c || b.$$typeof === g || b.$$typeof === x || b.$$typeof === L || b.$$typeof === f);
  }, pn.typeOf = E, pn;
}
var En = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JD;
function xoe() {
  return JD || (JD = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
    function E(A) {
      return typeof A == "string" || typeof A == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      A === r || A === u || A === i || A === o || A === p || A === d || typeof A == "object" && A !== null && (A.$$typeof === y || A.$$typeof === h || A.$$typeof === s || A.$$typeof === a || A.$$typeof === c || A.$$typeof === g || A.$$typeof === x || A.$$typeof === L || A.$$typeof === f);
    }
    function T(A) {
      if (typeof A == "object" && A !== null) {
        var ae = A.$$typeof;
        switch (ae) {
          case t:
            var ce = A.type;
            switch (ce) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ce;
              default:
                var ue = ce && ce.$$typeof;
                switch (ue) {
                  case a:
                  case c:
                  case y:
                  case h:
                  case s:
                    return ue;
                  default:
                    return ae;
                }
            }
          case n:
            return ae;
        }
      }
    }
    var b = l, C = u, M = a, S = s, F = t, D = c, Z = r, U = y, $ = h, N = n, V = i, J = o, j = p, K = !1;
    function te(A) {
      return K || (K = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), O(A) || T(A) === l;
    }
    function O(A) {
      return T(A) === u;
    }
    function P(A) {
      return T(A) === a;
    }
    function H(A) {
      return T(A) === s;
    }
    function I(A) {
      return typeof A == "object" && A !== null && A.$$typeof === t;
    }
    function W(A) {
      return T(A) === c;
    }
    function X(A) {
      return T(A) === r;
    }
    function w(A) {
      return T(A) === y;
    }
    function R(A) {
      return T(A) === h;
    }
    function z(A) {
      return T(A) === n;
    }
    function _(A) {
      return T(A) === i;
    }
    function Y(A) {
      return T(A) === o;
    }
    function Q(A) {
      return T(A) === p;
    }
    En.AsyncMode = b, En.ConcurrentMode = C, En.ContextConsumer = M, En.ContextProvider = S, En.Element = F, En.ForwardRef = D, En.Fragment = Z, En.Lazy = U, En.Memo = $, En.Portal = N, En.Profiler = V, En.StrictMode = J, En.Suspense = j, En.isAsyncMode = te, En.isConcurrentMode = O, En.isContextConsumer = P, En.isContextProvider = H, En.isElement = I, En.isForwardRef = W, En.isFragment = X, En.isLazy = w, En.isMemo = R, En.isPortal = z, En.isProfiler = _, En.isStrictMode = Y, En.isSuspense = Q, En.isValidElementType = E, En.typeOf = T;
  }()), En;
}
var KD;
function cN() {
  return KD || (KD = 1, process.env.NODE_ENV === "production" ? Rm.exports = Coe() : Rm.exports = xoe()), Rm.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Nm, QD;
function Eoe() {
  if (QD) return Nm;
  QD = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Nm = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, Nm;
}
var Fm, eP;
function _1() {
  if (eP) return Fm;
  eP = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Fm = e, Fm;
}
var tP, nP;
function pN() {
  return nP || (nP = 1, tP = Function.call.bind(Object.prototype.hasOwnProperty)), tP;
}
var zm, rP;
function Loe() {
  if (rP) return zm;
  rP = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = _1(), n = {}, r = pN();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (y) {
            p = y;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var h = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (h ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, zm = o, zm;
}
var Um, oP;
function koe() {
  if (oP) return Um;
  oP = 1;
  var e = cN(), t = Eoe(), n = _1(), r = pN(), o = Loe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return Um = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(O) {
      var P = O && (u && O[u] || O[c]);
      if (typeof P == "function")
        return P;
    }
    var d = "<<anonymous>>", h = {
      array: x("array"),
      bigint: x("bigint"),
      bool: x("boolean"),
      func: x("function"),
      number: x("number"),
      object: x("object"),
      string: x("string"),
      symbol: x("symbol"),
      any: L(),
      arrayOf: E,
      element: T(),
      elementType: b(),
      instanceOf: C,
      node: D(),
      objectOf: S,
      oneOf: M,
      oneOfType: F,
      shape: U,
      exact: $
    };
    function y(O, P) {
      return O === P ? O !== 0 || 1 / O === 1 / P : O !== O && P !== P;
    }
    function f(O, P) {
      this.message = O, this.data = P && typeof P == "object" ? P : {}, this.stack = "";
    }
    f.prototype = Error.prototype;
    function g(O) {
      if (process.env.NODE_ENV !== "production")
        var P = {}, H = 0;
      function I(X, w, R, z, _, Y, Q) {
        if (z = z || d, Y = Y || R, Q !== n) {
          if (l) {
            var A = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw A.name = "Invariant Violation", A;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ae = z + ":" + R;
            !P[ae] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + Y + "` prop on `" + z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), P[ae] = !0, H++);
          }
        }
        return w[R] == null ? X ? w[R] === null ? new f("The " + _ + " `" + Y + "` is marked as required " + ("in `" + z + "`, but its value is `null`.")) : new f("The " + _ + " `" + Y + "` is marked as required in " + ("`" + z + "`, but its value is `undefined`.")) : null : O(w, R, z, _, Y);
      }
      var W = I.bind(null, !1);
      return W.isRequired = I.bind(null, !0), W;
    }
    function x(O) {
      function P(H, I, W, X, w, R) {
        var z = H[I], _ = J(z);
        if (_ !== O) {
          var Y = j(z);
          return new f(
            "Invalid " + X + " `" + w + "` of type " + ("`" + Y + "` supplied to `" + W + "`, expected ") + ("`" + O + "`."),
            { expectedType: O }
          );
        }
        return null;
      }
      return g(P);
    }
    function L() {
      return g(s);
    }
    function E(O) {
      function P(H, I, W, X, w) {
        if (typeof O != "function")
          return new f("Property `" + w + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var R = H[I];
        if (!Array.isArray(R)) {
          var z = J(R);
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected an array."));
        }
        for (var _ = 0; _ < R.length; _++) {
          var Y = O(R, _, W, X, w + "[" + _ + "]", n);
          if (Y instanceof Error)
            return Y;
        }
        return null;
      }
      return g(P);
    }
    function T() {
      function O(P, H, I, W, X) {
        var w = P[H];
        if (!a(w)) {
          var R = J(w);
          return new f("Invalid " + W + " `" + X + "` of type " + ("`" + R + "` supplied to `" + I + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(O);
    }
    function b() {
      function O(P, H, I, W, X) {
        var w = P[H];
        if (!e.isValidElementType(w)) {
          var R = J(w);
          return new f("Invalid " + W + " `" + X + "` of type " + ("`" + R + "` supplied to `" + I + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(O);
    }
    function C(O) {
      function P(H, I, W, X, w) {
        if (!(H[I] instanceof O)) {
          var R = O.name || d, z = te(H[I]);
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected ") + ("instance of `" + R + "`."));
        }
        return null;
      }
      return g(P);
    }
    function M(O) {
      if (!Array.isArray(O))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function P(H, I, W, X, w) {
        for (var R = H[I], z = 0; z < O.length; z++)
          if (y(R, O[z]))
            return null;
        var _ = JSON.stringify(O, function(Y, Q) {
          var A = j(Q);
          return A === "symbol" ? String(Q) : Q;
        });
        return new f("Invalid " + X + " `" + w + "` of value `" + String(R) + "` " + ("supplied to `" + W + "`, expected one of " + _ + "."));
      }
      return g(P);
    }
    function S(O) {
      function P(H, I, W, X, w) {
        if (typeof O != "function")
          return new f("Property `" + w + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected an object."));
        for (var _ in R)
          if (r(R, _)) {
            var Y = O(R, _, W, X, w + "." + _, n);
            if (Y instanceof Error)
              return Y;
          }
        return null;
      }
      return g(P);
    }
    function F(O) {
      if (!Array.isArray(O))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var P = 0; P < O.length; P++) {
        var H = O[P];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + K(H) + " at index " + P + "."
          ), s;
      }
      function I(W, X, w, R, z) {
        for (var _ = [], Y = 0; Y < O.length; Y++) {
          var Q = O[Y], A = Q(W, X, w, R, z, n);
          if (A == null)
            return null;
          A.data && r(A.data, "expectedType") && _.push(A.data.expectedType);
        }
        var ae = _.length > 0 ? ", expected one of type [" + _.join(", ") + "]" : "";
        return new f("Invalid " + R + " `" + z + "` supplied to " + ("`" + w + "`" + ae + "."));
      }
      return g(I);
    }
    function D() {
      function O(P, H, I, W, X) {
        return N(P[H]) ? null : new f("Invalid " + W + " `" + X + "` supplied to " + ("`" + I + "`, expected a ReactNode."));
      }
      return g(O);
    }
    function Z(O, P, H, I, W) {
      return new f(
        (O || "React class") + ": " + P + " type `" + H + "." + I + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function U(O) {
      function P(H, I, W, X, w) {
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type `" + z + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var _ in O) {
          var Y = O[_];
          if (typeof Y != "function")
            return Z(W, X, w, _, j(Y));
          var Q = Y(R, _, W, X, w + "." + _, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return g(P);
    }
    function $(O) {
      function P(H, I, W, X, w) {
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type `" + z + "` " + ("supplied to `" + W + "`, expected `object`."));
        var _ = t({}, H[I], O);
        for (var Y in _) {
          var Q = O[Y];
          if (r(O, Y) && typeof Q != "function")
            return Z(W, X, w, Y, j(Q));
          if (!Q)
            return new f(
              "Invalid " + X + " `" + w + "` key `" + Y + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(H[I], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(O), null, "  ")
            );
          var A = Q(R, Y, W, X, w + "." + Y, n);
          if (A)
            return A;
        }
        return null;
      }
      return g(P);
    }
    function N(O) {
      switch (typeof O) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !O;
        case "object":
          if (Array.isArray(O))
            return O.every(N);
          if (O === null || a(O))
            return !0;
          var P = p(O);
          if (P) {
            var H = P.call(O), I;
            if (P !== O.entries) {
              for (; !(I = H.next()).done; )
                if (!N(I.value))
                  return !1;
            } else
              for (; !(I = H.next()).done; ) {
                var W = I.value;
                if (W && !N(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function V(O, P) {
      return O === "symbol" ? !0 : P ? P["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && P instanceof Symbol : !1;
    }
    function J(O) {
      var P = typeof O;
      return Array.isArray(O) ? "array" : O instanceof RegExp ? "object" : V(P, O) ? "symbol" : P;
    }
    function j(O) {
      if (typeof O > "u" || O === null)
        return "" + O;
      var P = J(O);
      if (P === "object") {
        if (O instanceof Date)
          return "date";
        if (O instanceof RegExp)
          return "regexp";
      }
      return P;
    }
    function K(O) {
      var P = j(O);
      switch (P) {
        case "array":
        case "object":
          return "an " + P;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + P;
        default:
          return P;
      }
    }
    function te(O) {
      return !O.constructor || !O.constructor.name ? d : O.constructor.name;
    }
    return h.checkPropTypes = o, h.resetWarningCache = o.resetWarningCache, h.PropTypes = h, h;
  }, Um;
}
var $m, iP;
function Ooe() {
  if (iP) return $m;
  iP = 1;
  var e = _1();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, $m = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, $m;
}
if (process.env.NODE_ENV !== "production") {
  var Moe = cN(), Soe = !0;
  Wy.exports = koe()(Moe.isElement, Soe);
} else
  Wy.exports = Ooe()();
var Sh = Wy.exports, Dh = {};
Object.defineProperty(Dh, "__esModule", {
  value: !0
});
var Doe = uc, Wm = Poe(Doe);
function Poe(e) {
  return e && e.__esModule ? e : { default: e };
}
var Toe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Wm.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Wm.default.getHash() !== e && Wm.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Dh.default = Toe;
Object.defineProperty(sc, "__esModule", {
  value: !0
});
var Tp = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, _oe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Aoe = Ae, sP = dc(Aoe), Boe = ac, _p = dc(Boe), Ioe = tl, joe = dc(Ioe), Roe = Sh, lr = dc(Roe), Noe = Dh, Qi = dc(Noe);
function dc(e) {
  return e && e.__esModule ? e : { default: e };
}
function Foe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function zoe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Uoe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var aP = {
  to: lr.default.string.isRequired,
  containerId: lr.default.string,
  container: lr.default.object,
  activeClass: lr.default.string,
  activeStyle: lr.default.object,
  spy: lr.default.bool,
  horizontal: lr.default.bool,
  smooth: lr.default.oneOfType([lr.default.bool, lr.default.string]),
  offset: lr.default.number,
  delay: lr.default.number,
  isDynamic: lr.default.bool,
  onClick: lr.default.func,
  duration: lr.default.oneOfType([lr.default.number, lr.default.func]),
  absolute: lr.default.bool,
  onSetActive: lr.default.func,
  onSetInactive: lr.default.func,
  ignoreCancelEvents: lr.default.bool,
  hashSpy: lr.default.bool,
  saveHashHistory: lr.default.bool,
  spyThrottle: lr.default.number
};
sc.default = function(e, t) {
  var n = t || joe.default, r = function(i) {
    Uoe(s, i);
    function s(a) {
      Foe(this, s);
      var l = zoe(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return _oe(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          _p.default.isMounted(a) || _p.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (Qi.default.isMounted() || Qi.default.mount(n), Qi.default.mapContainer(this.props.to, a)), _p.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        _p.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Tp({}, this.props.style, this.props.activeStyle) : l = Tp({}, this.props.style);
        var u = Tp({}, this.props);
        for (var c in aP)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, sP.default.createElement(e, u);
      }
    }]), s;
  }(sP.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, Tp({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Qi.default.isMounted() && !Qi.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, h = void 0;
        if (u) {
          var y = 0, f = 0, g = 0;
          if (l.getBoundingClientRect) {
            var x = l.getBoundingClientRect();
            g = x.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var L = p.getBoundingClientRect();
            y = L.left - g + s, f = y + L.width;
          }
          var E = s - i.props.offset;
          d = E >= Math.floor(y) && E < Math.floor(f), h = E < Math.floor(y) || E >= Math.floor(f);
        } else {
          var T = 0, b = 0, C = 0;
          if (l.getBoundingClientRect) {
            var M = l.getBoundingClientRect();
            C = M.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var S = p.getBoundingClientRect();
            T = S.top - C + a, b = T + S.height;
          }
          var F = a - i.props.offset;
          d = F >= Math.floor(T) && F < Math.floor(b), h = F < Math.floor(T) || F >= Math.floor(b);
        }
        var D = n.getActiveLink();
        if (h) {
          if (c === D && n.setActiveLink(void 0), i.props.hashSpy && Qi.default.getHash() === c) {
            var Z = i.props.saveHashHistory, U = Z === void 0 ? !1 : Z;
            Qi.default.changeHash("", U);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (D !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, N = $ === void 0 ? !1 : $;
          i.props.hashSpy && Qi.default.changeHash(c, N), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = aP, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(M1, "__esModule", {
  value: !0
});
var $oe = Ae, lP = dN($oe), Woe = sc, Hoe = dN(Woe);
function dN(e) {
  return e && e.__esModule ? e : { default: e };
}
function Voe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function uP(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Zoe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var qoe = function(e) {
  Zoe(t, e);
  function t() {
    var n, r, o, i;
    Voe(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = uP(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return lP.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), uP(o, i);
  }
  return t;
}(lP.default.Component);
M1.default = (0, Hoe.default)(qoe);
var A1 = {};
Object.defineProperty(A1, "__esModule", {
  value: !0
});
var Goe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Xoe = Ae, cP = fN(Xoe), Yoe = sc, Joe = fN(Yoe);
function fN(e) {
  return e && e.__esModule ? e : { default: e };
}
function Koe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Qoe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function eie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var tie = function(e) {
  eie(t, e);
  function t() {
    return Koe(this, t), Qoe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Goe(t, [{
    key: "render",
    value: function() {
      return cP.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(cP.default.Component);
A1.default = (0, Joe.default)(tie);
var B1 = {}, Ph = {};
Object.defineProperty(Ph, "__esModule", {
  value: !0
});
var nie = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, rie = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), oie = Ae, pP = Th(oie), iie = qa;
Th(iie);
var sie = tl, dP = Th(sie), aie = Sh, fP = Th(aie);
function Th(e) {
  return e && e.__esModule ? e : { default: e };
}
function lie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function uie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function cie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Ph.default = function(e) {
  var t = function(n) {
    cie(r, n);
    function r(o) {
      lie(this, r);
      var i = uie(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return rie(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        dP.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        dP.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return pP.default.createElement(e, nie({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(pP.default.Component);
  return t.propTypes = {
    name: fP.default.string,
    id: fP.default.string
  }, t;
};
Object.defineProperty(B1, "__esModule", {
  value: !0
});
var hP = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, pie = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), die = Ae, gP = I1(die), fie = Ph, hie = I1(fie), gie = Sh, mP = I1(gie);
function I1(e) {
  return e && e.__esModule ? e : { default: e };
}
function mie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function yie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var hN = function(e) {
  yie(t, e);
  function t() {
    return mie(this, t), vie(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return pie(t, [{
    key: "render",
    value: function() {
      var n = this, r = hP({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, gP.default.createElement(
        "div",
        hP({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(gP.default.Component);
hN.propTypes = {
  name: mP.default.string,
  id: mP.default.string
};
B1.default = (0, hie.default)(hN);
var Hm = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, vP = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function yP(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function bP(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function wP(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Ap = Ae, Xs = ac, Vm = tl, Cr = Sh, es = Dh, CP = {
  to: Cr.string.isRequired,
  containerId: Cr.string,
  container: Cr.object,
  activeClass: Cr.string,
  spy: Cr.bool,
  smooth: Cr.oneOfType([Cr.bool, Cr.string]),
  offset: Cr.number,
  delay: Cr.number,
  isDynamic: Cr.bool,
  onClick: Cr.func,
  duration: Cr.oneOfType([Cr.number, Cr.func]),
  absolute: Cr.bool,
  onSetActive: Cr.func,
  onSetInactive: Cr.func,
  ignoreCancelEvents: Cr.bool,
  hashSpy: Cr.bool,
  spyThrottle: Cr.number
}, bie = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Vm, r = function(i) {
      wP(s, i);
      function s(a) {
        yP(this, s);
        var l = bP(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return vP(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            Xs.isMounted(a) || Xs.mount(a, this.props.spyThrottle), this.props.hashSpy && (es.isMounted() || es.mount(n), es.mapContainer(this.props.to, a)), this.props.spy && Xs.addStateHandler(this.stateHandler), Xs.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Xs.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = Hm({}, this.props);
          for (var u in CP)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, Ap.createElement(e, l);
        }
      }]), s;
    }(Ap.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, Hm({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(es.isMounted() && !es.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var h = a.getBoundingClientRect();
            d = h.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var y = u.getBoundingClientRect();
            c = y.top - d + s, p = c + y.height;
          }
          var f = s - i.props.offset, g = f >= Math.floor(c) && f < Math.floor(p), x = f < Math.floor(c) || f >= Math.floor(p), L = n.getActiveLink();
          if (x)
            return l === L && n.setActiveLink(void 0), i.props.hashSpy && es.getHash() === l && es.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Xs.updateStates();
          if (g && L !== l)
            return n.setActiveLink(l), i.props.hashSpy && es.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Xs.updateStates();
        }
      };
    };
    return r.propTypes = CP, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      wP(r, n);
      function r(o) {
        yP(this, r);
        var i = bP(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return vP(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Vm.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Vm.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Ap.createElement(e, Hm({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Ap.Component);
    return t.propTypes = {
      name: Cr.string,
      id: Cr.string
    }, t;
  }
}, wie = bie;
Object.defineProperty(Pr, "__esModule", {
  value: !0
});
Pr.Helpers = Pr.ScrollElement = Pr.ScrollLink = Pr.animateScroll = Pr.scrollSpy = Pr.Events = Pr.scroller = Pr.Element = Pr.Button = Pr.Link = void 0;
var Cie = M1, gN = mi(Cie), xie = A1, mN = mi(xie), Eie = B1, vN = mi(Eie), Lie = tl, yN = mi(Lie), kie = cc, bN = mi(kie), Oie = ac, wN = mi(Oie), Mie = kh, CN = mi(Mie), Sie = sc, xN = mi(Sie), Die = Ph, EN = mi(Die), Pie = wie, LN = mi(Pie);
function mi(e) {
  return e && e.__esModule ? e : { default: e };
}
Pr.Link = gN.default;
Pr.Button = mN.default;
Pr.Element = vN.default;
Pr.scroller = yN.default;
Pr.Events = bN.default;
Pr.scrollSpy = wN.default;
Pr.animateScroll = CN.default;
Pr.ScrollLink = xN.default;
Pr.ScrollElement = EN.default;
Pr.Helpers = LN.default;
Pr.default = { Link: gN.default, Button: mN.default, Element: vN.default, scroller: yN.default, Events: bN.default, scrollSpy: wN.default, animateScroll: CN.default, ScrollLink: xN.default, ScrollElement: EN.default, Helpers: LN.default };
qe({});
qe({});
qe({});
let Tie = { data: "" }, _ie = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Tie, Aie = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Bie = /\/\*[^]*?\*\/|  +/g, xP = /\n+/g, bs = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? bs(s, i) : i + "{" + bs(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += bs(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += bs.p ? bs.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Mi = {}, kN = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + kN(e[n]);
    return t;
  }
  return e;
}, Iie = (e, t, n, r, o) => {
  let i = kN(e), s = Mi[i] || (Mi[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Mi[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Aie.exec(u.replace(Bie, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(xP, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(xP, " ").trim();
      return d[0];
    })(e);
    Mi[s] = bs(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Mi.g ? Mi.g : null;
  return n && (Mi.g = Mi[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Mi[s], t, r, a), s;
}, jie = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : bs(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function _h(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Iie(n.unshift ? n.raw ? jie(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, _ie(t.target), t.g, t.o, t.k);
}
let ON, Hy, Vy;
_h.bind({ g: 1 });
let Ni = _h.bind({ k: 1 });
function Rie(e, t, n, r) {
  bs.p = t, ON = e, Hy = n, Vy = r;
}
function js(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: Hy && Hy() }, a), n.o = / *go\d+/.test(l), a.className = _h.apply(n, r) + (l ? " " + l : ""), t && (a.ref = s);
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Vy && u[0] && Vy(a), ON(u, a);
    }
    return t ? t(o) : o;
  };
}
var Nie = (e) => typeof e == "function", Fie = (e, t) => Nie(e) ? e(t) : e, zie = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Uie = Ni`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, $ie = Ni`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Wie = Ni`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Hie = js("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Uie} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${$ie} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Wie} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Vie = Ni`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Zie = js("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Vie} 1s linear infinite;
`, qie = Ni`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Gie = Ni`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, Xie = js("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${qie} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Gie} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Yie = js("div")`
  position: absolute;
`, Jie = js("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Kie = Ni`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Qie = js("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Kie} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, ese = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? He.createElement(Qie, null, t) : t : n === "blank" ? null : He.createElement(Jie, null, He.createElement(Zie, { ...r }), n !== "loading" && He.createElement(Yie, null, n === "error" ? He.createElement(Hie, { ...r }) : He.createElement(Xie, { ...r })));
}, tse = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, nse = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, rse = "0%{opacity:0;} 100%{opacity:1;}", ose = "0%{opacity:1;} 100%{opacity:0;}", ise = js("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, sse = js("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, ase = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = zie() ? [rse, ose] : [tse(n), nse(n)];
  return { animation: t ? `${Ni(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ni(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
He.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? ase(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = He.createElement(ese, { toast: e }), s = He.createElement(sse, { ...e.ariaProps }, Fie(e.message, e));
  return He.createElement(ise, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : He.createElement(He.Fragment, null, i, s));
});
Rie(He.createElement);
_h`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function lse(e) {
  const {
    filePath: t,
    isLoading: n,
    acceptImage: r,
    changeImageButtonText: o,
    handleSelectFile: i,
    reSendImage: s
  } = e;
  function a() {
    const l = document.createElement("input");
    l.type = "file", l.accept = r, l.onchange = (u) => {
      var p;
      const c = (p = u.target.files) == null ? void 0 : p[0];
      c && i(c);
    }, l.click();
  }
  return /* @__PURE__ */ re.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${t}")` },
      children: [
        s && /* @__PURE__ */ re.jsx(Ere, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ re.jsx(
          q$,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: n,
            onClick: s,
            icon: k2
          }
        ) }),
        /* @__PURE__ */ re.jsx(
          SA,
          {
            isLoading: n,
            onClick: a,
            variant: "outline",
            size: "sm",
            type: "button",
            children: o
          }
        )
      ]
    }
  );
}
function use(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ re.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ re.jsx(re.Fragment, {});
}
function cse(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ re.jsx("strong", { className: o.trim(), children: t });
}
function pse(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i
  } = e;
  function s(l) {
    l.preventDefault();
    const u = l.dataTransfer.files[0];
    u && o(u);
  }
  function a() {
    const l = document.createElement("input");
    l.type = "file", l.accept = r, l.onchange = (u) => {
      var p;
      const c = (p = u.target.files) == null ? void 0 : p[0];
      c && o(c);
    }, l.click();
  }
  return /* @__PURE__ */ re.jsxs("div", { onDrop: s, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ re.jsx(
      SA,
      {
        isLoading: n,
        onClick: a,
        variant: "ghost",
        size: "sm",
        type: "button",
        children: i
      }
    ),
    /* @__PURE__ */ re.jsx("p", { children: t })
  ] });
}
function Vme(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: s = "file",
    method: a = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: p = "Selecionar imagem",
    dropImageText: d = "Ou arraste e solte a imagem aqui",
    onUpload: h
  } = e, f = H$()[t], [g, x] = k(n), [L, E] = k(""), [T, b] = k(null), [C, M] = k(n), [S, F] = k(!1);
  async function D(J) {
    F(!0), b(J);
    const j = new FormData();
    j.append(s, J), await fetch(i, { method: a, body: j }).then(async (K) => await K.json()).then((K) => {
      K != null && K.error ? E(K.error) : x(K == null ? void 0 : K[u]), h && h(K == null ? void 0 : K[u]);
    }).catch((K) => {
      console.error(K), E("Erro ao enviar imagem");
    }).finally(() => F(!1));
  }
  function Z(J) {
    M(URL.createObjectURL(J)), D(J);
  }
  const U = f || L, V = `arkynImageUpload ${U ? "hasError" : "noHasError"} ${C ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ re.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ re.jsx(cse, { label: r, showAsterisk: o }),
    /* @__PURE__ */ re.jsxs("div", { className: V, children: [
      /* @__PURE__ */ re.jsx("input", { type: "hidden", name: t, value: g || "" }),
      !C && /* @__PURE__ */ re.jsx(
        pse,
        {
          isLoading: S,
          acceptImage: l,
          dropImageText: d,
          handleSelectFile: Z,
          selectImageButtonText: p
        }
      ),
      C && /* @__PURE__ */ re.jsx(
        lse,
        {
          isLoading: S,
          acceptImage: l,
          filePath: C,
          handleSelectFile: Z,
          changeImageButtonText: c,
          reSendImage: U && T ? () => D(T) : void 0
        }
      )
    ] }),
    U && /* @__PURE__ */ re.jsx(use, { error: U })
  ] });
}
const MN = qe({});
function dse() {
  return Te(MN);
}
function Zme(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: s = "",
    ...a
  } = e, [l, u] = k(t || ""), { inputRef: c, id: p } = Fo();
  function d(y) {
    u(y), o && o(y);
  }
  const h = `arkynRadioGroup ${i} ${s}`;
  return /* @__PURE__ */ re.jsxs(
    MN.Provider,
    {
      value: { onChange: d, value: r || l, size: i },
      children: [
        /* @__PURE__ */ re.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: p,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ re.jsx("div", { className: h.trim(), ...a })
      ]
    }
  );
}
function qme(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...s
  } = e, { onChange: a, size: l, value: u } = dse(), { error: c } = Fo(), f = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ re.jsxs("label", { className: f.trim(), children: [
    /* @__PURE__ */ re.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => a(t),
        onFocus: () => a(t),
        ...s
      }
    ),
    o
  ] });
}
var Zi = {};
Object.defineProperty(Zi, "__esModule", {
  value: !0
});
var fse = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Zm = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, SN = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: fse ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, j1 = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Bp = 1; Bp < 20; Bp++)
  j1["f" + Bp] = 111 + Bp;
function Ah(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return DN(s, t);
  }), o = function(a) {
    return r.some(function(l) {
      return PN(l, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function hse(e, t) {
  return Ah(e, t);
}
function gse(e, t) {
  return Ah(e, { byKey: !0 }, t);
}
function DN(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Zm)
    r[Zm[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, h = d.endsWith("?") && d.length > 1;
      h && (d = d.slice(0, -1));
      var y = R1(d), f = Zm[y];
      if (d.length > 1 && !f && !SN[d] && !j1[y])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !f) && (n ? r.key = y : r.which = TN(d)), f && (r[f] = h ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function PN(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function TN(e) {
  e = R1(e);
  var t = j1[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function R1(e) {
  return e = e.toLowerCase(), e = SN[e] || e, e;
}
var mse = Zi.default = Ah, qm = Zi.isHotkey = Ah;
Zi.isCodeHotkey = hse;
Zi.isKeyHotkey = gse;
Zi.parseHotkey = DN;
Zi.compareHotkey = PN;
Zi.toKeyCode = TN;
Zi.toKeyName = R1;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function EP(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Kr(e) {
  var t, n;
  return EP(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(EP(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var _N = Symbol.for("immer-nothing"), LP = Symbol.for("immer-draftable"), Ro = Symbol.for("immer-state"), vse = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function fo(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = vse[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Ha = Object.getPrototypeOf;
function Ta(e) {
  return !!e && !!e[Ro];
}
function _a(e) {
  var t;
  return e ? AN(e) || Array.isArray(e) || !!e[LP] || !!((t = e.constructor) != null && t[LP]) || Ih(e) || jh(e) : !1;
}
var yse = Object.prototype.constructor.toString();
function AN(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Ha(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === yse;
}
function Zd(e, t) {
  Bh(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Bh(e) {
  const t = e[Ro];
  return t ? t.type_ : Array.isArray(e) ? 1 : Ih(e) ? 2 : jh(e) ? 3 : 0;
}
function Zy(e, t) {
  return Bh(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function BN(e, t, n) {
  const r = Bh(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function bse(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Ih(e) {
  return e instanceof Map;
}
function jh(e) {
  return e instanceof Set;
}
function na(e) {
  return e.copy_ || e.base_;
}
function qy(e, t) {
  if (Ih(e))
    return new Map(e);
  if (jh(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = AN(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ro];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(Ha(e), r);
  } else {
    const r = Ha(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function N1(e, t = !1) {
  return Rh(e) || Ta(e) || !_a(e) || (Bh(e) > 1 && (e.set = e.add = e.clear = e.delete = wse), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => N1(r, !0))), e;
}
function wse() {
  fo(2);
}
function Rh(e) {
  return Object.isFrozen(e);
}
var Cse = {};
function Aa(e) {
  const t = Cse[e];
  return t || fo(0, e), t;
}
var Tu;
function IN() {
  return Tu;
}
function xse(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function kP(e, t) {
  t && (Aa("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Gy(e) {
  Xy(e), e.drafts_.forEach(Ese), e.drafts_ = null;
}
function Xy(e) {
  e === Tu && (Tu = e.parent_);
}
function OP(e) {
  return Tu = xse(Tu, e);
}
function Ese(e) {
  const t = e[Ro];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function MP(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ro].modified_ && (Gy(t), fo(4)), _a(e) && (e = qd(t, e), t.parent_ || Gd(t, e)), t.patches_ && Aa("Patches").generateReplacementPatches_(
    n[Ro].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = qd(t, n, []), Gy(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== _N ? e : void 0;
}
function qd(e, t, n) {
  if (Rh(t))
    return t;
  const r = t[Ro];
  if (!r)
    return Zd(
      t,
      (o, i) => SP(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Gd(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Zd(
      i,
      (a, l) => SP(e, r, o, a, l, n, s)
    ), Gd(e, o, !1), n && e.patches_ && Aa("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function SP(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && fo(5), Ta(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Zy(t.assigned_, r) ? i.concat(r) : void 0, l = qd(e, o, a);
    if (BN(n, r, l), Ta(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (_a(o) && !Rh(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    qd(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Gd(e, o);
  }
}
function Gd(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && N1(t, n);
}
function Lse(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : IN(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = F1;
  n && (o = [r], i = _u);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var F1 = {
  get(e, t) {
    if (t === Ro)
      return e;
    const n = na(e);
    if (!Zy(n, t))
      return kse(e, n, t);
    const r = n[t];
    return e.finalized_ || !_a(r) ? r : r === Gm(e.base_, t) ? (Xm(e), e.copy_[t] = Jy(r, e)) : r;
  },
  has(e, t) {
    return t in na(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(na(e));
  },
  set(e, t, n) {
    const r = jN(na(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Gm(na(e), t), i = o == null ? void 0 : o[Ro];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (bse(n, o) && (n !== void 0 || Zy(e.base_, t)))
        return !0;
      Xm(e), Yy(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Gm(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Xm(e), Yy(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = na(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    fo(11);
  },
  getPrototypeOf(e) {
    return Ha(e.base_);
  },
  setPrototypeOf() {
    fo(12);
  }
}, _u = {};
Zd(F1, (e, t) => {
  _u[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
_u.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && fo(13), _u.set.call(this, e, t, void 0);
};
_u.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && fo(14), F1.set.call(this, e[0], t, n, e[0]);
};
function Gm(e, t) {
  const n = e[Ro];
  return (n ? na(n) : e)[t];
}
function kse(e, t, n) {
  var o;
  const r = jN(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function jN(e, t) {
  if (!(t in e))
    return;
  let n = Ha(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Ha(n);
  }
}
function Yy(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Yy(e.parent_));
}
function Xm(e) {
  e.copy_ || (e.copy_ = qy(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Ose = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(l = i, ...u) {
          return s.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && fo(6), r !== void 0 && typeof r != "function" && fo(7);
      let o;
      if (_a(t)) {
        const i = OP(this), s = Jy(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? Gy(i) : Xy(i);
        }
        return kP(i, r), MP(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === _N && (o = void 0), this.autoFreeze_ && N1(o, !0), r) {
          const i = [], s = [];
          Aa("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        fo(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (s, ...a) => this.produceWithPatches(s, (l) => t(l, ...a));
      let r, o;
      return [this.produce(t, n, (s, a) => {
        r = s, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    _a(e) || fo(8), Ta(e) && (e = Mse(e));
    const t = OP(this), n = Jy(e, void 0);
    return n[Ro].isManual_ = !0, Xy(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ro];
    (!n || !n.isManual_) && fo(9);
    const { scope_: r } = n;
    return kP(r, t), MP(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Aa("Patches").applyPatches_;
    return Ta(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Jy(e, t) {
  const n = Ih(e) ? Aa("MapSet").proxyMap_(e, t) : jh(e) ? Aa("MapSet").proxySet_(e, t) : Lse(e, t);
  return (t ? t.scope_ : IN()).drafts_.push(n), n;
}
function Mse(e) {
  return Ta(e) || fo(10, e), RN(e);
}
function RN(e) {
  if (!_a(e) || Rh(e))
    return e;
  const t = e[Ro];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = qy(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = qy(e, !0);
  return Zd(n, (r, o) => {
    BN(n, r, RN(o));
  }), t && (t.finalized_ = !1), n;
}
var No = new Ose(), z1 = No.produce;
No.produceWithPatches.bind(
  No
);
No.setAutoFreeze.bind(No);
No.setUseStrictShallowCopy.bind(No);
No.applyPatches.bind(No);
var DP = No.createDraft.bind(No), PP = No.finishDraft.bind(No), Sse = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = le.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Dse = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = kt.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Pse = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = we.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Xd = /* @__PURE__ */ new WeakMap(), Yd = /* @__PURE__ */ new WeakMap(), ou = /* @__PURE__ */ new WeakMap(), NN = /* @__PURE__ */ new WeakMap(), TP = /* @__PURE__ */ new WeakMap(), _P = /* @__PURE__ */ new WeakMap(), AP = /* @__PURE__ */ new WeakMap(), le = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = le.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return le.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return le.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return le.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return le.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && le.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return le.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && le.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && le.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && le.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && le.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && le.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!le.isAncestor(t, e) && !le.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (le.equals(i, r) || le.endsBefore(i, r) || le.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (le.equals(s, r) || le.isAncestor(s, r))
          return null;
        le.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        le.equals(a, r) || le.endsBefore(a, r) ? r[a.length - 1] -= 1 : le.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (le.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else le.endsBefore(u, r) ? r[u.length - 1] += 1 : le.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (le.equals(p, d))
          return r;
        if (le.isAncestor(p, r) || le.equals(p, r)) {
          var h = d.slice();
          return le.endsBefore(p, d) && p.length < d.length && (h[p.length - 1] -= 1), h.concat(r.slice(p.length));
        } else le.isSibling(p, d) && (le.isAncestor(d, r) || le.equals(d, r)) ? le.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : le.endsBefore(d, r) || le.equals(d, r) || le.isAncestor(d, r) ? (le.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : le.endsBefore(p, r) && (le.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Au(e) {
  "@babel/helpers - typeof";
  return Au = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Au(e);
}
function Tse(e, t) {
  if (Au(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Au(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function _se(e) {
  var t = Tse(e, "string");
  return Au(t) === "symbol" ? t : String(t);
}
function io(e, t, n) {
  return t = _se(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function BP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BP(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ase = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Ue.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of we.points(t))
          t[l] = kt.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Ue.leaf(e, u), h = d.text.slice(0, c), y = d.text.slice(c);
      if (d.text = h + p + y, t)
        for (var [f, g] of we.points(t))
          t[g] = kt.transform(f, n);
      break;
    }
    case "merge_node": {
      var {
        path: x
      } = n, L = Ue.get(e, x), E = le.previous(x), T = Ue.get(e, E), b = Ue.parent(e, x), C = x[x.length - 1];
      if (Ze.isText(L) && Ze.isText(T))
        T.text += L.text;
      else if (!Ze.isText(L) && !Ze.isText(T))
        T.children.push(...L.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(x, "] to nodes of different interfaces: ").concat(Fr.stringify(L), " ").concat(Fr.stringify(T)));
      if (b.children.splice(C, 1), t)
        for (var [M, S] of we.points(t))
          t[S] = kt.transform(M, n);
      break;
    }
    case "move_node": {
      var {
        path: F,
        newPath: D
      } = n;
      if (le.isAncestor(F, D))
        throw new Error("Cannot move a path [".concat(F, "] to new path [").concat(D, "] because the destination is inside itself."));
      var Z = Ue.get(e, F), U = Ue.parent(e, F), $ = F[F.length - 1];
      U.children.splice($, 1);
      var N = le.transform(F, n), V = Ue.get(e, le.parent(N)), J = N[N.length - 1];
      if (V.children.splice(J, 0, Z), t)
        for (var [j, K] of we.points(t))
          t[K] = kt.transform(j, n);
      break;
    }
    case "remove_node": {
      var {
        path: te
      } = n, O = te[te.length - 1], P = Ue.parent(e, te);
      if (P.children.splice(O, 1), t)
        for (var [H, I] of we.points(t)) {
          var W = kt.transform(H, n);
          if (t != null && W != null)
            t[I] = W;
          else {
            var X = void 0, w = void 0;
            for (var [R, z] of Ue.texts(e))
              if (le.compare(z, te) === -1)
                X = [R, z];
              else {
                w = [R, z];
                break;
              }
            var _ = !1;
            X && w && (le.equals(w[1], te) ? _ = !le.hasPrevious(w[1]) : _ = le.common(X[1], te).length < le.common(w[1], te).length), X && !_ ? (H.path = X[1], H.offset = X[0].text.length) : w ? (H.path = w[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: Y,
        offset: Q,
        text: A
      } = n;
      if (A.length === 0) break;
      var ae = Ue.leaf(e, Y), ce = ae.text.slice(0, Q), ue = ae.text.slice(Q + A.length);
      if (ae.text = ce + ue, t)
        for (var [de, be] of we.points(t))
          t[be] = kt.transform(de, n);
      break;
    }
    case "set_node": {
      var {
        path: ve,
        properties: ge,
        newProperties: se
      } = n;
      if (ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var xe = Ue.get(e, ve);
      for (var ne in se) {
        if (ne === "children" || ne === "text")
          throw new Error('Cannot set the "'.concat(ne, '" property of nodes!'));
        var Me = se[ne];
        Me == null ? delete xe[ne] : xe[ne] = Me;
      }
      for (var ee in ge)
        se.hasOwnProperty(ee) || delete xe[ee];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Ce
      } = n;
      if (Ce == null)
        t = Ce;
      else {
        if (t == null) {
          if (!we.isRange(Ce))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Fr.stringify(Ce), " when there is no current selection."));
          t = Dl({}, Ce);
        }
        for (var Be in Ce) {
          var _e = Ce[Be];
          if (_e == null) {
            if (Be === "anchor" || Be === "focus")
              throw new Error('Cannot remove the "'.concat(Be, '" selection property'));
            delete t[Be];
          } else
            t[Be] = _e;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: $e,
        position: he,
        properties: Ge
      } = n;
      if ($e.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat($e, "] because the root node cannot be split."));
      var We = Ue.get(e, $e), Ut = Ue.parent(e, $e), ot = $e[$e.length - 1], st;
      if (Ze.isText(We)) {
        var Zt = We.text.slice(0, he), qt = We.text.slice(he);
        We.text = Zt, st = Dl(Dl({}, Ge), {}, {
          text: qt
        });
      } else {
        var Gt = We.children.slice(0, he), Xt = We.children.slice(he);
        We.children = Gt, st = Dl(Dl({}, Ge), {}, {
          children: Xt
        });
      }
      if (Ut.children.splice(ot + 1, 0, st), t)
        for (var [et, bt] of we.points(t))
          t[bt] = kt.transform(et, n);
      break;
    }
  }
  return t;
}, Bse = {
  transform(e, t) {
    e.children = DP(e.children);
    var n = e.selection && DP(e.selection);
    try {
      n = Ase(e, n, t);
    } finally {
      e.children = PP(e.children), n ? e.selection = Ta(n) ? PP(n) : n : e.selection = null;
    }
  }
}, Ise = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, jse = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, FN = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Kr(r) && Kr(o)) {
      if (!FN(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function Rse(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Fi(e, t) {
  if (e == null) return {};
  var n = Rse(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Nse = ["anchor", "focus"];
function IP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fse(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IP(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var we = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return we.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = we.edges(e);
    return t;
  },
  equals(e, t) {
    return kt.equals(e.anchor, t.anchor) && kt.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (we.isRange(t)) {
      if (we.includes(e, t.anchor) || we.includes(e, t.focus))
        return !0;
      var [n, r] = we.edges(e), [o, i] = we.edges(t);
      return kt.isBefore(n, o) && kt.isAfter(r, i);
    }
    var [s, a] = we.edges(e), l = !1, u = !1;
    return kt.isPoint(t) ? (l = kt.compare(t, s) >= 0, u = kt.compare(t, a) <= 0) : (l = le.compare(t, s.path) >= 0, u = le.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Fi(e, Nse), [r, o] = we.edges(e), [i, s] = we.edges(t), a = kt.isBefore(r, i) ? i : r, l = kt.isBefore(o, s) ? o : s;
    return kt.isBefore(l, a) ? null : Fse({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return kt.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return kt.equals(t, n);
  },
  isExpanded(e) {
    return !we.isCollapsed(e);
  },
  isForward(e) {
    return !we.isBackward(e);
  },
  isRange(e) {
    return Kr(e) && kt.isPoint(e.anchor) && kt.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = we.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return z1(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = we.isCollapsed(r);
        we.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? we.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = kt.transform(r.anchor, t, {
        affinity: i
      }), u = kt.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, jP = (e) => Kr(e) && Ue.isNodeList(e.children) && !q.isEditor(e), Ve = {
  isAncestor(e) {
    return Kr(e) && Ue.isNodeList(e.children);
  },
  isElement: jP,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Ve.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return jP(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, zse = ["children"], Use = ["text"], RP = /* @__PURE__ */ new WeakMap(), Ue = {
  ancestor(e, t) {
    var n = Ue.get(e, t);
    if (Ze.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Fr.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of le.ancestors(t, n)) {
        var o = Ue.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Ze.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Fr.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Fr.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Ue.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = Ue.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = le.common(t, n), o = Ue.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Ue.get(e, t);
    if (q.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Fr.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ue.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ue.nodes(e, t))
        Ve.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Ve.isAncestor(e)) {
      var t = Fi(e, zse);
      return t;
    } else {
      var t = Fi(e, Use);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Ue.get(e, n); r && !(Ze.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Ze.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Fr.stringify(e)));
    var n = z1({
      children: e.children
    }, (r) => {
      var [o, i] = we.edges(t), s = Ue.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, h] = d;
          return !we.includes(t, h);
        }
      });
      for (var [, a] of s) {
        if (!we.includes(t, a)) {
          var l = Ue.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (le.equals(a, i.path)) {
          var c = Ue.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (le.equals(a, o.path)) {
          var p = Ue.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      q.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ze.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Fr.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ze.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Ze.isText(e) || Ve.isElement(e) || q.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = RP.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Ue.isNode(r));
    return RP.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Ue.get(e, n); r && !(Ze.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Ue.get(e, t);
    if (!Ze.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Fr.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of le.levels(t, n)) {
        var o = Ue.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Ve.isElement(e) && Ve.isElementProps(t) && Ve.matches(e, t) || Ze.isText(e) && Ze.isTextProps(t) && Ze.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? le.isBefore(a, i) : le.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Ze.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          le.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = Ue.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = le.next(a);
          if (Ue.has(e, c)) {
            a = c, l = Ue.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = le.previous(a);
          a = p, l = Ue.get(e, a);
          continue;
        }
        a = le.parent(a), l = Ue.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = le.parent(t), r = Ue.get(e, n);
    if (Ze.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Ze.isText(e) ? e.text : e.children.map(Ue.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ue.nodes(e, t))
        Ze.isText(n) && (yield [n, r]);
    }();
  }
};
function NP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ur(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NP(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Cs = {
  isNodeOperation(e) {
    return Cs.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Kr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return le.isPath(e.path) && Ue.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && le.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && le.isPath(e.path) && Kr(e.properties);
      case "move_node":
        return le.isPath(e.path) && le.isPath(e.newPath);
      case "remove_node":
        return le.isPath(e.path) && Ue.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && le.isPath(e.path);
      case "set_node":
        return le.isPath(e.path) && Kr(e.properties) && Kr(e.newProperties);
      case "set_selection":
        return e.properties === null && we.isRange(e.newProperties) || e.newProperties === null && we.isRange(e.properties) || Kr(e.properties) && Kr(e.newProperties);
      case "split_node":
        return le.isPath(e.path) && typeof e.position == "number" && Kr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Cs.isOperation(t));
  },
  isSelectionOperation(e) {
    return Cs.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Cs.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return ur(ur({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return ur(ur({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return ur(ur({}, e), {}, {
          type: "split_node",
          path: le.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (le.equals(t, n))
          return e;
        if (le.isSibling(n, t))
          return ur(ur({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = le.transform(n, e), o = le.transform(le.next(n), e);
        return ur(ur({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return ur(ur({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return ur(ur({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return ur(ur({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? ur(ur({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? ur(ur({}, e), {}, {
          properties: null,
          newProperties: a
        }) : ur(ur({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return ur(ur({}, e), {}, {
          type: "merge_node",
          path: le.next(e.path)
        });
    }
  }
}, FP = /* @__PURE__ */ new WeakMap(), $se = (e) => {
  var t = FP.get(e);
  if (t !== void 0)
    return t;
  if (!Kr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Kr(e.marks)) && (e.selection === null || we.isRange(e.selection)) && Ue.isNodeList(e.children) && Cs.isOperationList(e.operations);
  return FP.set(e, n), n;
}, q = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return $se(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, Wse = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(le.isPath);
  }
};
function zP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function UP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zP(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kt = {
  compare(e, t) {
    var n = le.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return kt.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return kt.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && le.equals(e.path, t.path);
  },
  isPoint(e) {
    return Kr(e) && typeof e.offset == "number" && le.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return z1(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = le.transform(i, t, n);
          break;
        }
        case "insert_text": {
          le.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          le.equals(t.path, i) && (r.offset += t.position), r.path = le.transform(i, t, n);
          break;
        }
        case "remove_text": {
          le.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (le.equals(t.path, i) || le.isAncestor(t.path, i))
            return null;
          r.path = le.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (le.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = le.transform(i, t, UP(UP({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = le.transform(i, t, n);
          break;
        }
      }
    });
  }
}, $P = void 0, Fr = {
  setScrubber(e) {
    $P = e;
  },
  stringify(e) {
    return JSON.stringify(e, $P);
  }
}, Hse = ["text"], Vse = ["anchor", "focus"];
function WP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Si(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WP(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ze = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = Fi(i, Hse);
      return s;
    }
    return FN(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Kr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Ze.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Si({}, e)];
    for (var r of t) {
      var o = Fi(r, Vse), [i, s] = we.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, h = l;
        if (l += d, u <= h && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === h) || u > l || c < h || c === h && h !== 0) {
          a.push(p);
          continue;
        }
        var y = p, f = void 0, g = void 0;
        if (c < l) {
          var x = c - h;
          g = Si(Si({}, y), {}, {
            text: y.text.slice(x)
          }), y = Si(Si({}, y), {}, {
            text: y.text.slice(0, x)
          });
        }
        if (u > h) {
          var L = u - h;
          f = Si(Si({}, y), {}, {
            text: y.text.slice(0, L)
          }), y = Si(Si({}, y), {}, {
            text: y.text.slice(L)
          });
        }
        Object.assign(y, o), f && a.push(f), a.push(y), g && a.push(g);
      }
      n = a;
    }
    return n;
  }
}, U1 = (e) => e.selection ? e.selection : e.children.length > 0 ? q.end(e, []) : [0], nl = (e, t) => {
  var [n] = q.node(e, t);
  return (r) => r === n;
}, $1 = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? Jse(t) : t, i = lt.None, s = lt.None, a = 0, l = null, u = null;
  for (var c of o) {
    var p = c.codePointAt(0);
    if (!p) break;
    var d = uae(c, p);
    if ([i, s] = r ? [s, d] : [d, i], Ra(i, lt.ZWJ) && Ra(s, lt.ExtPict) && (r ? l = HP(t.substring(0, a)) : l = HP(t.substring(0, t.length - a)), !l) || Ra(i, lt.RI) && Ra(s, lt.RI) && (u !== null ? u = !u : r ? u = !0 : u = hae(t.substring(0, t.length - a)), !u) || i !== lt.None && s !== lt.None && pae(i, s))
      break;
    a += c.length;
  }
  return a || 1;
}, Zse = /\s/, qse = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, Gse = /['\u2018\u2019]/, Xse = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = $1(t, n), [s, a] = W1(t, i, n);
    if (Yse(s, a, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = a;
  }
  return r;
}, W1 = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, Yse = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (Zse.test(t))
    return !1;
  if (Gse.test(t)) {
    var o = $1(n, r), [i, s] = W1(n, o, r);
    if (e(i, s, r))
      return !0;
  }
  return !qse.test(t);
}, Jse = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (Qse(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (Kse(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, Kse = (e) => e >= 55296 && e <= 56319, Qse = (e) => e >= 56320 && e <= 57343, lt;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(lt || (lt = {}));
var eae = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, tae = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, nae = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, rae = /^[\u1100-\u115F\uA960-\uA97C]$/, oae = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, iae = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, sae = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, aae = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, lae = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, uae = (e, t) => {
  var n = lt.Any;
  return e.search(eae) !== -1 && (n |= lt.Extend), t === 8205 && (n |= lt.ZWJ), t >= 127462 && t <= 127487 && (n |= lt.RI), e.search(tae) !== -1 && (n |= lt.Prepend), e.search(nae) !== -1 && (n |= lt.SpacingMark), e.search(rae) !== -1 && (n |= lt.L), e.search(oae) !== -1 && (n |= lt.V), e.search(iae) !== -1 && (n |= lt.T), e.search(sae) !== -1 && (n |= lt.LV), e.search(aae) !== -1 && (n |= lt.LVT), e.search(lae) !== -1 && (n |= lt.ExtPict), n;
};
function Ra(e, t) {
  return (e & t) !== 0;
}
var cae = [
  // GB6
  [lt.L, lt.L | lt.V | lt.LV | lt.LVT],
  // GB7
  [lt.LV | lt.V, lt.V | lt.T],
  // GB8
  [lt.LVT | lt.T, lt.T],
  // GB9
  [lt.Any, lt.Extend | lt.ZWJ],
  // GB9a
  [lt.Any, lt.SpacingMark],
  // GB9b
  [lt.Prepend, lt.Any],
  // GB11
  [lt.ZWJ, lt.ExtPict],
  // GB12 and GB13
  [lt.RI, lt.RI]
];
function pae(e, t) {
  return cae.findIndex((n) => Ra(e, n[0]) && Ra(t, n[1])) === -1;
}
var dae = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, HP = (e) => e.search(dae) !== -1, fae = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, hae = (e) => {
  var t = e.match(fae);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, gae = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    q.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = U1(e)
      } = n;
      if (le.isPath(o) && (o = q.range(e, o)), we.isRange(o))
        if (we.isCollapsed(o))
          o = o.anchor;
        else {
          var i = we.end(o);
          if (!r && q.void(e, {
            at: i
          }))
            return;
          var s = we.start(o), a = q.pointRef(e, s), l = q.pointRef(e, i);
          Se.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Se.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && q.void(e, {
        at: o
      }) || q.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function VP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ip(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VP(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Se = Ip(Ip(Ip(Ip({}, Bse), Ise), jse), gae), rd = /* @__PURE__ */ new WeakMap(), mae = (e) => rd.get(e) || !1, vae = (e, t, n) => {
  var r = rd.get(e) || !1;
  rd.set(e, !0);
  try {
    t(), n();
  } finally {
    rd.set(e, r);
  }
};
function zN(e, t, n) {
  var r = Xd.get(e) || [], o = Yd.get(e) || /* @__PURE__ */ new Set(), i, s, a = (p) => {
    if (p) {
      var d = p.join(",");
      s.has(d) || (s.add(d), i.push(p));
    }
  };
  if (n) {
    i = [], s = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      a(u);
    }
  } else
    i = r, s = o;
  for (var c of t)
    a(c);
  Xd.set(e, i), Yd.set(e, s);
}
var yae = (e, t) => {
  for (var n of q.pathRefs(e))
    Sse.transform(n, t);
  for (var r of q.pointRefs(e))
    Dse.transform(r, t);
  for (var o of q.rangeRefs(e))
    Pse.transform(o, t);
  if (!mae(e)) {
    var i = le.operationCanTransformPath(t) ? (s) => le.transform(s, t) : void 0;
    zN(e, e.getDirtyPaths(t), i);
  }
  Se.transform(e, t), e.operations.push(t), q.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), ou.get(e) || (ou.set(e, !0), Promise.resolve().then(() => {
    ou.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, bae = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return le.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = le.levels(o), s = Ze.isText(r) ? [] : Array.from(Ue.nodes(r), (D) => {
        var [, Z] = D;
        return o.concat(Z);
      });
      return [...i, ...s];
    }
    case "merge_node": {
      var {
        path: a
      } = t, l = le.ancestors(a), u = le.previous(a);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: p
      } = t;
      if (le.equals(c, p))
        return [];
      var d = [], h = [];
      for (var y of le.ancestors(c)) {
        var f = le.transform(y, t);
        d.push(f);
      }
      for (var g of le.ancestors(p)) {
        var x = le.transform(g, t);
        h.push(x);
      }
      var L = h[h.length - 1], E = p[p.length - 1], T = L.concat(E);
      return [...d, ...h, T];
    }
    case "remove_node": {
      var {
        path: b
      } = t, C = le.ancestors(b);
      return [...C];
    }
    case "split_node": {
      var {
        path: M
      } = t, S = le.levels(M), F = le.next(M);
      return [...S, F];
    }
    default:
      return [];
  }
}, wae = (e) => {
  var {
    selection: t
  } = e;
  return t ? Ue.fragment(e, t) : [];
}, Cae = (e, t) => {
  var [n, r] = t;
  if (!Ze.isText(n)) {
    if (Ve.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      Se.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = q.isEditor(n) ? !1 : Ve.isElement(n) && (e.isInline(n) || n.children.length === 0 || Ze.isText(n.children[0]) || e.isInline(n.children[0])), s = 0, a = 0; a < n.children.length; a++, s++) {
      var l = Ue.get(e, r);
      if (!Ze.isText(l)) {
        var u = l.children[s], c = l.children[s - 1], p = a === n.children.length - 1, d = Ze.isText(u) || Ve.isElement(u) && e.isInline(u);
        if (d !== i)
          Se.removeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--;
        else if (Ve.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !Ze.isText(c)) {
              var h = {
                text: ""
              };
              Se.insertNodes(e, h, {
                at: r.concat(s),
                voids: !0
              }), s++;
            } else if (p) {
              var y = {
                text: ""
              };
              Se.insertNodes(e, y, {
                at: r.concat(s + 1),
                voids: !0
              }), s++;
            }
          }
        } else {
          if (!Ze.isText(u) && !("children" in u)) {
            var f = u;
            f.children = [];
          }
          c != null && Ze.isText(c) && (Ze.equals(u, c, {
            loose: !0
          }) ? (Se.mergeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--) : c.text === "" ? (Se.removeNodes(e, {
            at: r.concat(s - 1),
            voids: !0
          }), s--) : u.text === "" && (Se.removeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--));
        }
      }
    }
  }
}, xae = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, Eae = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: s
  } = n;
  if (i) {
    var a = q.path(t, i), l = o === "lowest";
    for (var [u, c] of q.levels(t, {
      at: a,
      voids: r,
      match: s,
      reverse: l
    }))
      if (!Ze.isText(u)) {
        if (we.isRange(i)) {
          if (le.isAncestor(c, i.anchor.path) && le.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!le.equals(a, c))
          return [u, c];
      }
  }
};
function ZP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZP(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Lae = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (p, d) => {
      if (!Ze.isText(p))
        return !1;
      var [h, y] = q.parent(e, d);
      return !e.isVoid(h) || e.markableVoid(h);
    }, i = we.isExpanded(r), s = !1;
    if (!i) {
      var [a, l] = q.node(e, r);
      if (a && o(a, l)) {
        var [u] = q.parent(e, l);
        s = u && e.markableVoid(u);
      }
    }
    if (i || s)
      Se.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = qP(qP({}, q.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, ou.get(e) || e.onChange();
    }
  }
};
function GP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function XP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GP(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kae = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = q.point(t, n, {
    edge: "end"
  }), i = q.end(t, []), s = {
    anchor: o,
    focus: i
  }, {
    distance: a = 1
  } = r, l = 0, u;
  for (var c of q.positions(t, XP(XP({}, r), {}, {
    at: s
  }))) {
    if (l > a)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function YP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function JP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YP(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Oae = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = q.start(t, []), i = q.point(t, n, {
    edge: "start"
  }), s = {
    anchor: o,
    focus: i
  }, {
    distance: a = 1
  } = r, l = 0, u;
  for (var c of q.positions(t, JP(JP({}, r), {}, {
    at: s,
    reverse: !0
  }))) {
    if (l > a)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, Mae = (e, t) => {
  var {
    selection: n
  } = e;
  n && we.isCollapsed(n) && Se.delete(e, {
    unit: t,
    reverse: !0
  });
}, Sae = (e, t) => {
  var {
    selection: n
  } = e;
  n && we.isCollapsed(n) && Se.delete(e, {
    unit: t
  });
}, Dae = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && we.isExpanded(r) && Se.delete(t, {
    reverse: n === "backward"
  });
}, Pae = (e, t) => [q.start(e, t), q.end(e, t)];
function KP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function QP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KP(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Tae = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return q.above(t, QP(QP({}, n), {}, {
    match: (r) => Ve.isElement(r) && q.isElementReadOnly(t, r)
  }));
}, _ae = (e, t) => q.point(e, t, {
  edge: "end"
}), Aae = (e, t) => {
  var n = q.path(e, t, {
    edge: "start"
  });
  return q.node(e, n);
}, Bae = (e, t) => {
  var n = q.range(e, t);
  return Ue.fragment(e, n);
};
function eT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eT(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Iae = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return q.above(t, tT(tT({}, n), {}, {
    match: (r) => Ve.isElement(r) && q.isVoid(t, r)
  }));
}, jae = (e, t) => t.children.some((n) => Ve.isElement(n) && q.isBlock(e, n)), Rae = (e, t) => t.children.some((n) => Ze.isText(n) || q.isInline(e, n)), Nae = (e, t) => Ue.has(e, t), Fae = (e, t) => t.children.every((n) => Ze.isText(n)), zae = (e) => {
  Se.splitNodes(e, {
    always: !0
  });
}, Uae = (e, t, n) => {
  Se.insertNodes(e, t, n);
}, $ae = (e) => {
  Se.splitNodes(e, {
    always: !0
  });
};
function nT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wae(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nT(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Hae = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var s = Wae({
        text: n
      }, i);
      Se.insertNodes(t, s, {
        at: r.at,
        voids: r.voids
      });
    } else
      Se.insertText(t, n, r);
    t.marks = null;
  }
}, Vae = (e, t) => !e.isInline(t), Zae = (e, t, n) => q.isStart(e, t, n) || q.isEnd(e, t, n), qae = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && Ze.isText(r) && r.text === "" && !e.isVoid(t);
}, Gae = (e, t, n) => {
  var r = q.end(e, n);
  return kt.equals(t, r);
}, Xae = (e) => {
  var t = NN.get(e);
  return t === void 0 ? !0 : t;
}, Yae = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = q.start(e, n);
  return kt.equals(t, r);
}, Jae = (e, t) => {
  var n = q.path(e, t, {
    edge: "end"
  });
  return q.node(e, n);
}, Kae = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = q.path(t, n, r), i = Ue.leaf(t, o);
  return [i, o];
};
function Qae(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var s = [], a = q.path(e, n);
      for (var [l, u] of Ue.levels(e, a))
        if (i(l, u) && (s.push([l, u]), !o && Ve.isElement(l) && q.isVoid(e, l)))
          break;
      r && s.reverse(), yield* s;
    }
  }();
}
var ele = ["text"], tle = ["text"], nle = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (we.isExpanded(r)) {
    var s = q.isEnd(t, o, o.path);
    if (s) {
      var a = q.after(t, o);
      a && (o = a);
    }
    var [l] = q.nodes(t, {
      match: Ze.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = Fi(u, ele);
      return c;
    } else
      return {};
  }
  var {
    path: p
  } = o, [d] = q.leaf(t, p);
  if (o.offset === 0) {
    var h = q.previous(t, {
      at: p,
      match: Ze.isText
    }), y = q.above(t, {
      match: (T) => Ve.isElement(T) && q.isVoid(t, T) && t.markableVoid(T)
    });
    if (!y) {
      var f = q.above(t, {
        match: (T) => Ve.isElement(T) && q.isBlock(t, T)
      });
      if (h && f) {
        var [g, x] = h, [, L] = f;
        le.isAncestor(L, x) && (d = g);
      }
    }
  }
  var E = Fi(d, tle);
  return E;
}, rle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: s = t.selection
  } = n;
  if (s) {
    var a = q.after(t, s, {
      voids: o
    });
    if (a) {
      var [, l] = q.last(t, []), u = [a.path, l];
      if (le.isPath(s) && s.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (le.isPath(s)) {
          var [c] = q.parent(t, s);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = q.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, ole = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = q.path(t, n, r), i = Ue.get(t, o);
  return [i, o];
};
function ile(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: s = !1,
      ignoreNonSelectable: a = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (Wse.isSpan(n))
        u = n[0], c = n[1];
      else {
        var p = q.path(e, n, {
          edge: "start"
        }), d = q.path(e, n, {
          edge: "end"
        });
        u = i ? d : p, c = i ? p : d;
      }
      var h = Ue.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (T) => {
          var [b] = T;
          return Ve.isElement(b) ? !!(!s && (q.isVoid(e, b) || q.isElementReadOnly(e, b)) || a && !q.isSelectable(e, b)) : !1;
        }
      }), y = [], f;
      for (var [g, x] of h)
        if (!(a && Ve.isElement(g) && !q.isSelectable(e, g))) {
          var L = f && le.compare(x, f[1]) === 0;
          if (!(r === "highest" && L)) {
            if (!l(g, x)) {
              if (o && !L && Ze.isText(g))
                return;
              continue;
            }
            if (r === "lowest" && L) {
              f = [g, x];
              continue;
            }
            var E = r === "lowest" ? f : [g, x];
            E && (o ? y.push(E) : yield E), f = [g, x];
          }
        }
      r === "lowest" && f && (o ? y.push(f) : yield f), o && (yield* y);
    }
  }();
}
var sle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => Xd.get(c) || [], s = (c) => Yd.get(c) || /* @__PURE__ */ new Set(), a = (c) => {
    var p = i(c).pop(), d = p.join(",");
    return s(c).delete(d), p;
  };
  if (q.isNormalizing(t)) {
    if (r) {
      var l = Array.from(Ue.nodes(t), (c) => {
        var [, p] = c;
        return p;
      }), u = new Set(l.map((c) => c.join(",")));
      Xd.set(t, l), Yd.set(t, u);
    }
    i(t).length !== 0 && q.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (Ue.has(t, c)) {
          var p = q.node(t, c), [d, h] = p;
          Ve.isElement(d) && d.children.length === 0 && t.normalizeNode(p, {
            operation: o
          });
        }
      for (var y = i(t), f = y.length, g = 0; y.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: y,
          iteration: g,
          initialDirtyPathsLength: f,
          operation: o
        }))
          return;
        var x = a(t);
        if (Ue.has(t, x)) {
          var L = q.node(t, x);
          t.normalizeNode(L, {
            operation: o
          });
        }
        g++, y = i(t);
      }
    });
  }
}, ale = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = q.path(t, n, r), i = le.parent(o), s = q.node(t, i);
  return s;
}, lle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = q.pathRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = q.pathRefs(t);
  return s.add(i), i;
}, ule = (e) => {
  var t = TP.get(e);
  return t || (t = /* @__PURE__ */ new Set(), TP.set(e, t)), t;
}, cle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (le.isPath(n)) {
    if (i === "start") {
      var [, s] = Ue.first(t, n);
      n = s;
    } else if (i === "end") {
      var [, a] = Ue.last(t, n);
      n = a;
    }
  }
  return we.isRange(n) && (i === "start" ? n = we.start(n) : i === "end" ? n = we.end(n) : n = le.common(n.anchor.path, n.focus.path)), kt.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, ple = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = q.pointRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = q.pointRefs(t);
  return s.add(i), i;
}, dle = (e) => {
  var t = _P.get(e);
  return t || (t = /* @__PURE__ */ new Set(), _P.set(e, t)), t;
}, fle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (le.isPath(n)) {
    var i;
    if (o === "end") {
      var [, s] = Ue.last(t, n);
      i = s;
    } else {
      var [, a] = Ue.first(t, n);
      i = a;
    }
    var l = Ue.get(t, i);
    if (!Ze.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (we.isRange(n)) {
    var [u, c] = we.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function hle(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: s = !1
    } = t;
    if (!n)
      return;
    var a = q.range(e, n), [l, u] = we.edges(a), c = o ? u : l, p = !1, d = "", h = 0, y = 0, f = 0;
    for (var [g, x] of q.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: s
    })) {
      if (Ve.isElement(g)) {
        if (!i && (e.isVoid(g) || e.isElementReadOnly(g))) {
          yield q.start(e, x);
          continue;
        }
        if (e.isInline(g)) continue;
        if (q.hasInlines(e, g)) {
          var L = le.isAncestor(x, u.path) ? u : q.end(e, x), E = le.isAncestor(x, l.path) ? l : q.start(e, x);
          d = q.string(e, {
            anchor: E,
            focus: L
          }, {
            voids: i
          }), p = !0;
        }
      }
      if (Ze.isText(g)) {
        var T = le.equals(x, c.path);
        for (T ? (y = o ? c.offset : g.text.length - c.offset, f = c.offset) : (y = g.text.length, f = o ? y : 0), (T || p || r === "offset") && (yield {
          path: x,
          offset: f
        }, p = !1); ; ) {
          if (h === 0) {
            if (d === "") break;
            h = b(d, r, o), d = W1(d, h, o)[1];
          }
          if (f = o ? f - h : f + h, y = y - h, y < 0) {
            h = -y;
            break;
          }
          h = 0, yield {
            path: x,
            offset: f
          };
        }
      }
    }
    function b(C, M, S) {
      return M === "character" ? $1(C, S) : M === "word" ? Xse(C, S) : M === "line" || M === "block" ? C.length : 1;
    }
  }();
}
var gle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: s = t.selection
  } = n;
  if (s) {
    var a = q.before(t, s, {
      voids: o
    });
    if (a) {
      var [, l] = q.first(t, []), u = [a.path, l];
      if (le.isPath(s) && s.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (le.isPath(s)) {
          var [c] = q.parent(t, s);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = q.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, mle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = q.rangeRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = q.rangeRefs(t);
  return s.add(i), i;
}, vle = (e) => {
  var t = AP.get(e);
  return t || (t = /* @__PURE__ */ new Set(), AP.set(e, t)), t;
}, yle = (e, t, n) => {
  if (we.isRange(t) && !n)
    return t;
  var r = q.start(e, t), o = q.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function rT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ble(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rT(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wle = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, p) => {
      if (!Ze.isText(c))
        return !1;
      var [d, h] = q.parent(e, p);
      return !e.isVoid(d) || e.markableVoid(d);
    }, o = we.isExpanded(n), i = !1;
    if (!o) {
      var [s, a] = q.node(e, n);
      if (s && r(s, a)) {
        var [l] = q.parent(e, a);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      Se.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = ble({}, q.marks(e) || {});
      delete u[t], e.marks = u, ou.get(e) || e.onChange();
    }
  }
}, Cle = (e, t) => {
  NN.set(e, t);
}, xle = (e, t) => q.point(e, t, {
  edge: "start"
}), Ele = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = q.range(t, n), [s, a] = we.edges(i), l = "";
  for (var [u, c] of q.nodes(t, {
    at: i,
    match: Ze.isText,
    voids: o
  })) {
    var p = u.text;
    le.equals(c, a.path) && (p = p.slice(0, a.offset)), le.equals(c, s.path) && (p = p.slice(s.offset)), l += p;
  }
  return l;
}, Lle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, s] = we.edges(n);
  if (i.offset !== 0 || s.offset !== 0 || we.isCollapsed(n) || le.hasPrevious(s.path))
    return n;
  var a = q.above(t, {
    at: s,
    match: (y) => Ve.isElement(y) && q.isBlock(t, y),
    voids: o
  }), l = a ? a[1] : [], u = q.start(t, i), c = {
    anchor: u,
    focus: s
  }, p = !0;
  for (var [d, h] of q.nodes(t, {
    at: c,
    match: Ze.isText,
    reverse: !0,
    voids: o
  })) {
    if (p) {
      p = !1;
      continue;
    }
    if (d.text !== "" || le.isBefore(h, l)) {
      s = {
        path: h,
        offset: d.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: s
  };
}, kle = (e, t) => {
  var n = q.isNormalizing(e);
  q.setNormalizing(e, !1);
  try {
    t();
  } finally {
    q.setNormalizing(e, n);
  }
  q.normalize(e);
}, Ole = (e, t, n) => {
  var [r, o] = t;
  return Ve.isElement(r) && q.isEmpty(e, r) || Ze.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, Mle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  q.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: s = "character",
      distance: a = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var p = !1;
      if (we.isRange(u) && we.isCollapsed(u) && (p = !0, u = u.anchor), kt.isPoint(u)) {
        var d = q.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && d) {
          var [, h] = d;
          u = h;
        } else {
          var y = {
            unit: s,
            distance: a
          }, f = i ? q.before(t, u, y) || q.start(t, []) : q.after(t, u, y) || q.end(t, []);
          u = {
            anchor: u,
            focus: f
          }, c = !0;
        }
      }
      if (le.isPath(u)) {
        Se.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!we.isCollapsed(u)) {
        if (!c) {
          var [, g] = we.edges(u), x = q.end(t, []);
          kt.equals(g, x) || (u = q.unhangRange(t, u, {
            voids: l
          }));
        }
        var [L, E] = we.edges(u), T = q.above(t, {
          match: (ce) => Ve.isElement(ce) && q.isBlock(t, ce),
          at: L,
          voids: l
        }), b = q.above(t, {
          match: (ce) => Ve.isElement(ce) && q.isBlock(t, ce),
          at: E,
          voids: l
        }), C = T && b && !le.equals(T[1], b[1]), M = le.equals(L.path, E.path), S = l ? null : (r = q.void(t, {
          at: L,
          mode: "highest"
        })) !== null && r !== void 0 ? r : q.elementReadOnly(t, {
          at: L,
          mode: "highest"
        }), F = l ? null : (o = q.void(t, {
          at: E,
          mode: "highest"
        })) !== null && o !== void 0 ? o : q.elementReadOnly(t, {
          at: E,
          mode: "highest"
        });
        if (S) {
          var D = q.before(t, L);
          D && T && le.isAncestor(T[1], D.path) && (L = D);
        }
        if (F) {
          var Z = q.after(t, E);
          Z && b && le.isAncestor(b[1], Z.path) && (E = Z);
        }
        var U = [], $;
        for (var N of q.nodes(t, {
          at: u,
          voids: l
        })) {
          var [V, J] = N;
          $ && le.compare(J, $) === 0 || (!l && Ve.isElement(V) && (q.isVoid(t, V) || q.isElementReadOnly(t, V)) || !le.isCommon(J, L.path) && !le.isCommon(J, E.path)) && (U.push(N), $ = J);
        }
        var j = Array.from(U, (ce) => {
          var [, ue] = ce;
          return q.pathRef(t, ue);
        }), K = q.pointRef(t, L), te = q.pointRef(t, E), O = "";
        if (!M && !S) {
          var P = K.current, [H] = q.leaf(t, P), {
            path: I
          } = P, {
            offset: W
          } = L, X = H.text.slice(W);
          X.length > 0 && (t.apply({
            type: "remove_text",
            path: I,
            offset: W,
            text: X
          }), O = X);
        }
        if (j.reverse().map((ce) => ce.unref()).filter((ce) => ce !== null).forEach((ce) => Se.removeNodes(t, {
          at: ce,
          voids: l
        })), !F) {
          var w = te.current, [R] = q.leaf(t, w), {
            path: z
          } = w, _ = M ? L.offset : 0, Y = R.text.slice(_, E.offset);
          Y.length > 0 && (t.apply({
            type: "remove_text",
            path: z,
            offset: _,
            text: Y
          }), O = Y);
        }
        !M && C && te.current && K.current && Se.mergeNodes(t, {
          at: te.current,
          hanging: !0,
          voids: l
        }), p && i && s === "character" && O.length > 1 && O.match(/[\u0E00-\u0E7F]+/) && Se.insertText(t, O.slice(0, O.length - a));
        var Q = K.unref(), A = te.unref(), ae = i ? Q || A : A || Q;
        n.at == null && ae && Se.select(t, ae);
      }
    }
  });
}, Sle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  q.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: s = U1(t),
      batchDirty: a = !0
    } = r;
    if (n.length) {
      if (we.isRange(s))
        if (o || (s = q.unhangRange(t, s, {
          voids: i
        })), we.isCollapsed(s))
          s = s.anchor;
        else {
          var [, l] = we.edges(s);
          if (!i && q.void(t, {
            at: l
          }))
            return;
          var u = q.pointRef(t, l);
          Se.delete(t, {
            at: s
          }), s = u.unref();
        }
      else le.isPath(s) && (s = q.start(t, s));
      if (!(!i && q.void(t, {
        at: s
      }))) {
        var c = q.above(t, {
          at: s,
          match: (X) => Ve.isElement(X) && q.isInline(t, X),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, p] = c;
          if (q.isEnd(t, s, p)) {
            var d = q.after(t, p);
            s = d;
          } else if (q.isStart(t, s, p)) {
            var h = q.before(t, p);
            s = h;
          }
        }
        var y = q.above(t, {
          match: (X) => Ve.isElement(X) && q.isBlock(t, X),
          at: s,
          voids: i
        }), [, f] = y, g = q.isStart(t, s, f), x = q.isEnd(t, s, f), L = g && x, E = !g || g && x, T = !x, [, b] = Ue.first({
          children: n
        }, []), [, C] = Ue.last({
          children: n
        }, []), M = [], S = (X) => {
          var [w, R] = X, z = R.length === 0;
          return z ? !1 : L ? !0 : !(E && le.isAncestor(R, b) && Ve.isElement(w) && !t.isVoid(w) && !t.isInline(w) || T && le.isAncestor(R, C) && Ve.isElement(w) && !t.isVoid(w) && !t.isInline(w));
        };
        for (var F of Ue.nodes({
          children: n
        }, {
          pass: S
        }))
          S(F) && M.push(F);
        var D = [], Z = [], U = [], $ = !0, N = !1;
        for (var [V] of M)
          Ve.isElement(V) && !t.isInline(V) ? ($ = !1, N = !0, Z.push(V)) : $ ? D.push(V) : U.push(V);
        var [J] = q.nodes(t, {
          at: s,
          match: (X) => Ze.isText(X) || q.isInline(t, X),
          mode: "highest",
          voids: i
        }), [, j] = J, K = q.isStart(t, s, j), te = q.isEnd(t, s, j), O = q.pathRef(t, x && !U.length ? le.next(f) : f), P = q.pathRef(t, te ? le.next(j) : j);
        Se.splitNodes(t, {
          at: s,
          match: (X) => N ? Ve.isElement(X) && q.isBlock(t, X) : Ze.isText(X) || q.isInline(t, X),
          mode: N ? "lowest" : "highest",
          always: N && (!g || D.length > 0) && (!x || U.length > 0),
          voids: i
        });
        var H = q.pathRef(t, !K || K && te ? le.next(j) : j);
        if (Se.insertNodes(t, D, {
          at: H.current,
          match: (X) => Ze.isText(X) || q.isInline(t, X),
          mode: "highest",
          voids: i,
          batchDirty: a
        }), L && !D.length && Z.length && !U.length && Se.delete(t, {
          at: f,
          voids: i
        }), Se.insertNodes(t, Z, {
          at: O.current,
          match: (X) => Ve.isElement(X) && q.isBlock(t, X),
          mode: "lowest",
          voids: i,
          batchDirty: a
        }), Se.insertNodes(t, U, {
          at: P.current,
          match: (X) => Ze.isText(X) || q.isInline(t, X),
          mode: "highest",
          voids: i,
          batchDirty: a
        }), !r.at) {
          var I;
          if (U.length > 0 && P.current ? I = le.previous(P.current) : Z.length > 0 && O.current ? I = le.previous(O.current) : H.current && (I = le.previous(H.current)), I) {
            var W = q.end(t, I);
            Se.select(t, W);
          }
        }
        H.unref(), O.unref(), P.unref();
      }
    }
  });
}, Dle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      Se.select(t, o.anchor);
    else if (r === "focus")
      Se.select(t, o.focus);
    else if (r === "start") {
      var [i] = we.edges(o);
      Se.select(t, i);
    } else if (r === "end") {
      var [, s] = we.edges(o);
      Se.select(t, s);
    }
  } else return;
}, Ple = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, Tle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: s = !1
  } = n, {
    edge: a = null
  } = n;
  if (r) {
    a === "start" && (a = we.isBackward(r) ? "focus" : "anchor"), a === "end" && (a = we.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, p = {};
    if (a == null || a === "anchor") {
      var d = s ? q.before(t, l, c) : q.after(t, l, c);
      d && (p.anchor = d);
    }
    if (a == null || a === "focus") {
      var h = s ? q.before(t, u, c) : q.after(t, u, c);
      h && (p.focus = h);
    }
    Se.setSelection(t, p);
  }
}, _le = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = q.range(e, t), n) {
    Se.setSelection(e, t);
    return;
  }
  if (!we.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Fr.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function oT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oT(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ale = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = we.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = we.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: s,
      focus: a
    } = o, l = i === "anchor" ? s : a;
    Se.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: iT(iT({}, l), n)
    });
  }
}, Ble = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !kt.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !kt.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, Ile = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  q.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: s = "lowest",
      batchDirty: a = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (Ue.isNode(n) && (n = [n]), n.length !== 0) {
      var [p] = n;
      if (l || (l = U1(t), c !== !1 && (c = !0)), c == null && (c = !1), we.isRange(l))
        if (o || (l = q.unhangRange(t, l, {
          voids: i
        })), we.isCollapsed(l))
          l = l.anchor;
        else {
          var [, d] = we.edges(l), h = q.pointRef(t, d);
          Se.delete(t, {
            at: l
          }), l = h.unref();
        }
      if (kt.isPoint(l)) {
        u == null && (Ze.isText(p) ? u = (D) => Ze.isText(D) : t.isInline(p) ? u = (D) => Ze.isText(D) || q.isInline(t, D) : u = (D) => Ve.isElement(D) && q.isBlock(t, D));
        var [y] = q.nodes(t, {
          at: l.path,
          match: u,
          mode: s,
          voids: i
        });
        if (y) {
          var [, f] = y, g = q.pathRef(t, f), x = q.isEnd(t, l, f);
          Se.splitNodes(t, {
            at: l,
            match: u,
            mode: s,
            voids: i
          });
          var L = g.unref();
          l = x ? le.next(L) : L;
        } else
          return;
      }
      var E = le.parent(l), T = l[l.length - 1];
      if (!(!i && q.void(t, {
        at: E
      }))) {
        if (a) {
          var b = [], C = le.levels(E);
          vae(t, () => {
            var D = function() {
              var $ = E.concat(T);
              T++;
              var N = {
                type: "insert_node",
                path: $,
                node: Z
              };
              t.apply(N), l = le.next(l), b.push(N), Ze.isText ? C.push(...Array.from(Ue.nodes(Z), (V) => {
                var [, J] = V;
                return $.concat(J);
              })) : C.push($);
            };
            for (var Z of n)
              D();
          }, () => {
            zN(t, C, (D) => {
              var Z = D;
              for (var U of b)
                if (le.operationCanTransformPath(U) && (Z = le.transform(Z, U), !Z))
                  return null;
              return Z;
            });
          });
        } else
          for (var M of n) {
            var S = E.concat(T);
            T++, t.apply({
              type: "insert_node",
              path: S,
              node: M
            }), l = le.next(l);
          }
        if (l = le.previous(l), c) {
          var F = q.end(t, l);
          F && Se.select(t, F);
        }
      }
    }
  });
}, jle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  q.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: s
    } = n;
    if (s == null && (s = le.isPath(r) ? nl(t, r) : (T) => Ve.isElement(T) && q.isBlock(t, T)), !!r) {
      var a = q.nodes(t, {
        at: r,
        match: s,
        mode: o,
        voids: i
      }), l = Array.from(a, (T) => {
        var [, b] = T;
        return q.pathRef(t, b);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var p = q.node(t, le.parent(c)), [d, h] = p, y = c[c.length - 1], {
          length: f
        } = d.children;
        if (f === 1) {
          var g = le.next(h);
          Se.moveNodes(t, {
            at: c,
            to: g,
            voids: i
          }), Se.removeNodes(t, {
            at: h,
            voids: i
          });
        } else if (y === 0)
          Se.moveNodes(t, {
            at: c,
            to: h,
            voids: i
          });
        else if (y === f - 1) {
          var x = le.next(h);
          Se.moveNodes(t, {
            at: c,
            to: x,
            voids: i
          });
        } else {
          var L = le.next(c), E = le.next(h);
          Se.splitNodes(t, {
            at: L,
            voids: i
          }), Se.moveNodes(t, {
            at: c,
            to: E,
            voids: i
          });
        }
      }
    }
  });
}, Rle = ["text"], Nle = ["children"], UN = (e, t) => {
  if (Ve.isElement(t)) {
    var n = t;
    return q.isVoid(e, t) ? !0 : n.children.length === 1 ? UN(e, n.children[0]) : !1;
  } else return !q.isEditor(t);
}, Fle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  q.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: s = !1,
      mode: a = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (le.isPath(o)) {
          var [l] = q.parent(t, o);
          r = (D) => l.children.includes(D);
        } else
          r = (D) => Ve.isElement(D) && q.isBlock(t, D);
      if (!i && we.isRange(o) && (o = q.unhangRange(t, o, {
        voids: s
      })), we.isRange(o))
        if (we.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = we.edges(o), c = q.pointRef(t, u);
          Se.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && Se.select(t, o);
        }
      var [p] = q.nodes(t, {
        at: o,
        match: r,
        voids: s,
        mode: a
      }), d = q.previous(t, {
        at: o,
        match: r,
        voids: s,
        mode: a
      });
      if (!(!p || !d)) {
        var [h, y] = p, [f, g] = d;
        if (!(y.length === 0 || g.length === 0)) {
          var x = le.next(g), L = le.common(y, g), E = le.isSibling(y, g), T = Array.from(q.levels(t, {
            at: y
          }), (D) => {
            var [Z] = D;
            return Z;
          }).slice(L.length).slice(0, -1), b = q.above(t, {
            at: y,
            mode: "highest",
            match: (D) => T.includes(D) && UN(t, D)
          }), C = b && q.pathRef(t, b[1]), M, S;
          if (Ze.isText(h) && Ze.isText(f)) {
            var F = Fi(h, Rle);
            S = f.text.length, M = F;
          } else if (Ve.isElement(h) && Ve.isElement(f)) {
            var F = Fi(h, Nle);
            S = f.children.length, M = F;
          } else
            throw new Error("Cannot merge the node at path [".concat(y, "] with the previous sibling because it is not the same kind: ").concat(Fr.stringify(h), " ").concat(Fr.stringify(f)));
          E || Se.moveNodes(t, {
            at: y,
            to: x,
            voids: s
          }), C && Se.removeNodes(t, {
            at: C.current,
            voids: s
          }), q.shouldMergeNodesRemovePrevNode(t, d, p) ? Se.removeNodes(t, {
            at: g,
            voids: s
          }) : t.apply({
            type: "merge_node",
            path: x,
            position: S,
            properties: M
          }), C && C.unref();
        }
      }
    }
  });
}, zle = (e, t) => {
  q.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: s
    } = t;
    if (r) {
      s == null && (s = le.isPath(r) ? nl(e, r) : (h) => Ve.isElement(h) && q.isBlock(e, h));
      var a = q.pathRef(e, n), l = q.nodes(e, {
        at: r,
        match: s,
        mode: o,
        voids: i
      }), u = Array.from(l, (h) => {
        var [, y] = h;
        return q.pathRef(e, y);
      });
      for (var c of u) {
        var p = c.unref(), d = a.current;
        p.length !== 0 && e.apply({
          type: "move_node",
          path: p,
          newPath: d
        }), a.current && le.isSibling(d, p) && le.isAfter(d, p) && (a.current = le.next(a.current));
      }
      a.unref();
    }
  });
}, Ule = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  q.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: s = t.selection,
      match: a
    } = n;
    if (s) {
      a == null && (a = le.isPath(s) ? nl(t, s) : (h) => Ve.isElement(h) && q.isBlock(t, h)), !r && we.isRange(s) && (s = q.unhangRange(t, s, {
        voids: o
      }));
      var l = q.nodes(t, {
        at: s,
        match: a,
        mode: i,
        voids: o
      }), u = Array.from(l, (h) => {
        var [, y] = h;
        return q.pathRef(t, y);
      });
      for (var c of u) {
        var p = c.unref();
        if (p) {
          var [d] = q.node(t, p);
          t.apply({
            type: "remove_node",
            path: p,
            node: d
          });
        }
      }
    }
  });
}, $le = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  q.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: s,
      merge: a
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: p = !1
    } = r;
    if (i) {
      if (o == null && (o = le.isPath(i) ? nl(t, i) : (S) => Ve.isElement(S) && q.isBlock(t, S)), !l && we.isRange(i) && (i = q.unhangRange(t, i, {
        voids: p
      })), c && we.isRange(i)) {
        if (we.isCollapsed(i) && q.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var d = q.rangeRef(t, i, {
          affinity: "inward"
        }), [h, y] = we.edges(i), f = u === "lowest" ? "lowest" : "highest", g = q.isEnd(t, y, y.path);
        Se.splitNodes(t, {
          at: y,
          match: o,
          mode: f,
          voids: p,
          always: !g
        });
        var x = q.isStart(t, h, h.path);
        Se.splitNodes(t, {
          at: h,
          match: o,
          mode: f,
          voids: p,
          always: !x
        }), i = d.unref(), r.at == null && Se.select(t, i);
      }
      s || (s = (S, F) => S !== F);
      for (var [L, E] of q.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: p
      })) {
        var T = {}, b = {};
        if (E.length !== 0) {
          var C = !1;
          for (var M in n)
            M === "children" || M === "text" || s(n[M], L[M]) && (C = !0, L.hasOwnProperty(M) && (T[M] = L[M]), a ? n[M] != null && (b[M] = a(L[M], n[M])) : n[M] != null && (b[M] = n[M]));
          C && t.apply({
            type: "set_node",
            path: E,
            properties: T,
            newProperties: b
          });
        }
      }
    }
  });
}, Wle = (e, t) => {
  if (we.isCollapsed(t))
    return t.anchor;
  var [, n] = we.edges(t), r = q.pointRef(e, n);
  return Se.delete(e, {
    at: t
  }), r.unref();
}, Hle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  q.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: s = t.selection,
      height: a = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (te) => Ve.isElement(te) && q.isBlock(t, te)), we.isRange(s) && (s = Wle(t, s)), le.isPath(s)) {
      var u = s, c = q.point(t, u), [p] = q.parent(t, u);
      i = (te) => te === p, a = c.path.length - u.length + 1, s = c, l = !0;
    }
    if (s) {
      var d = q.pointRef(t, s, {
        affinity: "backward"
      }), h;
      try {
        var [y] = q.nodes(t, {
          at: s,
          match: i,
          mode: r,
          voids: o
        });
        if (!y)
          return;
        var f = q.void(t, {
          at: s,
          mode: "highest"
        }), g = 0;
        if (!o && f) {
          var [x, L] = f;
          if (Ve.isElement(x) && t.isInline(x)) {
            var E = q.after(t, L);
            if (!E) {
              var T = {
                text: ""
              }, b = le.next(L);
              Se.insertNodes(t, T, {
                at: b,
                voids: o
              }), E = q.point(t, b);
            }
            s = E, l = !0;
          }
          var C = s.path.length - L.length;
          a = C + 1, l = !0;
        }
        h = q.pointRef(t, s);
        var M = s.path.length - a, [, S] = y, F = s.path.slice(0, M), D = a === 0 ? s.offset : s.path[M] + g;
        for (var [Z, U] of q.levels(t, {
          at: F,
          reverse: !0,
          voids: o
        })) {
          var $ = !1;
          if (U.length < S.length || U.length === 0 || !o && Ve.isElement(Z) && q.isVoid(t, Z))
            break;
          var N = d.current, V = q.isEnd(t, N, U);
          if (l || !d || !q.isEdge(t, N, U)) {
            $ = !0;
            var J = Ue.extractProps(Z);
            t.apply({
              type: "split_node",
              path: U,
              position: D,
              properties: J
            });
          }
          D = U[U.length - 1] + ($ || V ? 1 : 0);
        }
        if (n.at == null) {
          var j = h.current || q.end(t, []);
          Se.select(t, j);
        }
      } finally {
        var K;
        d.unref(), (K = h) === null || K === void 0 || K.unref();
      }
    }
  });
}, Vle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  Se.setNodes(t, o, r);
}, Zle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  q.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: s = t.selection,
      match: a
    } = n;
    if (s) {
      a == null && (a = le.isPath(s) ? nl(t, s) : (h) => Ve.isElement(h) && q.isBlock(t, h)), le.isPath(s) && (s = q.range(t, s));
      var l = we.isRange(s) ? q.rangeRef(t, s) : null, u = q.nodes(t, {
        at: s,
        match: a,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (h) => {
          var [, y] = h;
          return q.pathRef(t, y);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), p = function() {
        var y = d.unref(), [f] = q.node(t, y), g = q.range(t, y);
        o && l && (g = we.intersection(l.current, g)), Se.liftNodes(t, {
          at: g,
          match: (x) => Ve.isAncestor(f) && f.children.includes(x),
          voids: i
        });
      };
      for (var d of c)
        p();
      l && l.unref();
    }
  });
};
function sT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sT(Object(n), !0).forEach(function(r) {
      io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  q.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: s = !1
    } = r, {
      match: a,
      at: l = t.selection
    } = r;
    if (l) {
      if (a == null && (le.isPath(l) ? a = nl(t, l) : t.isInline(n) ? a = (g) => Ve.isElement(g) && q.isInline(t, g) || Ze.isText(g) : a = (g) => Ve.isElement(g) && q.isBlock(t, g)), i && we.isRange(l)) {
        var [u, c] = we.edges(l), p = q.rangeRef(t, l, {
          affinity: "inward"
        });
        Se.splitNodes(t, {
          at: c,
          match: a,
          voids: s
        }), Se.splitNodes(t, {
          at: u,
          match: a,
          voids: s
        }), l = p.unref(), r.at == null && Se.select(t, l);
      }
      var d = Array.from(q.nodes(t, {
        at: l,
        match: t.isInline(n) ? (g) => Ve.isElement(g) && q.isBlock(t, g) : (g) => q.isEditor(g),
        mode: "lowest",
        voids: s
      })), h = function() {
        var x = we.isRange(l) ? we.intersection(l, q.range(t, f)) : l;
        if (!x)
          return 0;
        var L = Array.from(q.nodes(t, {
          at: x,
          match: a,
          mode: o,
          voids: s
        }));
        if (L.length > 0) {
          var [E] = L, T = L[L.length - 1], [, b] = E, [, C] = T;
          if (b.length === 0 && C.length === 0)
            return 0;
          var M = le.equals(b, C) ? le.parent(b) : le.common(b, C), S = q.range(t, b, C), F = q.node(t, M), [D] = F, Z = M.length + 1, U = le.next(C.slice(0, Z)), $ = aT(aT({}, n), {}, {
            children: []
          });
          Se.insertNodes(t, $, {
            at: U,
            voids: s
          }), Se.moveNodes(t, {
            at: S,
            match: (N) => Ve.isAncestor(D) && D.children.includes(N),
            to: U.concat(0),
            voids: s
          });
        }
      }, y;
      for (var [, f] of d)
        y = h();
    }
  });
}, Gle = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yae(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Lae(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mae(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Sae(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dae(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wae(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zae(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $ae(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Sle(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Uae(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hae(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Cae(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wle(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bae(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xae(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Eae(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kae(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Oae(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dle(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mle(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ple(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Pae(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tae(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _ae(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Aae(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Bae(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nle(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jae(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Rae(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nae(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fae(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ile(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vae(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zae(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qae(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Gae(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Xae(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Yae(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jae(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Kae(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qae(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jle(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fle(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tle(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zle(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rle(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ole(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ile(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sle(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ale(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cle(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lle(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ule(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fle(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ple(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dle(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hle(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gle(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yle(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mle(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vle(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ule(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _le(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $le(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Cle(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ale(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ble(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hle(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xle(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ele(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Lle(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vle(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zle(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Iae(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kle(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qle(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ole(e, ...r);
    }
  };
  return e;
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function lT(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Xle(e) {
  var t, n;
  return lT(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(lT(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Yle = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return Xle(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || Cs.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || Cs.isOperationList(e.undos[0].operations));
  }
}, Ym = /* @__PURE__ */ new WeakMap(), Pl = /* @__PURE__ */ new WeakMap(), ha = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return Yle.isHistory(e.history) && q.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return Pl.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return Ym.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = ha.isMerging(e);
    Pl.set(e, !0), t(), Pl.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = ha.isMerging(e);
    Pl.set(e, !1), t(), Pl.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = ha.isSaving(e);
    Ym.set(e, !1), t(), Ym.set(e, n);
  }
}, Jle = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && Se.setSelection(t, i.selectionBefore), ha.withoutSaving(t, () => {
        q.withoutNormalizing(t, () => {
          for (var s of i.operations)
            t.apply(s);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      ha.withoutSaving(t, () => {
        q.withoutNormalizing(t, () => {
          var s = i.operations.map(Cs.inverse).reverse();
          for (var a of s)
            t.apply(a);
          i.selectionBefore && Se.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: s
    } = i, a = s[s.length - 1], l = a && a.operations[a.operations.length - 1], u = ha.isSaving(t), c = ha.isMerging(t);
    if (u == null && (u = Qle(r)), u) {
      if (c == null && (a == null ? c = !1 : o.length !== 0 ? c = !0 : c = Kle(r, l)), a && c)
        a.operations.push(r);
      else {
        var p = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", p);
      }
      for (; s.length > 100; )
        s.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, Kle = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && le.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && le.equals(e.path, t.path)), Qle = (e, t) => e.type !== "set_selection", eue = rue, $N = "֑-߿יִ-﷽ﹰ-ﻼ", WN = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", tue = new RegExp("^[^" + WN + "]*[" + $N + "]"), nue = new RegExp("^[^" + $N + "]*[" + WN + "]");
function rue(e) {
  return e = String(e || ""), tue.test(e) ? "rtl" : nue.test(e) ? "ltr" : "neutral";
}
const HN = /* @__PURE__ */ tf(eue);
function oue(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var H1 = oue, iue = typeof Sn == "object" && Sn && Sn.Object === Object && Sn, sue = iue, aue = sue, lue = typeof self == "object" && self && self.Object === Object && self, uue = aue || lue || Function("return this")(), VN = uue, cue = VN, pue = function() {
  return cue.Date.now();
}, due = pue, fue = /\s/;
function hue(e) {
  for (var t = e.length; t-- && fue.test(e.charAt(t)); )
    ;
  return t;
}
var gue = hue, mue = gue, vue = /^\s+/;
function yue(e) {
  return e && e.slice(0, mue(e) + 1).replace(vue, "");
}
var bue = yue, wue = VN, Cue = wue.Symbol, ZN = Cue, uT = ZN, qN = Object.prototype, xue = qN.hasOwnProperty, Eue = qN.toString, Tl = uT ? uT.toStringTag : void 0;
function Lue(e) {
  var t = xue.call(e, Tl), n = e[Tl];
  try {
    e[Tl] = void 0;
    var r = !0;
  } catch {
  }
  var o = Eue.call(e);
  return r && (t ? e[Tl] = n : delete e[Tl]), o;
}
var kue = Lue, Oue = Object.prototype, Mue = Oue.toString;
function Sue(e) {
  return Mue.call(e);
}
var Due = Sue, cT = ZN, Pue = kue, Tue = Due, _ue = "[object Null]", Aue = "[object Undefined]", pT = cT ? cT.toStringTag : void 0;
function Bue(e) {
  return e == null ? e === void 0 ? Aue : _ue : pT && pT in Object(e) ? Pue(e) : Tue(e);
}
var Iue = Bue;
function jue(e) {
  return e != null && typeof e == "object";
}
var Rue = jue, Nue = Iue, Fue = Rue, zue = "[object Symbol]";
function Uue(e) {
  return typeof e == "symbol" || Fue(e) && Nue(e) == zue;
}
var $ue = Uue, Wue = bue, dT = H1, Hue = $ue, fT = NaN, Vue = /^[-+]0x[0-9a-f]+$/i, Zue = /^0b[01]+$/i, que = /^0o[0-7]+$/i, Gue = parseInt;
function Xue(e) {
  if (typeof e == "number")
    return e;
  if (Hue(e))
    return fT;
  if (dT(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = dT(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = Wue(e);
  var n = Zue.test(e);
  return n || que.test(e) ? Gue(e.slice(2), n ? 2 : 8) : Vue.test(e) ? fT : +e;
}
var Yue = Xue, Jue = H1, Jm = due, hT = Yue, Kue = "Expected a function", Que = Math.max, ece = Math.min;
function tce(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Kue);
  t = hT(t) || 0, Jue(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Que(hT(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function h(C) {
    var M = r, S = o;
    return r = o = void 0, u = C, s = e.apply(S, M), s;
  }
  function y(C) {
    return u = C, a = setTimeout(x, t), c ? h(C) : s;
  }
  function f(C) {
    var M = C - l, S = C - u, F = t - M;
    return p ? ece(F, i - S) : F;
  }
  function g(C) {
    var M = C - l, S = C - u;
    return l === void 0 || M >= t || M < 0 || p && S >= i;
  }
  function x() {
    var C = Jm();
    if (g(C))
      return L(C);
    a = setTimeout(x, f(C));
  }
  function L(C) {
    return a = void 0, d && r ? h(C) : (r = o = void 0, s);
  }
  function E() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function T() {
    return a === void 0 ? s : L(Jm());
  }
  function b() {
    var C = Jm(), M = g(C);
    if (r = arguments, o = this, l = C, M) {
      if (a === void 0)
        return y(l);
      if (p)
        return clearTimeout(a), a = setTimeout(x, t), h(l);
    }
    return a === void 0 && (a = setTimeout(x, t)), s;
  }
  return b.cancel = E, b.flush = T, b;
}
var GN = tce;
const nce = /* @__PURE__ */ tf(GN);
var rce = GN, oce = H1, ice = "Expected a function";
function sce(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(ice);
  return oce(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), rce(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var ace = sce;
const lce = /* @__PURE__ */ tf(ace), gT = (e) => typeof e == "object" && e != null && e.nodeType === 1, mT = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", Km = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return mT(n.overflowY, t) || mT(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, jp = (e, t, n, r, o, i, s, a) => i < e && s > t || i > e && s < t ? 0 : i <= e && a <= n || s >= t && a >= n ? i - e - r : s > t && a < n || i < e && a > n ? s - t + o : 0, uce = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, vT = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: s, block: a, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, p = typeof u == "function" ? u : (J) => J !== u;
  if (!gT(e)) throw new TypeError("Invalid target");
  const d = document.scrollingElement || document.documentElement, h = [];
  let y = e;
  for (; gT(y) && p(y); ) {
    if (y = uce(y), y === d) {
      h.push(y);
      break;
    }
    y != null && y === document.body && Km(y) && !Km(document.documentElement) || y != null && Km(y, c) && h.push(y);
  }
  const f = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, g = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: x, scrollY: L } = window, { height: E, width: T, top: b, right: C, bottom: M, left: S } = e.getBoundingClientRect(), { top: F, right: D, bottom: Z, left: U } = ((J) => {
    const j = window.getComputedStyle(J);
    return { top: parseFloat(j.scrollMarginTop) || 0, right: parseFloat(j.scrollMarginRight) || 0, bottom: parseFloat(j.scrollMarginBottom) || 0, left: parseFloat(j.scrollMarginLeft) || 0 };
  })(e);
  let $ = a === "start" || a === "nearest" ? b - F : a === "end" ? M + Z : b + E / 2 - F + Z, N = l === "center" ? S + T / 2 - U + D : l === "end" ? C + D : S - U;
  const V = [];
  for (let J = 0; J < h.length; J++) {
    const j = h[J], { height: K, width: te, top: O, right: P, bottom: H, left: I } = j.getBoundingClientRect();
    if (s === "if-needed" && b >= 0 && S >= 0 && M <= g && C <= f && b >= O && M <= H && S >= I && C <= P) return V;
    const W = getComputedStyle(j), X = parseInt(W.borderLeftWidth, 10), w = parseInt(W.borderTopWidth, 10), R = parseInt(W.borderRightWidth, 10), z = parseInt(W.borderBottomWidth, 10);
    let _ = 0, Y = 0;
    const Q = "offsetWidth" in j ? j.offsetWidth - j.clientWidth - X - R : 0, A = "offsetHeight" in j ? j.offsetHeight - j.clientHeight - w - z : 0, ae = "offsetWidth" in j ? j.offsetWidth === 0 ? 0 : te / j.offsetWidth : 0, ce = "offsetHeight" in j ? j.offsetHeight === 0 ? 0 : K / j.offsetHeight : 0;
    if (d === j) _ = a === "start" ? $ : a === "end" ? $ - g : a === "nearest" ? jp(L, L + g, g, w, z, L + $, L + $ + E, E) : $ - g / 2, Y = l === "start" ? N : l === "center" ? N - f / 2 : l === "end" ? N - f : jp(x, x + f, f, X, R, x + N, x + N + T, T), _ = Math.max(0, _ + L), Y = Math.max(0, Y + x);
    else {
      _ = a === "start" ? $ - O - w : a === "end" ? $ - H + z + A : a === "nearest" ? jp(O, H, K, w, z + A, $, $ + E, E) : $ - (O + K / 2) + A / 2, Y = l === "start" ? N - I - X : l === "center" ? N - (I + te / 2) + Q / 2 : l === "end" ? N - P + R + Q : jp(I, P, te, X, R + Q, N, N + T, T);
      const { scrollLeft: ue, scrollTop: de } = j;
      _ = ce === 0 ? 0 : Math.max(0, Math.min(de + _ / ce, j.scrollHeight - K / ce + A)), Y = ae === 0 ? 0 : Math.max(0, Math.min(ue + Y / ae, j.scrollWidth - te / ae + Q)), $ += de - _, N += ue - Y;
    }
    V.push({ el: j, top: _, left: Y });
  }
  return V;
}, cce = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function pce(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(vT(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: s } of vT(e, cce(t))) {
    const a = i - n.top + n.bottom, l = s - n.left + n.right;
    o.scroll({ top: a, left: l, behavior: r });
  }
}
var ma = [], dce = function() {
  return ma.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, fce = function() {
  return ma.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, yT = "ResizeObserver loop completed with undelivered notifications.", hce = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: yT
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = yT), window.dispatchEvent(e);
}, Bu;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Bu || (Bu = {}));
var va = function(e) {
  return Object.freeze(e);
}, gce = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, va(this);
  }
  return e;
}(), XN = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, va(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), V1 = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, YN = function(e) {
  if (V1(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, s = o.offsetHeight;
  return !(i || s || e.getClientRects().length);
}, bT = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, mce = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, iu = typeof window < "u" ? window : {}, Rp = /* @__PURE__ */ new WeakMap(), wT = /auto|scroll/, vce = /^tb|vertical/, yce = /msie|trident/i.test(iu.navigator && iu.navigator.userAgent), Qo = function(e) {
  return parseFloat(e || "0");
}, Fa = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new gce((n ? t : e) || 0, (n ? e : t) || 0);
}, CT = va({
  devicePixelContentBoxSize: Fa(),
  borderBoxSize: Fa(),
  contentBoxSize: Fa(),
  contentRect: new XN(0, 0, 0, 0)
}), JN = function(e, t) {
  if (t === void 0 && (t = !1), Rp.has(e) && !t)
    return Rp.get(e);
  if (YN(e))
    return Rp.set(e, CT), CT;
  var n = getComputedStyle(e), r = V1(e) && e.ownerSVGElement && e.getBBox(), o = !yce && n.boxSizing === "border-box", i = vce.test(n.writingMode || ""), s = !r && wT.test(n.overflowY || ""), a = !r && wT.test(n.overflowX || ""), l = r ? 0 : Qo(n.paddingTop), u = r ? 0 : Qo(n.paddingRight), c = r ? 0 : Qo(n.paddingBottom), p = r ? 0 : Qo(n.paddingLeft), d = r ? 0 : Qo(n.borderTopWidth), h = r ? 0 : Qo(n.borderRightWidth), y = r ? 0 : Qo(n.borderBottomWidth), f = r ? 0 : Qo(n.borderLeftWidth), g = p + u, x = l + c, L = f + h, E = d + y, T = a ? e.offsetHeight - E - e.clientHeight : 0, b = s ? e.offsetWidth - L - e.clientWidth : 0, C = o ? g + L : 0, M = o ? x + E : 0, S = r ? r.width : Qo(n.width) - C - b, F = r ? r.height : Qo(n.height) - M - T, D = S + g + b + L, Z = F + x + T + E, U = va({
    devicePixelContentBoxSize: Fa(Math.round(S * devicePixelRatio), Math.round(F * devicePixelRatio), i),
    borderBoxSize: Fa(D, Z, i),
    contentBoxSize: Fa(S, F, i),
    contentRect: new XN(p, l, S, F)
  });
  return Rp.set(e, U), U;
}, KN = function(e, t, n) {
  var r = JN(e, n), o = r.borderBoxSize, i = r.contentBoxSize, s = r.devicePixelContentBoxSize;
  switch (t) {
    case Bu.DEVICE_PIXEL_CONTENT_BOX:
      return s;
    case Bu.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, bce = /* @__PURE__ */ function() {
  function e(t) {
    var n = JN(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = va([n.borderBoxSize]), this.contentBoxSize = va([n.contentBoxSize]), this.devicePixelContentBoxSize = va([n.devicePixelContentBoxSize]);
  }
  return e;
}(), QN = function(e) {
  if (YN(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, wce = function() {
  var e = 1 / 0, t = [];
  ma.forEach(function(s) {
    if (s.activeTargets.length !== 0) {
      var a = [];
      s.activeTargets.forEach(function(u) {
        var c = new bce(u.target), p = QN(u.target);
        a.push(c), u.lastReportedSize = KN(u.target, u.observedBox), p < e && (e = p);
      }), t.push(function() {
        s.callback.call(s.observer, a, s.observer);
      }), s.activeTargets.splice(0, s.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, xT = function(e) {
  ma.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (QN(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, Cce = function() {
  var e = 0;
  for (xT(e); dce(); )
    e = wce(), xT(e);
  return fce() && hce(), e > 0;
}, Qm, eF = [], xce = function() {
  return eF.splice(0).forEach(function(e) {
    return e();
  });
}, Ece = function(e) {
  if (!Qm) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return xce();
    }).observe(n, r), Qm = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  eF.push(e), Qm();
}, Lce = function(e) {
  Ece(function() {
    requestAnimationFrame(e);
  });
}, od = 0, kce = function() {
  return !!od;
}, Oce = 250, Mce = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, ET = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], LT = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, ev = !1, Sce = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = Oce), !ev) {
      ev = !0;
      var r = LT(t);
      Lce(function() {
        var o = !1;
        try {
          o = Cce();
        } finally {
          if (ev = !1, t = r - LT(), !kce())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, Mce);
    };
    document.body ? n() : iu.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), ET.forEach(function(n) {
      return iu.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), ET.forEach(function(n) {
      return iu.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), Ky = new Sce(), kT = function(e) {
  !od && e > 0 && Ky.start(), od += e, !od && Ky.stop();
}, Dce = function(e) {
  return !V1(e) && !mce(e) && getComputedStyle(e).display === "inline";
}, Pce = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || Bu.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = KN(this.target, this.observedBox, !0);
    return Dce(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), Tce = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Np = /* @__PURE__ */ new WeakMap(), OT = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Fp = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new Tce(t, n);
    Np.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = Np.get(t), i = o.observationTargets.length === 0;
    OT(o.observationTargets, n) < 0 && (i && ma.push(o), o.observationTargets.push(new Pce(n, r && r.box)), kT(1), Ky.schedule());
  }, e.unobserve = function(t, n) {
    var r = Np.get(t), o = OT(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && ma.splice(ma.indexOf(r), 1), r.observationTargets.splice(o, 1), kT(-1));
  }, e.disconnect = function(t) {
    var n = this, r = Np.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), _ce = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Fp.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!bT(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Fp.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!bT(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Fp.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Fp.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function Ace(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Va(e, t) {
  if (e == null) return {};
  var n = Ace(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function Iu(e) {
  "@babel/helpers - typeof";
  return Iu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Iu(e);
}
function Bce(e, t) {
  if (Iu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Iu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Ice(e) {
  var t = Bce(e, "string");
  return Iu(t) === "symbol" ? t : String(t);
}
function Zo(e, t, n) {
  return t = Ice(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Z1 = /* @__PURE__ */ qe(null), Rs = () => {
  var e = Te(Z1);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, tv, nv, tF = parseInt(Ae.version.split(".")[0], 10), nF = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, MT = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), eo = typeof navigator < "u" && /Android/.test(navigator.userAgent), Na = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), ra = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), jce = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), rF = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), Rce = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), Nce = eo && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), Fce = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), zce = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), Uce = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), id = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((tv = navigator.userAgent.match(/Version\/(\d+)/)) !== null && tv !== void 0 && tv[1] && parseInt((nv = navigator.userAgent.match(/Version\/(\d+)/)) === null || nv === void 0 ? void 0 : nv[1], 10) < 17);
var ts = (!Rce || !Nce) && !jce && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", q1 = /* @__PURE__ */ new WeakMap(), G1 = /* @__PURE__ */ new WeakMap(), oF = /* @__PURE__ */ new WeakMap(), sd = /* @__PURE__ */ new WeakMap(), Qy = /* @__PURE__ */ new WeakMap(), ju = /* @__PURE__ */ new WeakMap(), ya = /* @__PURE__ */ new WeakMap(), Jd = /* @__PURE__ */ new WeakMap(), Nh = /* @__PURE__ */ new WeakMap(), e0 = /* @__PURE__ */ new WeakMap(), xs = /* @__PURE__ */ new WeakMap(), ga = /* @__PURE__ */ new WeakMap(), su = /* @__PURE__ */ new WeakMap(), t0 = /* @__PURE__ */ new WeakMap(), X1 = /* @__PURE__ */ new WeakMap(), qo = /* @__PURE__ */ new WeakMap(), Bi = /* @__PURE__ */ new WeakMap(), ao = /* @__PURE__ */ new WeakMap(), hs = /* @__PURE__ */ new WeakMap(), gs = /* @__PURE__ */ new WeakMap(), iF = /* @__PURE__ */ new WeakMap(), Za = Symbol("placeholder"), sF = Symbol("mark-placeholder"), aF = globalThis.Node, $ce = globalThis.Text, Y1 = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Wce = (e) => Ls(e) && e.nodeType === 8, Vo = (e) => Ls(e) && e.nodeType === 1, Ls = (e) => {
  var t = Y1(e);
  return !!t && e instanceof t.Node;
}, n0 = (e) => {
  var t = e && e.anchorNode && Y1(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, lF = (e) => Ls(e) && e.nodeType === 3, Hce = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, Vce = (e) => {
  var [t, n] = e;
  if (Vo(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = uF(t, o, r ? "backward" : "forward"), r = o < n; Vo(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = qce(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, Zce = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, uF = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (Wce(o) || Vo(o) && o.childNodes.length === 0 || Vo(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, qce = (e, t, n) => {
  var [r] = uF(e, t, n);
  return r;
}, cF = (e) => {
  var t = "";
  if (lF(e) && e.nodeValue)
    return e.nodeValue;
  if (Vo(e)) {
    for (var n of Array.from(e.childNodes))
      t += cF(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, Gce = /data-slate-fragment="(.+?)"/m, Xce = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(Gce) || [];
  return n;
}, au = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), J1 = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Vo(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = ke.getWindow(e);
  if (o.contains(r))
    return ke.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : J1(e, i, n);
}, Yce = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, ST = (e, t) => !!(e.compareDocumentPosition(t) & aF.DOCUMENT_POSITION_PRECEDING), Jce = (e, t) => !!(e.compareDocumentPosition(t) & aF.DOCUMENT_POSITION_FOLLOWING), Kce = 0;
class Qce {
  constructor() {
    Zo(this, "id", void 0), this.id = "".concat(Kce++);
  }
}
var ke = {
  androidPendingDiffs: (e) => ao.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = X1.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = ke.toDOMNode(e, e), n = ke.findDocumentOrShadowRoot(e);
    xs.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = ke.findDocumentOrShadowRoot(e), r = au(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Se.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = ke.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = ke.toSlateNode(e, t.target), s = ke.findPath(e, i);
    if (Ve.isElement(i) && q.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = q.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? q.before(e, u) : q.after(e, u);
      if (c) {
        var p = q.range(e, c);
        return p;
      }
    }
    var d, {
      document: h
    } = ke.getWindow(e);
    if (h.caretRangeFromPoint)
      d = h.caretRangeFromPoint(n, r);
    else {
      var y = h.caretPositionFromPoint(n, r);
      y && (d = h.createRange(), d.setStart(y.offsetNode, y.offset), d.setEnd(y.offsetNode, y.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var f = ke.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return f;
  },
  findKey: (e, t) => {
    var n = Jd.get(t);
    return n || (n = new Qce(), Jd.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = G1.get(r);
      if (o == null) {
        if (q.isEditor(r))
          return n;
        break;
      }
      var i = q1.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Fr.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!xs.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          ke.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = ke.toDOMNode(t, t), o = ke.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = au(o), s = ke.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(s);
        }
        t.selection || Se.select(t, q.start(t, [])), xs.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = oF.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = ke.toDOMNode(t, t), s;
    try {
      s = Vo(n) ? n : n.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return s ? s.closest("[data-slate-editor]") === i && (!o || s.isContentEditable ? !0 : typeof s.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    s.closest('[contenteditable="false"]') === i || !!s.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Ls(t) && ke.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return q.hasPath(e, n.path) && q.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => ke.hasEditableTarget(e, t) || ke.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Ls(t) && ke.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!ga.get(e),
  isFocused: (e) => !!xs.get(e),
  isReadOnly: (e) => !!e0.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (e0.get(e)) return !1;
    var n = ke.hasTarget(e, t) && ke.toSlateNode(e, t);
    return Ve.isElement(n) && q.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Nh.get(e), r = q.isEditor(t) ? sd.get(e) : n == null ? void 0 : n.get(ke.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Fr.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = q.node(e, t.path), r = ke.toDOMNode(e, n), o;
    q.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), h = d == null ? p : parseInt(d, 10), y = a + h, f = s[l + 1];
        if (t.offset === y && f !== null && f !== void 0 && f.hasAttribute("data-slate-mark-placeholder")) {
          var g, x = f.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            x instanceof $ce ? x : f,
            (g = f.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= y) {
          var L = Math.min(p, Math.max(0, t.offset - a));
          o = [c, L];
          break;
        }
        a = y;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Fr.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = we.isBackward(t), i = ke.toDOMPoint(e, n), s = we.isCollapsed(t) ? i : ke.toDOMPoint(e, r), a = ke.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, h = Vo(u) ? u : u.parentElement, y = !!h.getAttribute("data-slate-zero-width"), f = Vo(p) ? p : p.parentElement, g = !!f.getAttribute("data-slate-zero-width");
    return l.setStart(u, y ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Vo(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? ju.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : Vce(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, h = ke.toDOMNode(e, e), y = l.closest('[data-slate-void="true"]'), f = y && h.contains(y) ? y : null, g = l.closest('[contenteditable="false"]'), x = g && h.contains(g) ? g : null, L = l.closest("[data-slate-leaf]"), E = null;
      if (L) {
        if (u = L.closest('[data-slate-node="text"]'), u) {
          var T = ke.getWindow(e), b = T.document.createRange();
          b.setStart(u, 0), b.setEnd(s, a);
          var C = b.cloneContents(), M = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          M.forEach((I) => {
            if (eo && !r && I.hasAttribute("data-slate-zero-width") && I.textContent.length > 0 && I.textContext !== "\uFEFF") {
              I.textContent.startsWith("\uFEFF") && (I.textContent = I.textContent.slice(1));
              return;
            }
            I.parentNode.removeChild(I);
          }), c = C.textContent.length, E = u;
        }
      } else if (f) {
        for (var S = f.querySelectorAll("[data-slate-leaf]"), F = 0; F < S.length; F++) {
          var D = S[F];
          if (ke.hasDOMNode(e, D)) {
            L = D;
            break;
          }
        }
        L ? (u = L.closest('[data-slate-node="text"]'), E = L, c = E.textContent.length, E.querySelectorAll("[data-slate-zero-width]").forEach((I) => {
          c -= I.textContent.length;
        })) : c = 1;
      } else if (x) {
        var Z = (I) => I ? I.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], U = x.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, N = [...Z(U), ...Z(U == null ? void 0 : U.nextElementSibling)];
          L = ($ = N.find((I) => Jce(x, I))) !== null && $ !== void 0 ? $ : null;
        } else {
          var V, J = [...Z(U == null ? void 0 : U.previousElementSibling), ...Z(U)];
          L = (V = J.findLast((I) => ST(x, I))) !== null && V !== void 0 ? V : null;
        }
        L && (u = L.closest('[data-slate-node="text"]'), E = L, i === "forward" ? c = 0 : (c = E.textContent.length, E.querySelectorAll("[data-slate-zero-width]").forEach((I) => {
          c -= I.textContent.length;
        })));
      }
      E && c === E.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      eo && E.getAttribute("data-slate-zero-width") === "z" && (p = E.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Na && (d = E.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (eo && !u && !r) {
      var j = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (j && ke.hasDOMNode(e, j, {
        editable: !0
      })) {
        var K = ke.toSlateNode(e, j), {
          path: te,
          offset: O
        } = q.start(e, ke.findPath(e, K));
        return j.querySelector("[data-slate-leaf]") || (O = a), {
          path: te,
          offset: O
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var P = ke.toSlateNode(e, u), H = ke.findPath(e, P);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = n0(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (n0(t)) {
        if (Na && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), h = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && h.startContainer instanceof HTMLTableRowElement) {
            let C = function(M) {
              return M.childElementCount > 0 ? C(M.children[0]) : M;
            };
            var y = d.startContainer, f = h.startContainer, g = C(y.children[d.startOffset]), x = C(f.children[h.startOffset]);
            c = 0, x.childNodes.length > 0 ? a = x.childNodes[0] : a = x, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, x instanceof HTMLElement ? l = x.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = h.endContainer, l = h.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = h.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        rF && Zce(a) || Na ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Na && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var L = ke.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!L)
      return null;
    var E = ST(a, u) || a === u && c < l, T = p ? L : ke.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: E ? "forward" : "backward"
    });
    if (!T)
      return null;
    var b = {
      anchor: L,
      focus: T
    };
    return we.isExpanded(b) && we.isForward(b) && Vo(u) && q.void(e, {
      at: b.focus,
      mode: "highest"
    }) && (b = q.unhangRange(e, b, {
      voids: !0
    })), b;
  }
};
function epe(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!q.hasPath(e, n))
    return !1;
  var o = Ue.get(e, n);
  if (!Ze.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = le.next(n);
  if (!q.hasPath(e, i))
    return !1;
  var s = Ue.get(e, i);
  return Ze.isText(s) && s.text.startsWith(r.text);
}
function pF(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function tpe(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function npe(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function dF(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), s = tpe(i, o), a = Math.min(i.length - s, o.length - s), l = npe(i, o, a), u = {
    start: n + s,
    end: r - l,
    text: o.slice(s, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function rpe(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = pF(e, t, n), s = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), a = i.slice(r, s), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return dF(e, {
    start: r,
    end: l,
    text: a
  });
}
function ope(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function r0(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!q.hasPath(e, n))
    return null;
  var o = Ue.get(e, n);
  if (!Ze.isText(o))
    return null;
  var i = q.above(e, {
    match: (a) => Ve.isElement(a) && q.isBlock(e, a),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var s = q.next(e, {
      at: n,
      match: Ze.isText
    });
    if (!s || !le.isDescendant(s[1], i[1]))
      return null;
    r -= o.text.length, o = s[0], n = s[1];
  }
  return {
    path: n,
    offset: r
  };
}
function DT(e, t) {
  var n = r0(e, t.anchor);
  if (!n)
    return null;
  if (we.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = r0(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function o0(e, t, n) {
  var r = ao.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: p
    } = c;
    return le.equals(p, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return kt.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var s = {
      path: t.path,
      offset: i.start
    }, a = kt.transform(s, n, {
      affinity: "backward"
    });
    return a ? {
      path: a.path,
      offset: a.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = kt.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && le.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function PT(e, t, n) {
  var r = o0(e, t.anchor, n);
  if (!r)
    return null;
  if (we.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = o0(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function ipe(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !le.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !le.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !le.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: le.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: le.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return le.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: le.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: le.transform(n, t)
      };
  }
  var i = le.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function TT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TT(Object(n), !0).forEach(function(r) {
      Zo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var spe = 25, ape = 200, lpe = function() {
}, upe = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function cpe(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, s = null, a = null, l = 0, u = !1, c = () => {
    var U = gs.get(t);
    if (gs.delete(t), U) {
      var {
        selection: $
      } = t, N = DT(t, U);
      N && (!$ || !we.equals(N, $)) && Se.select(t, N);
    }
  }, p = () => {
    var U = hs.get(t);
    if (hs.delete(t), !!U) {
      if (U.at) {
        var $ = kt.isPoint(U.at) ? r0(t, U.at) : DT(t, U.at);
        if (!$)
          return;
        var N = q.range(t, $);
        (!t.selection || !we.equals(t.selection, N)) && Se.select(t, $);
      }
      U.run();
    }
  }, d = () => {
    if (s && (clearTimeout(s), s = null), a && (clearTimeout(a), a = null), !T() && !E()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), E() && (o = "action");
    var U = t.selection && q.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    Bi.set(t, t.marks), lpe("flush", hs.get(t), ao.get(t));
    for (var $ = T(), N; N = (V = ao.get(t)) === null || V === void 0 ? void 0 : V[0]; ) {
      var V, J, j = qo.get(t);
      j !== void 0 && (qo.delete(t), t.marks = j), j && u === !1 && (u = null);
      var K = ope(N);
      (!t.selection || !we.equals(t.selection, K)) && Se.select(t, K), N.diff.text ? q.insertText(t, N.diff.text) : q.deleteFragment(t), ao.set(t, (J = ao.get(t)) === null || J === void 0 ? void 0 : J.filter((P) => {
        var {
          id: H
        } = P;
        return H !== N.id;
      })), epe(t, N) || ($ = !1, hs.delete(t), Bi.delete(t), o = "action", gs.delete(t), n.cancel(), r.cancel(), U == null || U.unref());
    }
    var te = U == null ? void 0 : U.unref();
    if (te && !gs.get(t) && (!t.selection || !we.equals(te, t.selection)) && Se.select(t, te), E()) {
      p();
      return;
    }
    $ && n(), n.flush(), r.flush(), c();
    var O = Bi.get(t);
    Bi.delete(t), O !== void 0 && (t.marks = O, t.onChange());
  }, h = (U) => {
    i && clearTimeout(i), i = setTimeout(() => {
      ga.set(t, !1), d();
    }, spe);
  }, y = (U) => {
    ga.set(t, !0), i && (clearTimeout(i), i = null);
  }, f = function() {
    var $ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, N = Qy.get(t);
    if (N) {
      if (T() || $) {
        N.style.display = "none";
        return;
      }
      N.style.removeProperty("display");
    }
  }, g = (U, $) => {
    var N, V = (N = ao.get(t)) !== null && N !== void 0 ? N : [];
    ao.set(t, V);
    var J = Ue.leaf(t, U), j = V.findIndex((O) => le.equals(O.path, U));
    if (j < 0) {
      var K = dF(J.text, $);
      K && V.push({
        path: U,
        diff: $,
        id: l++
      }), f();
      return;
    }
    var te = rpe(J.text, V[j].diff, $);
    if (!te) {
      V.splice(j, 1), f();
      return;
    }
    V[j] = zp(zp({}, V[j]), {}, {
      diff: te
    });
  }, x = function($) {
    var {
      at: N
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, gs.delete(t), n.cancel(), r.cancel(), E() && d(), hs.set(t, {
      at: N,
      run: $
    }), a = setTimeout(d);
  }, L = (U) => {
    var $;
    s && (clearTimeout(s), s = null);
    var {
      inputType: N
    } = U, V = null, J = U.dataTransfer || U.data || void 0;
    u !== !1 && N !== "insertText" && N !== "insertCompositionText" && (u = !1);
    var [j] = U.getTargetRanges();
    j && (V = ke.toSlateRange(t, j, {
      exactMatch: !1,
      suppressThrow: !0
    }));
    var K = ke.getWindow(t), te = K.getSelection();
    if (!V && te && (j = te, V = ke.toSlateRange(t, te, {
      exactMatch: !1,
      suppressThrow: !0
    })), V = ($ = V) !== null && $ !== void 0 ? $ : t.selection, !!V) {
      var O = !0;
      if (N.startsWith("delete")) {
        if (we.isExpanded(V)) {
          var [P, H] = we.edges(V), I = Ue.leaf(t, P.path);
          if (I.text.length === P.offset && H.offset === 0) {
            var W = q.next(t, {
              at: P.path,
              match: Ze.isText
            });
            W && le.equals(W[1], H.path) && (V = {
              anchor: H,
              focus: H
            });
          }
        }
        var X = N.endsWith("Backward") ? "backward" : "forward", [w, R] = we.edges(V), [z, _] = q.leaf(t, w.path), Y = {
          text: "",
          start: w.offset,
          end: R.offset
        }, Q = ao.get(t), A = Q == null ? void 0 : Q.find(($e) => le.equals($e.path, _)), ae = A ? [A.diff, Y] : [Y], ce = pF(z.text, ...ae);
        if (ce.length === 0 && (O = !1), we.isExpanded(V)) {
          if (O && le.equals(V.anchor.path, V.focus.path)) {
            var ue = {
              path: V.anchor.path,
              offset: w.offset
            }, de = q.range(t, ue, ue);
            return M(de), g(V.anchor.path, {
              text: "",
              end: R.offset,
              start: w.offset
            });
          }
          return x(() => q.deleteFragment(t, {
            direction: X
          }), {
            at: V
          });
        }
      }
      switch (N) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag":
          return x(() => q.deleteFragment(t), {
            at: V
          });
        case "deleteContent":
        case "deleteContentForward": {
          var {
            anchor: be
          } = V;
          if (O && we.isCollapsed(V)) {
            var ve = Ue.leaf(t, be.path);
            if (be.offset < ve.text.length)
              return g(be.path, {
                text: "",
                start: be.offset,
                end: be.offset + 1
              });
          }
          return x(() => q.deleteForward(t), {
            at: V
          });
        }
        case "deleteContentBackward": {
          var ge, {
            anchor: se
          } = V, xe = n0(j) ? j.isCollapsed : !!((ge = j) !== null && ge !== void 0 && ge.collapsed);
          return O && xe && we.isCollapsed(V) && se.offset > 0 ? g(se.path, {
            text: "",
            start: se.offset - 1,
            end: se.offset
          }) : x(() => q.deleteBackward(t), {
            at: V
          });
        }
        case "deleteEntireSoftLine":
          return x(() => {
            q.deleteBackward(t, {
              unit: "line"
            }), q.deleteForward(t, {
              unit: "line"
            });
          }, {
            at: V
          });
        case "deleteHardLineBackward":
          return x(() => q.deleteBackward(t, {
            unit: "block"
          }), {
            at: V
          });
        case "deleteSoftLineBackward":
          return x(() => q.deleteBackward(t, {
            unit: "line"
          }), {
            at: V
          });
        case "deleteHardLineForward":
          return x(() => q.deleteForward(t, {
            unit: "block"
          }), {
            at: V
          });
        case "deleteSoftLineForward":
          return x(() => q.deleteForward(t, {
            unit: "line"
          }), {
            at: V
          });
        case "deleteWordBackward":
          return x(() => q.deleteBackward(t, {
            unit: "word"
          }), {
            at: V
          });
        case "deleteWordForward":
          return x(() => q.deleteForward(t, {
            unit: "word"
          }), {
            at: V
          });
        case "insertLineBreak":
          return x(() => q.insertSoftBreak(t), {
            at: V
          });
        case "insertParagraph":
          return x(() => q.insertBreak(t), {
            at: V
          });
        case "insertCompositionText":
        case "deleteCompositionText":
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          if (upe(J))
            return x(() => ke.insertData(t, J), {
              at: V
            });
          var ne = J ?? "";
          if (qo.get(t) && (ne = ne.replace("\uFEFF", "")), N === "insertText" && /.*\n.*\n$/.test(ne) && (ne = ne.slice(0, -1)), ne.includes(`
`))
            return x(() => {
              var $e = ne.split(`
`);
              $e.forEach((he, Ge) => {
                he && q.insertText(t, he), Ge !== $e.length - 1 && q.insertSoftBreak(t);
              });
            }, {
              at: V
            });
          if (le.equals(V.anchor.path, V.focus.path)) {
            var [Me, ee] = we.edges(V), Ce = {
              start: Me.offset,
              end: ee.offset,
              text: ne
            };
            if (ne && u && N === "insertCompositionText") {
              var Be = u.start + u.text.search(/\S|$/), _e = Ce.start + Ce.text.search(/\S|$/);
              _e === Be + 1 && Ce.end === u.start + u.text.length ? (Ce.start -= 1, u = null, D()) : u = !1;
            } else N === "insertText" ? u === null ? u = Ce : u && we.isCollapsed(V) && u.end + u.text.length === Me.offset ? u = zp(zp({}, u), {}, {
              text: u.text + ne
            }) : u = !1 : u = !1;
            if (O) {
              g(Me.path, Ce);
              return;
            }
          }
          return x(() => q.insertText(t, ne), {
            at: V
          });
        }
      }
    }
  }, E = () => !!hs.get(t), T = () => {
    var U;
    return !!((U = ao.get(t)) !== null && U !== void 0 && U.length);
  }, b = () => E() || T(), C = () => o, M = (U) => {
    gs.set(t, U), s && (clearTimeout(s), s = null);
    var {
      selection: $
    } = t;
    if (U) {
      var N = !$ || !le.equals($.anchor.path, U.anchor.path), V = !$ || !le.equals($.anchor.path.slice(0, -1), U.anchor.path.slice(0, -1));
      (N && u || V) && (u = !1), (N || T()) && (s = setTimeout(d, ape));
    }
  }, S = () => {
    (E() || !T()) && d();
  }, F = (U) => {
    T() || (f(!0), setTimeout(f));
  }, D = () => {
    E() || (a = setTimeout(d));
  }, Z = (U) => {
    if (!(T() || E()) && U.some((N) => J1(t, N, U))) {
      var $;
      ($ = iF.get(t)) === null || $ === void 0 || $();
    }
  };
  return {
    flush: d,
    scheduleFlush: D,
    hasPendingDiffs: T,
    hasPendingAction: E,
    hasPendingChanges: b,
    isFlushing: C,
    handleUserSelect: M,
    handleCompositionEnd: h,
    handleCompositionStart: y,
    handleDOMBeforeInput: L,
    handleKeyDown: F,
    handleDomMutations: Z,
    handleInput: S
  };
}
function ppe() {
  var e = it(!1);
  return m(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var Ru = id ? x2 : m;
function dpe(e, t, n) {
  var [r] = k(() => new MutationObserver(t));
  Ru(() => {
    r.takeRecords();
  }), m(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var fpe = ["node"];
function _T(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hpe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _T(Object(n), !0).forEach(function(r) {
      Zo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _T(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gpe = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, mpe = eo ? (e) => {
  var {
    node: t
  } = e, n = Va(e, fpe);
  if (!eo)
    return null;
  var r = Rs(), o = ppe(), [i] = k(() => cpe(hpe({
    editor: r
  }, n)));
  return dpe(t, i.handleDomMutations, gpe), X1.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, vpe = ["anchor", "focus"], ype = ["anchor", "focus"], bpe = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), fF = (e, t) => {
  var n = Va(e, vpe), r = Va(t, ype);
  return e[Za] === t[Za] && bpe(n, r);
}, wpe = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!we.equals(r, o) || !fF(r, o))
      return !1;
  }
  return !0;
}, Cpe = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !fF(r, o))
      return !1;
  }
  return !0;
};
function AT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xpe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AT(Object(n), !0).forEach(function(r) {
      Zo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Epe = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = Rs(), s = ke.findPath(i, o), a = le.parent(s), l = !!n[sF];
  return i.isVoid(r) ? /* @__PURE__ */ Ae.createElement(rv, {
    length: Ue.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && q.string(i, a) === "" ? /* @__PURE__ */ Ae.createElement(rv, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ Ae.createElement(rv, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ Ae.createElement(BT, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ Ae.createElement(BT, {
    text: n.text
  });
}, BT = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = it(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = k(o);
  return Ru(() => {
    var s = o();
    r.current && r.current.textContent !== s && (r.current.textContent = s);
  }), /* @__PURE__ */ Ae.createElement(Lpe, {
    ref: r
  }, i);
}, Lpe = /* @__PURE__ */ Ie(/* @__PURE__ */ Ba((e, t) => /* @__PURE__ */ Ae.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), rv = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ Ae.createElement("span", xpe({}, o), !(eo || nF) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ Ae.createElement("br", null) : null);
};
function IT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IT(Object(n), !0).forEach(function(r) {
      Zo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kpe = eo ? 300 : 0;
function Ope(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function jT(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var Mpe = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: s = (L) => /* @__PURE__ */ Ae.createElement(Dpe, hF({}, L))
  } = e, a = Rs(), l = it(null), u = it(null), [c, p] = k(!1), d = it(null), h = hn((L) => {
    if (Ope(l, L == null), L == null) {
      var E;
      Qy.delete(a), (E = t.onPlaceholderResize) === null || E === void 0 || E.call(t, null);
    } else {
      if (Qy.set(a, L), !l.current) {
        var T = window.ResizeObserver || _ce;
        l.current = new T(() => {
          var b;
          (b = t.onPlaceholderResize) === null || b === void 0 || b.call(t, L);
        });
      }
      l.current.observe(L), u.current = L;
    }
  }, [u, t, a]), y = /* @__PURE__ */ Ae.createElement(Epe, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), f = !!t[Za];
  if (m(() => (f ? d.current || (d.current = setTimeout(() => {
    p(!0), d.current = null;
  }, kpe)) : (jT(d), p(!1)), () => jT(d)), [f, p]), f && c) {
    var g = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: ra ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: h
      }
    };
    y = /* @__PURE__ */ Ae.createElement(Ae.Fragment, null, i(g), y);
  }
  var x = {
    "data-slate-leaf": !0
  };
  return s({
    attributes: x,
    children: y,
    leaf: t,
    text: r
  });
}, Spe = /* @__PURE__ */ Ae.memo(Mpe, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && Ze.equals(t.leaf, e.leaf) && t.leaf[Za] === e.leaf[Za]), Dpe = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ Ae.createElement("span", hF({}, t), n);
}, Ppe = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: s
  } = e, a = Rs(), l = it(null), u = Ze.decorations(s, t), c = ke.findKey(a, s), p = [], d = 0; d < u.length; d++) {
    var h = u[d];
    p.push(/* @__PURE__ */ Ae.createElement(Spe, {
      isLast: n && d === u.length - 1,
      key: "".concat(c.id, "-").concat(d),
      renderPlaceholder: o,
      leaf: h,
      text: s,
      parent: r,
      renderLeaf: i
    }));
  }
  var y = hn((f) => {
    var g = Nh.get(a);
    f ? (g == null || g.set(c, f), ya.set(s, f), ju.set(f, s)) : (g == null || g.delete(c), ya.delete(s), l.current && ju.delete(l.current)), l.current = f;
  }, [l, a, c, s]);
  return /* @__PURE__ */ Ae.createElement("span", {
    "data-slate-node": "text",
    ref: y
  }, p);
}, gF = /* @__PURE__ */ Ae.memo(Ppe, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && Cpe(t.decorations, e.decorations));
function RT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function i0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RT(Object(n), !0).forEach(function(r) {
      Zo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Tpe = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (L) => /* @__PURE__ */ Ae.createElement(Ape, i0({}, L)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  } = e, a = Rs(), l = jpe(), u = a.isInline(n), c = ke.findKey(a, n), p = hn((L) => {
    var E = Nh.get(a);
    L ? (E == null || E.set(c, L), ya.set(n, L), ju.set(L, n)) : (E == null || E.delete(c), ya.delete(n));
  }, [a, c, n]), d = vF({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  }), h = {
    "data-slate-node": "element",
    ref: p
  };
  if (u && (h["data-slate-inline"] = !0), !u && q.hasInlines(a, n)) {
    var y = Ue.string(n), f = HN(y);
    f === "rtl" && (h.dir = f);
  }
  if (q.isVoid(a, n)) {
    h["data-slate-void"] = !0, !l && u && (h.contentEditable = !1);
    var g = u ? "span" : "div", [[x]] = Ue.texts(n);
    d = /* @__PURE__ */ Ae.createElement(g, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ Ae.createElement(gF, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: x
    })), q1.set(x, 0), G1.set(x, n);
  }
  return r({
    attributes: h,
    children: d,
    element: n
  });
}, _pe = /* @__PURE__ */ Ae.memo(Tpe, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && wpe(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && we.equals(e.selection, t.selection))), Ape = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = Rs(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ Ae.createElement(i, i0(i0({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, mF = /* @__PURE__ */ qe(() => []), Bpe = () => Te(mF), Ipe = /* @__PURE__ */ qe(!1), vF = (e) => {
  for (var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  } = e, a = Bpe(), l = Rs(), u = ke.findPath(l, n), c = [], p = Ve.isElement(n) && !l.isInline(n) && q.hasInlines(l, n), d = 0; d < n.children.length; d++) {
    var h = u.concat(d), y = n.children[d], f = ke.findKey(l, y), g = q.range(l, h), x = s && we.intersection(g, s), L = a([y, h]);
    for (var E of t) {
      var T = we.intersection(E, g);
      T && L.push(T);
    }
    Ve.isElement(y) ? c.push(/* @__PURE__ */ Ae.createElement(Ipe.Provider, {
      key: "provider-".concat(f.id),
      value: !!x
    }, /* @__PURE__ */ Ae.createElement(_pe, {
      decorations: L,
      element: y,
      key: f.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: x
    }))) : c.push(/* @__PURE__ */ Ae.createElement(gF, {
      decorations: L,
      key: f.id,
      isLast: p && d === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: y
    })), q1.set(y, d), G1.set(y, n);
  }
  return c;
}, yF = /* @__PURE__ */ qe(!1), jpe = () => Te(yF), bF = /* @__PURE__ */ qe(null), K1 = () => {
  var e = Te(bF);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function Rpe() {
  var e = Rs(), t = it(!1), n = it(0), r = hn(() => {
    if (!t.current) {
      t.current = !0;
      var o = ke.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return m(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var Npe = 3, Fpe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, zpe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Upe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, cr = (e) => {
  var t = Fpe[e], n = zpe[e], r = Upe[e], o = t && qm(t), i = n && qm(n), s = r && qm(r);
  return (a) => !!(o && o(a) || MT && i && i(a) || !MT && s && s(a));
}, dr = {
  isBold: cr("bold"),
  isCompose: cr("compose"),
  isMoveBackward: cr("moveBackward"),
  isMoveForward: cr("moveForward"),
  isDeleteBackward: cr("deleteBackward"),
  isDeleteForward: cr("deleteForward"),
  isDeleteLineBackward: cr("deleteLineBackward"),
  isDeleteLineForward: cr("deleteLineForward"),
  isDeleteWordBackward: cr("deleteWordBackward"),
  isDeleteWordForward: cr("deleteWordForward"),
  isExtendBackward: cr("extendBackward"),
  isExtendForward: cr("extendForward"),
  isExtendLineBackward: cr("extendLineBackward"),
  isExtendLineForward: cr("extendLineForward"),
  isItalic: cr("italic"),
  isMoveLineBackward: cr("moveLineBackward"),
  isMoveLineForward: cr("moveLineForward"),
  isMoveWordBackward: cr("moveWordBackward"),
  isMoveWordForward: cr("moveWordForward"),
  isRedo: cr("redo"),
  isSoftBreak: cr("insertSoftBreak"),
  isSplitBlock: cr("splitBlock"),
  isTransposeCharacter: cr("transposeCharacter"),
  isUndo: cr("undo")
}, $pe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => J1(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, Wpe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class wF extends Nu {
  constructor() {
    super(...arguments), Zo(this, "context", null), Zo(this, "manager", null), Zo(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, Wpe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = $pe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Zo(wF, "contextType", Z1);
var Hpe = eo ? wF : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ Ae.createElement(Ae.Fragment, null, t);
}, Vpe = /* @__PURE__ */ qe(!1), Zpe = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], qpe = ["text"];
function NT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ei(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NT(Object(n), !0).forEach(function(r) {
      Zo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Gpe = (e) => /* @__PURE__ */ Ae.createElement(Ae.Fragment, null, vF(e)), Xpe = /* @__PURE__ */ Ba((e, t) => {
  var n = hn((w) => /* @__PURE__ */ Ae.createElement(Ype, ei({}, w)), []), {
    autoFocus: r,
    decorate: o = Jpe,
    onDOMBeforeInput: i,
    placeholder: s,
    readOnly: a = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: p = Kpe,
    style: d = {},
    as: h = "div",
    disableDefaultStyles: y = !1
  } = e, f = Va(e, Zpe), g = K1(), [x, L] = k(!1), E = it(null), T = it([]), [b, C] = k(), M = it(!1), {
    onUserInput: S,
    receivedUserInput: F
  } = Rpe(), [, D] = C2((w) => w + 1, 0);
  iF.set(g, D), e0.set(g, a);
  var Z = Zn(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  m(() => {
    E.current && r && E.current.focus();
  }, [r]);
  var U = it(), $ = Zn(() => lce(() => {
    var w = ke.toDOMNode(g, g), R = w.getRootNode();
    if (!M.current && ra && R instanceof ShadowRoot) {
      M.current = !0;
      var z = Yce();
      z ? document.execCommand("indent") : Se.deselect(g), M.current = !1;
      return;
    }
    var _ = U.current;
    if ((eo || !ke.isComposing(g)) && (!Z.isUpdatingSelection || _ != null && _.isFlushing()) && !Z.isDraggingInternally) {
      var Y = ke.findDocumentOrShadowRoot(g), {
        activeElement: Q
      } = Y, A = ke.toDOMNode(g, g), ae = au(Y);
      if (Q === A ? (Z.latestElement = Q, xs.set(g, !0)) : xs.delete(g), !ae)
        return Se.deselect(g);
      var {
        anchorNode: ce,
        focusNode: ue
      } = ae, de = ke.hasEditableTarget(g, ce) || ke.isTargetInsideNonReadonlyVoid(g, ce), be = ke.hasTarget(g, ue);
      if (de && be) {
        var ve = ke.toSlateRange(g, ae, {
          exactMatch: !1,
          suppressThrow: !0
        });
        ve && (!ke.isComposing(g) && !(_ != null && _.hasPendingChanges()) && !(_ != null && _.isFlushing()) ? Se.select(g, ve) : _ == null || _.handleUserSelect(ve));
      }
      a && (!de || !be) && Se.deselect(g);
    }
  }, 100), [g, a, Z]), N = Zn(() => nce($, 0), [$]);
  U.current = mpe({
    node: E,
    onDOMSelectionChange: $,
    scheduleOnDOMSelectionChange: N
  }), Ru(() => {
    var w, R, z;
    E.current && (z = Y1(E.current)) ? (oF.set(g, z), sd.set(g, E.current), ya.set(g, E.current), ju.set(E.current, g)) : ya.delete(g);
    var {
      selection: _
    } = g, Y = ke.findDocumentOrShadowRoot(g), Q = au(Y);
    if (!(!Q || !ke.isFocused(g) || (w = U.current) !== null && w !== void 0 && w.hasPendingAction())) {
      var A = (de) => {
        var be = Q.type !== "None";
        if (!(!_ && !be)) {
          var ve = Q.focusNode, ge;
          if (Na && Q.rangeCount > 1) {
            var se = Q.getRangeAt(0), xe = Q.getRangeAt(Q.rangeCount - 1);
            se.startContainer === ve ? ge = xe.endContainer : ge = se.startContainer;
          } else
            ge = Q.anchorNode;
          var ne = sd.get(g), Me = !1;
          if (ne.contains(ge) && ne.contains(ve) && (Me = !0), be && Me && _ && !de) {
            var ee = ke.toSlateRange(g, Q, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (ee && we.equals(ee, _)) {
              var Ce;
              if (!Z.hasMarkPlaceholder || (Ce = ge) !== null && Ce !== void 0 && (Ce = Ce.parentElement) !== null && Ce !== void 0 && Ce.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (_ && !ke.hasRange(g, _)) {
            g.selection = ke.toSlateRange(g, Q, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          Z.isUpdatingSelection = !0;
          var Be = _ && ke.toDOMRange(g, _);
          return Be ? (ke.isComposing(g) && !eo ? Q.collapseToEnd() : we.isBackward(_) ? Q.setBaseAndExtent(Be.endContainer, Be.endOffset, Be.startContainer, Be.startOffset) : Q.setBaseAndExtent(Be.startContainer, Be.startOffset, Be.endContainer, Be.endOffset), p(g, Be)) : Q.removeAllRanges(), Be;
        }
      };
      Q.rangeCount <= 1 && A();
      var ae = ((R = U.current) === null || R === void 0 ? void 0 : R.isFlushing()) === "action";
      if (!eo || !ae) {
        setTimeout(() => {
          Z.isUpdatingSelection = !1;
        });
        return;
      }
      var ce = null, ue = requestAnimationFrame(() => {
        if (ae) {
          var de = (be) => {
            try {
              var ve = ke.toDOMNode(g, g);
              ve.focus(), A(be);
            } catch {
            }
          };
          de(), ce = setTimeout(() => {
            de(!0), Z.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(ue), ce && clearTimeout(ce);
      };
    }
  });
  var V = hn((w) => {
    var R = ke.toDOMNode(g, g), z = R.getRootNode();
    if (M != null && M.current && ra && z instanceof ShadowRoot) {
      var _ = w.getTargetRanges(), Y = _[0], Q = new window.Range();
      Q.setStart(Y.startContainer, Y.startOffset), Q.setEnd(Y.endContainer, Y.endOffset);
      var A = ke.toSlateRange(g, Q, {
        exactMatch: !1,
        suppressThrow: !1
      });
      Se.select(g, A), w.preventDefault(), w.stopImmediatePropagation();
      return;
    }
    if (S(), !a && ke.hasEditableTarget(g, w.target) && !Qpe(w, i)) {
      var ae;
      if (U.current)
        return U.current.handleDOMBeforeInput(w);
      N.flush(), $.flush();
      var {
        selection: ce
      } = g, {
        inputType: ue
      } = w, de = w.dataTransfer || w.data || void 0, be = ue === "insertCompositionText" || ue === "deleteCompositionText";
      if (be && ke.isComposing(g))
        return;
      var ve = !1;
      if (ue === "insertText" && ce && we.isCollapsed(ce) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      w.data && w.data.length === 1 && /[a-z ]/i.test(w.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      ce.anchor.offset !== 0) {
        var ge, se;
        ve = !0, g.marks && (ve = !1);
        var {
          anchor: xe
        } = ce, [ne, Me] = ke.toDOMPoint(g, xe), ee = (ge = ne.parentElement) === null || ge === void 0 ? void 0 : ge.closest("a"), Ce = ke.getWindow(g);
        if (ve && ee && ke.hasDOMNode(g, ee)) {
          var Be, _e = Ce == null ? void 0 : Ce.document.createTreeWalker(ee, NodeFilter.SHOW_TEXT).lastChild();
          _e === ne && ((Be = _e.textContent) === null || Be === void 0 ? void 0 : Be.length) === Me && (ve = !1);
        }
        if (ve && ne.parentElement && (Ce == null || (se = Ce.getComputedStyle(ne.parentElement)) === null || se === void 0 ? void 0 : se.whiteSpace) === "pre") {
          var $e = q.above(g, {
            at: xe.path,
            match: (st) => Ve.isElement(st) && q.isBlock(g, st)
          });
          $e && Ue.string($e[0]).includes("	") && (ve = !1);
        }
      }
      if (!ue.startsWith("delete") || ue.startsWith("deleteBy")) {
        var [he] = w.getTargetRanges();
        if (he) {
          var Ge = ke.toSlateRange(g, he, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!ce || !we.equals(ce, Ge)) {
            ve = !1;
            var We = !be && g.selection && q.rangeRef(g, g.selection);
            Se.select(g, Ge), We && su.set(g, We);
          }
        }
      }
      if (be)
        return;
      if (ve || w.preventDefault(), ce && we.isExpanded(ce) && ue.startsWith("delete")) {
        var Ut = ue.endsWith("Backward") ? "backward" : "forward";
        q.deleteFragment(g, {
          direction: Ut
        });
        return;
      }
      switch (ue) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          q.deleteFragment(g);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          q.deleteForward(g);
          break;
        }
        case "deleteContentBackward": {
          q.deleteBackward(g);
          break;
        }
        case "deleteEntireSoftLine": {
          q.deleteBackward(g, {
            unit: "line"
          }), q.deleteForward(g, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          q.deleteBackward(g, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          q.deleteBackward(g, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          q.deleteForward(g, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          q.deleteForward(g, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          q.deleteBackward(g, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          q.deleteForward(g, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          q.insertSoftBreak(g);
          break;
        case "insertParagraph": {
          q.insertBreak(g);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          ue === "insertFromComposition" && ke.isComposing(g) && (L(!1), ga.set(g, !1)), (de == null ? void 0 : de.constructor.name) === "DataTransfer" ? ke.insertData(g, de) : typeof de == "string" && (ve ? T.current.push(() => q.insertText(g, de)) : q.insertText(g, de));
          break;
        }
      }
      var ot = (ae = su.get(g)) === null || ae === void 0 ? void 0 : ae.unref();
      su.delete(g), ot && (!g.selection || !we.equals(g.selection, ot)) && Se.select(g, ot);
    }
  }, [g, $, S, i, a, N]), J = hn((w) => {
    w == null ? ($.cancel(), N.cancel(), sd.delete(g), ya.delete(g), E.current && ts && E.current.removeEventListener("beforeinput", V)) : ts && w.addEventListener("beforeinput", V), E.current = w, typeof t == "function" ? t(w) : t && (t.current = w);
  }, [$, N, g, V, t]);
  Ru(() => {
    var w = ke.getWindow(g);
    w.document.addEventListener("selectionchange", N);
    var R = () => {
      Z.isDraggingInternally = !1;
    };
    return w.document.addEventListener("dragend", R), w.document.addEventListener("drop", R), () => {
      w.document.removeEventListener("selectionchange", N), w.document.removeEventListener("dragend", R), w.document.removeEventListener("drop", R);
    };
  }, [N, Z]);
  var j = o([g, []]), K = s && g.children.length === 1 && Array.from(Ue.texts(g)).length === 1 && Ue.string(g) === "" && !x, te = hn((w) => {
    if (w && K) {
      var R;
      C((R = w.getBoundingClientRect()) === null || R === void 0 ? void 0 : R.height);
    } else
      C(void 0);
  }, [K]);
  if (K) {
    var O = q.start(g, []);
    j.push({
      [Za]: !0,
      placeholder: s,
      onPlaceholderResize: te,
      anchor: O,
      focus: O
    });
  }
  var {
    marks: P
  } = g;
  if (Z.hasMarkPlaceholder = !1, g.selection && we.isCollapsed(g.selection) && P) {
    var {
      anchor: H
    } = g.selection, I = Ue.leaf(g, H.path), W = Va(I, qpe);
    if (!Ze.equals(I, P, {
      loose: !0
    })) {
      Z.hasMarkPlaceholder = !0;
      var X = Object.fromEntries(Object.keys(W).map((w) => [w, null]));
      j.push(ei(ei(ei({
        [sF]: !0
      }, X), P), {}, {
        anchor: H,
        focus: H
      }));
    }
  }
  return m(() => {
    setTimeout(() => {
      var {
        selection: w
      } = g;
      if (w) {
        var {
          anchor: R
        } = w, z = Ue.leaf(g, R.path);
        if (P && !Ze.equals(z, P, {
          loose: !0
        })) {
          qo.set(g, P);
          return;
        }
      }
      qo.delete(g);
    });
  }), /* @__PURE__ */ Ae.createElement(yF.Provider, {
    value: a
  }, /* @__PURE__ */ Ae.createElement(Vpe.Provider, {
    value: x
  }, /* @__PURE__ */ Ae.createElement(mF.Provider, {
    value: o
  }, /* @__PURE__ */ Ae.createElement(Hpe, {
    node: E,
    receivedUserInput: F
  }, /* @__PURE__ */ Ae.createElement(h, ei(ei({
    role: a ? void 0 : "textbox",
    "aria-multiline": a ? void 0 : !0
  }, f), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: ts || !id ? f.spellCheck : !1,
    autoCorrect: ts || !id ? f.autoCorrect : "false",
    autoCapitalize: ts || !id ? f.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !a,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: J,
    style: ei(ei({}, y ? {} : ei({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, b ? {
      minHeight: b
    } : {})), d),
    onBeforeInput: hn((w) => {
      if (!ts && !a && !Qr(w, f.onBeforeInput) && ke.hasSelectableTarget(g, w.target) && (w.preventDefault(), !ke.isComposing(g))) {
        var R = w.data;
        q.insertText(g, R);
      }
    }, [f.onBeforeInput, g, a]),
    onInput: hn((w) => {
      if (!Qr(w, f.onInput)) {
        if (U.current) {
          U.current.handleInput();
          return;
        }
        for (var R of T.current)
          R();
        T.current = [];
      }
    }, [f.onInput]),
    onBlur: hn((w) => {
      if (!(a || Z.isUpdatingSelection || !ke.hasSelectableTarget(g, w.target) || Qr(w, f.onBlur))) {
        var R = ke.findDocumentOrShadowRoot(g);
        if (Z.latestElement !== R.activeElement) {
          var {
            relatedTarget: z
          } = w, _ = ke.toDOMNode(g, g);
          if (z !== _ && !(Vo(z) && z.hasAttribute("data-slate-spacer"))) {
            if (z != null && Ls(z) && ke.hasDOMNode(g, z)) {
              var Y = ke.toSlateNode(g, z);
              if (Ve.isElement(Y) && !g.isVoid(Y))
                return;
            }
            if (ra) {
              var Q = au(R);
              Q == null || Q.removeAllRanges();
            }
            xs.delete(g);
          }
        }
      }
    }, [a, Z.isUpdatingSelection, Z.latestElement, g, f.onBlur]),
    onClick: hn((w) => {
      if (ke.hasTarget(g, w.target) && !Qr(w, f.onClick) && Ls(w.target)) {
        var R = ke.toSlateNode(g, w.target), z = ke.findPath(g, R);
        if (!q.hasPath(g, z) || Ue.get(g, z) !== R)
          return;
        if (w.detail === Npe && z.length >= 1) {
          var _ = z;
          if (!(Ve.isElement(R) && q.isBlock(g, R))) {
            var Y, Q = q.above(g, {
              match: (ve) => Ve.isElement(ve) && q.isBlock(g, ve),
              at: z
            });
            _ = (Y = Q == null ? void 0 : Q[1]) !== null && Y !== void 0 ? Y : z.slice(0, 1);
          }
          var A = q.range(g, _);
          Se.select(g, A);
          return;
        }
        if (a)
          return;
        var ae = q.start(g, z), ce = q.end(g, z), ue = q.void(g, {
          at: ae
        }), de = q.void(g, {
          at: ce
        });
        if (ue && de && le.equals(ue[1], de[1])) {
          var be = q.range(g, ae);
          Se.select(g, be);
        }
      }
    }, [g, f.onClick, a]),
    onCompositionEnd: hn((w) => {
      if (ke.hasSelectableTarget(g, w.target)) {
        var R;
        if (ke.isComposing(g) && Promise.resolve().then(() => {
          L(!1), ga.set(g, !1);
        }), (R = U.current) === null || R === void 0 || R.handleCompositionEnd(w), Qr(w, f.onCompositionEnd) || eo)
          return;
        if (!ra && !Fce && !nF && !Uce && !zce && w.data) {
          var z = qo.get(g);
          qo.delete(g), z !== void 0 && (Bi.set(g, g.marks), g.marks = z), q.insertText(g, w.data);
          var _ = Bi.get(g);
          Bi.delete(g), _ !== void 0 && (g.marks = _);
        }
      }
    }, [f.onCompositionEnd, g]),
    onCompositionUpdate: hn((w) => {
      ke.hasSelectableTarget(g, w.target) && !Qr(w, f.onCompositionUpdate) && (ke.isComposing(g) || (L(!0), ga.set(g, !0)));
    }, [f.onCompositionUpdate, g]),
    onCompositionStart: hn((w) => {
      if (ke.hasSelectableTarget(g, w.target)) {
        var R;
        if ((R = U.current) === null || R === void 0 || R.handleCompositionStart(w), Qr(w, f.onCompositionStart) || eo)
          return;
        L(!0);
        var {
          selection: z
        } = g;
        if (z && we.isExpanded(z)) {
          q.deleteFragment(g);
          return;
        }
      }
    }, [f.onCompositionStart, g]),
    onCopy: hn((w) => {
      ke.hasSelectableTarget(g, w.target) && !Qr(w, f.onCopy) && !FT(w) && (w.preventDefault(), ke.setFragmentData(g, w.clipboardData, "copy"));
    }, [f.onCopy, g]),
    onCut: hn((w) => {
      if (!a && ke.hasSelectableTarget(g, w.target) && !Qr(w, f.onCut) && !FT(w)) {
        w.preventDefault(), ke.setFragmentData(g, w.clipboardData, "cut");
        var {
          selection: R
        } = g;
        if (R)
          if (we.isExpanded(R))
            q.deleteFragment(g);
          else {
            var z = Ue.parent(g, R.anchor.path);
            q.isVoid(g, z) && Se.delete(g);
          }
      }
    }, [a, g, f.onCut]),
    onDragOver: hn((w) => {
      if (ke.hasTarget(g, w.target) && !Qr(w, f.onDragOver)) {
        var R = ke.toSlateNode(g, w.target);
        Ve.isElement(R) && q.isVoid(g, R) && w.preventDefault();
      }
    }, [f.onDragOver, g]),
    onDragStart: hn((w) => {
      if (!a && ke.hasTarget(g, w.target) && !Qr(w, f.onDragStart)) {
        var R = ke.toSlateNode(g, w.target), z = ke.findPath(g, R), _ = Ve.isElement(R) && q.isVoid(g, R) || q.void(g, {
          at: z,
          voids: !0
        });
        if (_) {
          var Y = q.range(g, z);
          Se.select(g, Y);
        }
        Z.isDraggingInternally = !0, ke.setFragmentData(g, w.dataTransfer, "drag");
      }
    }, [a, g, f.onDragStart, Z]),
    onDrop: hn((w) => {
      if (!a && ke.hasTarget(g, w.target) && !Qr(w, f.onDrop)) {
        w.preventDefault();
        var R = g.selection, z = ke.findEventRange(g, w), _ = w.dataTransfer;
        Se.select(g, z), Z.isDraggingInternally && R && !we.equals(R, z) && !q.void(g, {
          at: z,
          voids: !0
        }) && Se.delete(g, {
          at: R
        }), ke.insertData(g, _), ke.isFocused(g) || ke.focus(g);
      }
    }, [a, g, f.onDrop, Z]),
    onDragEnd: hn((w) => {
      !a && Z.isDraggingInternally && f.onDragEnd && ke.hasTarget(g, w.target) && f.onDragEnd(w);
    }, [a, Z, f, g]),
    onFocus: hn((w) => {
      if (!a && !Z.isUpdatingSelection && ke.hasEditableTarget(g, w.target) && !Qr(w, f.onFocus)) {
        var R = ke.toDOMNode(g, g), z = ke.findDocumentOrShadowRoot(g);
        if (Z.latestElement = z.activeElement, Na && w.target !== R) {
          R.focus();
          return;
        }
        xs.set(g, !0);
      }
    }, [a, Z, g, f.onFocus]),
    onKeyDown: hn((w) => {
      if (!a && ke.hasEditableTarget(g, w.target)) {
        var R;
        (R = U.current) === null || R === void 0 || R.handleKeyDown(w);
        var {
          nativeEvent: z
        } = w;
        if (ke.isComposing(g) && z.isComposing === !1 && (ga.set(g, !1), L(!1)), Qr(w, f.onKeyDown) || ke.isComposing(g))
          return;
        var {
          selection: _
        } = g, Y = g.children[_ !== null ? _.focus.path[0] : 0], Q = HN(Ue.string(Y)) === "rtl";
        if (dr.isRedo(z)) {
          w.preventDefault();
          var A = g;
          typeof A.redo == "function" && A.redo();
          return;
        }
        if (dr.isUndo(z)) {
          w.preventDefault();
          var ae = g;
          typeof ae.undo == "function" && ae.undo();
          return;
        }
        if (dr.isMoveLineBackward(z)) {
          w.preventDefault(), Se.move(g, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (dr.isMoveLineForward(z)) {
          w.preventDefault(), Se.move(g, {
            unit: "line"
          });
          return;
        }
        if (dr.isExtendLineBackward(z)) {
          w.preventDefault(), Se.move(g, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (dr.isExtendLineForward(z)) {
          w.preventDefault(), Se.move(g, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (dr.isMoveBackward(z)) {
          w.preventDefault(), _ && we.isCollapsed(_) ? Se.move(g, {
            reverse: !Q
          }) : Se.collapse(g, {
            edge: Q ? "end" : "start"
          });
          return;
        }
        if (dr.isMoveForward(z)) {
          w.preventDefault(), _ && we.isCollapsed(_) ? Se.move(g, {
            reverse: Q
          }) : Se.collapse(g, {
            edge: Q ? "start" : "end"
          });
          return;
        }
        if (dr.isMoveWordBackward(z)) {
          w.preventDefault(), _ && we.isExpanded(_) && Se.collapse(g, {
            edge: "focus"
          }), Se.move(g, {
            unit: "word",
            reverse: !Q
          });
          return;
        }
        if (dr.isMoveWordForward(z)) {
          w.preventDefault(), _ && we.isExpanded(_) && Se.collapse(g, {
            edge: "focus"
          }), Se.move(g, {
            unit: "word",
            reverse: Q
          });
          return;
        }
        if (ts) {
          if ((rF || ra) && _ && (dr.isDeleteBackward(z) || dr.isDeleteForward(z)) && we.isCollapsed(_)) {
            var ce = Ue.parent(g, _.anchor.path);
            if (Ve.isElement(ce) && q.isVoid(g, ce) && (q.isInline(g, ce) || q.isBlock(g, ce))) {
              w.preventDefault(), q.deleteBackward(g, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (dr.isBold(z) || dr.isItalic(z) || dr.isTransposeCharacter(z)) {
            w.preventDefault();
            return;
          }
          if (dr.isSoftBreak(z)) {
            w.preventDefault(), q.insertSoftBreak(g);
            return;
          }
          if (dr.isSplitBlock(z)) {
            w.preventDefault(), q.insertBreak(g);
            return;
          }
          if (dr.isDeleteBackward(z)) {
            w.preventDefault(), _ && we.isExpanded(_) ? q.deleteFragment(g, {
              direction: "backward"
            }) : q.deleteBackward(g);
            return;
          }
          if (dr.isDeleteForward(z)) {
            w.preventDefault(), _ && we.isExpanded(_) ? q.deleteFragment(g, {
              direction: "forward"
            }) : q.deleteForward(g);
            return;
          }
          if (dr.isDeleteLineBackward(z)) {
            w.preventDefault(), _ && we.isExpanded(_) ? q.deleteFragment(g, {
              direction: "backward"
            }) : q.deleteBackward(g, {
              unit: "line"
            });
            return;
          }
          if (dr.isDeleteLineForward(z)) {
            w.preventDefault(), _ && we.isExpanded(_) ? q.deleteFragment(g, {
              direction: "forward"
            }) : q.deleteForward(g, {
              unit: "line"
            });
            return;
          }
          if (dr.isDeleteWordBackward(z)) {
            w.preventDefault(), _ && we.isExpanded(_) ? q.deleteFragment(g, {
              direction: "backward"
            }) : q.deleteBackward(g, {
              unit: "word"
            });
            return;
          }
          if (dr.isDeleteWordForward(z)) {
            w.preventDefault(), _ && we.isExpanded(_) ? q.deleteFragment(g, {
              direction: "forward"
            }) : q.deleteForward(g, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [a, g, f.onKeyDown]),
    onPaste: hn((w) => {
      !a && ke.hasEditableTarget(g, w.target) && !Qr(w, f.onPaste) && (!ts || Hce(w.nativeEvent) || ra) && (w.preventDefault(), ke.insertData(g, w.clipboardData));
    }, [a, g, f.onPaste])
  }), /* @__PURE__ */ Ae.createElement(Gpe, {
    decorations: j,
    node: g,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: g.selection
  }))))));
}), Ype = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ Ae.createElement("span", ei({}, t), n, eo && /* @__PURE__ */ Ae.createElement("br", null))
  );
}, Jpe = () => [], Kpe = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && we.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), pce(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, Qr = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, FT = (e) => Ls(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), Qpe = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, ede = /* @__PURE__ */ qe(!1), tde = /* @__PURE__ */ qe({});
function nde(e) {
  var t = it([]).current, n = it({
    editor: e
  }).current, r = hn((i) => {
    n.editor = i, t.forEach((s) => s(i));
  }, [t, n]), o = Zn(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var rde = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], ode = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: s
  } = e, a = Va(e, rde), [l, u] = Ae.useState(() => {
    if (!Ue.isNodeList(s))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(Fr.stringify(s)));
    if (!q.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(Fr.stringify(t)));
    return t.children = s, Object.assign(t, a), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: p
  } = nde(t), d = hn((f) => {
    var g;
    switch (r && r(t.children), f == null || (g = f.operation) === null || g === void 0 ? void 0 : g.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((x) => ({
      v: x.v + 1,
      editor: t
    })), p(t);
  }, [t, p, r, o, i]);
  m(() => (t0.set(t, d), () => {
    t0.set(t, () => {
    });
  }), [t, d]);
  var [h, y] = k(ke.isFocused(t));
  return m(() => {
    y(ke.isFocused(t));
  }, [t]), Ru(() => {
    var f = () => y(ke.isFocused(t));
    return tF >= 17 ? (document.addEventListener("focusin", f), document.addEventListener("focusout", f), () => {
      document.removeEventListener("focusin", f), document.removeEventListener("focusout", f);
    }) : (document.addEventListener("focus", f, !0), document.addEventListener("blur", f, !0), () => {
      document.removeEventListener("focus", f, !0), document.removeEventListener("blur", f, !0);
    });
  }, []), /* @__PURE__ */ Ae.createElement(tde.Provider, {
    value: c
  }, /* @__PURE__ */ Ae.createElement(bF.Provider, {
    value: l
  }, /* @__PURE__ */ Ae.createElement(Z1.Provider, {
    value: l.editor
  }, /* @__PURE__ */ Ae.createElement(ede.Provider, {
    value: h
  }, n))));
}, zT = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, UT = (e, t, n) => {
  var r = ke.toDOMRange(e, t).getBoundingClientRect(), o = ke.toDOMRange(e, n).getBoundingClientRect();
  return zT(r, o) && zT(o, r);
}, ide = (e, t) => {
  var n = q.range(e, we.end(t)), r = Array.from(q.positions(e, {
    at: t
  })), o = 0, i = r.length, s = Math.floor(i / 2);
  if (UT(e, q.range(e, r[o]), n))
    return q.range(e, r[o], n);
  if (r.length < 2)
    return q.range(e, r[r.length - 1], n);
  for (; s !== r.length && s !== o; )
    UT(e, q.range(e, r[s]), n) ? i = s : o = s, s = Math.floor((o + i) / 2);
  return q.range(e, r[i], n);
};
function $T(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function WT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $T(Object(n), !0).forEach(function(r) {
      Zo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $T(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sde = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: s,
    addMark: a,
    removeMark: l
  } = r;
  return Nh.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var p, d;
    (p = X1.get(r)) === null || p === void 0 || p(), !qo.get(r) && (d = ao.get(r)) !== null && d !== void 0 && d.length && qo.set(r, null), Bi.delete(r), a(u, c);
  }, r.removeMark = (u) => {
    var c;
    !qo.get(r) && (c = ao.get(r)) !== null && c !== void 0 && c.length && qo.set(r, null), Bi.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return s(u);
    if (r.selection && we.isCollapsed(r.selection)) {
      var c = q.above(r, {
        match: (y) => Ve.isElement(y) && q.isBlock(r, y),
        at: r.selection
      });
      if (c) {
        var [, p] = c, d = q.range(r, p, r.selection.anchor), h = ide(r, d);
        we.isCollapsed(h) || Se.delete(r, {
          at: h
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], p = [], d = ao.get(r);
    if (d != null && d.length) {
      var h = d.map((N) => ipe(N, u)).filter(Boolean);
      ao.set(r, h);
    }
    var y = gs.get(r);
    y && gs.set(r, PT(r, y, u));
    var f = hs.get(r);
    if (f != null && f.at) {
      var g = kt.isPoint(f == null ? void 0 : f.at) ? o0(r, f.at, u) : PT(r, f.at, u);
      hs.set(r, g ? WT(WT({}, f), {}, {
        at: g
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...ja(r, u.path));
        break;
      }
      case "set_selection": {
        var x;
        (x = su.get(r)) === null || x === void 0 || x.unref(), su.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...ja(r, le.parent(u.path)));
        break;
      }
      case "merge_node": {
        var L = le.previous(u.path);
        c.push(...ja(r, L));
        break;
      }
      case "move_node": {
        var E = le.common(le.parent(u.path), le.parent(u.newPath));
        c.push(...ja(r, E));
        var T;
        le.isBefore(u.path, u.newPath) ? (c.push(...ja(r, le.parent(u.path))), T = u.newPath) : (c.push(...ja(r, le.parent(u.newPath))), T = u.path);
        var b = Ue.get(t, le.parent(T)), C = ke.findKey(r, b), M = q.pathRef(r, le.parent(T));
        p.push([M, C]);
        break;
      }
    }
    o(u);
    for (var [S, F] of c) {
      var [D] = q.node(r, S);
      Jd.set(D, F);
    }
    for (var [Z, U] of p)
      if (Z.current) {
        var [$] = q.node(r, Z.current);
        Jd.set($, U);
      }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [p, d] = we.edges(c), h = q.void(r, {
        at: p.path
      }), y = q.void(r, {
        at: d.path
      });
      if (!(we.isCollapsed(c) && !h)) {
        var f = ke.toDOMRange(r, c), g = f.cloneContents(), x = g.childNodes[0];
        if (g.childNodes.forEach((D) => {
          D.textContent && D.textContent.trim() !== "" && (x = D);
        }), y) {
          var [L] = y, E = f.cloneRange(), T = ke.toDOMNode(r, L);
          E.setEndAfter(T), g = E.cloneContents();
        }
        if (h && (x = g.querySelector("[data-slate-spacer]")), Array.from(g.querySelectorAll("[data-slate-zero-width]")).forEach((D) => {
          var Z = D.getAttribute("data-slate-zero-width") === "n";
          D.textContent = Z ? `
` : "";
        }), lF(x)) {
          var b = x.ownerDocument.createElement("span");
          b.style.whiteSpace = "pre", b.appendChild(x), g.appendChild(b), x = b;
        }
        var C = r.getFragment(), M = JSON.stringify(C), S = window.btoa(encodeURIComponent(M));
        x.setAttribute("data-slate-fragment", S), u.setData("application/".concat(n), S);
        var F = g.ownerDocument.createElement("div");
        return F.appendChild(g), F.setAttribute("hidden", "true"), g.ownerDocument.body.appendChild(F), u.setData("text/html", F.innerHTML), u.setData("text/plain", cF(F)), g.ownerDocument.body.removeChild(F), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || Xce(u);
    if (c) {
      var p = decodeURIComponent(window.atob(c)), d = JSON.parse(p);
      return r.insertFragment(d), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var p = c.split(/\r\n|\r|\n/), d = !1;
      for (var h of p)
        d && Se.splitNodes(r, {
          always: !0
        }), r.insertText(h), d = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = tF < 18 ? qa.unstable_batchedUpdates : (p) => p();
    c(() => {
      var p = t0.get(r);
      p && p(u), i(u);
    });
  }, r;
}, ja = (e, t) => {
  var n = [];
  for (var [r, o] of q.levels(e, {
    at: t
  })) {
    var i = ke.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function CF(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    q.nodes(e, {
      at: q.unhangRange(e, r),
      match: (i) => !q.isEditor(i) && Ve.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const HT = ["listItem", "numberedList"], ad = ["left", "center", "right", "justify"];
function ade(e, t) {
  const n = ad.includes(t) ? "align" : "type", r = CF(e, t, n), o = HT.includes(t);
  Se.unwrapNodes(e, {
    match: (s) => !q.isEditor(s) && Ve.isElement(s) && HT.includes(s.type) && !ad.includes(t),
    split: !0
  });
  let i;
  if (ad.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, Se.setNodes(e, i), !r && o) {
    const s = { type: t, children: [] };
    Se.wrapNodes(e, s);
  }
}
function Ys({ format: e, icon: t }) {
  const n = K1(), r = ad.includes(e) ? "align" : "type", i = CF(n, e, r) ? "activeTrue" : "activeFalse";
  function s(a) {
    a.preventDefault(), ade(n, e);
  }
  return /* @__PURE__ */ re.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: s,
      children: /* @__PURE__ */ re.jsx(t, {})
    }
  );
}
function lde({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ re.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ re.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ re.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ re.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ re.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ re.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    default:
      return /* @__PURE__ */ re.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
function ude({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ re.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ re.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ re.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ re.jsx("u", { children: t })), /* @__PURE__ */ re.jsx("span", { ...e, children: t });
}
function xF(e, t) {
  const n = q.marks(e);
  return n ? n[t] === !0 : !1;
}
function EF(e, t) {
  xF(e, t) ? q.removeMark(e, t) : q.addMark(e, t, !0);
}
function Up({ format: e, icon: t }) {
  const n = K1(), o = xF(n, e) ? "activeTrue" : "activeFalse";
  function i(s) {
    s.preventDefault(), EF(n, e);
  }
  return /* @__PURE__ */ re.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ re.jsx(t, {})
    }
  );
}
function cde({ children: e }) {
  return /* @__PURE__ */ re.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
const VT = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, pde = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
var LF = {}, Q1 = {}, ew = {};
Object.defineProperty(ew, "__esModule", { value: !0 });
ew.default = gde;
var ZT = "html", qT = "head", $p = "body", dde = /<([a-zA-Z]+[0-9]?)/, GT = /<head[^]*>/i, XT = /<body[^]*>/i, Kd = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, s0 = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, YT = typeof window == "object" && window.DOMParser;
if (typeof YT == "function") {
  var fde = new YT(), hde = "text/html";
  s0 = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), fde.parseFromString(e, hde);
  }, Kd = s0;
}
if (typeof document == "object" && document.implementation) {
  var Wp = document.implementation.createHTMLDocument();
  Kd = function(e, t) {
    if (t) {
      var n = Wp.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Wp;
    }
    return Wp.documentElement.innerHTML = e, Wp;
  };
}
var Hp = typeof document == "object" && document.createElement("template"), a0;
Hp && Hp.content && (a0 = function(e) {
  return Hp.innerHTML = e, Hp.content.childNodes;
});
function gde(e) {
  var t, n, r = e.match(dde), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case ZT: {
      var i = s0(e);
      if (!GT.test(e)) {
        var s = i.querySelector(qT);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!XT.test(e)) {
        var s = i.querySelector($p);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(ZT);
    }
    case qT:
    case $p: {
      var a = Kd(e).querySelectorAll(o);
      return XT.test(e) && GT.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (a0)
        return a0(e);
      var s = Kd(e, $p).querySelector($p);
      return s.childNodes;
    }
  }
}
var Fh = {}, tw = {}, nw = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(nw);
var It = {}, Ns = Sn && Sn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), lu = Sn && Sn.__assign || function() {
  return lu = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, lu.apply(this, arguments);
};
Object.defineProperty(It, "__esModule", { value: !0 });
It.cloneNode = It.hasChildren = It.isDocument = It.isDirective = It.isComment = It.isText = It.isCDATA = It.isTag = It.Element = It.Document = It.CDATA = It.NodeWithChildren = It.ProcessingInstruction = It.Comment = It.Text = It.DataNode = It.Node = void 0;
var yo = nw, rw = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), ow(this, t);
    }, e;
  }()
);
It.Node = rw;
var zh = (
  /** @class */
  function(e) {
    Ns(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rw)
);
It.DataNode = zh;
var kF = (
  /** @class */
  function(e) {
    Ns(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = yo.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(zh)
);
It.Text = kF;
var OF = (
  /** @class */
  function(e) {
    Ns(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = yo.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(zh)
);
It.Comment = OF;
var MF = (
  /** @class */
  function(e) {
    Ns(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = yo.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(zh)
);
It.ProcessingInstruction = MF;
var Uh = (
  /** @class */
  function(e) {
    Ns(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rw)
);
It.NodeWithChildren = Uh;
var SF = (
  /** @class */
  function(e) {
    Ns(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = yo.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Uh)
);
It.CDATA = SF;
var DF = (
  /** @class */
  function(e) {
    Ns(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = yo.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Uh)
);
It.Document = DF;
var PF = (
  /** @class */
  function(e) {
    Ns(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? yo.ElementType.Script : n === "style" ? yo.ElementType.Style : yo.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Uh)
);
It.Element = PF;
function TF(e) {
  return (0, yo.isTag)(e);
}
It.isTag = TF;
function _F(e) {
  return e.type === yo.ElementType.CDATA;
}
It.isCDATA = _F;
function AF(e) {
  return e.type === yo.ElementType.Text;
}
It.isText = AF;
function BF(e) {
  return e.type === yo.ElementType.Comment;
}
It.isComment = BF;
function IF(e) {
  return e.type === yo.ElementType.Directive;
}
It.isDirective = IF;
function jF(e) {
  return e.type === yo.ElementType.Root;
}
It.isDocument = jF;
function mde(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
It.hasChildren = mde;
function ow(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (AF(e))
    n = new kF(e.data);
  else if (BF(e))
    n = new OF(e.data);
  else if (TF(e)) {
    var r = t ? ov(e.children) : [], o = new PF(e.name, lu({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = lu({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = lu({}, e["x-attribsPrefix"])), n = o;
  } else if (_F(e)) {
    var r = t ? ov(e.children) : [], i = new SF(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (jF(e)) {
    var r = t ? ov(e.children) : [], s = new DF(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (IF(e)) {
    var a = new MF(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
It.cloneNode = ow;
function ov(e) {
  for (var t = e.map(function(r) {
    return ow(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Sn && Sn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = Sn && Sn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = nw, o = It;
  n(It, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(tw);
var RF = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(RF);
Object.defineProperty(Fh, "__esModule", { value: !0 });
Fh.formatAttributes = NF;
Fh.formatDOM = FF;
var Vp = tw, vde = RF;
function yde(e) {
  return vde.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function NF(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function bde(e) {
  e = e.toLowerCase();
  var t = yde(e);
  return t || e;
}
function FF(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = bde(a.nodeName);
        o = new Vp.Element(l, NF(a.attributes)), o.children = FF(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Vp.Text(a.nodeValue);
        break;
      case 8:
        o = new Vp.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Vp.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var wde = Sn && Sn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Q1, "__esModule", { value: !0 });
Q1.default = Lde;
var Cde = wde(ew), xde = Fh, Ede = /<(![a-zA-Z\s]+)>/;
function Lde(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Ede), n = t ? t[1] : void 0;
  return (0, xde.formatDOM)((0, Cde.default)(e), null, n);
}
var $h = {}, Ko = {}, Wh = {}, kde = 0;
Wh.SAME = kde;
var Ode = 1;
Wh.CAMELCASE = Ode;
Wh.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const zF = 0, Fs = 1, Hh = 2, Vh = 3, iw = 4, UF = 5, $F = 6;
function Mde(e) {
  return qr.hasOwnProperty(e) ? qr[e] : null;
}
function so(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === Hh || t === Vh || t === iw, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const qr = {}, Sde = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Sde.forEach((e) => {
  qr[e] = new so(
    e,
    zF,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  qr[e] = new so(
    e,
    Fs,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  qr[e] = new so(
    e,
    Hh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  qr[e] = new so(
    e,
    Hh,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  qr[e] = new so(
    e,
    Vh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  qr[e] = new so(
    e,
    Vh,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  qr[e] = new so(
    e,
    iw,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  qr[e] = new so(
    e,
    $F,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  qr[e] = new so(
    e,
    UF,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const sw = /[\-\:]([a-z])/g, aw = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(sw, aw);
  qr[t] = new so(
    t,
    Fs,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(sw, aw);
  qr[t] = new so(
    t,
    Fs,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(sw, aw);
  qr[t] = new so(
    t,
    Fs,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  qr[e] = new so(
    e,
    Fs,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Dde = "xlinkHref";
qr[Dde] = new so(
  "xlinkHref",
  Fs,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  qr[e] = new so(
    e,
    Fs,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Pde,
  SAME: Tde,
  possibleStandardNames: JT
} = Wh, _de = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Ade = _de + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Bde = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Ade + "]*$")
), Ide = Object.keys(
  JT
).reduce((e, t) => {
  const n = JT[t];
  return n === Tde ? e[t] = t : n === Pde ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Ko.BOOLEAN = Vh;
Ko.BOOLEANISH_STRING = Hh;
Ko.NUMERIC = UF;
Ko.OVERLOADED_BOOLEAN = iw;
Ko.POSITIVE_NUMERIC = $F;
Ko.RESERVED = zF;
Ko.STRING = Fs;
Ko.getPropertyInfo = Mde;
Ko.isCustomAttribute = Bde;
Ko.possibleStandardNames = Ide;
var lw = {}, uw = {}, KT = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, jde = /\n/g, Rde = /^\s*/, Nde = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Fde = /^:\s*/, zde = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Ude = /^[;\s]*/, $de = /^\s+|\s+$/g, Wde = `
`, QT = "/", e_ = "*", la = "", Hde = "comment", Vde = "declaration", Zde = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(y) {
    var f = y.match(jde);
    f && (n += f.length);
    var g = y.lastIndexOf(Wde);
    r = ~g ? y.length - g : r + y.length;
  }
  function i() {
    var y = { line: n, column: r };
    return function(f) {
      return f.position = new s(y), u(), f;
    };
  }
  function s(y) {
    this.start = y, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(y) {
    var f = new Error(
      t.source + ":" + n + ":" + r + ": " + y
    );
    if (f.reason = y, f.filename = t.source, f.line = n, f.column = r, f.source = e, !t.silent) throw f;
  }
  function l(y) {
    var f = y.exec(e);
    if (f) {
      var g = f[0];
      return o(g), e = e.slice(g.length), f;
    }
  }
  function u() {
    l(Rde);
  }
  function c(y) {
    var f;
    for (y = y || []; f = p(); )
      f !== !1 && y.push(f);
    return y;
  }
  function p() {
    var y = i();
    if (!(QT != e.charAt(0) || e_ != e.charAt(1))) {
      for (var f = 2; la != e.charAt(f) && (e_ != e.charAt(f) || QT != e.charAt(f + 1)); )
        ++f;
      if (f += 2, la === e.charAt(f - 1))
        return a("End of comment missing");
      var g = e.slice(2, f - 2);
      return r += 2, o(g), e = e.slice(f), r += 2, y({
        type: Hde,
        comment: g
      });
    }
  }
  function d() {
    var y = i(), f = l(Nde);
    if (f) {
      if (p(), !l(Fde)) return a("property missing ':'");
      var g = l(zde), x = y({
        type: Vde,
        property: t_(f[0].replace(KT, la)),
        value: g ? t_(g[0].replace(KT, la)) : la
      });
      return l(Ude), x;
    }
  }
  function h() {
    var y = [];
    c(y);
    for (var f; f = d(); )
      f !== !1 && (y.push(f), c(y));
    return y;
  }
  return u(), h();
};
function t_(e) {
  return e ? e.replace($de, la) : la;
}
var qde = Sn && Sn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(uw, "__esModule", { value: !0 });
uw.default = Xde;
var Gde = qde(Zde);
function Xde(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Gde.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Zh = {};
Object.defineProperty(Zh, "__esModule", { value: !0 });
Zh.camelCase = void 0;
var Yde = /^--[a-zA-Z0-9-]+$/, Jde = /-([a-z])/g, Kde = /^[^-]+$/, Qde = /^-(webkit|moz|ms|o|khtml)-/, efe = /^-(ms)-/, tfe = function(e) {
  return !e || Kde.test(e) || Yde.test(e);
}, nfe = function(e, t) {
  return t.toUpperCase();
}, n_ = function(e, t) {
  return "".concat(t, "-");
}, rfe = function(e, t) {
  return t === void 0 && (t = {}), tfe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(efe, n_) : e = e.replace(Qde, n_), e.replace(Jde, nfe));
};
Zh.camelCase = rfe;
var ofe = Sn && Sn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, ife = ofe(uw), sfe = Zh;
function l0(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, ife.default)(e, function(r, o) {
    r && o && (n[(0, sfe.camelCase)(r, t)] = o);
  }), n;
}
l0.default = l0;
var afe = l0;
(function(e) {
  var t = Sn && Sn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Ae, r = t(afe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(lw);
Object.defineProperty($h, "__esModule", { value: !0 });
$h.default = pfe;
var zl = Ko, r_ = lw, lfe = ["checked", "value"], ufe = ["input", "select", "textarea"], cfe = {
  reset: !0,
  submit: !0
};
function pfe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && cfe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, zl.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = o_(s);
    if (a) {
      var l = (0, zl.getPropertyInfo)(a);
      switch (lfe.includes(a) && ufe.includes(t) && !r && (a = o_("default" + s)), n[a] = i, l && l.type) {
        case zl.BOOLEAN:
          n[a] = !0;
          break;
        case zl.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    r_.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, r_.setStyleProp)(e.style, n), n;
}
function o_(e) {
  return zl.possibleStandardNames[e];
}
var cw = {}, dfe = Sn && Sn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(cw, "__esModule", { value: !0 });
cw.default = WF;
var iv = Ae, ffe = dfe($h), uu = lw, hfe = {
  cloneElement: iv.cloneElement,
  createElement: iv.createElement,
  isValidElement: iv.isValidElement
};
function WF(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || uu.returnFirstArg, i = t.library || hfe, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var h = !p.data.trim().length;
      if (h && p.parent && !(0, uu.canTextBeChildOfNode)(p.parent) || t.trim && h)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var y = p, f = {};
    gfe(y) ? ((0, uu.setStyleProp)(y.attribs.style, y.attribs), f = y.attribs) : y.attribs && (f = (0, ffe.default)(y.attribs, y.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (f.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? f.defaultValue = p.children[0].data : p.children && p.children.length && (g = WF(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (f.key = c), n.push(o(a(p.name, f, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function gfe(e) {
  return uu.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, uu.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Sn && Sn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(Q1);
  e.htmlToDOM = n.default;
  var r = t($h);
  e.attributesToProps = r.default;
  var o = t(cw);
  e.domToReact = o.default;
  var i = tw;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(LF);
const i_ = /* @__PURE__ */ tf(LF), mfe = i_.default || i_, u0 = (e) => {
  if (typeof e == "string") return { text: e || "" };
  function t(o) {
    return o.map((i) => u0(i));
  }
  const n = Array.isArray(e.props.children) ? t(e.props.children) : [{ text: e.props.children }], r = typeof e.props.children == "string" ? e.props.children : "";
  switch (e.type) {
    case "p":
      return { type: "paragraph", children: n };
    case "blockquote":
      return { type: "blockQuote", children: n };
    case "ul":
      return { type: "bulletedList", children: n };
    case "h1":
      return { type: "headingOne", children: n };
    case "h2":
      return { type: "headingTwo", children: n };
    case "li":
      return { type: "listItem", children: n };
    case "ol":
      return { type: "numberedList", children: n };
    case "strong":
      return { type: "paragraph", text: r, bold: !0 };
    case "code":
      return { text: r, code: !0 };
    case "em":
      return { text: r, italic: !0 };
    case "u":
      return { text: r, underline: !0 };
    default:
      return { text: r };
  }
}, vfe = (e) => {
  const t = mfe(e);
  return Array.isArray(t) ? t.flatMap((n) => typeof n == "string" ? { text: n } : u0(n)) : typeof t == "string" ? [{ text: t }] : [u0(t)];
};
function s_(e) {
  return e.map((t) => Ue.string(t)).join("");
}
const HF = (e) => {
  if (Ze.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (Ve.isElement(e)) {
    const t = e.children.map((n) => HF(n)).join("");
    switch (e.type) {
      case "paragraph":
        return `<p>${t}</p>`;
      case "blockQuote":
        return `<blockquote>${t}</blockquote>`;
      case "bulletedList":
        return `<ul>${t}</ul>`;
      case "headingOne":
        return `<h1>${t}</h1>`;
      case "headingTwo":
        return `<h2>${t}</h2>`;
      case "listItem":
        return `<li>${t}</li>`;
      case "numberedList":
        return `<ol>${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, a_ = (e) => e.children.map((t) => HF(t)).join(""), l_ = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function Gme({
  name: e,
  defaultValue: t,
  enforceCharacterLimit: n = !1,
  onChangeCharactersCount: r,
  maxLimit: o = 2e3,
  onValueChange: i,
  onChange: s,
  isError: a
}) {
  const l = Zn(() => Jle(sde(Gle())), []), { id: u, inputRef: c, error: p } = Fo(), d = it(null), h = l_(t) ? vfe(t) : pde, y = s_(h), [f, g] = k(y.length), [x, L] = k(
    l_(t) ? t : ""
  ), [E, T] = k(!1), b = c || d, C = a || !!p, M = hn(ude, []), S = hn(lde, []);
  function F(N) {
    const V = s_(N);
    g(V.length), r && r(V.length), !(n && V.length >= o) && (L(a_(l)), s && s(N), i && i(a_(l)), l.children = N, Se.setNodes(l, { children: N }));
  }
  const D = E ? "focusTrue" : "focusFalse", U = `arkynRichText ${C || o < f ? "errorTrue" : "errorFalse"} ${D}`, $ = o - f;
  return /* @__PURE__ */ re.jsxs(
    ode,
    {
      editor: l,
      initialValue: h,
      onChange: F,
      onValueChange: F,
      children: [
        /* @__PURE__ */ re.jsxs("div", { className: U, children: [
          /* @__PURE__ */ re.jsxs(cde, { children: [
            /* @__PURE__ */ re.jsx(Ys, { format: "headingOne", icon: O2 }),
            /* @__PURE__ */ re.jsx(Ys, { format: "headingTwo", icon: M2 }),
            /* @__PURE__ */ re.jsx(Ys, { format: "blockQuote", icon: S2 }),
            /* @__PURE__ */ re.jsx(Up, { format: "bold", icon: D2 }),
            /* @__PURE__ */ re.jsx(Up, { format: "italic", icon: P2 }),
            /* @__PURE__ */ re.jsx(Up, { format: "underline", icon: T2 }),
            /* @__PURE__ */ re.jsx(Up, { format: "code", icon: _2 }),
            /* @__PURE__ */ re.jsx(Ys, { format: "left", icon: A2 }),
            /* @__PURE__ */ re.jsx(Ys, { format: "right", icon: B2 }),
            /* @__PURE__ */ re.jsx(Ys, { format: "center", icon: I2 }),
            /* @__PURE__ */ re.jsx(Ys, { format: "justify", icon: j2 })
          ] }),
          /* @__PURE__ */ re.jsx(
            Xpe,
            {
              className: "editorContainer",
              renderElement: S,
              renderLeaf: M,
              spellCheck: !0,
              id: u,
              onFocus: () => T(!0),
              onBlur: () => T(!1),
              onKeyDown: (N) => {
                for (const V in VT)
                  if (mse(V, N)) {
                    N.preventDefault();
                    const J = VT[V];
                    EF(l, J);
                  }
              }
            }
          ),
          $ < 0 && /* @__PURE__ */ re.jsx("div", { className: "restatesCharacters", children: $ })
        ] }),
        /* @__PURE__ */ re.jsx("input", { ref: b, type: "hidden", name: e, value: x }),
        /* @__PURE__ */ re.jsx("input", { type: "hidden", name: `${e}Count`, value: f })
      ]
    }
  );
}
function yfe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: p,
    onBlur: d,
    title: h,
    style: y,
    closeOnSelect: f = !0,
    ...g
  } = e, b = `arkyn_select ${a ? "hasPrefix" : ""} ${s} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, M = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: b,
    prefix: G2(a, M, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: p,
    onBlur: d,
    title: h,
    closeOnSelect: f,
    style: y,
    iconSize: M,
    Spinner: /* @__PURE__ */ re.jsx(Ui, { className: "spinner", size: M, strokeWidth: 2.5 }),
    ...g
  };
}
function Xme(e) {
  var w;
  const [t, n] = k(""), [r, o] = k(!1), { inputRef: i, id: s, error: a } = Fo(), l = it(null), u = i || l, c = e.isError || !!a, {
    disabled: p,
    title: d,
    style: h,
    className: y,
    prefix: f,
    iconSize: g,
    isLoading: x,
    LeftIcon: L,
    value: E = null,
    defaultValue: T = "",
    onFocus: b,
    onBlur: C,
    Spinner: M,
    name: S,
    placeholder: F,
    onSelect: D,
    options: Z,
    optionMaxHeight: U,
    closeOnSelect: $,
    isSearchable: N,
    onSearch: V,
    ...J
  } = yfe({ ...e, id: s, isError: c }, r), [j, K] = k(T);
  function te() {
    p || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function O(R) {
    r || (o(!0), b && b(R));
  }
  function P() {
    o(!1), C && u.current && u.current.blur();
  }
  function H(R) {
    const { label: z, value: _ } = R;
    K(j !== _ ? _ : ""), D && D({ label: z, value: _ }), $ && P();
  }
  const I = typeof E == "string" ? E : j, W = ((w = Z.find((R) => R.value === I)) == null ? void 0 : w.label) || "", X = () => {
    if (!r && W) return !0;
    if (!r && !W) return !1;
    if (r && W) return !0;
    if (r && !W) return !1;
  };
  return /* @__PURE__ */ re.jsxs(re.Fragment, { children: [
    /* @__PURE__ */ re.jsxs(
      "section",
      {
        title: d,
        style: h,
        onClick: te,
        className: `${y} placeholder_dark_${X()}`,
        children: [
          f,
          L && /* @__PURE__ */ re.jsx(L, { size: g, strokeWidth: 2.5 }),
          /* @__PURE__ */ re.jsx(
            "input",
            {
              disabled: p,
              readOnly: !0,
              placeholder: W || F,
              onFocus: O,
              ...J
            }
          ),
          /* @__PURE__ */ re.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: S,
              value: I || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ re.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: U },
              children: [
                N && /* @__PURE__ */ re.jsx(
                  gA,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: R2,
                    onChange: (R) => n(R.target.value)
                  }
                ),
                Z.filter((R) => !!(e.onSearch || !e.isSearchable || R.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: R, value: z }) => /* @__PURE__ */ re.jsxs(
                  "div",
                  {
                    onClick: () => H({ label: R, value: z }),
                    className: I === z ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      R,
                      " ",
                      /* @__PURE__ */ re.jsx(V_, {})
                    ]
                  },
                  z
                )),
                Z.length <= 0 && /* @__PURE__ */ re.jsx("p", { children: "Sem opções disponíveis" })
              ]
            }
          ),
          !x && /* @__PURE__ */ re.jsx(
            N2,
            {
              className: "arkyn_select_arrow",
              size: g,
              strokeWidth: 2.5
            }
          ),
          x && M
        ]
      }
    ),
    r && /* @__PURE__ */ re.jsx("aside", { className: "arkyn_select_overlay", onClick: P })
  ] });
}
function Yme(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: s,
    className: a = "",
    onCheck: l,
    ...u
  } = e, [c, p] = k(n), { id: d, inputRef: h } = Fo(), y = typeof r == "boolean" ? r : c;
  function f() {
    p(!c), l && l(y ? i : o || "checked");
  }
  const x = `arkynSwitch ${y ? "checkedTrue" : "checkedFalse"} ${t} ${a}`;
  return /* @__PURE__ */ re.jsx("button", { type: "button", onClick: f, className: x, ...u, children: /* @__PURE__ */ re.jsx(
    "input",
    {
      id: d,
      type: "hidden",
      name: s,
      ref: h,
      onClick: f,
      value: y ? o || "checked" : i
    }
  ) });
}
function Jme(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: s,
    onBlur: a,
    title: l,
    style: u,
    ...c
  } = e, [p, d] = k(!1), { inputRef: h, id: y, error: f } = Fo(), g = it(null), x = h || g, E = e.isError || !!f ? "errorTrue" : "errorFalse", C = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${E} ${p ? "focusedTrue" : "focusedFalse"} ${r}`;
  function M() {
    o || !(x != null && x.current) || (d(!0), x.current.focus());
  }
  function S(D) {
    d(!0), s && s(D);
  }
  function F(D) {
    d(!1), a && a(D);
  }
  return /* @__PURE__ */ re.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: M,
      className: C,
      children: /* @__PURE__ */ re.jsx(
        "textarea",
        {
          id: y,
          disabled: o,
          readOnly: i,
          ref: x,
          onFocus: S,
          onBlur: F,
          ...c
        }
      )
    }
  );
}
function Kme(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ re.jsx("nav", { className: r, ...n });
}
function Qme(e) {
  const { pathname: t } = y0(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...s
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ re.jsxs("p", { className: l, children: [
    /* @__PURE__ */ re.jsx(vv, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ re.jsxs(z2, { to: i, className: l, ...s, children: [
    /* @__PURE__ */ re.jsx(vv, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function VF(e = "") {
  const t = y0(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([s, a]) => {
      a === void 0 ? n.delete(`${r}${s}`) : n.set(`${r}${s}`, String(a));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let s = n.toString();
      return s && (s = "?" + s), s;
    }
  };
}
function eve(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    ...s
  } = e, a = X_(), { getParam: l, getScopedSearch: u } = VF(t), c = Number(l(o)) || 1, p = Number(l(r)) || 20, d = Math.ceil(n / p), h = q2(c, i), y = Z2(c, i, d);
  function f(g) {
    a(u({ page: g }));
  }
  return /* @__PURE__ */ re.jsxs("div", { className: "arkynPagination", ...s, children: [
    /* @__PURE__ */ re.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: c <= 1,
        onClick: () => f(c - 1),
        children: /* @__PURE__ */ re.jsx(F2, {})
      }
    ),
    c > 1 + i && /* @__PURE__ */ re.jsxs(re.Fragment, { children: [
      /* @__PURE__ */ re.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => f(1),
          children: "1"
        }
      ),
      c > 2 + i && /* @__PURE__ */ re.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ re.jsx(Cw, {}) })
    ] }),
    h.map((g, x) => /* @__PURE__ */ re.jsx(
      "button",
      {
        onClick: () => f(g),
        className: "arkynPaginationPageButton",
        children: g
      },
      x
    )),
    /* @__PURE__ */ re.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: c }),
    y.map((g, x) => /* @__PURE__ */ re.jsx(
      "button",
      {
        onClick: () => f(g),
        className: "arkynPaginationPageButton",
        children: g
      },
      x
    )),
    c + i < d && /* @__PURE__ */ re.jsxs(re.Fragment, { children: [
      c + 1 + i < d && /* @__PURE__ */ re.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ re.jsx(Cw, {}) }),
      /* @__PURE__ */ re.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => f(d),
          children: d
        }
      )
    ] }),
    /* @__PURE__ */ re.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: c >= d,
        onClick: () => f(c + 1),
        children: /* @__PURE__ */ re.jsx(vv, {})
      }
    )
  ] });
}
const c0 = qe({});
function bfe() {
  if (!c0)
    throw new Error("useTabContext must be used within a TabProvider");
  return Te(c0);
}
function tve(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [s, a] = k(r || ""), [l, u] = k(!0), c = it(null), p = `arkynTabContainer ${o || ""}`, [d, h] = k({
    width: "0px",
    left: "0px",
    transition: "none"
  }), y = (g, x) => {
    const L = g.getBoundingClientRect(), E = c.current.getBoundingClientRect(), T = x ? void 0 : "none";
    u(!1), h({
      transition: T,
      width: `${L.width}px`,
      left: `${L.left - E.left}px`
    });
  };
  m(() => {
    const g = c.current;
    if (!g) return;
    let x = null;
    x = g.querySelector("button.activeTrue"), x && y(x);
  }, []);
  const f = (g) => {
    const x = g.target;
    x && (a(x.value), x.classList.add("activeTrue"), y(x, !0), n && n(x.value));
  };
  return /* @__PURE__ */ re.jsxs("nav", { ref: c, className: p.trim(), ...i, children: [
    /* @__PURE__ */ re.jsx(c0.Provider, { value: { handleTabClick: f, showInitialTab: l, value: s }, children: t }),
    /* @__PURE__ */ re.jsx("div", { className: "activeLine", style: d })
  ] });
}
function nve(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: s, handleTabClick: a } = bfe(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && s ? "showBorderBottom" : ""} ${l} ${n}`;
  function p(d) {
    a(d), r && r(d);
  }
  return /* @__PURE__ */ re.jsx("button", { onClick: p, className: c.trim(), ...o, children: t });
}
const ZF = qe({});
function rve(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...s
  } = e, a = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ re.jsx(ZF.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ re.jsx(Y_, { children: t && /* @__PURE__ */ re.jsxs("aside", { className: u.trim(), ...s, children: [
    /* @__PURE__ */ re.jsx(
      cu.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ re.jsx(
      cu.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${a})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${a})` },
        children: o
      }
    )
  ] }) }) });
}
function ove(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = Te(ZF), s = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ re.jsxs("header", { className: s.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ re.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ re.jsx(Z_, { size: 24 })
      }
    )
  ] });
}
const qF = qe({});
function ive(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, a = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ re.jsx(qF.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ re.jsx(Y_, { children: t && /* @__PURE__ */ re.jsxs("aside", { className: a.trim(), ...i, children: [
    /* @__PURE__ */ re.jsx(
      cu.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ re.jsx(
      cu.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function sve(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ re.jsx("footer", { className: o.trim(), ...r });
}
function ave(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = Te(qF), s = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ re.jsxs("header", { className: s.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ re.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ re.jsx(Z_, { size: 24 })
      }
    )
  ] });
}
function lve(e) {
  const { children: t, button: n, closeOnClick: r, orientation: o = "bottomLeft" } = e, [i, s] = k(!1), l = `arkynPopover ${o} ${i ? "visibleTrue" : "visibleFalse"}`;
  function u() {
    i || s(!0);
  }
  return /* @__PURE__ */ re.jsxs("div", { className: l, onClick: u, children: [
    n,
    /* @__PURE__ */ re.jsx(
      cu.div,
      {
        style: { visibility: i ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: i ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && s(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    i && /* @__PURE__ */ re.jsx("div", { onClick: () => s(!1), className: "arkynPopoverOverlay" })
  ] });
}
function uve(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ re.jsx(H_, {});
      case "danger":
        return /* @__PURE__ */ re.jsx(W_, {});
      default:
        return /* @__PURE__ */ re.jsx($_, {});
    }
  }
  return /* @__PURE__ */ re.jsxs("div", { className: r, children: [
    /* @__PURE__ */ re.jsxs("div", { children: [
      /* @__PURE__ */ re.jsx("div", { className: "bg" }),
      /* @__PURE__ */ re.jsx(o, {})
    ] }),
    /* @__PURE__ */ re.jsx("p", { children: /* @__PURE__ */ re.jsx("span", { children: t }) })
  ] });
}
function cve(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...s
  } = e, a = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ re.jsxs("div", { className: a.trim(), ...s, children: [
    r,
    /* @__PURE__ */ re.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
var Tr = {}, pw = {}, fc = {}, hc = {}, GF = "Expected a function", u_ = NaN, wfe = "[object Symbol]", Cfe = /^\s+|\s+$/g, xfe = /^[-+]0x[0-9a-f]+$/i, Efe = /^0b[01]+$/i, Lfe = /^0o[0-7]+$/i, kfe = parseInt, Ofe = typeof Sn == "object" && Sn && Sn.Object === Object && Sn, Mfe = typeof self == "object" && self && self.Object === Object && self, Sfe = Ofe || Mfe || Function("return this")(), Dfe = Object.prototype, Pfe = Dfe.toString, Tfe = Math.max, _fe = Math.min, sv = function() {
  return Sfe.Date.now();
};
function Afe(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(GF);
  t = c_(t) || 0, Qd(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Tfe(c_(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function h(C) {
    var M = r, S = o;
    return r = o = void 0, u = C, s = e.apply(S, M), s;
  }
  function y(C) {
    return u = C, a = setTimeout(x, t), c ? h(C) : s;
  }
  function f(C) {
    var M = C - l, S = C - u, F = t - M;
    return p ? _fe(F, i - S) : F;
  }
  function g(C) {
    var M = C - l, S = C - u;
    return l === void 0 || M >= t || M < 0 || p && S >= i;
  }
  function x() {
    var C = sv();
    if (g(C))
      return L(C);
    a = setTimeout(x, f(C));
  }
  function L(C) {
    return a = void 0, d && r ? h(C) : (r = o = void 0, s);
  }
  function E() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function T() {
    return a === void 0 ? s : L(sv());
  }
  function b() {
    var C = sv(), M = g(C);
    if (r = arguments, o = this, l = C, M) {
      if (a === void 0)
        return y(l);
      if (p)
        return a = setTimeout(x, t), h(l);
    }
    return a === void 0 && (a = setTimeout(x, t)), s;
  }
  return b.cancel = E, b.flush = T, b;
}
function Bfe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(GF);
  return Qd(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Afe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Qd(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Ife(e) {
  return !!e && typeof e == "object";
}
function jfe(e) {
  return typeof e == "symbol" || Ife(e) && Pfe.call(e) == wfe;
}
function c_(e) {
  if (typeof e == "number")
    return e;
  if (jfe(e))
    return u_;
  if (Qd(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Qd(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Cfe, "");
  var n = Efe.test(e);
  return n || Lfe.test(e) ? kfe(e.slice(2), n ? 2 : 8) : xfe.test(e) ? u_ : +e;
}
var Rfe = Bfe, gc = {};
Object.defineProperty(gc, "__esModule", {
  value: !0
});
gc.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), ld.has(n) || ld.set(n, /* @__PURE__ */ new Set());
  var i = ld.get(n);
  if (!i.has(o)) {
    var s = function() {
      var a = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return a;
    }();
    t.addEventListener(n, r, s ? { passive: !0 } : !1), i.add(o);
  }
};
gc.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), ld.get(n).delete(r.name || n);
};
var ld = /* @__PURE__ */ new Map();
Object.defineProperty(hc, "__esModule", {
  value: !0
});
var Nfe = Rfe, Ffe = Ufe(Nfe), zfe = gc;
function Ufe(e) {
  return e && e.__esModule ? e : { default: e };
}
var $fe = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Ffe.default)(t, n);
}, vr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = $fe(function(o) {
        vr.scrollHandler(t);
      }, n);
      vr.scrollSpyContainers.push(t), (0, zfe.addPassiveEventListener)(t, "scroll", r);
    }
  },
  isMounted: function(t) {
    return vr.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.pageYOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = vr.scrollSpyContainers[vr.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(vr.currentPositionX(t), vr.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    vr.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = vr.scrollSpyContainers[vr.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t), t(vr.currentPositionX(n), vr.currentPositionY(n));
  },
  updateStates: function() {
    vr.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    vr.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), vr.spySetState && vr.spySetState.length && vr.spySetState.indexOf(t) > -1 && vr.spySetState.splice(vr.spySetState.indexOf(t), 1), document.removeEventListener("scroll", vr.scrollHandler);
  },
  update: function() {
    return vr.scrollSpyContainers.forEach(function(t) {
      return vr.scrollHandler(t);
    });
  }
};
hc.default = vr;
var rl = {}, mc = {};
Object.defineProperty(mc, "__esModule", {
  value: !0
});
var Wfe = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, s = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", s) : history.replaceState(history.state, "", s);
}, Hfe = function() {
  return window.location.hash.replace(/^#/, "");
}, Vfe = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, Zfe = function(t) {
  return getComputedStyle(t).position !== "static";
}, av = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, qfe = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Zfe(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = av(n, o), s = i.offsetTop, a = i.offsetParent;
      if (a !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return s;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return av(n, l).offsetTop - av(t, l).offsetTop;
};
mc.default = {
  updateHash: Wfe,
  getHash: Hfe,
  filterElementInContainer: Vfe,
  scrollOffset: qfe
};
var qh = {}, dw = {};
Object.defineProperty(dw, "__esModule", {
  value: !0
});
dw.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var fw = {};
Object.defineProperty(fw, "__esModule", {
  value: !0
});
var Gfe = gc, Xfe = ["mousedown", "mousewheel", "touchmove", "keydown"];
fw.default = {
  subscribe: function(t) {
    return typeof document < "u" && Xfe.forEach(function(n) {
      return (0, Gfe.addPassiveEventListener)(document, n, t);
    });
  }
};
var vc = {};
Object.defineProperty(vc, "__esModule", {
  value: !0
});
var p0 = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      p0.registered[t] = n;
    },
    remove: function(t) {
      p0.registered[t] = null;
    }
  }
};
vc.default = p0;
Object.defineProperty(qh, "__esModule", {
  value: !0
});
var Yfe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Jfe = mc;
Gh(Jfe);
var Kfe = dw, p_ = Gh(Kfe), Qfe = fw, ehe = Gh(Qfe), the = vc, ii = Gh(the);
function Gh(e) {
  return e && e.__esModule ? e : { default: e };
}
var XF = function(t) {
  return p_.default[t.smooth] || p_.default.defaultEasing;
}, nhe = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, rhe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, d0 = function() {
  return rhe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), YF = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, JF = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, KF = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, ohe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, ihe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, she = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    ii.default.registered.end && ii.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    d0.call(window, i);
    return;
  }
  ii.default.registered.end && ii.default.registered.end(o.to, o.target, o.currentPosition);
}, hw = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, yc = function(t, n, r, o) {
  n.data = n.data || YF(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (ehe.default.subscribe(i), hw(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? JF(n) : KF(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    ii.default.registered.end && ii.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = nhe(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var s = XF(n), a = she.bind(null, s, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      ii.default.registered.begin && ii.default.registered.begin(n.data.to, n.data.target), d0.call(window, a);
    }, n.delay);
    return;
  }
  ii.default.registered.begin && ii.default.registered.begin(n.data.to, n.data.target), d0.call(window, a);
}, Xh = function(t) {
  return t = Yfe({}, t), t.data = t.data || YF(), t.absolute = !0, t;
}, ahe = function(t) {
  yc(0, Xh(t));
}, lhe = function(t, n) {
  yc(t, Xh(n));
}, uhe = function(t) {
  t = Xh(t), hw(t), yc(t.horizontal ? ohe(t) : ihe(t), t);
}, che = function(t, n) {
  n = Xh(n), hw(n);
  var r = n.horizontal ? JF(n) : KF(n);
  yc(t + r, n);
};
qh.default = {
  animateTopScroll: yc,
  getAnimationType: XF,
  scrollToTop: ahe,
  scrollToBottom: uhe,
  scrollTo: lhe,
  scrollMore: che
};
Object.defineProperty(rl, "__esModule", {
  value: !0
});
var phe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, dhe = mc, fhe = gw(dhe), hhe = qh, ghe = gw(hhe), mhe = vc, Zp = gw(mhe);
function gw(e) {
  return e && e.__esModule ? e : { default: e };
}
var qp = {}, d_ = void 0;
rl.default = {
  unmount: function() {
    qp = {};
  },
  register: function(t, n) {
    qp[t] = n;
  },
  unregister: function(t) {
    delete qp[t];
  },
  get: function(t) {
    return qp[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return d_ = t;
  },
  getActiveLink: function() {
    return d_;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = phe({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, s = void 0;
    o ? s = document.getElementById(o) : i && i.nodeType ? s = i : s = document, n.absolute = !0;
    var a = n.horizontal, l = fhe.default.scrollOffset(s, r, a) + (n.offset || 0);
    if (!n.smooth) {
      Zp.default.registered.begin && Zp.default.registered.begin(t, r), s === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : s.scrollTop = l, Zp.default.registered.end && Zp.default.registered.end(t, r);
      return;
    }
    ghe.default.animateTopScroll(l, n, t, r);
  }
};
var f0 = { exports: {} }, Gp = { exports: {} }, dn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f_;
function vhe() {
  if (f_) return dn;
  f_ = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
  function E(b) {
    if (typeof b == "object" && b !== null) {
      var C = b.$$typeof;
      switch (C) {
        case t:
          switch (b = b.type, b) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case a:
                case c:
                case y:
                case h:
                case s:
                  return b;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function T(b) {
    return E(b) === u;
  }
  return dn.AsyncMode = l, dn.ConcurrentMode = u, dn.ContextConsumer = a, dn.ContextProvider = s, dn.Element = t, dn.ForwardRef = c, dn.Fragment = r, dn.Lazy = y, dn.Memo = h, dn.Portal = n, dn.Profiler = i, dn.StrictMode = o, dn.Suspense = p, dn.isAsyncMode = function(b) {
    return T(b) || E(b) === l;
  }, dn.isConcurrentMode = T, dn.isContextConsumer = function(b) {
    return E(b) === a;
  }, dn.isContextProvider = function(b) {
    return E(b) === s;
  }, dn.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === t;
  }, dn.isForwardRef = function(b) {
    return E(b) === c;
  }, dn.isFragment = function(b) {
    return E(b) === r;
  }, dn.isLazy = function(b) {
    return E(b) === y;
  }, dn.isMemo = function(b) {
    return E(b) === h;
  }, dn.isPortal = function(b) {
    return E(b) === n;
  }, dn.isProfiler = function(b) {
    return E(b) === i;
  }, dn.isStrictMode = function(b) {
    return E(b) === o;
  }, dn.isSuspense = function(b) {
    return E(b) === p;
  }, dn.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === r || b === u || b === i || b === o || b === p || b === d || typeof b == "object" && b !== null && (b.$$typeof === y || b.$$typeof === h || b.$$typeof === s || b.$$typeof === a || b.$$typeof === c || b.$$typeof === g || b.$$typeof === x || b.$$typeof === L || b.$$typeof === f);
  }, dn.typeOf = E, dn;
}
var fn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h_;
function yhe() {
  return h_ || (h_ = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
    function E(A) {
      return typeof A == "string" || typeof A == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      A === r || A === u || A === i || A === o || A === p || A === d || typeof A == "object" && A !== null && (A.$$typeof === y || A.$$typeof === h || A.$$typeof === s || A.$$typeof === a || A.$$typeof === c || A.$$typeof === g || A.$$typeof === x || A.$$typeof === L || A.$$typeof === f);
    }
    function T(A) {
      if (typeof A == "object" && A !== null) {
        var ae = A.$$typeof;
        switch (ae) {
          case t:
            var ce = A.type;
            switch (ce) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ce;
              default:
                var ue = ce && ce.$$typeof;
                switch (ue) {
                  case a:
                  case c:
                  case y:
                  case h:
                  case s:
                    return ue;
                  default:
                    return ae;
                }
            }
          case n:
            return ae;
        }
      }
    }
    var b = l, C = u, M = a, S = s, F = t, D = c, Z = r, U = y, $ = h, N = n, V = i, J = o, j = p, K = !1;
    function te(A) {
      return K || (K = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), O(A) || T(A) === l;
    }
    function O(A) {
      return T(A) === u;
    }
    function P(A) {
      return T(A) === a;
    }
    function H(A) {
      return T(A) === s;
    }
    function I(A) {
      return typeof A == "object" && A !== null && A.$$typeof === t;
    }
    function W(A) {
      return T(A) === c;
    }
    function X(A) {
      return T(A) === r;
    }
    function w(A) {
      return T(A) === y;
    }
    function R(A) {
      return T(A) === h;
    }
    function z(A) {
      return T(A) === n;
    }
    function _(A) {
      return T(A) === i;
    }
    function Y(A) {
      return T(A) === o;
    }
    function Q(A) {
      return T(A) === p;
    }
    fn.AsyncMode = b, fn.ConcurrentMode = C, fn.ContextConsumer = M, fn.ContextProvider = S, fn.Element = F, fn.ForwardRef = D, fn.Fragment = Z, fn.Lazy = U, fn.Memo = $, fn.Portal = N, fn.Profiler = V, fn.StrictMode = J, fn.Suspense = j, fn.isAsyncMode = te, fn.isConcurrentMode = O, fn.isContextConsumer = P, fn.isContextProvider = H, fn.isElement = I, fn.isForwardRef = W, fn.isFragment = X, fn.isLazy = w, fn.isMemo = R, fn.isPortal = z, fn.isProfiler = _, fn.isStrictMode = Y, fn.isSuspense = Q, fn.isValidElementType = E, fn.typeOf = T;
  }()), fn;
}
var g_;
function QF() {
  return g_ || (g_ = 1, process.env.NODE_ENV === "production" ? Gp.exports = vhe() : Gp.exports = yhe()), Gp.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var lv, m_;
function bhe() {
  if (m_) return lv;
  m_ = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return lv = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, lv;
}
var uv, v_;
function mw() {
  if (v_) return uv;
  v_ = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return uv = e, uv;
}
var cv, y_;
function e2() {
  return y_ || (y_ = 1, cv = Function.call.bind(Object.prototype.hasOwnProperty)), cv;
}
var pv, b_;
function whe() {
  if (b_) return pv;
  b_ = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = mw(), n = {}, r = e2();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (y) {
            p = y;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var h = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (h ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, pv = o, pv;
}
var dv, w_;
function Che() {
  if (w_) return dv;
  w_ = 1;
  var e = QF(), t = bhe(), n = mw(), r = e2(), o = whe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return dv = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(O) {
      var P = O && (u && O[u] || O[c]);
      if (typeof P == "function")
        return P;
    }
    var d = "<<anonymous>>", h = {
      array: x("array"),
      bigint: x("bigint"),
      bool: x("boolean"),
      func: x("function"),
      number: x("number"),
      object: x("object"),
      string: x("string"),
      symbol: x("symbol"),
      any: L(),
      arrayOf: E,
      element: T(),
      elementType: b(),
      instanceOf: C,
      node: D(),
      objectOf: S,
      oneOf: M,
      oneOfType: F,
      shape: U,
      exact: $
    };
    function y(O, P) {
      return O === P ? O !== 0 || 1 / O === 1 / P : O !== O && P !== P;
    }
    function f(O, P) {
      this.message = O, this.data = P && typeof P == "object" ? P : {}, this.stack = "";
    }
    f.prototype = Error.prototype;
    function g(O) {
      if (process.env.NODE_ENV !== "production")
        var P = {}, H = 0;
      function I(X, w, R, z, _, Y, Q) {
        if (z = z || d, Y = Y || R, Q !== n) {
          if (l) {
            var A = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw A.name = "Invariant Violation", A;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ae = z + ":" + R;
            !P[ae] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + Y + "` prop on `" + z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), P[ae] = !0, H++);
          }
        }
        return w[R] == null ? X ? w[R] === null ? new f("The " + _ + " `" + Y + "` is marked as required " + ("in `" + z + "`, but its value is `null`.")) : new f("The " + _ + " `" + Y + "` is marked as required in " + ("`" + z + "`, but its value is `undefined`.")) : null : O(w, R, z, _, Y);
      }
      var W = I.bind(null, !1);
      return W.isRequired = I.bind(null, !0), W;
    }
    function x(O) {
      function P(H, I, W, X, w, R) {
        var z = H[I], _ = J(z);
        if (_ !== O) {
          var Y = j(z);
          return new f(
            "Invalid " + X + " `" + w + "` of type " + ("`" + Y + "` supplied to `" + W + "`, expected ") + ("`" + O + "`."),
            { expectedType: O }
          );
        }
        return null;
      }
      return g(P);
    }
    function L() {
      return g(s);
    }
    function E(O) {
      function P(H, I, W, X, w) {
        if (typeof O != "function")
          return new f("Property `" + w + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var R = H[I];
        if (!Array.isArray(R)) {
          var z = J(R);
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected an array."));
        }
        for (var _ = 0; _ < R.length; _++) {
          var Y = O(R, _, W, X, w + "[" + _ + "]", n);
          if (Y instanceof Error)
            return Y;
        }
        return null;
      }
      return g(P);
    }
    function T() {
      function O(P, H, I, W, X) {
        var w = P[H];
        if (!a(w)) {
          var R = J(w);
          return new f("Invalid " + W + " `" + X + "` of type " + ("`" + R + "` supplied to `" + I + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(O);
    }
    function b() {
      function O(P, H, I, W, X) {
        var w = P[H];
        if (!e.isValidElementType(w)) {
          var R = J(w);
          return new f("Invalid " + W + " `" + X + "` of type " + ("`" + R + "` supplied to `" + I + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(O);
    }
    function C(O) {
      function P(H, I, W, X, w) {
        if (!(H[I] instanceof O)) {
          var R = O.name || d, z = te(H[I]);
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected ") + ("instance of `" + R + "`."));
        }
        return null;
      }
      return g(P);
    }
    function M(O) {
      if (!Array.isArray(O))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function P(H, I, W, X, w) {
        for (var R = H[I], z = 0; z < O.length; z++)
          if (y(R, O[z]))
            return null;
        var _ = JSON.stringify(O, function(Q, A) {
          var ae = j(A);
          return ae === "symbol" ? String(A) : A;
        });
        return new f("Invalid " + X + " `" + w + "` of value `" + String(R) + "` " + ("supplied to `" + W + "`, expected one of " + _ + "."));
      }
      return g(P);
    }
    function S(O) {
      function P(H, I, W, X, w) {
        if (typeof O != "function")
          return new f("Property `" + w + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type " + ("`" + z + "` supplied to `" + W + "`, expected an object."));
        for (var _ in R)
          if (r(R, _)) {
            var Y = O(R, _, W, X, w + "." + _, n);
            if (Y instanceof Error)
              return Y;
          }
        return null;
      }
      return g(P);
    }
    function F(O) {
      if (!Array.isArray(O))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var P = 0; P < O.length; P++) {
        var H = O[P];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + K(H) + " at index " + P + "."
          ), s;
      }
      function I(W, X, w, R, z) {
        for (var _ = [], Y = 0; Y < O.length; Y++) {
          var Q = O[Y], A = Q(W, X, w, R, z, n);
          if (A == null)
            return null;
          A.data && r(A.data, "expectedType") && _.push(A.data.expectedType);
        }
        var ae = _.length > 0 ? ", expected one of type [" + _.join(", ") + "]" : "";
        return new f("Invalid " + R + " `" + z + "` supplied to " + ("`" + w + "`" + ae + "."));
      }
      return g(I);
    }
    function D() {
      function O(P, H, I, W, X) {
        return N(P[H]) ? null : new f("Invalid " + W + " `" + X + "` supplied to " + ("`" + I + "`, expected a ReactNode."));
      }
      return g(O);
    }
    function Z(O, P, H, I, W) {
      return new f(
        (O || "React class") + ": " + P + " type `" + H + "." + I + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function U(O) {
      function P(H, I, W, X, w) {
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type `" + z + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var _ in O) {
          var Y = O[_];
          if (typeof Y != "function")
            return Z(W, X, w, _, j(Y));
          var Q = Y(R, _, W, X, w + "." + _, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return g(P);
    }
    function $(O) {
      function P(H, I, W, X, w) {
        var R = H[I], z = J(R);
        if (z !== "object")
          return new f("Invalid " + X + " `" + w + "` of type `" + z + "` " + ("supplied to `" + W + "`, expected `object`."));
        var _ = t({}, H[I], O);
        for (var Y in _) {
          var Q = O[Y];
          if (r(O, Y) && typeof Q != "function")
            return Z(W, X, w, Y, j(Q));
          if (!Q)
            return new f(
              "Invalid " + X + " `" + w + "` key `" + Y + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(H[I], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(O), null, "  ")
            );
          var A = Q(R, Y, W, X, w + "." + Y, n);
          if (A)
            return A;
        }
        return null;
      }
      return g(P);
    }
    function N(O) {
      switch (typeof O) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !O;
        case "object":
          if (Array.isArray(O))
            return O.every(N);
          if (O === null || a(O))
            return !0;
          var P = p(O);
          if (P) {
            var H = P.call(O), I;
            if (P !== O.entries) {
              for (; !(I = H.next()).done; )
                if (!N(I.value))
                  return !1;
            } else
              for (; !(I = H.next()).done; ) {
                var W = I.value;
                if (W && !N(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function V(O, P) {
      return O === "symbol" ? !0 : P ? P["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && P instanceof Symbol : !1;
    }
    function J(O) {
      var P = typeof O;
      return Array.isArray(O) ? "array" : O instanceof RegExp ? "object" : V(P, O) ? "symbol" : P;
    }
    function j(O) {
      if (typeof O > "u" || O === null)
        return "" + O;
      var P = J(O);
      if (P === "object") {
        if (O instanceof Date)
          return "date";
        if (O instanceof RegExp)
          return "regexp";
      }
      return P;
    }
    function K(O) {
      var P = j(O);
      switch (P) {
        case "array":
        case "object":
          return "an " + P;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + P;
        default:
          return P;
      }
    }
    function te(O) {
      return !O.constructor || !O.constructor.name ? d : O.constructor.name;
    }
    return h.checkPropTypes = o, h.resetWarningCache = o.resetWarningCache, h.PropTypes = h, h;
  }, dv;
}
var fv, C_;
function xhe() {
  if (C_) return fv;
  C_ = 1;
  var e = mw();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, fv = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, fv;
}
if (process.env.NODE_ENV !== "production") {
  var Ehe = QF(), Lhe = !0;
  f0.exports = Che()(Ehe.isElement, Lhe);
} else
  f0.exports = xhe()();
var Yh = f0.exports, Jh = {};
Object.defineProperty(Jh, "__esModule", {
  value: !0
});
var khe = mc, hv = Ohe(khe);
function Ohe(e) {
  return e && e.__esModule ? e : { default: e };
}
var Mhe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return hv.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && hv.default.getHash() !== t && hv.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Jh.default = Mhe;
Object.defineProperty(fc, "__esModule", {
  value: !0
});
var Xp = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, She = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Dhe = Ae, x_ = bc(Dhe), Phe = hc, Yp = bc(Phe), The = rl, _he = bc(The), Ahe = Yh, pr = bc(Ahe), Bhe = Jh, ns = bc(Bhe);
function bc(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ihe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function jhe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Rhe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var E_ = {
  to: pr.default.string.isRequired,
  containerId: pr.default.string,
  container: pr.default.object,
  activeClass: pr.default.string,
  activeStyle: pr.default.object,
  spy: pr.default.bool,
  horizontal: pr.default.bool,
  smooth: pr.default.oneOfType([pr.default.bool, pr.default.string]),
  offset: pr.default.number,
  delay: pr.default.number,
  isDynamic: pr.default.bool,
  onClick: pr.default.func,
  duration: pr.default.oneOfType([pr.default.number, pr.default.func]),
  absolute: pr.default.bool,
  onSetActive: pr.default.func,
  onSetInactive: pr.default.func,
  ignoreCancelEvents: pr.default.bool,
  hashSpy: pr.default.bool,
  saveHashHistory: pr.default.bool,
  spyThrottle: pr.default.number
};
fc.default = function(e, t) {
  var n = t || _he.default, r = function(i) {
    Rhe(s, i);
    function s(a) {
      Ihe(this, s);
      var l = jhe(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return She(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          Yp.default.isMounted(l) || Yp.default.mount(l, this.props.spyThrottle), this.props.hashSpy && (ns.default.isMounted() || ns.default.mount(n), ns.default.mapContainer(this.props.to, l)), Yp.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Yp.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = Xp({}, this.props.style, this.props.activeStyle) : u = Xp({}, this.props.style);
        var c = Xp({}, this.props);
        for (var p in E_)
          c.hasOwnProperty(p) && delete c[p];
        return c.className = l, c.style = u, c.onClick = this.handleClick, x_.default.createElement(e, c);
      }
    }]), s;
  }(x_.default.PureComponent), o = function() {
    var s = this;
    this.scrollTo = function(a, l) {
      n.scrollTo(a, Xp({}, s.state, l));
    }, this.handleClick = function(a) {
      s.props.onClick && s.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), s.scrollTo(s.props.to, s.props);
    }, this.spyHandler = function(a, l) {
      var u = s.getScrollSpyContainer();
      if (!(ns.default.isMounted() && !ns.default.isInitialized())) {
        var c = s.props.horizontal, p = s.props.to, d = null, h = void 0, y = void 0;
        if (c) {
          var f = 0, g = 0, x = 0;
          if (u.getBoundingClientRect) {
            var L = u.getBoundingClientRect();
            x = L.left;
          }
          if (!d || s.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var E = d.getBoundingClientRect();
            f = E.left - x + a, g = f + E.width;
          }
          var T = a - s.props.offset;
          h = T >= Math.floor(f) && T < Math.floor(g), y = T < Math.floor(f) || T >= Math.floor(g);
        } else {
          var b = 0, C = 0, M = 0;
          if (u.getBoundingClientRect) {
            var S = u.getBoundingClientRect();
            M = S.top;
          }
          if (!d || s.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var F = d.getBoundingClientRect();
            b = F.top - M + l, C = b + F.height;
          }
          var D = l - s.props.offset;
          h = D >= Math.floor(b) && D < Math.floor(C), y = D < Math.floor(b) || D >= Math.floor(C);
        }
        var Z = n.getActiveLink();
        if (y) {
          if (p === Z && n.setActiveLink(void 0), s.props.hashSpy && ns.default.getHash() === p) {
            var U = s.props.saveHashHistory, $ = U === void 0 ? !1 : U;
            ns.default.changeHash("", $);
          }
          s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive(p, d));
        }
        if (h && (Z !== p || s.state.active === !1)) {
          n.setActiveLink(p);
          var N = s.props.saveHashHistory, V = N === void 0 ? !1 : N;
          s.props.hashSpy && ns.default.changeHash(p, V), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(p, d));
        }
      }
    };
  };
  return r.propTypes = E_, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(pw, "__esModule", {
  value: !0
});
var Nhe = Ae, L_ = t2(Nhe), Fhe = fc, zhe = t2(Fhe);
function t2(e) {
  return e && e.__esModule ? e : { default: e };
}
function Uhe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function k_(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function $he(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Whe = function(e) {
  $he(t, e);
  function t() {
    var n, r, o, i;
    Uhe(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = k_(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return L_.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), k_(o, i);
  }
  return t;
}(L_.default.Component);
pw.default = (0, zhe.default)(Whe);
var vw = {};
Object.defineProperty(vw, "__esModule", {
  value: !0
});
var Hhe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Vhe = Ae, O_ = n2(Vhe), Zhe = fc, qhe = n2(Zhe);
function n2(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ghe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Xhe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Yhe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Jhe = function(e) {
  Yhe(t, e);
  function t() {
    return Ghe(this, t), Xhe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Hhe(t, [{
    key: "render",
    value: function() {
      return O_.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(O_.default.Component);
vw.default = (0, qhe.default)(Jhe);
var yw = {}, Kh = {};
Object.defineProperty(Kh, "__esModule", {
  value: !0
});
var Khe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Qhe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ege = Ae, M_ = Qh(ege), tge = qa;
Qh(tge);
var nge = rl, S_ = Qh(nge), rge = Yh, D_ = Qh(rge);
function Qh(e) {
  return e && e.__esModule ? e : { default: e };
}
function oge(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ige(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function sge(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Kh.default = function(e) {
  var t = function(n) {
    sge(r, n);
    function r(o) {
      oge(this, r);
      var i = ige(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Qhe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        S_.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        S_.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return M_.default.createElement(e, Khe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(M_.default.Component);
  return t.propTypes = {
    name: D_.default.string,
    id: D_.default.string
  }, t;
};
Object.defineProperty(yw, "__esModule", {
  value: !0
});
var P_ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, age = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), lge = Ae, T_ = bw(lge), uge = Kh, cge = bw(uge), pge = Yh, __ = bw(pge);
function bw(e) {
  return e && e.__esModule ? e : { default: e };
}
function dge(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fge(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function hge(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var r2 = function(e) {
  hge(t, e);
  function t() {
    return dge(this, t), fge(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return age(t, [{
    key: "render",
    value: function() {
      var r = this, o = P_({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, T_.default.createElement(
        "div",
        P_({}, o, { ref: function(s) {
          r.props.parentBindings.domNode = s;
        } }),
        this.props.children
      );
    }
  }]), t;
}(T_.default.Component);
r2.propTypes = {
  name: __.default.string,
  id: __.default.string
};
yw.default = (0, cge.default)(r2);
var gv = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, A_ = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function B_(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function I_(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function j_(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Jp = Ae, Js = hc, mv = rl, xr = Yh, rs = Jh, R_ = {
  to: xr.string.isRequired,
  containerId: xr.string,
  container: xr.object,
  activeClass: xr.string,
  spy: xr.bool,
  smooth: xr.oneOfType([xr.bool, xr.string]),
  offset: xr.number,
  delay: xr.number,
  isDynamic: xr.bool,
  onClick: xr.func,
  duration: xr.oneOfType([xr.number, xr.func]),
  absolute: xr.bool,
  onSetActive: xr.func,
  onSetInactive: xr.func,
  ignoreCancelEvents: xr.bool,
  hashSpy: xr.bool,
  spyThrottle: xr.number
}, gge = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || mv, o = function(s) {
      j_(a, s);
      function a(l) {
        B_(this, a);
        var u = I_(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return A_(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            Js.isMounted(u) || Js.mount(u, this.props.spyThrottle), this.props.hashSpy && (rs.isMounted() || rs.mount(r), rs.mapContainer(this.props.to, u)), this.props.spy && Js.addStateHandler(this.stateHandler), Js.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Js.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = gv({}, this.props);
          for (var p in R_)
            c.hasOwnProperty(p) && delete c[p];
          return c.className = u, c.onClick = this.handleClick, Jp.createElement(t, c);
        }
      }]), a;
    }(Jp.Component), i = function() {
      var a = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, gv({}, a.state, u));
      }, this.handleClick = function(l) {
        a.props.onClick && a.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), a.scrollTo(a.props.to, a.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== a.props.to && (a.state !== null && a.state.active && a.props.onSetInactive && a.props.onSetInactive(), a.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = a.getScrollSpyContainer();
        if (!(rs.isMounted() && !rs.isInitialized())) {
          var c = a.props.to, p = null, d = 0, h = 0, y = 0;
          if (u.getBoundingClientRect) {
            var f = u.getBoundingClientRect();
            y = f.top;
          }
          if (!p || a.props.isDynamic) {
            if (p = r.get(c), !p)
              return;
            var g = p.getBoundingClientRect();
            d = g.top - y + l, h = d + g.height;
          }
          var x = l - a.props.offset, L = x >= Math.floor(d) && x < Math.floor(h), E = x < Math.floor(d) || x >= Math.floor(h), T = r.getActiveLink();
          if (E)
            return c === T && r.setActiveLink(void 0), a.props.hashSpy && rs.getHash() === c && rs.changeHash(), a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive()), Js.updateStates();
          if (L && T !== c)
            return r.setActiveLink(c), a.props.hashSpy && rs.changeHash(c), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(c)), Js.updateStates();
        }
      };
    };
    return o.propTypes = R_, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      j_(o, r);
      function o(i) {
        B_(this, o);
        var s = I_(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return s.childBindings = {
          domNode: null
        }, s;
      }
      return A_(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(s) {
          this.props.name !== s.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          mv.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(s) {
          mv.register(s, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Jp.createElement(t, gv({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(Jp.Component);
    return n.propTypes = {
      name: xr.string,
      id: xr.string
    }, n;
  }
}, mge = gge;
Object.defineProperty(Tr, "__esModule", {
  value: !0
});
Tr.Helpers = Tr.ScrollElement = Tr.ScrollLink = h2 = Tr.animateScroll = Tr.scrollSpy = Tr.Events = Tr.scroller = Tr.Element = Tr.Button = Tr.Link = void 0;
var vge = pw, o2 = vi(vge), yge = vw, i2 = vi(yge), bge = yw, s2 = vi(bge), wge = rl, a2 = vi(wge), Cge = vc, l2 = vi(Cge), xge = hc, u2 = vi(xge), Ege = qh, c2 = vi(Ege), Lge = fc, p2 = vi(Lge), kge = Kh, d2 = vi(kge), Oge = mge, f2 = vi(Oge);
function vi(e) {
  return e && e.__esModule ? e : { default: e };
}
Tr.Link = o2.default;
Tr.Button = i2.default;
Tr.Element = s2.default;
Tr.scroller = a2.default;
Tr.Events = l2.default;
Tr.scrollSpy = u2.default;
var h2 = Tr.animateScroll = c2.default;
Tr.ScrollLink = p2.default;
Tr.ScrollElement = d2.default;
Tr.Helpers = f2.default;
Tr.default = { Link: o2.default, Button: i2.default, Element: s2.default, scroller: a2.default, Events: l2.default, scrollSpy: u2.default, animateScroll: c2.default, ScrollLink: p2.default, ScrollElement: d2.default, Helpers: f2.default };
const ww = qe({}), g2 = qe({});
function Mge() {
  const e = Te(g2);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function N_(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function pve() {
  const e = v0(), { closeModal: t, closeAll: n } = Te(ww), { showToast: r } = Mge(), { getParam: o } = VF(), { pathname: i } = y0(), s = X_(), a = o("closeAllModals");
  m(() => {
    a === "true" && (n(), s(i));
  }, [a]), m(() => {
    const l = e == null ? void 0 : e.closeModalKey;
    l && t(l);
  }, [e]), m(() => {
    const l = e == null ? void 0 : e.toast, u = e == null ? void 0 : e.message;
    N_(l) && r(l), !N_(l) && u && r({ message: u, type: "danger" });
  }, [e]), m(() => {
    var l, u;
    if (typeof ((l = e == null ? void 0 : e.data) == null ? void 0 : l.scrollTo) == "string") {
      const c = document.getElementById((u = e == null ? void 0 : e.data) == null ? void 0 : u.scrollTo);
      c && h2.scrollTo(c.offsetTop - 200);
    }
  }, [e]);
}
const m2 = qe({});
function dve(e) {
  const t = Te(m2);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, s = r(e), a = n(e);
    return { drawerIsOpen: s, drawerData: a, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function fve(e) {
  const t = Te(ww);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, s = r(e), a = n(e);
    return { modalIsOpen: s, modalData: a, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function hve(e) {
  const { children: t = !1 } = e, [n, r] = k([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function s(l, u) {
    const c = o(l);
    r(c ? (p) => [...p.filter((h) => h.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function a(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ re.jsx(
    m2.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: s, closeDrawer: a },
      children: t
    }
  );
}
function gve({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ re.jsx(
    lz,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function mve(e) {
  const { children: t = !1 } = e, [n, r] = k([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((p) => p.key === u)) == null ? void 0 : c.data;
  }
  function s(u, c) {
    const p = o(u);
    r(p ? (d) => [...d.filter((y) => y.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function a(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ re.jsx(
    ww.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: s, closeModal: a, closeAll: l },
      children: t
    }
  );
}
let Sge = { data: "" }, Dge = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Sge, Pge = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Tge = /\/\*[^]*?\*\/|  +/g, F_ = /\n+/g, ws = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? ws(s, i) : i + "{" + ws(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += ws(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ws.p ? ws.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Di = {}, v2 = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + v2(e[n]);
    return t;
  }
  return e;
}, _ge = (e, t, n, r, o) => {
  let i = v2(e), s = Di[i] || (Di[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Di[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Pge.exec(u.replace(Tge, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(F_, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(F_, " ").trim();
      return d[0];
    })(e);
    Di[s] = ws(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Di.g ? Di.g : null;
  return n && (Di.g = Di[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Di[s], t, r, a), s;
}, Age = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : ws(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function eg(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return _ge(n.unshift ? n.raw ? Age(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Dge(t.target), t.g, t.o, t.k);
}
let y2, h0, g0;
eg.bind({ g: 1 });
let zi = eg.bind({ k: 1 });
function Bge(e, t, n, r) {
  ws.p = t, y2 = e, h0 = n, g0 = r;
}
function zs(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: h0 && h0() }, a), n.o = / *go\d+/.test(l), a.className = eg.apply(n, r) + (l ? " " + l : ""), t && (a.ref = s);
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), g0 && u[0] && g0(a), y2(u, a);
    }
    return t ? t(o) : o;
  };
}
var Ige = (e) => typeof e == "function", ef = (e, t) => Ige(e) ? e(t) : e, jge = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), b2 = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Rge = 20, ud = /* @__PURE__ */ new Map(), Nge = 1e3, z_ = (e) => {
  if (ud.has(e)) return;
  let t = setTimeout(() => {
    ud.delete(e), Ia({ type: 4, toastId: e });
  }, Nge);
  ud.set(e, t);
}, Fge = (e) => {
  let t = ud.get(e);
  t && clearTimeout(t);
}, m0 = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, Rge) };
    case 1:
      return t.toast.id && Fge(t.toast.id), { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return e.toasts.find((i) => i.id === n.id) ? m0(e, { type: 1, toast: n }) : m0(e, { type: 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return r ? z_(r) : e.toasts.forEach((i) => {
        z_(i.id);
      }), { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, cd = [], pd = { toasts: [], pausedAt: void 0 }, Ia = (e) => {
  pd = m0(pd, e), cd.forEach((t) => {
    t(pd);
  });
}, zge = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, Uge = (e = {}) => {
  let [t, n] = k(pd);
  m(() => (cd.push(n), () => {
    let o = cd.indexOf(n);
    o > -1 && cd.splice(o, 1);
  }), [t]);
  let r = t.toasts.map((o) => {
    var i, s;
    return { ...e, ...e[o.type], ...o, duration: o.duration || ((i = e[o.type]) == null ? void 0 : i.duration) || (e == null ? void 0 : e.duration) || zge[o.type], style: { ...e.style, ...(s = e[o.type]) == null ? void 0 : s.style, ...o.style } };
  });
  return { ...t, toasts: r };
}, $ge = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || jge() }), wc = (e) => (t, n) => {
  let r = $ge(t, e, n);
  return Ia({ type: 2, toast: r }), r.id;
}, So = (e, t) => wc("blank")(e, t);
So.error = wc("error");
So.success = wc("success");
So.loading = wc("loading");
So.custom = wc("custom");
So.dismiss = (e) => {
  Ia({ type: 3, toastId: e });
};
So.remove = (e) => Ia({ type: 4, toastId: e });
So.promise = (e, t, n) => {
  let r = So.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return e.then((o) => (So.success(ef(t.success, o), { id: r, ...n, ...n == null ? void 0 : n.success }), o)).catch((o) => {
    So.error(ef(t.error, o), { id: r, ...n, ...n == null ? void 0 : n.error });
  }), e;
};
var Wge = (e, t) => {
  Ia({ type: 1, toast: { id: e, height: t } });
}, Hge = () => {
  Ia({ type: 5, time: Date.now() });
}, Vge = (e) => {
  let { toasts: t, pausedAt: n } = Uge(e);
  m(() => {
    if (n) return;
    let i = Date.now(), s = t.map((a) => {
      if (a.duration === 1 / 0) return;
      let l = (a.duration || 0) + a.pauseDuration - (i - a.createdAt);
      if (l < 0) {
        a.visible && So.dismiss(a.id);
        return;
      }
      return setTimeout(() => So.dismiss(a.id), l);
    });
    return () => {
      s.forEach((a) => a && clearTimeout(a));
    };
  }, [t, n]);
  let r = hn(() => {
    n && Ia({ type: 6, time: Date.now() });
  }, [n]), o = hn((i, s) => {
    let { reverseOrder: a = !1, gutter: l = 8, defaultPosition: u } = s || {}, c = t.filter((h) => (h.position || u) === (i.position || u) && h.height), p = c.findIndex((h) => h.id === i.id), d = c.filter((h, y) => y < p && h.visible).length;
    return c.filter((h) => h.visible).slice(...a ? [d + 1] : [0, d]).reduce((h, y) => h + (y.height || 0) + l, 0);
  }, [t]);
  return { toasts: t, handlers: { updateHeight: Wge, startPause: Hge, endPause: r, calculateOffset: o } };
}, Zge = zi`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, qge = zi`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Gge = zi`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Xge = zs("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Zge} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${qge} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Gge} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Yge = zi`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Jge = zs("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Yge} 1s linear infinite;
`, Kge = zi`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Qge = zi`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, eme = zs("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Kge} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Qge} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, tme = zs("div")`
  position: absolute;
`, nme = zs("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, rme = zi`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, ome = zs("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${rme} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, ime = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? He.createElement(ome, null, t) : t : n === "blank" ? null : He.createElement(nme, null, He.createElement(Jge, { ...r }), n !== "loading" && He.createElement(tme, null, n === "error" ? He.createElement(Xge, { ...r }) : He.createElement(eme, { ...r })));
}, sme = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ame = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, lme = "0%{opacity:0;} 100%{opacity:1;}", ume = "0%{opacity:1;} 100%{opacity:0;}", cme = zs("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, pme = zs("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, dme = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = b2() ? [lme, ume] : [sme(n), ame(n)];
  return { animation: t ? `${zi(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${zi(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, fme = He.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? dme(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = He.createElement(ime, { toast: e }), s = He.createElement(pme, { ...e.ariaProps }, ef(e.message, e));
  return He.createElement(cme, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : He.createElement(He.Fragment, null, i, s));
});
Bge(He.createElement);
var hme = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = He.useCallback((s) => {
    if (s) {
      let a = () => {
        let l = s.getBoundingClientRect().height;
        r(e, l);
      };
      a(), new MutationObserver(a).observe(s, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return He.createElement("div", { ref: i, className: t, style: n }, o);
}, gme = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: b2() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, mme = eg`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, Kp = 16, vme = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: s }) => {
  let { toasts: a, handlers: l } = Vge(n);
  return He.createElement("div", { style: { position: "fixed", zIndex: 9999, top: Kp, left: Kp, right: Kp, bottom: Kp, pointerEvents: "none", ...i }, className: s, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, a.map((u) => {
    let c = u.position || t, p = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), d = gme(c, p);
    return He.createElement(hme, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? mme : "", style: d }, u.type === "custom" ? ef(u.message, u) : o ? o(u) : He.createElement(fme, { toast: u, position: c }));
  }));
}, U_ = So;
function vve({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return U_.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return U_.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ re.jsxs(g2.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ re.jsx(
      vme,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
export {
  Lme as AlertContainer,
  kme as AlertContent,
  Ome as AlertDescription,
  Mme as AlertIcon,
  H2 as AlertTitle,
  Sme as Badge,
  Kme as BreadcrumbContainer,
  Qme as BreadcrumbLink,
  Nme as Button,
  Dme as Card,
  zme as Checkbox,
  Pme as Divider,
  rve as DrawerContainer,
  ove as DrawerHeader,
  hve as DrawerProvider,
  Fme as FormController,
  Ume as FormError,
  $me as FormLabel,
  Tme as GoogleMap,
  gve as GoogleProvider,
  Wme as GoogleSearchPlaces,
  Hme as IconButton,
  Vme as ImageUpload,
  gA as Input,
  ive as ModalContainer,
  sve as ModalFooter,
  ave as ModalHeader,
  mve as ModalProvider,
  eve as Pagination,
  lve as Popover,
  qme as RadioBox,
  Zme as RadioGroup,
  Gme as RichText,
  Xme as Select,
  _me as Skeleton,
  Yme as Switch,
  nve as TabButton,
  tve as TabContainer,
  Ame as TableBody,
  Bme as TableCaption,
  Ime as TableContainer,
  jme as TableFooter,
  Rme as TableHeader,
  Jme as Textarea,
  uve as Toast,
  vve as ToastProvider,
  cve as Tooltip,
  pve as useAutomation,
  dve as useDrawer,
  hU as useFieldErrors,
  fve as useModal,
  VF as useScopedParams,
  Mge as useToast
};
