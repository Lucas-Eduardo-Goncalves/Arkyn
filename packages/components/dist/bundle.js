var L$ = Object.defineProperty;
var P$ = (e, t, n) => t in e ? L$(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Gc = (e, t, n) => P$(e, typeof t != "symbol" ? t + "" : t, n);
import * as ze from "react";
import Oe, { createContext as qe, useContext as Ee, Children as it, forwardRef as Ir, useState as k, useEffect as v, memo as ke, useRef as Qe, useMemo as Bn, isValidElement as ti, cloneElement as ni, Component as uc, PureComponent as be, createRef as Hr, useId as S$, useCallback as dn, useLayoutEffect as D$, useReducer as M$, useSyncExternalStore as T$ } from "react";
import { Info as fR, AlertTriangle as j$, XCircle as hR, CheckCircle2 as gR, Loader2 as ri, Pause as A$, Play as B$, RefreshCw as _0, Check as hh, FileImage as R$, FileAudio as I$, FileArchive as N$, File as F$, ChevronDown as L0, X as P0, Search as mR, Image as z$, Heading1 as U$, Heading2 as $$, Quote as W$, Bold as V$, Italic as H$, Underline as G$, Code as q$, AlignLeft as Z$, AlignRight as K$, AlignCenter as X$, AlignJustify as Y$, ChevronRight as Ty, ChevronLeft as J$, Ellipsis as Ix, MapPinned as Q$ } from "lucide-react";
import { useActionData as S0, useNavigation as vR, useFetchers as D0, useLocation as M0, Link as eW, useNavigate as yR } from "@remix-run/react";
import { InputMask as el } from "@react-input/mask";
import { AnimatePresence as bR, motion as Ou } from "framer-motion";
import * as oi from "react-dom";
import tl, { createPortal as br } from "react-dom";
var xn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function gh(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var jy = { exports: {} }, vl = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Nx;
function tW() {
  if (Nx) return vl;
  Nx = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return vl.Fragment = n, vl.jsx = a, vl.jsxs = a, vl;
}
var yl = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Fx;
function nW() {
  return Fx || (Fx = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var R = f && b[f] || b[m];
      return typeof R == "function" ? R : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var R = arguments.length, Y = new Array(R > 1 ? R - 1 : 0), ne = 1; ne < R; ne++)
          Y[ne - 1] = arguments[ne];
        S("error", b, Y);
      }
    }
    function S(b, R, Y) {
      {
        var ne = E.ReactDebugCurrentFrame, ue = ne.getStackAddendum();
        ue !== "" && (R += "%s", Y = Y.concat([ue]));
        var ce = Y.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + R), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, y = !1, C = !1, P = !1, F = !1, _;
    _ = Symbol.for("react.module.reference");
    function I(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || P || b === g || x || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === _ || b.getModuleId !== void 0));
    }
    function B(b, R, Y) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var ue = R.displayName || R.name || "";
      return ue !== "" ? Y + "(" + ue + ")" : Y;
    }
    function $(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var R = b;
            return $(R) + ".Consumer";
          case a:
            var Y = b;
            return $(Y._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var ue = b, ce = ue._payload, ae = ue._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, H = 0, X, J, te, ee, L, T, W;
    function D() {
    }
    D.__reactDisabledLog = !0;
    function G() {
      {
        if (H === 0) {
          X = console.log, J = console.info, te = console.warn, ee = console.error, L = console.group, T = console.groupCollapsed, W = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: D,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        H++;
      }
    }
    function O() {
      {
        if (H--, H === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: X
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: L
            }),
            groupCollapsed: z({}, b, {
              value: T
            }),
            groupEnd: z({}, b, {
              value: W
            })
          });
        }
        H < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = E.ReactCurrentDispatcher, U;
    function j(b, R, Y) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ue) {
            var ne = ue.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var Z = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function N(b, R) {
      if (!b || Z)
        return "";
      {
        var Y = A.get(b);
        if (Y !== void 0)
          return Y;
      }
      var ne;
      Z = !0;
      var ue = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = M.current, M.current = null, G();
      try {
        if (R) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Ne) {
              ne = Ne;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Ne) {
              ne = Ne;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            ne = Ne;
          }
          b();
        }
      } catch (Ne) {
        if (Ne && ne && typeof Ne.stack == "string") {
          for (var se = Ne.stack.split(`
`), Ae = ne.stack.split(`
`), we = se.length - 1, xe = Ae.length - 1; we >= 1 && xe >= 0 && se[we] !== Ae[xe]; )
            xe--;
          for (; we >= 1 && xe >= 0; we--, xe--)
            if (se[we] !== Ae[xe]) {
              if (we !== 1 || xe !== 1)
                do
                  if (we--, xe--, xe < 0 || se[we] !== Ae[xe]) {
                    var Ge = `
` + se[we].replace(" at new ", " at ");
                    return b.displayName && Ge.includes("<anonymous>") && (Ge = Ge.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ge), Ge;
                  }
                while (we >= 1 && xe >= 0);
              break;
            }
        }
      } finally {
        Z = !1, M.current = ce, O(), Error.prepareStackTrace = ue;
      }
      var Jt = b ? b.displayName || b.name : "", Et = Jt ? j(Jt) : "";
      return typeof b == "function" && A.set(b, Et), Et;
    }
    function le(b, R, Y) {
      return N(b, !1);
    }
    function ye(b) {
      var R = b.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(b, R, Y) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, ye(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return le(b.render);
          case p:
            return oe(b.type, R, Y);
          case d: {
            var ne = b, ue = ne._payload, ce = ne._init;
            try {
              return oe(ce(ue), R, Y);
            } catch {
            }
          }
        }
      return "";
    }
    var Be = Object.prototype.hasOwnProperty, Ue = {}, $e = E.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var R = b._owner, Y = oe(b.type, b._source, R ? R.type : null);
        $e.setExtraStackFrame(Y);
      } else
        $e.setExtraStackFrame(null);
    }
    function Je(b, R, Y, ne, ue) {
      {
        var ce = Function.call.bind(Be);
        for (var ae in b)
          if (ce(b, ae)) {
            var se = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Ae = Error((ne || "React class") + ": " + Y + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ae.name = "Invariant Violation", Ae;
              }
              se = b[ae](R, ae, ne, Y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (we) {
              se = we;
            }
            se && !(se instanceof Error) && (Ie(ue), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", Y, ae, typeof se), Ie(null)), se instanceof Error && !(se.message in Ue) && (Ue[se.message] = !0, Ie(ue), w("Failed %s type: %s", Y, se.message), Ie(null));
          }
      }
    }
    var Ze = Array.isArray;
    function Me(b) {
      return Ze(b);
    }
    function Ye(b) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, Y = R && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Y;
      }
    }
    function nt(b) {
      try {
        return De(b), !1;
      } catch {
        return !0;
      }
    }
    function De(b) {
      return "" + b;
    }
    function je(b) {
      if (nt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ye(b)), De(b);
    }
    var Ke = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Fe, et;
    function Re(b) {
      if (Be.call(b, "ref")) {
        var R = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function Rt(b) {
      if (Be.call(b, "key")) {
        var R = Object.getOwnPropertyDescriptor(b, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function rt(b, R) {
      typeof b.ref == "string" && Ke.current;
    }
    function ot(b, R) {
      {
        var Y = function() {
          Fe || (Fe = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Y,
          configurable: !0
        });
      }
    }
    function at(b, R) {
      {
        var Y = function() {
          et || (et = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Y,
          configurable: !0
        });
      }
    }
    var Kt = function(b, R, Y, ne, ue, ce, ae) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: R,
        ref: Y,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ue
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function lt(b, R, Y, ne, ue) {
      {
        var ce, ae = {}, se = null, Ae = null;
        Y !== void 0 && (je(Y), se = "" + Y), Rt(R) && (je(R.key), se = "" + R.key), Re(R) && (Ae = R.ref, rt(R, ue));
        for (ce in R)
          Be.call(R, ce) && !We.hasOwnProperty(ce) && (ae[ce] = R[ce]);
        if (b && b.defaultProps) {
          var we = b.defaultProps;
          for (ce in we)
            ae[ce] === void 0 && (ae[ce] = we[ce]);
        }
        if (se || Ae) {
          var xe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && ot(ae, xe), Ae && at(ae, xe);
        }
        return Kt(b, se, Ae, ue, ne, Ke.current, ae);
      }
    }
    var ut = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var R = b._owner, Y = oe(b.type, b._source, R ? R.type : null);
        tt.setExtraStackFrame(Y);
      } else
        tt.setExtraStackFrame(null);
    }
    var Xt;
    Xt = !1;
    function Yt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function bt() {
      {
        if (ut.current) {
          var b = V(ut.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Rn(b) {
      return "";
    }
    var wt = {};
    function In(b) {
      {
        var R = bt();
        if (!R) {
          var Y = typeof b == "string" ? b : b.displayName || b.name;
          Y && (R = `

Check the top-level render call using <` + Y + ">.");
        }
        return R;
      }
    }
    function Ct(b, R) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Y = In(R);
        if (wt[Y])
          return;
        wt[Y] = !0;
        var ne = "";
        b && b._owner && b._owner !== ut.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Y, ne), Xe(null);
      }
    }
    function fn(b, R) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var Y = 0; Y < b.length; Y++) {
            var ne = b[Y];
            Yt(ne) && Ct(ne, R);
          }
        else if (Yt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ue = h(b);
          if (typeof ue == "function" && ue !== b.entries)
            for (var ce = ue.call(b), ae; !(ae = ce.next()).done; )
              Yt(ae.value) && Ct(ae.value, R);
        }
      }
    }
    function wr(b) {
      {
        var R = b.type;
        if (R == null || typeof R == "string")
          return;
        var Y;
        if (typeof R == "function")
          Y = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          Y = R.propTypes;
        else
          return;
        if (Y) {
          var ne = V(R);
          Je(Y, b.props, "prop", ne, b);
        } else if (R.PropTypes !== void 0 && !Xt) {
          Xt = !0;
          var ue = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ue || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function xt(b) {
      {
        for (var R = Object.keys(b.props), Y = 0; Y < R.length; Y++) {
          var ne = R[Y];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function Qr(b, R, Y, ne, ue, ce) {
      {
        var ae = I(b);
        if (!ae) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ae = Rn();
          Ae ? se += Ae : se += bt();
          var we;
          b === null ? we = "null" : Me(b) ? we = "array" : b !== void 0 && b.$$typeof === t ? (we = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : we = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", we, se);
        }
        var xe = lt(b, R, Y, ue, ce);
        if (xe == null)
          return xe;
        if (ae) {
          var Ge = R.children;
          if (Ge !== void 0)
            if (ne)
              if (Me(Ge)) {
                for (var Jt = 0; Jt < Ge.length; Jt++)
                  fn(Ge[Jt], b);
                Object.freeze && Object.freeze(Ge);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              fn(Ge, b);
        }
        if (Be.call(R, "key")) {
          var Et = V(b), Ne = Object.keys(R).filter(function(gi) {
            return gi !== "key";
          }), Cr = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[Et + Cr]) {
            var hi = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Cr, Et, hi, Et), re[Et + Cr] = !0;
          }
        }
        return b === r ? xt(xe) : wr(xe), xe;
      }
    }
    function ci(b, R, Y) {
      return Qr(b, R, Y, !0);
    }
    function pi(b, R, Y) {
      return Qr(b, R, Y, !1);
    }
    var di = pi, fi = ci;
    yl.Fragment = r, yl.jsx = di, yl.jsxs = fi;
  }()), yl;
}
process.env.NODE_ENV === "production" ? jy.exports = tW() : jy.exports = nW();
var q = jy.exports;
function rW(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ q.jsx("div", { className: r.trim(), ...n });
}
const wR = qe({});
function oW() {
  return Ee(wR);
}
function tEe(e) {
  const { schema: t, children: n, className: r, ...o } = e, s = !((u) => {
    let c = !1;
    const p = (d) => {
      Array.isArray(d) ? d.forEach(p) : d && typeof d == "object" && "type" in d && (d.type === rW ? c = !0 : d.props && d.props.children && p(d.props.children));
    };
    return p(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${s} ${r}`;
  return /* @__PURE__ */ q.jsx(wR.Provider, { value: e, children: /* @__PURE__ */ q.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function nEe(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ q.jsx("div", { className: r.trim(), ...n });
}
function rEe(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ q.jsx("div", { className: r.trim(), ...n });
}
function oEe(e) {
  const { className: t, ...n } = e, { schema: r } = oW(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ q.jsx(gR, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ q.jsx(hR, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ q.jsx(j$, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ q.jsx(fR, { className: o, ...n });
  }
}
function Nd(e, t) {
  return t ? /* @__PURE__ */ q.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function zx(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Pr(e) {
  var t, n;
  return zx(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(zx(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var CR = Symbol.for("immer-nothing"), Ux = Symbol.for("immer-draftable"), Co = Symbol.for("immer-state"), iW = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function to(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = iW[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var qa = Object.getPrototypeOf;
function ga(e) {
  return !!e && !!e[Co];
}
function ma(e) {
  var t;
  return e ? xR(e) || Array.isArray(e) || !!e[Ux] || !!((t = e.constructor) != null && t[Ux]) || vh(e) || yh(e) : !1;
}
var sW = Object.prototype.constructor.toString();
function xR(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = qa(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === sW;
}
function Fd(e, t) {
  mh(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function mh(e) {
  const t = e[Co];
  return t ? t.type_ : Array.isArray(e) ? 1 : vh(e) ? 2 : yh(e) ? 3 : 0;
}
function Ay(e, t) {
  return mh(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function ER(e, t, n) {
  const r = mh(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function aW(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function vh(e) {
  return e instanceof Map;
}
function yh(e) {
  return e instanceof Set;
}
function qs(e) {
  return e.copy_ || e.base_;
}
function By(e, t) {
  if (vh(e))
    return new Map(e);
  if (yh(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = xR(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Co];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(qa(e), r);
  } else {
    const r = qa(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function T0(e, t = !1) {
  return bh(e) || ga(e) || !ma(e) || (mh(e) > 1 && (e.set = e.add = e.clear = e.delete = lW), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => T0(r, !0))), e;
}
function lW() {
  to(2);
}
function bh(e) {
  return Object.isFrozen(e);
}
var uW = {};
function va(e) {
  const t = uW[e];
  return t || to(0, e), t;
}
var ku;
function OR() {
  return ku;
}
function cW(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function $x(e, t) {
  t && (va("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Ry(e) {
  Iy(e), e.drafts_.forEach(pW), e.drafts_ = null;
}
function Iy(e) {
  e === ku && (ku = e.parent_);
}
function Wx(e) {
  return ku = cW(ku, e);
}
function pW(e) {
  const t = e[Co];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Vx(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Co].modified_ && (Ry(t), to(4)), ma(e) && (e = zd(t, e), t.parent_ || Ud(t, e)), t.patches_ && va("Patches").generateReplacementPatches_(
    n[Co].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = zd(t, n, []), Ry(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== CR ? e : void 0;
}
function zd(e, t, n) {
  if (bh(t))
    return t;
  const r = t[Co];
  if (!r)
    return Fd(
      t,
      (o, i) => Hx(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Ud(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Fd(
      i,
      (s, l) => Hx(e, r, o, s, l, n, a)
    ), Ud(e, o, !1), n && e.patches_ && va("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Hx(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && to(5), ga(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Ay(t.assigned_, r) ? i.concat(r) : void 0, l = zd(e, o, s);
    if (ER(n, r, l), ga(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (ma(o) && !bh(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    zd(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Ud(e, o);
  }
}
function Ud(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && T0(t, n);
}
function dW(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : OR(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = j0;
  n && (o = [r], i = _u);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var j0 = {
  get(e, t) {
    if (t === Co)
      return e;
    const n = qs(e);
    if (!Ay(n, t))
      return fW(e, n, t);
    const r = n[t];
    return e.finalized_ || !ma(r) ? r : r === pm(e.base_, t) ? (dm(e), e.copy_[t] = Fy(r, e)) : r;
  },
  has(e, t) {
    return t in qs(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(qs(e));
  },
  set(e, t, n) {
    const r = kR(qs(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = pm(qs(e), t), i = o == null ? void 0 : o[Co];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (aW(n, o) && (n !== void 0 || Ay(e.base_, t)))
        return !0;
      dm(e), Ny(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return pm(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, dm(e), Ny(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = qs(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    to(11);
  },
  getPrototypeOf(e) {
    return qa(e.base_);
  },
  setPrototypeOf() {
    to(12);
  }
}, _u = {};
Fd(j0, (e, t) => {
  _u[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
_u.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && to(13), _u.set.call(this, e, t, void 0);
};
_u.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && to(14), j0.set.call(this, e[0], t, n, e[0]);
};
function pm(e, t) {
  const n = e[Co];
  return (n ? qs(n) : e)[t];
}
function fW(e, t, n) {
  var o;
  const r = kR(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function kR(e, t) {
  if (!(t in e))
    return;
  let n = qa(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = qa(n);
  }
}
function Ny(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Ny(e.parent_));
}
function dm(e) {
  e.copy_ || (e.copy_ = By(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var hW = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(l = i, ...u) {
          return a.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && to(6), r !== void 0 && typeof r != "function" && to(7);
      let o;
      if (ma(t)) {
        const i = Wx(this), a = Fy(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? Ry(i) : Iy(i);
        }
        return $x(i, r), Vx(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === CR && (o = void 0), this.autoFreeze_ && T0(o, !0), r) {
          const i = [], a = [];
          va("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        to(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (a, ...s) => this.produceWithPatches(a, (l) => t(l, ...s));
      let r, o;
      return [this.produce(t, n, (a, s) => {
        r = a, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ma(e) || to(8), ga(e) && (e = gW(e));
    const t = Wx(this), n = Fy(e, void 0);
    return n[Co].isManual_ = !0, Iy(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Co];
    (!n || !n.isManual_) && to(9);
    const { scope_: r } = n;
    return $x(r, t), Vx(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = va("Patches").applyPatches_;
    return ga(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Fy(e, t) {
  const n = vh(e) ? va("MapSet").proxyMap_(e, t) : yh(e) ? va("MapSet").proxySet_(e, t) : dW(e, t);
  return (t ? t.scope_ : OR()).drafts_.push(n), n;
}
function gW(e) {
  return ga(e) || to(10, e), _R(e);
}
function _R(e) {
  if (!ma(e) || bh(e))
    return e;
  const t = e[Co];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = By(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = By(e, !0);
  return Fd(n, (r, o) => {
    ER(n, r, _R(o));
  }), t && (t.finalized_ = !1), n;
}
var xo = new hW(), A0 = xo.produce;
xo.produceWithPatches.bind(
  xo
);
xo.setAutoFreeze.bind(xo);
xo.setUseStrictShallowCopy.bind(xo);
xo.applyPatches.bind(xo);
var Gx = xo.createDraft.bind(xo), qx = xo.finishDraft.bind(xo), mW = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ie.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, vW = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = Ot.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, yW = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = pe.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, $d = /* @__PURE__ */ new WeakMap(), Wd = /* @__PURE__ */ new WeakMap(), eu = /* @__PURE__ */ new WeakMap(), LR = /* @__PURE__ */ new WeakMap(), Zx = /* @__PURE__ */ new WeakMap(), Kx = /* @__PURE__ */ new WeakMap(), Xx = /* @__PURE__ */ new WeakMap(), ie = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = ie.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ie.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return ie.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ie.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return ie.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && ie.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return ie.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && ie.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && ie.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && ie.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && ie.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && ie.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!ie.isAncestor(t, e) && !ie.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (ie.equals(i, r) || ie.endsBefore(i, r) || ie.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (ie.equals(a, r) || ie.isAncestor(a, r))
          return null;
        ie.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        ie.equals(s, r) || ie.endsBefore(s, r) ? r[s.length - 1] -= 1 : ie.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (ie.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ie.endsBefore(u, r) ? r[u.length - 1] += 1 : ie.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (ie.equals(p, d))
          return r;
        if (ie.isAncestor(p, r) || ie.equals(p, r)) {
          var g = d.slice();
          return ie.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else ie.isSibling(p, d) && (ie.isAncestor(d, r) || ie.equals(d, r)) ? ie.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : ie.endsBefore(d, r) || ie.equals(d, r) || ie.isAncestor(d, r) ? (ie.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : ie.endsBefore(p, r) && (ie.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Lu(e) {
  "@babel/helpers - typeof";
  return Lu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Lu(e);
}
function bW(e, t) {
  if (Lu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Lu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function wW(e) {
  var t = bW(e, "string");
  return Lu(t) === "symbol" ? t : String(t);
}
function Gr(e, t, n) {
  return t = wW(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Yx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Yx(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Yx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var CW = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Te.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of pe.points(t))
          t[l] = Ot.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Te.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, h] of pe.points(t))
          t[h] = Ot.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Te.get(e, E), S = ie.previous(E), x = Te.get(e, S), y = Te.parent(e, E), C = E[E.length - 1];
      if (He.isText(w) && He.isText(x))
        x.text += w.text;
      else if (!He.isText(w) && !He.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Lr.stringify(w), " ").concat(Lr.stringify(x)));
      if (y.children.splice(C, 1), t)
        for (var [P, F] of pe.points(t))
          t[F] = Ot.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: _,
        newPath: I
      } = n;
      if (ie.isAncestor(_, I))
        throw new Error("Cannot move a path [".concat(_, "] to new path [").concat(I, "] because the destination is inside itself."));
      var B = Te.get(e, _), $ = Te.parent(e, _), V = _[_.length - 1];
      $.children.splice(V, 1);
      var z = ie.transform(_, n), H = Te.get(e, ie.parent(z)), X = z[z.length - 1];
      if (H.children.splice(X, 0, B), t)
        for (var [J, te] of pe.points(t))
          t[te] = Ot.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, L = ee[ee.length - 1], T = Te.parent(e, ee);
      if (T.children.splice(L, 1), t)
        for (var [W, D] of pe.points(t)) {
          var G = Ot.transform(W, n);
          if (t != null && G != null)
            t[D] = G;
          else {
            var O = void 0, M = void 0;
            for (var [U, j] of Te.texts(e))
              if (ie.compare(j, ee) === -1)
                O = [U, j];
              else {
                M = [U, j];
                break;
              }
            var Z = !1;
            O && M && (ie.equals(M[1], ee) ? Z = !ie.hasPrevious(M[1]) : Z = ie.common(O[1], ee).length < ie.common(M[1], ee).length), O && !Z ? (W.path = O[1], W.offset = O[0].text.length) : M ? (W.path = M[1], W.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: N
      } = n;
      if (N.length === 0) break;
      var le = Te.leaf(e, A), ye = le.text.slice(0, Q), oe = le.text.slice(Q + N.length);
      if (le.text = ye + oe, t)
        for (var [Be, Ue] of pe.points(t))
          t[Ue] = Ot.transform(Be, n);
      break;
    }
    case "set_node": {
      var {
        path: $e,
        properties: Ie,
        newProperties: Je
      } = n;
      if ($e.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ze = Te.get(e, $e);
      for (var Me in Je) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Ye = Je[Me];
        Ye == null ? delete Ze[Me] : Ze[Me] = Ye;
      }
      for (var nt in Ie)
        Je.hasOwnProperty(nt) || delete Ze[nt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: De
      } = n;
      if (De == null)
        t = De;
      else {
        if (t == null) {
          if (!pe.isRange(De))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Lr.stringify(De), " when there is no current selection."));
          t = bl({}, De);
        }
        for (var je in De) {
          var Ke = De[je];
          if (Ke == null) {
            if (je === "anchor" || je === "focus")
              throw new Error('Cannot remove the "'.concat(je, '" selection property'));
            delete t[je];
          } else
            t[je] = Ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Fe,
        properties: et
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var Re = Te.get(e, We), Rt = Te.parent(e, We), rt = We[We.length - 1], ot;
      if (He.isText(Re)) {
        var at = Re.text.slice(0, Fe), Kt = Re.text.slice(Fe);
        Re.text = at, ot = bl(bl({}, et), {}, {
          text: Kt
        });
      } else {
        var lt = Re.children.slice(0, Fe), ut = Re.children.slice(Fe);
        Re.children = lt, ot = bl(bl({}, et), {}, {
          children: ut
        });
      }
      if (Rt.children.splice(rt + 1, 0, ot), t)
        for (var [tt, Xe] of pe.points(t))
          t[Xe] = Ot.transform(tt, n);
      break;
    }
  }
  return t;
}, xW = {
  transform(e, t) {
    e.children = Gx(e.children);
    var n = e.selection && Gx(e.selection);
    try {
      n = CW(e, n, t);
    } finally {
      e.children = qx(e.children), n ? e.selection = ga(n) ? qx(n) : n : e.selection = null;
    }
  }
}, EW = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, OW = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, PR = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Pr(r) && Pr(o)) {
      if (!PR(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function kW(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Mi(e, t) {
  if (e == null) return {};
  var n = kW(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var _W = ["anchor", "focus"];
function Jx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function LW(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Jx(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Jx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pe = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return pe.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = pe.edges(e);
    return t;
  },
  equals(e, t) {
    return Ot.equals(e.anchor, t.anchor) && Ot.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (pe.isRange(t)) {
      if (pe.includes(e, t.anchor) || pe.includes(e, t.focus))
        return !0;
      var [n, r] = pe.edges(e), [o, i] = pe.edges(t);
      return Ot.isBefore(n, o) && Ot.isAfter(r, i);
    }
    var [a, s] = pe.edges(e), l = !1, u = !1;
    return Ot.isPoint(t) ? (l = Ot.compare(t, a) >= 0, u = Ot.compare(t, s) <= 0) : (l = ie.compare(t, a.path) >= 0, u = ie.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Mi(e, _W), [r, o] = pe.edges(e), [i, a] = pe.edges(t), s = Ot.isBefore(r, i) ? i : r, l = Ot.isBefore(o, a) ? o : a;
    return Ot.isBefore(l, s) ? null : LW({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Ot.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Ot.equals(t, n);
  },
  isExpanded(e) {
    return !pe.isCollapsed(e);
  },
  isForward(e) {
    return !pe.isBackward(e);
  },
  isRange(e) {
    return Pr(e) && Ot.isPoint(e.anchor) && Ot.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = pe.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return A0(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = pe.isCollapsed(r);
        pe.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? pe.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Ot.transform(r.anchor, t, {
        affinity: i
      }), u = Ot.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, Qx = (e) => Pr(e) && Te.isNodeList(e.children) && !K.isEditor(e), Ve = {
  isAncestor(e) {
    return Pr(e) && Te.isNodeList(e.children);
  },
  isElement: Qx,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Ve.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return Qx(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, PW = ["children"], SW = ["text"], eE = /* @__PURE__ */ new WeakMap(), Te = {
  ancestor(e, t) {
    var n = Te.get(e, t);
    if (He.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Lr.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ie.ancestors(t, n)) {
        var o = Te.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (He.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Lr.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Lr.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Te.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Te.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = ie.common(t, n), o = Te.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Te.get(e, t);
    if (K.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Lr.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Te.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Te.nodes(e, t))
        Ve.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Ve.isAncestor(e)) {
      var t = Mi(e, PW);
      return t;
    } else {
      var t = Mi(e, SW);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Te.get(e, n); r && !(He.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (He.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Lr.stringify(e)));
    var n = A0({
      children: e.children
    }, (r) => {
      var [o, i] = pe.edges(t), a = Te.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !pe.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!pe.includes(t, s)) {
          var l = Te.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (ie.equals(s, i.path)) {
          var c = Te.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (ie.equals(s, o.path)) {
          var p = Te.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      K.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (He.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Lr.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (He.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return He.isText(e) || Ve.isElement(e) || K.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = eE.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Te.isNode(r));
    return eE.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Te.get(e, n); r && !(He.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Te.get(e, t);
    if (!He.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Lr.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ie.levels(t, n)) {
        var o = Te.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Ve.isElement(e) && Ve.isElementProps(t) && Ve.matches(e, t) || He.isText(e) && He.isTextProps(t) && He.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? ie.isBefore(s, i) : ie.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !He.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          ie.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Te.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = ie.next(s);
          if (Te.has(e, c)) {
            s = c, l = Te.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = ie.previous(s);
          s = p, l = Te.get(e, s);
          continue;
        }
        s = ie.parent(s), l = Te.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = ie.parent(t), r = Te.get(e, n);
    if (He.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return He.isText(e) ? e.text : e.children.map(Te.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Te.nodes(e, t))
        He.isText(n) && (yield [n, r]);
    }();
  }
};
function tE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tE(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ms = {
  isNodeOperation(e) {
    return ms.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Pr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return ie.isPath(e.path) && Te.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ie.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && ie.isPath(e.path) && Pr(e.properties);
      case "move_node":
        return ie.isPath(e.path) && ie.isPath(e.newPath);
      case "remove_node":
        return ie.isPath(e.path) && Te.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ie.isPath(e.path);
      case "set_node":
        return ie.isPath(e.path) && Pr(e.properties) && Pr(e.newProperties);
      case "set_selection":
        return e.properties === null && pe.isRange(e.newProperties) || e.newProperties === null && pe.isRange(e.properties) || Pr(e.properties) && Pr(e.newProperties);
      case "split_node":
        return ie.isPath(e.path) && typeof e.position == "number" && Pr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => ms.isOperation(t));
  },
  isSelectionOperation(e) {
    return ms.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return ms.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Nn(Nn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Nn(Nn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Nn(Nn({}, e), {}, {
          type: "split_node",
          path: ie.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (ie.equals(t, n))
          return e;
        if (ie.isSibling(n, t))
          return Nn(Nn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = ie.transform(n, e), o = ie.transform(ie.next(n), e);
        return Nn(Nn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Nn(Nn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Nn(Nn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Nn(Nn({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Nn(Nn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Nn(Nn({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Nn(Nn({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Nn(Nn({}, e), {}, {
          type: "merge_node",
          path: ie.next(e.path)
        });
    }
  }
}, nE = /* @__PURE__ */ new WeakMap(), DW = (e) => {
  var t = nE.get(e);
  if (t !== void 0)
    return t;
  if (!Pr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Pr(e.marks)) && (e.selection === null || pe.isRange(e.selection)) && Te.isNodeList(e.children) && ms.isOperationList(e.operations);
  return nE.set(e, n), n;
}, K = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return DW(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, MW = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(ie.isPath);
  }
};
function rE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rE(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ot = {
  compare(e, t) {
    var n = ie.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Ot.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Ot.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && ie.equals(e.path, t.path);
  },
  isPoint(e) {
    return Pr(e) && typeof e.offset == "number" && ie.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return A0(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = ie.transform(i, t, n);
          break;
        }
        case "insert_text": {
          ie.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          ie.equals(t.path, i) && (r.offset += t.position), r.path = ie.transform(i, t, n);
          break;
        }
        case "remove_text": {
          ie.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (ie.equals(t.path, i) || ie.isAncestor(t.path, i))
            return null;
          r.path = ie.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (ie.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = ie.transform(i, t, oE(oE({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ie.transform(i, t, n);
          break;
        }
      }
    });
  }
}, iE = void 0, Lr = {
  setScrubber(e) {
    iE = e;
  },
  stringify(e) {
    return JSON.stringify(e, iE);
  }
}, TW = ["text"], jW = ["anchor", "focus"];
function sE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sE(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var He = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Mi(i, TW);
      return a;
    }
    return PR(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Pr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => He.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [mi({}, e)];
    for (var r of t) {
      var o = Mi(r, jW), [i, a] = pe.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, h = void 0;
        if (c < l) {
          var E = c - g;
          h = mi(mi({}, f), {}, {
            text: f.text.slice(E)
          }), f = mi(mi({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = mi(mi({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = mi(mi({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), h && s.push(h);
      }
      n = s;
    }
    return n;
  }
}, B0 = (e) => e.selection ? e.selection : e.children.length > 0 ? K.end(e, []) : [0], nl = (e, t) => {
  var [n] = K.node(e, t);
  return (r) => r === n;
}, R0 = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? FW(t) : t, i = st.None, a = st.None, s = 0, l = null, u = null;
  for (var c of o) {
    var p = c.codePointAt(0);
    if (!p) break;
    var d = YW(c, p);
    if ([i, a] = r ? [a, d] : [d, i], Ia(i, st.ZWJ) && Ia(a, st.ExtPict) && (r ? l = aE(t.substring(0, s)) : l = aE(t.substring(0, t.length - s)), !l) || Ia(i, st.RI) && Ia(a, st.RI) && (u !== null ? u = !u : r ? u = !0 : u = n9(t.substring(0, t.length - s)), !u) || i !== st.None && a !== st.None && QW(i, a))
      break;
    s += c.length;
  }
  return s || 1;
}, AW = /\s/, BW = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, RW = /['\u2018\u2019]/, IW = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = R0(t, n), [a, s] = I0(t, i, n);
    if (NW(a, s, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = s;
  }
  return r;
}, I0 = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, NW = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (AW.test(t))
    return !1;
  if (RW.test(t)) {
    var o = R0(n, r), [i, a] = I0(n, o, r);
    if (e(i, a, r))
      return !0;
  }
  return !BW.test(t);
}, FW = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (UW(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (zW(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, zW = (e) => e >= 55296 && e <= 56319, UW = (e) => e >= 56320 && e <= 57343, st;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(st || (st = {}));
var $W = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, WW = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, VW = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, HW = /^[\u1100-\u115F\uA960-\uA97C]$/, GW = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, qW = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, ZW = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, KW = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, XW = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, YW = (e, t) => {
  var n = st.Any;
  return e.search($W) !== -1 && (n |= st.Extend), t === 8205 && (n |= st.ZWJ), t >= 127462 && t <= 127487 && (n |= st.RI), e.search(WW) !== -1 && (n |= st.Prepend), e.search(VW) !== -1 && (n |= st.SpacingMark), e.search(HW) !== -1 && (n |= st.L), e.search(GW) !== -1 && (n |= st.V), e.search(qW) !== -1 && (n |= st.T), e.search(ZW) !== -1 && (n |= st.LV), e.search(KW) !== -1 && (n |= st.LVT), e.search(XW) !== -1 && (n |= st.ExtPict), n;
};
function Ia(e, t) {
  return (e & t) !== 0;
}
var JW = [
  // GB6
  [st.L, st.L | st.V | st.LV | st.LVT],
  // GB7
  [st.LV | st.V, st.V | st.T],
  // GB8
  [st.LVT | st.T, st.T],
  // GB9
  [st.Any, st.Extend | st.ZWJ],
  // GB9a
  [st.Any, st.SpacingMark],
  // GB9b
  [st.Prepend, st.Any],
  // GB11
  [st.ZWJ, st.ExtPict],
  // GB12 and GB13
  [st.RI, st.RI]
];
function QW(e, t) {
  return JW.findIndex((n) => Ia(e, n[0]) && Ia(t, n[1])) === -1;
}
var e9 = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, aE = (e) => e.search(e9) !== -1, t9 = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, n9 = (e) => {
  var t = e.match(t9);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, r9 = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    K.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = B0(e)
      } = n;
      if (ie.isPath(o) && (o = K.range(e, o)), pe.isRange(o))
        if (pe.isCollapsed(o))
          o = o.anchor;
        else {
          var i = pe.end(o);
          if (!r && K.void(e, {
            at: i
          }))
            return;
          var a = pe.start(o), s = K.pointRef(e, a), l = K.pointRef(e, i);
          Ce.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Ce.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && K.void(e, {
        at: o
      }) || K.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function lE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lE(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ce = qc(qc(qc(qc({}, xW), EW), OW), r9), Ld = /* @__PURE__ */ new WeakMap(), o9 = (e) => Ld.get(e) || !1, i9 = (e, t, n) => {
  var r = Ld.get(e) || !1;
  Ld.set(e, !0);
  try {
    t(), n();
  } finally {
    Ld.set(e, r);
  }
};
function SR(e, t, n) {
  var r = $d.get(e) || [], o = Wd.get(e) || /* @__PURE__ */ new Set(), i, a, s = (p) => {
    if (p) {
      var d = p.join(",");
      a.has(d) || (a.add(d), i.push(p));
    }
  };
  if (n) {
    i = [], a = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      s(u);
    }
  } else
    i = r, a = o;
  for (var c of t)
    s(c);
  $d.set(e, i), Wd.set(e, a);
}
var s9 = (e, t) => {
  for (var n of K.pathRefs(e))
    mW.transform(n, t);
  for (var r of K.pointRefs(e))
    vW.transform(r, t);
  for (var o of K.rangeRefs(e))
    yW.transform(o, t);
  if (!o9(e)) {
    var i = ie.operationCanTransformPath(t) ? (a) => ie.transform(a, t) : void 0;
    SR(e, e.getDirtyPaths(t), i);
  }
  Ce.transform(e, t), e.operations.push(t), K.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), eu.get(e) || (eu.set(e, !0), Promise.resolve().then(() => {
    eu.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, a9 = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return ie.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = ie.levels(o), a = He.isText(r) ? [] : Array.from(Te.nodes(r), (I) => {
        var [, B] = I;
        return o.concat(B);
      });
      return [...i, ...a];
    }
    case "merge_node": {
      var {
        path: s
      } = t, l = ie.ancestors(s), u = ie.previous(s);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: p
      } = t;
      if (ie.equals(c, p))
        return [];
      var d = [], g = [];
      for (var f of ie.ancestors(c)) {
        var m = ie.transform(f, t);
        d.push(m);
      }
      for (var h of ie.ancestors(p)) {
        var E = ie.transform(h, t);
        g.push(E);
      }
      var w = g[g.length - 1], S = p[p.length - 1], x = w.concat(S);
      return [...d, ...g, x];
    }
    case "remove_node": {
      var {
        path: y
      } = t, C = ie.ancestors(y);
      return [...C];
    }
    case "split_node": {
      var {
        path: P
      } = t, F = ie.levels(P), _ = ie.next(P);
      return [...F, _];
    }
    default:
      return [];
  }
}, l9 = (e) => {
  var {
    selection: t
  } = e;
  return t ? Te.fragment(e, t) : [];
}, u9 = (e, t) => {
  var [n, r] = t;
  if (!He.isText(n)) {
    if (Ve.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      Ce.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = K.isEditor(n) ? !1 : Ve.isElement(n) && (e.isInline(n) || n.children.length === 0 || He.isText(n.children[0]) || e.isInline(n.children[0])), a = 0, s = 0; s < n.children.length; s++, a++) {
      var l = Te.get(e, r);
      if (!He.isText(l)) {
        var u = l.children[a], c = l.children[a - 1], p = s === n.children.length - 1, d = He.isText(u) || Ve.isElement(u) && e.isInline(u);
        if (d !== i)
          Ce.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--;
        else if (Ve.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !He.isText(c)) {
              var g = {
                text: ""
              };
              Ce.insertNodes(e, g, {
                at: r.concat(a),
                voids: !0
              }), a++;
            } else if (p) {
              var f = {
                text: ""
              };
              Ce.insertNodes(e, f, {
                at: r.concat(a + 1),
                voids: !0
              }), a++;
            }
          }
        } else {
          if (!He.isText(u) && !("children" in u)) {
            var m = u;
            m.children = [];
          }
          c != null && He.isText(c) && (He.equals(u, c, {
            loose: !0
          }) ? (Ce.mergeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--) : c.text === "" ? (Ce.removeNodes(e, {
            at: r.concat(a - 1),
            voids: !0
          }), a--) : u.text === "" && (Ce.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--));
        }
      }
    }
  }
}, c9 = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, p9 = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: a
  } = n;
  if (i) {
    var s = K.path(t, i), l = o === "lowest";
    for (var [u, c] of K.levels(t, {
      at: s,
      voids: r,
      match: a,
      reverse: l
    }))
      if (!He.isText(u)) {
        if (pe.isRange(i)) {
          if (ie.isAncestor(c, i.anchor.path) && ie.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!ie.equals(s, c))
          return [u, c];
      }
  }
};
function uE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uE(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var d9 = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (p, d) => {
      if (!He.isText(p))
        return !1;
      var [g, f] = K.parent(e, d);
      return !e.isVoid(g) || e.markableVoid(g);
    }, i = pe.isExpanded(r), a = !1;
    if (!i) {
      var [s, l] = K.node(e, r);
      if (s && o(s, l)) {
        var [u] = K.parent(e, l);
        a = u && e.markableVoid(u);
      }
    }
    if (i || a)
      Ce.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = cE(cE({}, K.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, eu.get(e) || e.onChange();
    }
  }
};
function pE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pE(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var f9 = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = K.point(t, n, {
    edge: "end"
  }), i = K.end(t, []), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of K.positions(t, dE(dE({}, r), {}, {
    at: a
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function fE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fE(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var h9 = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = K.start(t, []), i = K.point(t, n, {
    edge: "start"
  }), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of K.positions(t, hE(hE({}, r), {}, {
    at: a,
    reverse: !0
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, g9 = (e, t) => {
  var {
    selection: n
  } = e;
  n && pe.isCollapsed(n) && Ce.delete(e, {
    unit: t,
    reverse: !0
  });
}, m9 = (e, t) => {
  var {
    selection: n
  } = e;
  n && pe.isCollapsed(n) && Ce.delete(e, {
    unit: t
  });
}, v9 = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && pe.isExpanded(r) && Ce.delete(t, {
    reverse: n === "backward"
  });
}, y9 = (e, t) => [K.start(e, t), K.end(e, t)];
function gE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gE(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var b9 = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return K.above(t, mE(mE({}, n), {}, {
    match: (r) => Ve.isElement(r) && K.isElementReadOnly(t, r)
  }));
}, w9 = (e, t) => K.point(e, t, {
  edge: "end"
}), C9 = (e, t) => {
  var n = K.path(e, t, {
    edge: "start"
  });
  return K.node(e, n);
}, x9 = (e, t) => {
  var n = K.range(e, t);
  return Te.fragment(e, n);
};
function vE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vE(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var E9 = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return K.above(t, yE(yE({}, n), {}, {
    match: (r) => Ve.isElement(r) && K.isVoid(t, r)
  }));
}, O9 = (e, t) => t.children.some((n) => Ve.isElement(n) && K.isBlock(e, n)), k9 = (e, t) => t.children.some((n) => He.isText(n) || K.isInline(e, n)), _9 = (e, t) => Te.has(e, t), L9 = (e, t) => t.children.every((n) => He.isText(n)), P9 = (e) => {
  Ce.splitNodes(e, {
    always: !0
  });
}, S9 = (e, t, n) => {
  Ce.insertNodes(e, t, n);
}, D9 = (e) => {
  Ce.splitNodes(e, {
    always: !0
  });
};
function bE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function M9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bE(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var T9 = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var a = M9({
        text: n
      }, i);
      Ce.insertNodes(t, a, {
        at: r.at,
        voids: r.voids
      });
    } else
      Ce.insertText(t, n, r);
    t.marks = null;
  }
}, j9 = (e, t) => !e.isInline(t), A9 = (e, t, n) => K.isStart(e, t, n) || K.isEnd(e, t, n), B9 = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && He.isText(r) && r.text === "" && !e.isVoid(t);
}, R9 = (e, t, n) => {
  var r = K.end(e, n);
  return Ot.equals(t, r);
}, I9 = (e) => {
  var t = LR.get(e);
  return t === void 0 ? !0 : t;
}, N9 = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = K.start(e, n);
  return Ot.equals(t, r);
}, F9 = (e, t) => {
  var n = K.path(e, t, {
    edge: "end"
  });
  return K.node(e, n);
}, z9 = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = K.path(t, n, r), i = Te.leaf(t, o);
  return [i, o];
};
function U9(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var a = [], s = K.path(e, n);
      for (var [l, u] of Te.levels(e, s))
        if (i(l, u) && (a.push([l, u]), !o && Ve.isElement(l) && K.isVoid(e, l)))
          break;
      r && a.reverse(), yield* a;
    }
  }();
}
var $9 = ["text"], W9 = ["text"], V9 = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (pe.isExpanded(r)) {
    var a = K.isEnd(t, o, o.path);
    if (a) {
      var s = K.after(t, o);
      s && (o = s);
    }
    var [l] = K.nodes(t, {
      match: He.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = Mi(u, $9);
      return c;
    } else
      return {};
  }
  var {
    path: p
  } = o, [d] = K.leaf(t, p);
  if (o.offset === 0) {
    var g = K.previous(t, {
      at: p,
      match: He.isText
    }), f = K.above(t, {
      match: (x) => Ve.isElement(x) && K.isVoid(t, x) && t.markableVoid(x)
    });
    if (!f) {
      var m = K.above(t, {
        match: (x) => Ve.isElement(x) && K.isBlock(t, x)
      });
      if (g && m) {
        var [h, E] = g, [, w] = m;
        ie.isAncestor(w, E) && (d = h);
      }
    }
  }
  var S = Mi(d, W9);
  return S;
}, H9 = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = K.after(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = K.last(t, []), u = [s.path, l];
      if (ie.isPath(a) && a.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (ie.isPath(a)) {
          var [c] = K.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = K.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, G9 = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = K.path(t, n, r), i = Te.get(t, o);
  return [i, o];
};
function q9(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: a = !1,
      ignoreNonSelectable: s = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (MW.isSpan(n))
        u = n[0], c = n[1];
      else {
        var p = K.path(e, n, {
          edge: "start"
        }), d = K.path(e, n, {
          edge: "end"
        });
        u = i ? d : p, c = i ? p : d;
      }
      var g = Te.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (x) => {
          var [y] = x;
          return Ve.isElement(y) ? !!(!a && (K.isVoid(e, y) || K.isElementReadOnly(e, y)) || s && !K.isSelectable(e, y)) : !1;
        }
      }), f = [], m;
      for (var [h, E] of g)
        if (!(s && Ve.isElement(h) && !K.isSelectable(e, h))) {
          var w = m && ie.compare(E, m[1]) === 0;
          if (!(r === "highest" && w)) {
            if (!l(h, E)) {
              if (o && !w && He.isText(h))
                return;
              continue;
            }
            if (r === "lowest" && w) {
              m = [h, E];
              continue;
            }
            var S = r === "lowest" ? m : [h, E];
            S && (o ? f.push(S) : yield S), m = [h, E];
          }
        }
      r === "lowest" && m && (o ? f.push(m) : yield m), o && (yield* f);
    }
  }();
}
var Z9 = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => $d.get(c) || [], a = (c) => Wd.get(c) || /* @__PURE__ */ new Set(), s = (c) => {
    var p = i(c).pop(), d = p.join(",");
    return a(c).delete(d), p;
  };
  if (K.isNormalizing(t)) {
    if (r) {
      var l = Array.from(Te.nodes(t), (c) => {
        var [, p] = c;
        return p;
      }), u = new Set(l.map((c) => c.join(",")));
      $d.set(t, l), Wd.set(t, u);
    }
    i(t).length !== 0 && K.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (Te.has(t, c)) {
          var p = K.node(t, c), [d, g] = p;
          Ve.isElement(d) && d.children.length === 0 && t.normalizeNode(p, {
            operation: o
          });
        }
      for (var f = i(t), m = f.length, h = 0; f.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: f,
          iteration: h,
          initialDirtyPathsLength: m,
          operation: o
        }))
          return;
        var E = s(t);
        if (Te.has(t, E)) {
          var w = K.node(t, E);
          t.normalizeNode(w, {
            operation: o
          });
        }
        h++, f = i(t);
      }
    });
  }
}, K9 = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = K.path(t, n, r), i = ie.parent(o), a = K.node(t, i);
  return a;
}, X9 = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = K.pathRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = K.pathRefs(t);
  return a.add(i), i;
}, Y9 = (e) => {
  var t = Zx.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Zx.set(e, t)), t;
}, J9 = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (ie.isPath(n)) {
    if (i === "start") {
      var [, a] = Te.first(t, n);
      n = a;
    } else if (i === "end") {
      var [, s] = Te.last(t, n);
      n = s;
    }
  }
  return pe.isRange(n) && (i === "start" ? n = pe.start(n) : i === "end" ? n = pe.end(n) : n = ie.common(n.anchor.path, n.focus.path)), Ot.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, Q9 = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = K.pointRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = K.pointRefs(t);
  return a.add(i), i;
}, eV = (e) => {
  var t = Kx.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Kx.set(e, t)), t;
}, tV = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (ie.isPath(n)) {
    var i;
    if (o === "end") {
      var [, a] = Te.last(t, n);
      i = a;
    } else {
      var [, s] = Te.first(t, n);
      i = s;
    }
    var l = Te.get(t, i);
    if (!He.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (pe.isRange(n)) {
    var [u, c] = pe.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function nV(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: a = !1
    } = t;
    if (!n)
      return;
    var s = K.range(e, n), [l, u] = pe.edges(s), c = o ? u : l, p = !1, d = "", g = 0, f = 0, m = 0;
    for (var [h, E] of K.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: a
    })) {
      if (Ve.isElement(h)) {
        if (!i && (e.isVoid(h) || e.isElementReadOnly(h))) {
          yield K.start(e, E);
          continue;
        }
        if (e.isInline(h)) continue;
        if (K.hasInlines(e, h)) {
          var w = ie.isAncestor(E, u.path) ? u : K.end(e, E), S = ie.isAncestor(E, l.path) ? l : K.start(e, E);
          d = K.string(e, {
            anchor: S,
            focus: w
          }, {
            voids: i
          }), p = !0;
        }
      }
      if (He.isText(h)) {
        var x = ie.equals(E, c.path);
        for (x ? (f = o ? c.offset : h.text.length - c.offset, m = c.offset) : (f = h.text.length, m = o ? f : 0), (x || p || r === "offset") && (yield {
          path: E,
          offset: m
        }, p = !1); ; ) {
          if (g === 0) {
            if (d === "") break;
            g = y(d, r, o), d = I0(d, g, o)[1];
          }
          if (m = o ? m - g : m + g, f = f - g, f < 0) {
            g = -f;
            break;
          }
          g = 0, yield {
            path: E,
            offset: m
          };
        }
      }
    }
    function y(C, P, F) {
      return P === "character" ? R0(C, F) : P === "word" ? IW(C, F) : P === "line" || P === "block" ? C.length : 1;
    }
  }();
}
var rV = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = K.before(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = K.first(t, []), u = [s.path, l];
      if (ie.isPath(a) && a.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (ie.isPath(a)) {
          var [c] = K.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = K.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, oV = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = K.rangeRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = K.rangeRefs(t);
  return a.add(i), i;
}, iV = (e) => {
  var t = Xx.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Xx.set(e, t)), t;
}, sV = (e, t, n) => {
  if (pe.isRange(t) && !n)
    return t;
  var r = K.start(e, t), o = K.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function wE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wE(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lV = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, p) => {
      if (!He.isText(c))
        return !1;
      var [d, g] = K.parent(e, p);
      return !e.isVoid(d) || e.markableVoid(d);
    }, o = pe.isExpanded(n), i = !1;
    if (!o) {
      var [a, s] = K.node(e, n);
      if (a && r(a, s)) {
        var [l] = K.parent(e, s);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      Ce.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = aV({}, K.marks(e) || {});
      delete u[t], e.marks = u, eu.get(e) || e.onChange();
    }
  }
}, uV = (e, t) => {
  LR.set(e, t);
}, cV = (e, t) => K.point(e, t, {
  edge: "start"
}), pV = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = K.range(t, n), [a, s] = pe.edges(i), l = "";
  for (var [u, c] of K.nodes(t, {
    at: i,
    match: He.isText,
    voids: o
  })) {
    var p = u.text;
    ie.equals(c, s.path) && (p = p.slice(0, s.offset)), ie.equals(c, a.path) && (p = p.slice(a.offset)), l += p;
  }
  return l;
}, dV = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, a] = pe.edges(n);
  if (i.offset !== 0 || a.offset !== 0 || pe.isCollapsed(n) || ie.hasPrevious(a.path))
    return n;
  var s = K.above(t, {
    at: a,
    match: (f) => Ve.isElement(f) && K.isBlock(t, f),
    voids: o
  }), l = s ? s[1] : [], u = K.start(t, i), c = {
    anchor: u,
    focus: a
  }, p = !0;
  for (var [d, g] of K.nodes(t, {
    at: c,
    match: He.isText,
    reverse: !0,
    voids: o
  })) {
    if (p) {
      p = !1;
      continue;
    }
    if (d.text !== "" || ie.isBefore(g, l)) {
      a = {
        path: g,
        offset: d.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: a
  };
}, fV = (e, t) => {
  var n = K.isNormalizing(e);
  K.setNormalizing(e, !1);
  try {
    t();
  } finally {
    K.setNormalizing(e, n);
  }
  K.normalize(e);
}, hV = (e, t, n) => {
  var [r, o] = t;
  return Ve.isElement(r) && K.isEmpty(e, r) || He.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, gV = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  K.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: a = "character",
      distance: s = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var p = !1;
      if (pe.isRange(u) && pe.isCollapsed(u) && (p = !0, u = u.anchor), Ot.isPoint(u)) {
        var d = K.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && d) {
          var [, g] = d;
          u = g;
        } else {
          var f = {
            unit: a,
            distance: s
          }, m = i ? K.before(t, u, f) || K.start(t, []) : K.after(t, u, f) || K.end(t, []);
          u = {
            anchor: u,
            focus: m
          }, c = !0;
        }
      }
      if (ie.isPath(u)) {
        Ce.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!pe.isCollapsed(u)) {
        if (!c) {
          var [, h] = pe.edges(u), E = K.end(t, []);
          Ot.equals(h, E) || (u = K.unhangRange(t, u, {
            voids: l
          }));
        }
        var [w, S] = pe.edges(u), x = K.above(t, {
          match: (ye) => Ve.isElement(ye) && K.isBlock(t, ye),
          at: w,
          voids: l
        }), y = K.above(t, {
          match: (ye) => Ve.isElement(ye) && K.isBlock(t, ye),
          at: S,
          voids: l
        }), C = x && y && !ie.equals(x[1], y[1]), P = ie.equals(w.path, S.path), F = l ? null : (r = K.void(t, {
          at: w,
          mode: "highest"
        })) !== null && r !== void 0 ? r : K.elementReadOnly(t, {
          at: w,
          mode: "highest"
        }), _ = l ? null : (o = K.void(t, {
          at: S,
          mode: "highest"
        })) !== null && o !== void 0 ? o : K.elementReadOnly(t, {
          at: S,
          mode: "highest"
        });
        if (F) {
          var I = K.before(t, w);
          I && x && ie.isAncestor(x[1], I.path) && (w = I);
        }
        if (_) {
          var B = K.after(t, S);
          B && y && ie.isAncestor(y[1], B.path) && (S = B);
        }
        var $ = [], V;
        for (var z of K.nodes(t, {
          at: u,
          voids: l
        })) {
          var [H, X] = z;
          V && ie.compare(X, V) === 0 || (!l && Ve.isElement(H) && (K.isVoid(t, H) || K.isElementReadOnly(t, H)) || !ie.isCommon(X, w.path) && !ie.isCommon(X, S.path)) && ($.push(z), V = X);
        }
        var J = Array.from($, (ye) => {
          var [, oe] = ye;
          return K.pathRef(t, oe);
        }), te = K.pointRef(t, w), ee = K.pointRef(t, S), L = "";
        if (!P && !F) {
          var T = te.current, [W] = K.leaf(t, T), {
            path: D
          } = T, {
            offset: G
          } = w, O = W.text.slice(G);
          O.length > 0 && (t.apply({
            type: "remove_text",
            path: D,
            offset: G,
            text: O
          }), L = O);
        }
        if (J.reverse().map((ye) => ye.unref()).filter((ye) => ye !== null).forEach((ye) => Ce.removeNodes(t, {
          at: ye,
          voids: l
        })), !_) {
          var M = ee.current, [U] = K.leaf(t, M), {
            path: j
          } = M, Z = P ? w.offset : 0, A = U.text.slice(Z, S.offset);
          A.length > 0 && (t.apply({
            type: "remove_text",
            path: j,
            offset: Z,
            text: A
          }), L = A);
        }
        !P && C && ee.current && te.current && Ce.mergeNodes(t, {
          at: ee.current,
          hanging: !0,
          voids: l
        }), p && i && a === "character" && L.length > 1 && L.match(/[\u0E00-\u0E7F]+/) && Ce.insertText(t, L.slice(0, L.length - s));
        var Q = te.unref(), N = ee.unref(), le = i ? Q || N : N || Q;
        n.at == null && le && Ce.select(t, le);
      }
    }
  });
}, mV = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  K.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: a = B0(t),
      batchDirty: s = !0
    } = r;
    if (n.length) {
      if (pe.isRange(a))
        if (o || (a = K.unhangRange(t, a, {
          voids: i
        })), pe.isCollapsed(a))
          a = a.anchor;
        else {
          var [, l] = pe.edges(a);
          if (!i && K.void(t, {
            at: l
          }))
            return;
          var u = K.pointRef(t, l);
          Ce.delete(t, {
            at: a
          }), a = u.unref();
        }
      else ie.isPath(a) && (a = K.start(t, a));
      if (!(!i && K.void(t, {
        at: a
      }))) {
        var c = K.above(t, {
          at: a,
          match: (O) => Ve.isElement(O) && K.isInline(t, O),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, p] = c;
          if (K.isEnd(t, a, p)) {
            var d = K.after(t, p);
            a = d;
          } else if (K.isStart(t, a, p)) {
            var g = K.before(t, p);
            a = g;
          }
        }
        var f = K.above(t, {
          match: (O) => Ve.isElement(O) && K.isBlock(t, O),
          at: a,
          voids: i
        }), [, m] = f, h = K.isStart(t, a, m), E = K.isEnd(t, a, m), w = h && E, S = !h || h && E, x = !E, [, y] = Te.first({
          children: n
        }, []), [, C] = Te.last({
          children: n
        }, []), P = [], F = (O) => {
          var [M, U] = O, j = U.length === 0;
          return j ? !1 : w ? !0 : !(S && ie.isAncestor(U, y) && Ve.isElement(M) && !t.isVoid(M) && !t.isInline(M) || x && ie.isAncestor(U, C) && Ve.isElement(M) && !t.isVoid(M) && !t.isInline(M));
        };
        for (var _ of Te.nodes({
          children: n
        }, {
          pass: F
        }))
          F(_) && P.push(_);
        var I = [], B = [], $ = [], V = !0, z = !1;
        for (var [H] of P)
          Ve.isElement(H) && !t.isInline(H) ? (V = !1, z = !0, B.push(H)) : V ? I.push(H) : $.push(H);
        var [X] = K.nodes(t, {
          at: a,
          match: (O) => He.isText(O) || K.isInline(t, O),
          mode: "highest",
          voids: i
        }), [, J] = X, te = K.isStart(t, a, J), ee = K.isEnd(t, a, J), L = K.pathRef(t, E && !$.length ? ie.next(m) : m), T = K.pathRef(t, ee ? ie.next(J) : J);
        Ce.splitNodes(t, {
          at: a,
          match: (O) => z ? Ve.isElement(O) && K.isBlock(t, O) : He.isText(O) || K.isInline(t, O),
          mode: z ? "lowest" : "highest",
          always: z && (!h || I.length > 0) && (!E || $.length > 0),
          voids: i
        });
        var W = K.pathRef(t, !te || te && ee ? ie.next(J) : J);
        if (Ce.insertNodes(t, I, {
          at: W.current,
          match: (O) => He.isText(O) || K.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), w && !I.length && B.length && !$.length && Ce.delete(t, {
          at: m,
          voids: i
        }), Ce.insertNodes(t, B, {
          at: L.current,
          match: (O) => Ve.isElement(O) && K.isBlock(t, O),
          mode: "lowest",
          voids: i,
          batchDirty: s
        }), Ce.insertNodes(t, $, {
          at: T.current,
          match: (O) => He.isText(O) || K.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), !r.at) {
          var D;
          if ($.length > 0 && T.current ? D = ie.previous(T.current) : B.length > 0 && L.current ? D = ie.previous(L.current) : W.current && (D = ie.previous(W.current)), D) {
            var G = K.end(t, D);
            Ce.select(t, G);
          }
        }
        W.unref(), L.unref(), T.unref();
      }
    }
  });
}, vV = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      Ce.select(t, o.anchor);
    else if (r === "focus")
      Ce.select(t, o.focus);
    else if (r === "start") {
      var [i] = pe.edges(o);
      Ce.select(t, i);
    } else if (r === "end") {
      var [, a] = pe.edges(o);
      Ce.select(t, a);
    }
  } else return;
}, yV = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, bV = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: a = !1
  } = n, {
    edge: s = null
  } = n;
  if (r) {
    s === "start" && (s = pe.isBackward(r) ? "focus" : "anchor"), s === "end" && (s = pe.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, p = {};
    if (s == null || s === "anchor") {
      var d = a ? K.before(t, l, c) : K.after(t, l, c);
      d && (p.anchor = d);
    }
    if (s == null || s === "focus") {
      var g = a ? K.before(t, u, c) : K.after(t, u, c);
      g && (p.focus = g);
    }
    Ce.setSelection(t, p);
  }
}, wV = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = K.range(e, t), n) {
    Ce.setSelection(e, t);
    return;
  }
  if (!pe.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Lr.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function CE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CE(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var CV = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = pe.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = pe.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: a,
      focus: s
    } = o, l = i === "anchor" ? a : s;
    Ce.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: xE(xE({}, l), n)
    });
  }
}, xV = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !Ot.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !Ot.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, EV = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  K.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: a = "lowest",
      batchDirty: s = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (Te.isNode(n) && (n = [n]), n.length !== 0) {
      var [p] = n;
      if (l || (l = B0(t), c !== !1 && (c = !0)), c == null && (c = !1), pe.isRange(l))
        if (o || (l = K.unhangRange(t, l, {
          voids: i
        })), pe.isCollapsed(l))
          l = l.anchor;
        else {
          var [, d] = pe.edges(l), g = K.pointRef(t, d);
          Ce.delete(t, {
            at: l
          }), l = g.unref();
        }
      if (Ot.isPoint(l)) {
        u == null && (He.isText(p) ? u = (I) => He.isText(I) : t.isInline(p) ? u = (I) => He.isText(I) || K.isInline(t, I) : u = (I) => Ve.isElement(I) && K.isBlock(t, I));
        var [f] = K.nodes(t, {
          at: l.path,
          match: u,
          mode: a,
          voids: i
        });
        if (f) {
          var [, m] = f, h = K.pathRef(t, m), E = K.isEnd(t, l, m);
          Ce.splitNodes(t, {
            at: l,
            match: u,
            mode: a,
            voids: i
          });
          var w = h.unref();
          l = E ? ie.next(w) : w;
        } else
          return;
      }
      var S = ie.parent(l), x = l[l.length - 1];
      if (!(!i && K.void(t, {
        at: S
      }))) {
        if (s) {
          var y = [], C = ie.levels(S);
          i9(t, () => {
            var I = function() {
              var V = S.concat(x);
              x++;
              var z = {
                type: "insert_node",
                path: V,
                node: B
              };
              t.apply(z), l = ie.next(l), y.push(z), He.isText ? C.push(...Array.from(Te.nodes(B), (H) => {
                var [, X] = H;
                return V.concat(X);
              })) : C.push(V);
            };
            for (var B of n)
              I();
          }, () => {
            SR(t, C, (I) => {
              var B = I;
              for (var $ of y)
                if (ie.operationCanTransformPath($) && (B = ie.transform(B, $), !B))
                  return null;
              return B;
            });
          });
        } else
          for (var P of n) {
            var F = S.concat(x);
            x++, t.apply({
              type: "insert_node",
              path: F,
              node: P
            }), l = ie.next(l);
          }
        if (l = ie.previous(l), c) {
          var _ = K.end(t, l);
          _ && Ce.select(t, _);
        }
      }
    }
  });
}, OV = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  K.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: a
    } = n;
    if (a == null && (a = ie.isPath(r) ? nl(t, r) : (x) => Ve.isElement(x) && K.isBlock(t, x)), !!r) {
      var s = K.nodes(t, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), l = Array.from(s, (x) => {
        var [, y] = x;
        return K.pathRef(t, y);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var p = K.node(t, ie.parent(c)), [d, g] = p, f = c[c.length - 1], {
          length: m
        } = d.children;
        if (m === 1) {
          var h = ie.next(g);
          Ce.moveNodes(t, {
            at: c,
            to: h,
            voids: i
          }), Ce.removeNodes(t, {
            at: g,
            voids: i
          });
        } else if (f === 0)
          Ce.moveNodes(t, {
            at: c,
            to: g,
            voids: i
          });
        else if (f === m - 1) {
          var E = ie.next(g);
          Ce.moveNodes(t, {
            at: c,
            to: E,
            voids: i
          });
        } else {
          var w = ie.next(c), S = ie.next(g);
          Ce.splitNodes(t, {
            at: w,
            voids: i
          }), Ce.moveNodes(t, {
            at: c,
            to: S,
            voids: i
          });
        }
      }
    }
  });
}, kV = ["text"], _V = ["children"], DR = (e, t) => {
  if (Ve.isElement(t)) {
    var n = t;
    return K.isVoid(e, t) ? !0 : n.children.length === 1 ? DR(e, n.children[0]) : !1;
  } else return !K.isEditor(t);
}, LV = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  K.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: a = !1,
      mode: s = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (ie.isPath(o)) {
          var [l] = K.parent(t, o);
          r = (I) => l.children.includes(I);
        } else
          r = (I) => Ve.isElement(I) && K.isBlock(t, I);
      if (!i && pe.isRange(o) && (o = K.unhangRange(t, o, {
        voids: a
      })), pe.isRange(o))
        if (pe.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = pe.edges(o), c = K.pointRef(t, u);
          Ce.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && Ce.select(t, o);
        }
      var [p] = K.nodes(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      }), d = K.previous(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      });
      if (!(!p || !d)) {
        var [g, f] = p, [m, h] = d;
        if (!(f.length === 0 || h.length === 0)) {
          var E = ie.next(h), w = ie.common(f, h), S = ie.isSibling(f, h), x = Array.from(K.levels(t, {
            at: f
          }), (I) => {
            var [B] = I;
            return B;
          }).slice(w.length).slice(0, -1), y = K.above(t, {
            at: f,
            mode: "highest",
            match: (I) => x.includes(I) && DR(t, I)
          }), C = y && K.pathRef(t, y[1]), P, F;
          if (He.isText(g) && He.isText(m)) {
            var _ = Mi(g, kV);
            F = m.text.length, P = _;
          } else if (Ve.isElement(g) && Ve.isElement(m)) {
            var _ = Mi(g, _V);
            F = m.children.length, P = _;
          } else
            throw new Error("Cannot merge the node at path [".concat(f, "] with the previous sibling because it is not the same kind: ").concat(Lr.stringify(g), " ").concat(Lr.stringify(m)));
          S || Ce.moveNodes(t, {
            at: f,
            to: E,
            voids: a
          }), C && Ce.removeNodes(t, {
            at: C.current,
            voids: a
          }), K.shouldMergeNodesRemovePrevNode(t, d, p) ? Ce.removeNodes(t, {
            at: h,
            voids: a
          }) : t.apply({
            type: "merge_node",
            path: E,
            position: F,
            properties: P
          }), C && C.unref();
        }
      }
    }
  });
}, PV = (e, t) => {
  K.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: a
    } = t;
    if (r) {
      a == null && (a = ie.isPath(r) ? nl(e, r) : (g) => Ve.isElement(g) && K.isBlock(e, g));
      var s = K.pathRef(e, n), l = K.nodes(e, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), u = Array.from(l, (g) => {
        var [, f] = g;
        return K.pathRef(e, f);
      });
      for (var c of u) {
        var p = c.unref(), d = s.current;
        p.length !== 0 && e.apply({
          type: "move_node",
          path: p,
          newPath: d
        }), s.current && ie.isSibling(d, p) && ie.isAfter(d, p) && (s.current = ie.next(s.current));
      }
      s.unref();
    }
  });
}, SV = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  K.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = ie.isPath(a) ? nl(t, a) : (g) => Ve.isElement(g) && K.isBlock(t, g)), !r && pe.isRange(a) && (a = K.unhangRange(t, a, {
        voids: o
      }));
      var l = K.nodes(t, {
        at: a,
        match: s,
        mode: i,
        voids: o
      }), u = Array.from(l, (g) => {
        var [, f] = g;
        return K.pathRef(t, f);
      });
      for (var c of u) {
        var p = c.unref();
        if (p) {
          var [d] = K.node(t, p);
          t.apply({
            type: "remove_node",
            path: p,
            node: d
          });
        }
      }
    }
  });
}, DV = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  K.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: a,
      merge: s
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: p = !1
    } = r;
    if (i) {
      if (o == null && (o = ie.isPath(i) ? nl(t, i) : (F) => Ve.isElement(F) && K.isBlock(t, F)), !l && pe.isRange(i) && (i = K.unhangRange(t, i, {
        voids: p
      })), c && pe.isRange(i)) {
        if (pe.isCollapsed(i) && K.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var d = K.rangeRef(t, i, {
          affinity: "inward"
        }), [g, f] = pe.edges(i), m = u === "lowest" ? "lowest" : "highest", h = K.isEnd(t, f, f.path);
        Ce.splitNodes(t, {
          at: f,
          match: o,
          mode: m,
          voids: p,
          always: !h
        });
        var E = K.isStart(t, g, g.path);
        Ce.splitNodes(t, {
          at: g,
          match: o,
          mode: m,
          voids: p,
          always: !E
        }), i = d.unref(), r.at == null && Ce.select(t, i);
      }
      a || (a = (F, _) => F !== _);
      for (var [w, S] of K.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: p
      })) {
        var x = {}, y = {};
        if (S.length !== 0) {
          var C = !1;
          for (var P in n)
            P === "children" || P === "text" || a(n[P], w[P]) && (C = !0, w.hasOwnProperty(P) && (x[P] = w[P]), s ? n[P] != null && (y[P] = s(w[P], n[P])) : n[P] != null && (y[P] = n[P]));
          C && t.apply({
            type: "set_node",
            path: S,
            properties: x,
            newProperties: y
          });
        }
      }
    }
  });
}, MV = (e, t) => {
  if (pe.isCollapsed(t))
    return t.anchor;
  var [, n] = pe.edges(t), r = K.pointRef(e, n);
  return Ce.delete(e, {
    at: t
  }), r.unref();
}, TV = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  K.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: a = t.selection,
      height: s = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (ee) => Ve.isElement(ee) && K.isBlock(t, ee)), pe.isRange(a) && (a = MV(t, a)), ie.isPath(a)) {
      var u = a, c = K.point(t, u), [p] = K.parent(t, u);
      i = (ee) => ee === p, s = c.path.length - u.length + 1, a = c, l = !0;
    }
    if (a) {
      var d = K.pointRef(t, a, {
        affinity: "backward"
      }), g;
      try {
        var [f] = K.nodes(t, {
          at: a,
          match: i,
          mode: r,
          voids: o
        });
        if (!f)
          return;
        var m = K.void(t, {
          at: a,
          mode: "highest"
        }), h = 0;
        if (!o && m) {
          var [E, w] = m;
          if (Ve.isElement(E) && t.isInline(E)) {
            var S = K.after(t, w);
            if (!S) {
              var x = {
                text: ""
              }, y = ie.next(w);
              Ce.insertNodes(t, x, {
                at: y,
                voids: o
              }), S = K.point(t, y);
            }
            a = S, l = !0;
          }
          var C = a.path.length - w.length;
          s = C + 1, l = !0;
        }
        g = K.pointRef(t, a);
        var P = a.path.length - s, [, F] = f, _ = a.path.slice(0, P), I = s === 0 ? a.offset : a.path[P] + h;
        for (var [B, $] of K.levels(t, {
          at: _,
          reverse: !0,
          voids: o
        })) {
          var V = !1;
          if ($.length < F.length || $.length === 0 || !o && Ve.isElement(B) && K.isVoid(t, B))
            break;
          var z = d.current, H = K.isEnd(t, z, $);
          if (l || !d || !K.isEdge(t, z, $)) {
            V = !0;
            var X = Te.extractProps(B);
            t.apply({
              type: "split_node",
              path: $,
              position: I,
              properties: X
            });
          }
          I = $[$.length - 1] + (V || H ? 1 : 0);
        }
        if (n.at == null) {
          var J = g.current || K.end(t, []);
          Ce.select(t, J);
        }
      } finally {
        var te;
        d.unref(), (te = g) === null || te === void 0 || te.unref();
      }
    }
  });
}, jV = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  Ce.setNodes(t, o, r);
}, AV = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  K.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = ie.isPath(a) ? nl(t, a) : (g) => Ve.isElement(g) && K.isBlock(t, g)), ie.isPath(a) && (a = K.range(t, a));
      var l = pe.isRange(a) ? K.rangeRef(t, a) : null, u = K.nodes(t, {
        at: a,
        match: s,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (g) => {
          var [, f] = g;
          return K.pathRef(t, f);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), p = function() {
        var f = d.unref(), [m] = K.node(t, f), h = K.range(t, f);
        o && l && (h = pe.intersection(l.current, h)), Ce.liftNodes(t, {
          at: h,
          match: (E) => Ve.isAncestor(m) && m.children.includes(E),
          voids: i
        });
      };
      for (var d of c)
        p();
      l && l.unref();
    }
  });
};
function EE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function OE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EE(Object(n), !0).forEach(function(r) {
      Gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var BV = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  K.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: a = !1
    } = r, {
      match: s,
      at: l = t.selection
    } = r;
    if (l) {
      if (s == null && (ie.isPath(l) ? s = nl(t, l) : t.isInline(n) ? s = (h) => Ve.isElement(h) && K.isInline(t, h) || He.isText(h) : s = (h) => Ve.isElement(h) && K.isBlock(t, h)), i && pe.isRange(l)) {
        var [u, c] = pe.edges(l), p = K.rangeRef(t, l, {
          affinity: "inward"
        });
        Ce.splitNodes(t, {
          at: c,
          match: s,
          voids: a
        }), Ce.splitNodes(t, {
          at: u,
          match: s,
          voids: a
        }), l = p.unref(), r.at == null && Ce.select(t, l);
      }
      var d = Array.from(K.nodes(t, {
        at: l,
        match: t.isInline(n) ? (h) => Ve.isElement(h) && K.isBlock(t, h) : (h) => K.isEditor(h),
        mode: "lowest",
        voids: a
      })), g = function() {
        var E = pe.isRange(l) ? pe.intersection(l, K.range(t, m)) : l;
        if (!E)
          return 0;
        var w = Array.from(K.nodes(t, {
          at: E,
          match: s,
          mode: o,
          voids: a
        }));
        if (w.length > 0) {
          var [S] = w, x = w[w.length - 1], [, y] = S, [, C] = x;
          if (y.length === 0 && C.length === 0)
            return 0;
          var P = ie.equals(y, C) ? ie.parent(y) : ie.common(y, C), F = K.range(t, y, C), _ = K.node(t, P), [I] = _, B = P.length + 1, $ = ie.next(C.slice(0, B)), V = OE(OE({}, n), {}, {
            children: []
          });
          Ce.insertNodes(t, V, {
            at: $,
            voids: a
          }), Ce.moveNodes(t, {
            at: F,
            match: (z) => Ve.isAncestor(I) && I.children.includes(z),
            to: $.concat(0),
            voids: a
          });
        }
      }, f;
      for (var [, m] of d)
        f = g();
    }
  });
}, RV = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return s9(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return d9(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return g9(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return m9(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return v9(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return l9(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return P9(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return D9(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mV(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return S9(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return T9(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return u9(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lV(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return a9(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return c9(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return p9(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return f9(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return h9(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vV(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gV(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yV(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return y9(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return b9(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return w9(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return C9(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return x9(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return V9(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return O9(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return k9(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _9(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return L9(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return EV(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return j9(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return A9(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return B9(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return R9(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return I9(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return N9(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return F9(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return z9(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return U9(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return OV(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LV(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bV(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return PV(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return H9(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return G9(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return q9(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Z9(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return K9(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return J9(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return X9(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Y9(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return tV(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Q9(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eV(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nV(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rV(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sV(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return oV(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return iV(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return SV(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wV(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return DV(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uV(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return CV(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xV(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return TV(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cV(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pV(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dV(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jV(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return AV(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return E9(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fV(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return BV(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hV(e, ...r);
    }
  };
  return e;
};
const MR = (e) => {
  if (He.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (Ve.isElement(e)) {
    const t = e.children.map((r) => MR(r)).join(""), n = e.align || "left";
    switch (e.type) {
      case "image":
        return `<img src="${e.src}" class="align_${n}" />`;
      case "paragraph":
        return `<p class="align_${n}">${t}</p>`;
      case "blockQuote":
        return `<blockquote class="align_${n}">${t}</blockquote>`;
      case "bulletedList":
        return `<ul class="align_${n}">${t}</ul>`;
      case "headingOne":
        return `<h1 class="align_${n}">${t}</h1>`;
      case "headingTwo":
        return `<h2 class="align_${n}">${t}</h2>`;
      case "listItem":
        return `<li class="align_${n}">${t}</li>`;
      case "numberedList":
        return `<ol class="align_${n}">${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, iEe = (e) => e.map((t) => MR(t)).join("");
var TR = {}, N0 = {}, F0 = {}, Da = {}, z0 = {}, U0 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(U0);
var Dt = {}, ws = xn && xn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), tu = xn && xn.__assign || function() {
  return tu = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, tu.apply(this, arguments);
};
Object.defineProperty(Dt, "__esModule", { value: !0 });
Dt.cloneNode = Dt.hasChildren = Dt.isDocument = Dt.isDirective = Dt.isComment = Dt.isText = Dt.isCDATA = Dt.isTag = Dt.Element = Dt.Document = Dt.CDATA = Dt.NodeWithChildren = Dt.ProcessingInstruction = Dt.Comment = Dt.Text = Dt.DataNode = Dt.Node = void 0;
var so = U0, $0 = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), W0(this, t);
    }, e;
  }()
);
Dt.Node = $0;
var wh = (
  /** @class */
  function(e) {
    ws(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }($0)
);
Dt.DataNode = wh;
var jR = (
  /** @class */
  function(e) {
    ws(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = so.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wh)
);
Dt.Text = jR;
var AR = (
  /** @class */
  function(e) {
    ws(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = so.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wh)
);
Dt.Comment = AR;
var BR = (
  /** @class */
  function(e) {
    ws(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = so.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wh)
);
Dt.ProcessingInstruction = BR;
var Ch = (
  /** @class */
  function(e) {
    ws(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }($0)
);
Dt.NodeWithChildren = Ch;
var RR = (
  /** @class */
  function(e) {
    ws(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = so.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ch)
);
Dt.CDATA = RR;
var IR = (
  /** @class */
  function(e) {
    ws(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = so.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ch)
);
Dt.Document = IR;
var NR = (
  /** @class */
  function(e) {
    ws(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? so.ElementType.Script : n === "style" ? so.ElementType.Style : so.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ch)
);
Dt.Element = NR;
function FR(e) {
  return (0, so.isTag)(e);
}
Dt.isTag = FR;
function zR(e) {
  return e.type === so.ElementType.CDATA;
}
Dt.isCDATA = zR;
function UR(e) {
  return e.type === so.ElementType.Text;
}
Dt.isText = UR;
function $R(e) {
  return e.type === so.ElementType.Comment;
}
Dt.isComment = $R;
function WR(e) {
  return e.type === so.ElementType.Directive;
}
Dt.isDirective = WR;
function VR(e) {
  return e.type === so.ElementType.Root;
}
Dt.isDocument = VR;
function IV(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Dt.hasChildren = IV;
function W0(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (UR(e))
    n = new jR(e.data);
  else if ($R(e))
    n = new AR(e.data);
  else if (FR(e)) {
    var r = t ? fm(e.children) : [], o = new NR(e.name, tu({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = tu({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = tu({}, e["x-attribsPrefix"])), n = o;
  } else if (zR(e)) {
    var r = t ? fm(e.children) : [], i = new RR(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (VR(e)) {
    var r = t ? fm(e.children) : [], a = new IR(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (WR(e)) {
    var s = new BR(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Dt.cloneNode = W0;
function fm(e) {
  for (var t = e.map(function(r) {
    return W0(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = xn && xn.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = xn && xn.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = U0, o = Dt;
  n(Dt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(z0);
var HR = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(HR);
Object.defineProperty(Da, "__esModule", { value: !0 });
Da.formatAttributes = GR;
Da.escapeSpecialCharacters = zV;
Da.revertEscapedCharacters = qR;
Da.formatDOM = ZR;
var Zc = z0, Pu = HR;
function NV(e) {
  return Pu.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function GR(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function FV(e) {
  e = e.toLowerCase();
  var t = NV(e);
  return t || e;
}
function zV(e) {
  return e.replace(Pu.CARRIAGE_RETURN_REGEX, Pu.CARRIAGE_RETURN_PLACEHOLDER);
}
function qR(e) {
  return e.replace(Pu.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Pu.CARRIAGE_RETURN);
}
function ZR(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = FV(s.nodeName);
        o = new Zc.Element(l, GR(s.attributes)), o.children = ZR(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Zc.Text(qR(s.nodeValue));
        break;
      case 8:
        o = new Zc.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Zc.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(F0, "__esModule", { value: !0 });
F0.default = HV;
var UV = Da, kE = "html", _E = "head", Kc = "body", $V = /<([a-zA-Z]+[0-9]?)/, LE = /<head[^]*>/i, PE = /<body[^]*>/i, Vd = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, zy = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, SE = typeof window == "object" && window.DOMParser;
if (typeof SE == "function") {
  var WV = new SE(), VV = "text/html";
  zy = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), WV.parseFromString(e, VV);
  }, Vd = zy;
}
if (typeof document == "object" && document.implementation) {
  var Xc = document.implementation.createHTMLDocument();
  Vd = function(e, t) {
    if (t) {
      var n = Xc.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Xc;
    }
    return Xc.documentElement.innerHTML = e, Xc;
  };
}
var Yc = typeof document == "object" && document.createElement("template"), Uy;
Yc && Yc.content && (Uy = function(e) {
  return Yc.innerHTML = e, Yc.content.childNodes;
});
function HV(e) {
  var t, n;
  e = (0, UV.escapeSpecialCharacters)(e);
  var r = e.match($V), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case kE: {
      var i = zy(e);
      if (!LE.test(e)) {
        var a = i.querySelector(_E);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!PE.test(e)) {
        var a = i.querySelector(Kc);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(kE);
    }
    case _E:
    case Kc: {
      var s = Vd(e).querySelectorAll(o);
      return PE.test(e) && LE.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (Uy)
        return Uy(e);
      var a = Vd(e, Kc).querySelector(Kc);
      return a.childNodes;
    }
  }
}
var GV = xn && xn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(N0, "__esModule", { value: !0 });
N0.default = XV;
var qV = GV(F0), ZV = Da, KV = /<(![a-zA-Z\s]+)>/;
function XV(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(KV), n = t ? t[1] : void 0;
  return (0, ZV.formatDOM)((0, qV.default)(e), null, n);
}
var xh = {}, Fo = {}, Eh = {}, YV = 0;
Eh.SAME = YV;
var JV = 1;
Eh.CAMELCASE = JV;
Eh.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const KR = 0, Cs = 1, Oh = 2, kh = 3, V0 = 4, XR = 5, YR = 6;
function QV(e) {
  return Tr.hasOwnProperty(e) ? Tr[e] : null;
}
function qr(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Oh || t === kh || t === V0, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Tr = {}, eH = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
eH.forEach((e) => {
  Tr[e] = new qr(
    e,
    KR,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Tr[e] = new qr(
    e,
    Cs,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Tr[e] = new qr(
    e,
    Oh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Tr[e] = new qr(
    e,
    Oh,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Tr[e] = new qr(
    e,
    kh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Tr[e] = new qr(
    e,
    kh,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Tr[e] = new qr(
    e,
    V0,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Tr[e] = new qr(
    e,
    YR,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Tr[e] = new qr(
    e,
    XR,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const H0 = /[\-\:]([a-z])/g, G0 = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(H0, G0);
  Tr[t] = new qr(
    t,
    Cs,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(H0, G0);
  Tr[t] = new qr(
    t,
    Cs,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(H0, G0);
  Tr[t] = new qr(
    t,
    Cs,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Tr[e] = new qr(
    e,
    Cs,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const tH = "xlinkHref";
Tr[tH] = new qr(
  "xlinkHref",
  Cs,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Tr[e] = new qr(
    e,
    Cs,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: nH,
  SAME: rH,
  possibleStandardNames: DE
} = Eh, oH = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", iH = oH + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", sH = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + iH + "]*$")
), aH = Object.keys(
  DE
).reduce((e, t) => {
  const n = DE[t];
  return n === rH ? e[t] = t : n === nH ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Fo.BOOLEAN = kh;
Fo.BOOLEANISH_STRING = Oh;
Fo.NUMERIC = XR;
Fo.OVERLOADED_BOOLEAN = V0;
Fo.POSITIVE_NUMERIC = YR;
Fo.RESERVED = KR;
Fo.STRING = Cs;
Fo.getPropertyInfo = QV;
Fo.isCustomAttribute = sH;
Fo.possibleStandardNames = aH;
var q0 = {}, Z0 = {}, ME = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, lH = /\n/g, uH = /^\s*/, cH = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, pH = /^:\s*/, dH = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, fH = /^[;\s]*/, hH = /^\s+|\s+$/g, gH = `
`, TE = "/", jE = "*", Qs = "", mH = "comment", vH = "declaration", yH = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(lH);
    m && (n += m.length);
    var h = f.lastIndexOf(gH);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var h = m[0];
      return o(h), e = e.slice(h.length), m;
    }
  }
  function u() {
    l(uH);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(TE != e.charAt(0) || jE != e.charAt(1))) {
      for (var m = 2; Qs != e.charAt(m) && (jE != e.charAt(m) || TE != e.charAt(m + 1)); )
        ++m;
      if (m += 2, Qs === e.charAt(m - 1))
        return s("End of comment missing");
      var h = e.slice(2, m - 2);
      return r += 2, o(h), e = e.slice(m), r += 2, f({
        type: mH,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), m = l(cH);
    if (m) {
      if (p(), !l(pH)) return s("property missing ':'");
      var h = l(dH), E = f({
        type: vH,
        property: AE(m[0].replace(ME, Qs)),
        value: h ? AE(h[0].replace(ME, Qs)) : Qs
      });
      return l(fH), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function AE(e) {
  return e ? e.replace(hH, Qs) : Qs;
}
var bH = xn && xn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Z0, "__esModule", { value: !0 });
Z0.default = CH;
var wH = bH(yH);
function CH(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, wH.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var _h = {};
Object.defineProperty(_h, "__esModule", { value: !0 });
_h.camelCase = void 0;
var xH = /^--[a-zA-Z0-9_-]+$/, EH = /-([a-z])/g, OH = /^[^-]+$/, kH = /^-(webkit|moz|ms|o|khtml)-/, _H = /^-(ms)-/, LH = function(e) {
  return !e || OH.test(e) || xH.test(e);
}, PH = function(e, t) {
  return t.toUpperCase();
}, BE = function(e, t) {
  return "".concat(t, "-");
}, SH = function(e, t) {
  return t === void 0 && (t = {}), LH(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(_H, BE) : e = e.replace(kH, BE), e.replace(EH, PH));
};
_h.camelCase = SH;
var DH = xn && xn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, MH = DH(Z0), TH = _h;
function $y(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, MH.default)(e, function(r, o) {
    r && o && (n[(0, TH.camelCase)(r, t)] = o);
  }), n;
}
$y.default = $y;
var jH = $y;
(function(e) {
  var t = xn && xn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(jH), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(q0);
Object.defineProperty(xh, "__esModule", { value: !0 });
xh.default = IH;
var Hl = Fo, RE = q0, AH = ["checked", "value"], BH = ["input", "select", "textarea"], RH = {
  reset: !0,
  submit: !0
};
function IH(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && RH[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Hl.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = IE(a);
    if (s) {
      var l = (0, Hl.getPropertyInfo)(s);
      switch (AH.includes(s) && BH.includes(t) && !r && (s = IE("default" + a)), n[s] = i, l && l.type) {
        case Hl.BOOLEAN:
          n[s] = !0;
          break;
        case Hl.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    RE.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, RE.setStyleProp)(e.style, n), n;
}
function IE(e) {
  return Hl.possibleStandardNames[e];
}
var K0 = {}, NH = xn && xn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(K0, "__esModule", { value: !0 });
K0.default = JR;
var hm = Oe, FH = NH(xh), nu = q0, zH = {
  cloneElement: hm.cloneElement,
  createElement: hm.createElement,
  isValidElement: hm.isValidElement
};
function JR(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || nu.returnFirstArg, i = t.library || zH, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, nu.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    UH(f) ? ((0, nu.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, FH.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (h = JR(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function UH(e) {
  return nu.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, nu.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = xn && xn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(N0);
  e.htmlToDOM = n.default;
  var r = t(xh);
  e.attributesToProps = r.default;
  var o = t(K0);
  e.domToReact = o.default;
  var i = z0;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(TR);
const NE = /* @__PURE__ */ gh(TR), $H = NE.default || NE, Wy = (e) => {
  var r;
  if (typeof e == "string")
    return { text: e };
  const t = Array.isArray(e.props.children) ? e.props.children.map((o) => Wy(o)) : [{ text: e.props.children || "" }], n = (r = e.props.className) == null ? void 0 : r.replace("align_", "");
  switch (e.type) {
    case "img":
      return {
        type: "image",
        align: n,
        src: e.props.src,
        children: [{ text: "" }]
      };
    case "p":
      return { type: "paragraph", align: n, children: t };
    case "blockquote":
      return { type: "blockQuote", align: n, children: t };
    case "ul":
      return { type: "bulletedList", align: n, children: t };
    case "ol":
      return { type: "numberedList", align: n, children: t };
    case "li":
      return { type: "listItem", align: n, children: t };
    case "h1":
      return { type: "headingOne", align: n, children: t };
    case "h2":
      return { type: "headingTwo", align: n, children: t };
    case "strong":
      return { text: e.props.children, bold: !0 };
    case "code":
      return { text: e.props.children, code: !0 };
    case "em":
      return { text: e.props.children, italic: !0 };
    case "u":
      return { text: e.props.children, underline: !0 };
    default:
      return { text: e.props.children || "" };
  }
}, sEe = (e) => {
  const t = $H(e);
  return Array.isArray(t) ? t.map((n) => typeof n == "string" ? { text: n } : Wy(n)) : typeof t == "string" ? [{ text: t }] : [Wy(t)];
}, aEe = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function QR(e, t, n) {
  if (!e) return /* @__PURE__ */ q.jsx(q.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ q.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ q.jsx("p", { className: n, children: /* @__PURE__ */ q.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function lEe(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: a = "",
    children: s,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], p = `arkynBadge ${t} ${n} ${r} ${a}`;
  return /* @__PURE__ */ q.jsxs("div", { className: p.trim(), ...l, children: [
    Nd(c, o),
    s,
    Nd(c, i)
  ] });
}
function uEe(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ q.jsx("div", { className: r.trim(), ...n });
}
function eI(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ q.jsx("div", { className: o.trim(), ...r });
}
function cEe(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ q.jsx("aside", { className: r.trim(), ...n });
}
function pEe(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, a = it.count(r) === 0;
  return /* @__PURE__ */ q.jsx("tbody", { className: i.trim(), ...o, children: a ? /* @__PURE__ */ q.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ q.jsx("td", { colSpan: 100, children: /* @__PURE__ */ q.jsx("div", { children: t }) }) }) : r });
}
function dEe(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ q.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ q.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function fEe(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ q.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ q.jsx("table", { children: t }) });
}
function hEe(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ q.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ q.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ q.jsx("tr", { children: /* @__PURE__ */ q.jsx("th", { colSpan: 100, children: /* @__PURE__ */ q.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function gEe(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ q.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ q.jsx("tr", { children: n }),
    /* @__PURE__ */ q.jsx("tr", { className: "spacingRow" })
  ] });
}
var En = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function WH(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Vy = { exports: {} }, wl = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var FE;
function VH() {
  if (FE) return wl;
  FE = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return wl.Fragment = n, wl.jsx = a, wl.jsxs = a, wl;
}
var Jc = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zE;
function HH() {
  return zE || (zE = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var R = f && b[f] || b[m];
      return typeof R == "function" ? R : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var R = arguments.length, Y = new Array(R > 1 ? R - 1 : 0), ne = 1; ne < R; ne++)
          Y[ne - 1] = arguments[ne];
        S("error", b, Y);
      }
    }
    function S(b, R, Y) {
      {
        var ne = E.ReactDebugCurrentFrame, ue = ne.getStackAddendum();
        ue !== "" && (R += "%s", Y = Y.concat([ue]));
        var ce = Y.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + R), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, y = !1, C = !1, P = !1, F = !1, _;
    _ = Symbol.for("react.module.reference");
    function I(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || P || b === g || x || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === _ || b.getModuleId !== void 0));
    }
    function B(b, R, Y) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var ue = R.displayName || R.name || "";
      return ue !== "" ? Y + "(" + ue + ")" : Y;
    }
    function $(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var R = b;
            return $(R) + ".Consumer";
          case a:
            var Y = b;
            return $(Y._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var ue = b, ce = ue._payload, ae = ue._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, H = 0, X, J, te, ee, L, T, W;
    function D() {
    }
    D.__reactDisabledLog = !0;
    function G() {
      {
        if (H === 0) {
          X = console.log, J = console.info, te = console.warn, ee = console.error, L = console.group, T = console.groupCollapsed, W = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: D,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        H++;
      }
    }
    function O() {
      {
        if (H--, H === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: X
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: L
            }),
            groupCollapsed: z({}, b, {
              value: T
            }),
            groupEnd: z({}, b, {
              value: W
            })
          });
        }
        H < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = E.ReactCurrentDispatcher, U;
    function j(b, R, Y) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ue) {
            var ne = ue.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var Z = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function N(b, R) {
      if (!b || Z)
        return "";
      {
        var Y = A.get(b);
        if (Y !== void 0)
          return Y;
      }
      var ne;
      Z = !0;
      var ue = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = M.current, M.current = null, G();
      try {
        if (R) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Ne) {
              ne = Ne;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Ne) {
              ne = Ne;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            ne = Ne;
          }
          b();
        }
      } catch (Ne) {
        if (Ne && ne && typeof Ne.stack == "string") {
          for (var se = Ne.stack.split(`
`), Ae = ne.stack.split(`
`), we = se.length - 1, xe = Ae.length - 1; we >= 1 && xe >= 0 && se[we] !== Ae[xe]; )
            xe--;
          for (; we >= 1 && xe >= 0; we--, xe--)
            if (se[we] !== Ae[xe]) {
              if (we !== 1 || xe !== 1)
                do
                  if (we--, xe--, xe < 0 || se[we] !== Ae[xe]) {
                    var Ge = `
` + se[we].replace(" at new ", " at ");
                    return b.displayName && Ge.includes("<anonymous>") && (Ge = Ge.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ge), Ge;
                  }
                while (we >= 1 && xe >= 0);
              break;
            }
        }
      } finally {
        Z = !1, M.current = ce, O(), Error.prepareStackTrace = ue;
      }
      var Jt = b ? b.displayName || b.name : "", Et = Jt ? j(Jt) : "";
      return typeof b == "function" && A.set(b, Et), Et;
    }
    function le(b, R, Y) {
      return N(b, !1);
    }
    function ye(b) {
      var R = b.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(b, R, Y) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, ye(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return le(b.render);
          case p:
            return oe(b.type, R, Y);
          case d: {
            var ne = b, ue = ne._payload, ce = ne._init;
            try {
              return oe(ce(ue), R, Y);
            } catch {
            }
          }
        }
      return "";
    }
    var Be = Object.prototype.hasOwnProperty, Ue = {}, $e = E.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var R = b._owner, Y = oe(b.type, b._source, R ? R.type : null);
        $e.setExtraStackFrame(Y);
      } else
        $e.setExtraStackFrame(null);
    }
    function Je(b, R, Y, ne, ue) {
      {
        var ce = Function.call.bind(Be);
        for (var ae in b)
          if (ce(b, ae)) {
            var se = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Ae = Error((ne || "React class") + ": " + Y + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ae.name = "Invariant Violation", Ae;
              }
              se = b[ae](R, ae, ne, Y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (we) {
              se = we;
            }
            se && !(se instanceof Error) && (Ie(ue), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", Y, ae, typeof se), Ie(null)), se instanceof Error && !(se.message in Ue) && (Ue[se.message] = !0, Ie(ue), w("Failed %s type: %s", Y, se.message), Ie(null));
          }
      }
    }
    var Ze = Array.isArray;
    function Me(b) {
      return Ze(b);
    }
    function Ye(b) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, Y = R && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Y;
      }
    }
    function nt(b) {
      try {
        return De(b), !1;
      } catch {
        return !0;
      }
    }
    function De(b) {
      return "" + b;
    }
    function je(b) {
      if (nt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ye(b)), De(b);
    }
    var Ke = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Fe, et;
    function Re(b) {
      if (Be.call(b, "ref")) {
        var R = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function Rt(b) {
      if (Be.call(b, "key")) {
        var R = Object.getOwnPropertyDescriptor(b, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function rt(b, R) {
      typeof b.ref == "string" && Ke.current;
    }
    function ot(b, R) {
      {
        var Y = function() {
          Fe || (Fe = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Y,
          configurable: !0
        });
      }
    }
    function at(b, R) {
      {
        var Y = function() {
          et || (et = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Y,
          configurable: !0
        });
      }
    }
    var Kt = function(b, R, Y, ne, ue, ce, ae) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: R,
        ref: Y,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ue
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function lt(b, R, Y, ne, ue) {
      {
        var ce, ae = {}, se = null, Ae = null;
        Y !== void 0 && (je(Y), se = "" + Y), Rt(R) && (je(R.key), se = "" + R.key), Re(R) && (Ae = R.ref, rt(R));
        for (ce in R)
          Be.call(R, ce) && !We.hasOwnProperty(ce) && (ae[ce] = R[ce]);
        if (b && b.defaultProps) {
          var we = b.defaultProps;
          for (ce in we)
            ae[ce] === void 0 && (ae[ce] = we[ce]);
        }
        if (se || Ae) {
          var xe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && ot(ae, xe), Ae && at(ae, xe);
        }
        return Kt(b, se, Ae, ue, ne, Ke.current, ae);
      }
    }
    var ut = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var R = b._owner, Y = oe(b.type, b._source, R ? R.type : null);
        tt.setExtraStackFrame(Y);
      } else
        tt.setExtraStackFrame(null);
    }
    var Xt;
    Xt = !1;
    function Yt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function bt() {
      {
        if (ut.current) {
          var b = V(ut.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Rn(b) {
      return "";
    }
    var wt = {};
    function In(b) {
      {
        var R = bt();
        if (!R) {
          var Y = typeof b == "string" ? b : b.displayName || b.name;
          Y && (R = `

Check the top-level render call using <` + Y + ">.");
        }
        return R;
      }
    }
    function Ct(b, R) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Y = In(R);
        if (wt[Y])
          return;
        wt[Y] = !0;
        var ne = "";
        b && b._owner && b._owner !== ut.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Y, ne), Xe(null);
      }
    }
    function fn(b, R) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var Y = 0; Y < b.length; Y++) {
            var ne = b[Y];
            Yt(ne) && Ct(ne, R);
          }
        else if (Yt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ue = h(b);
          if (typeof ue == "function" && ue !== b.entries)
            for (var ce = ue.call(b), ae; !(ae = ce.next()).done; )
              Yt(ae.value) && Ct(ae.value, R);
        }
      }
    }
    function wr(b) {
      {
        var R = b.type;
        if (R == null || typeof R == "string")
          return;
        var Y;
        if (typeof R == "function")
          Y = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          Y = R.propTypes;
        else
          return;
        if (Y) {
          var ne = V(R);
          Je(Y, b.props, "prop", ne, b);
        } else if (R.PropTypes !== void 0 && !Xt) {
          Xt = !0;
          var ue = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ue || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function xt(b) {
      {
        for (var R = Object.keys(b.props), Y = 0; Y < R.length; Y++) {
          var ne = R[Y];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function Qr(b, R, Y, ne, ue, ce) {
      {
        var ae = I(b);
        if (!ae) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ae = Rn();
          Ae ? se += Ae : se += bt();
          var we;
          b === null ? we = "null" : Me(b) ? we = "array" : b !== void 0 && b.$$typeof === t ? (we = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : we = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", we, se);
        }
        var xe = lt(b, R, Y, ue, ce);
        if (xe == null)
          return xe;
        if (ae) {
          var Ge = R.children;
          if (Ge !== void 0)
            if (ne)
              if (Me(Ge)) {
                for (var Jt = 0; Jt < Ge.length; Jt++)
                  fn(Ge[Jt], b);
                Object.freeze && Object.freeze(Ge);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              fn(Ge, b);
        }
        if (Be.call(R, "key")) {
          var Et = V(b), Ne = Object.keys(R).filter(function(gi) {
            return gi !== "key";
          }), Cr = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[Et + Cr]) {
            var hi = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Cr, Et, hi, Et), re[Et + Cr] = !0;
          }
        }
        return b === r ? xt(xe) : wr(xe), xe;
      }
    }
    function ci(b, R, Y) {
      return Qr(b, R, Y, !0);
    }
    function pi(b, R, Y) {
      return Qr(b, R, Y, !1);
    }
    var di = pi, fi = ci;
    Jc.Fragment = r, Jc.jsx = di, Jc.jsxs = fi;
  }()), Jc;
}
process.env.NODE_ENV === "production" ? Vy.exports = VH() : Vy.exports = HH();
var on = Vy.exports;
qe({});
function UE(e, t) {
  return t ? /* @__PURE__ */ on.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ on.jsx(on.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function $E(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Nr(e) {
  var t, n;
  return $E(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !($E(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var tI = Symbol.for("immer-nothing"), WE = Symbol.for("immer-draftable"), Eo = Symbol.for("immer-state"), GH = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function no(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = GH[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Za = Object.getPrototypeOf;
function ya(e) {
  return !!e && !!e[Eo];
}
function ba(e) {
  var t;
  return e ? nI(e) || Array.isArray(e) || !!e[WE] || !!((t = e.constructor) != null && t[WE]) || Ph(e) || Sh(e) : !1;
}
var qH = Object.prototype.constructor.toString();
function nI(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Za(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === qH;
}
function Hd(e, t) {
  Lh(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Lh(e) {
  const t = e[Eo];
  return t ? t.type_ : Array.isArray(e) ? 1 : Ph(e) ? 2 : Sh(e) ? 3 : 0;
}
function Hy(e, t) {
  return Lh(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function rI(e, t, n) {
  const r = Lh(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function ZH(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Ph(e) {
  return e instanceof Map;
}
function Sh(e) {
  return e instanceof Set;
}
function Zs(e) {
  return e.copy_ || e.base_;
}
function Gy(e, t) {
  if (Ph(e))
    return new Map(e);
  if (Sh(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = nI(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Eo];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Za(e), r);
  } else {
    const r = Za(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function X0(e, t = !1) {
  return Dh(e) || ya(e) || !ba(e) || (Lh(e) > 1 && (e.set = e.add = e.clear = e.delete = KH), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => X0(r, !0))), e;
}
function KH() {
  no(2);
}
function Dh(e) {
  return Object.isFrozen(e);
}
var XH = {};
function wa(e) {
  const t = XH[e];
  return t || no(0, e), t;
}
var Su;
function oI() {
  return Su;
}
function YH(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function VE(e, t) {
  t && (wa("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function qy(e) {
  Zy(e), e.drafts_.forEach(JH), e.drafts_ = null;
}
function Zy(e) {
  e === Su && (Su = e.parent_);
}
function HE(e) {
  return Su = YH(Su, e);
}
function JH(e) {
  const t = e[Eo];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function GE(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Eo].modified_ && (qy(t), no(4)), ba(e) && (e = Gd(t, e), t.parent_ || qd(t, e)), t.patches_ && wa("Patches").generateReplacementPatches_(
    n[Eo].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Gd(t, n, []), qy(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== tI ? e : void 0;
}
function Gd(e, t, n) {
  if (Dh(t))
    return t;
  const r = t[Eo];
  if (!r)
    return Hd(
      t,
      (o, i) => qE(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return qd(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Hd(
      i,
      (s, l) => qE(e, r, o, s, l, n, a)
    ), qd(e, o, !1), n && e.patches_ && wa("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function qE(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && no(5), ya(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Hy(t.assigned_, r) ? i.concat(r) : void 0, l = Gd(e, o, s);
    if (rI(n, r, l), ya(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (ba(o) && !Dh(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Gd(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && qd(e, o);
  }
}
function qd(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && X0(t, n);
}
function QH(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : oI(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Y0;
  n && (o = [r], i = Du);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var Y0 = {
  get(e, t) {
    if (t === Eo)
      return e;
    const n = Zs(e);
    if (!Hy(n, t))
      return e6(e, n, t);
    const r = n[t];
    return e.finalized_ || !ba(r) ? r : r === gm(e.base_, t) ? (mm(e), e.copy_[t] = Xy(r, e)) : r;
  },
  has(e, t) {
    return t in Zs(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Zs(e));
  },
  set(e, t, n) {
    const r = iI(Zs(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = gm(Zs(e), t), i = o == null ? void 0 : o[Eo];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (ZH(n, o) && (n !== void 0 || Hy(e.base_, t)))
        return !0;
      mm(e), Ky(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return gm(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, mm(e), Ky(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Zs(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    no(11);
  },
  getPrototypeOf(e) {
    return Za(e.base_);
  },
  setPrototypeOf() {
    no(12);
  }
}, Du = {};
Hd(Y0, (e, t) => {
  Du[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Du.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && no(13), Du.set.call(this, e, t, void 0);
};
Du.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && no(14), Y0.set.call(this, e[0], t, n, e[0]);
};
function gm(e, t) {
  const n = e[Eo];
  return (n ? Zs(n) : e)[t];
}
function e6(e, t, n) {
  var r;
  const o = iI(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function iI(e, t) {
  if (!(t in e))
    return;
  let n = Za(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Za(n);
  }
}
function Ky(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Ky(e.parent_));
}
function mm(e) {
  e.copy_ || (e.copy_ = Gy(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var t6 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && no(6), r !== void 0 && typeof r != "function" && no(7);
      let o;
      if (ba(t)) {
        const i = HE(this), a = Xy(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? qy(i) : Zy(i);
        }
        return VE(i, r), GE(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === tI && (o = void 0), this.autoFreeze_ && X0(o, !0), r) {
          const i = [], a = [];
          wa("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        no(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ba(e) || no(8), ya(e) && (e = n6(e));
    const t = HE(this), n = Xy(e, void 0);
    return n[Eo].isManual_ = !0, Zy(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Eo];
    (!n || !n.isManual_) && no(9);
    const { scope_: r } = n;
    return VE(r, t), GE(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = wa("Patches").applyPatches_;
    return ya(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Xy(e, t) {
  const n = Ph(e) ? wa("MapSet").proxyMap_(e, t) : Sh(e) ? wa("MapSet").proxySet_(e, t) : QH(e, t);
  return (t ? t.scope_ : oI()).drafts_.push(n), n;
}
function n6(e) {
  return ya(e) || no(10, e), sI(e);
}
function sI(e) {
  if (!ba(e) || Dh(e))
    return e;
  const t = e[Eo];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Gy(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Gy(e, !0);
  return Hd(n, (r, o) => {
    rI(n, r, sI(o));
  }), t && (t.finalized_ = !1), n;
}
var Oo = new t6(), J0 = Oo.produce;
Oo.produceWithPatches.bind(
  Oo
);
Oo.setAutoFreeze.bind(Oo);
Oo.setUseStrictShallowCopy.bind(Oo);
Oo.applyPatches.bind(Oo);
var ZE = Oo.createDraft.bind(Oo), KE = Oo.finishDraft.bind(Oo), _e = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = _e.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return _e.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return _e.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return _e.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return _e.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && _e.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return _e.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && _e.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && _e.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && _e.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && _e.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && _e.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!_e.isAncestor(t, e) && !_e.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (_e.equals(i, r) || _e.endsBefore(i, r) || _e.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (_e.equals(a, r) || _e.isAncestor(a, r))
          return null;
        _e.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        _e.equals(s, r) || _e.endsBefore(s, r) ? r[s.length - 1] -= 1 : _e.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (_e.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else _e.endsBefore(u, r) ? r[u.length - 1] += 1 : _e.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (_e.equals(p, d))
          return r;
        if (_e.isAncestor(p, r) || _e.equals(p, r)) {
          var g = d.slice();
          return _e.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else _e.isSibling(p, d) && (_e.isAncestor(d, r) || _e.equals(d, r)) ? _e.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : _e.endsBefore(d, r) || _e.equals(d, r) || _e.isAncestor(d, r) ? (_e.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : _e.endsBefore(p, r) && (_e.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Mu(e) {
  "@babel/helpers - typeof";
  return Mu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Mu(e);
}
function r6(e, t) {
  if (Mu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Mu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function o6(e) {
  var t = r6(e, "string");
  return Mu(t) === "symbol" ? t : String(t);
}
function rl(e, t, n) {
  return t = o6(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function XE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XE(Object(n), !0).forEach(function(r) {
      rl(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var i6 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = ct.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of kt.points(t))
          t[l] = Mn.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = ct.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, h] of kt.points(t))
          t[h] = Mn.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = ct.get(e, E), S = _e.previous(E), x = ct.get(e, S), y = ct.parent(e, E), C = E[E.length - 1];
      if (cr.isText(w) && cr.isText(x))
        x.text += w.text;
      else if (!cr.isText(w) && !cr.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(po.stringify(w), " ").concat(po.stringify(x)));
      if (y.children.splice(C, 1), t)
        for (var [P, F] of kt.points(t))
          t[F] = Mn.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: _,
        newPath: I
      } = n;
      if (_e.isAncestor(_, I))
        throw new Error("Cannot move a path [".concat(_, "] to new path [").concat(I, "] because the destination is inside itself."));
      var B = ct.get(e, _), $ = ct.parent(e, _), V = _[_.length - 1];
      $.children.splice(V, 1);
      var z = _e.transform(_, n), H = ct.get(e, _e.parent(z)), X = z[z.length - 1];
      if (H.children.splice(X, 0, B), t)
        for (var [J, te] of kt.points(t))
          t[te] = Mn.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, L = ee[ee.length - 1], T = ct.parent(e, ee);
      if (T.children.splice(L, 1), t)
        for (var [W, D] of kt.points(t)) {
          var G = Mn.transform(W, n);
          if (t != null && G != null)
            t[D] = G;
          else {
            var O = void 0, M = void 0;
            for (var [U, j] of ct.texts(e))
              if (_e.compare(j, ee) === -1)
                O = [U, j];
              else {
                M = [U, j];
                break;
              }
            var Z = !1;
            O && M && (_e.equals(M[1], ee) ? Z = !_e.hasPrevious(M[1]) : Z = _e.common(O[1], ee).length < _e.common(M[1], ee).length), O && !Z ? (W.path = O[1], W.offset = O[0].text.length) : M ? (W.path = M[1], W.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: N
      } = n;
      if (N.length === 0) break;
      var le = ct.leaf(e, A), ye = le.text.slice(0, Q), oe = le.text.slice(Q + N.length);
      if (le.text = ye + oe, t)
        for (var [Be, Ue] of kt.points(t))
          t[Ue] = Mn.transform(Be, n);
      break;
    }
    case "set_node": {
      var {
        path: $e,
        properties: Ie,
        newProperties: Je
      } = n;
      if ($e.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ze = ct.get(e, $e);
      for (var Me in Je) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Ye = Je[Me];
        Ye == null ? delete Ze[Me] : Ze[Me] = Ye;
      }
      for (var nt in Ie)
        Je.hasOwnProperty(nt) || delete Ze[nt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: De
      } = n;
      if (De == null)
        t = De;
      else {
        if (t == null) {
          if (!kt.isRange(De))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(po.stringify(De), " when there is no current selection."));
          t = Cl({}, De);
        }
        for (var je in De) {
          var Ke = De[je];
          if (Ke == null) {
            if (je === "anchor" || je === "focus")
              throw new Error('Cannot remove the "'.concat(je, '" selection property'));
            delete t[je];
          } else
            t[je] = Ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Fe,
        properties: et
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var Re = ct.get(e, We), Rt = ct.parent(e, We), rt = We[We.length - 1], ot;
      if (cr.isText(Re)) {
        var at = Re.text.slice(0, Fe), Kt = Re.text.slice(Fe);
        Re.text = at, ot = Cl(Cl({}, et), {}, {
          text: Kt
        });
      } else {
        var lt = Re.children.slice(0, Fe), ut = Re.children.slice(Fe);
        Re.children = lt, ot = Cl(Cl({}, et), {}, {
          children: ut
        });
      }
      if (Rt.children.splice(rt + 1, 0, ot), t)
        for (var [tt, Xe] of kt.points(t))
          t[Xe] = Mn.transform(tt, n);
      break;
    }
  }
  return t;
}, s6 = {
  transform(e, t) {
    e.children = ZE(e.children);
    var n = e.selection && ZE(e.selection);
    try {
      n = i6(e, n, t);
    } finally {
      e.children = KE(e.children), n ? e.selection = ya(n) ? KE(n) : n : e.selection = null;
    }
  }
}, a6 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, l6 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, aI = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Nr(r) && Nr(o)) {
      if (!aI(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function u6(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Tu(e, t) {
  if (e == null) return {};
  var n = u6(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var c6 = ["anchor", "focus"];
function YE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function p6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YE(Object(n), !0).forEach(function(r) {
      rl(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return kt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = kt.edges(e);
    return t;
  },
  equals(e, t) {
    return Mn.equals(e.anchor, t.anchor) && Mn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (kt.isRange(t)) {
      if (kt.includes(e, t.anchor) || kt.includes(e, t.focus))
        return !0;
      var [n, r] = kt.edges(e), [o, i] = kt.edges(t);
      return Mn.isBefore(n, o) && Mn.isAfter(r, i);
    }
    var [a, s] = kt.edges(e), l = !1, u = !1;
    return Mn.isPoint(t) ? (l = Mn.compare(t, a) >= 0, u = Mn.compare(t, s) <= 0) : (l = _e.compare(t, a.path) >= 0, u = _e.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Tu(e, c6), [r, o] = kt.edges(e), [i, a] = kt.edges(t), s = Mn.isBefore(r, i) ? i : r, l = Mn.isBefore(o, a) ? o : a;
    return Mn.isBefore(l, s) ? null : p6({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Mn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Mn.equals(t, n);
  },
  isExpanded(e) {
    return !kt.isCollapsed(e);
  },
  isForward(e) {
    return !kt.isBackward(e);
  },
  isRange(e) {
    return Nr(e) && Mn.isPoint(e.anchor) && Mn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = kt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return J0(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = kt.isCollapsed(r);
        kt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? kt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Mn.transform(r.anchor, t, {
        affinity: i
      }), u = Mn.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, JE = (e) => Nr(e) && ct.isNodeList(e.children) && !yn.isEditor(e), _i = {
  isAncestor(e) {
    return Nr(e) && ct.isNodeList(e.children);
  },
  isElement: JE,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => _i.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return JE(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, d6 = ["children"], f6 = ["text"], QE = /* @__PURE__ */ new WeakMap(), ct = {
  ancestor(e, t) {
    var n = ct.get(e, t);
    if (cr.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(po.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of _e.ancestors(t, n)) {
        var o = ct.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (cr.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(po.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(po.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = ct.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = ct.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = _e.common(t, n), o = ct.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = ct.get(e, t);
    if (yn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(po.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ct.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ct.nodes(e, t))
        _i.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (_i.isAncestor(e)) {
      var t = Tu(e, d6);
      return t;
    } else {
      var t = Tu(e, f6);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = ct.get(e, n); r && !(cr.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (cr.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(po.stringify(e)));
    var n = J0({
      children: e.children
    }, (r) => {
      var [o, i] = kt.edges(t), a = ct.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !kt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!kt.includes(t, s)) {
          var l = ct.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (_e.equals(s, i.path)) {
          var c = ct.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (_e.equals(s, o.path)) {
          var p = ct.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      yn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (cr.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(po.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (cr.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return cr.isText(e) || _i.isElement(e) || yn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = QE.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => ct.isNode(r));
    return QE.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = ct.get(e, n); r && !(cr.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = ct.get(e, t);
    if (!cr.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(po.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of _e.levels(t, n)) {
        var o = ct.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return _i.isElement(e) && _i.isElementProps(t) && _i.matches(e, t) || cr.isText(e) && cr.isTextProps(t) && cr.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? _e.isBefore(s, i) : _e.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !cr.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          _e.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = ct.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = _e.next(s);
          if (ct.has(e, c)) {
            s = c, l = ct.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = _e.previous(s);
          s = p, l = ct.get(e, s);
          continue;
        }
        s = _e.parent(s), l = ct.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = _e.parent(t), r = ct.get(e, n);
    if (cr.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return cr.isText(e) ? e.text : e.children.map(ct.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ct.nodes(e, t))
        cr.isText(n) && (yield [n, r]);
    }();
  }
};
function eO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eO(Object(n), !0).forEach(function(r) {
      rl(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Gl = {
  isNodeOperation(e) {
    return Gl.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Nr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return _e.isPath(e.path) && ct.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && _e.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && _e.isPath(e.path) && Nr(e.properties);
      case "move_node":
        return _e.isPath(e.path) && _e.isPath(e.newPath);
      case "remove_node":
        return _e.isPath(e.path) && ct.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && _e.isPath(e.path);
      case "set_node":
        return _e.isPath(e.path) && Nr(e.properties) && Nr(e.newProperties);
      case "set_selection":
        return e.properties === null && kt.isRange(e.newProperties) || e.newProperties === null && kt.isRange(e.properties) || Nr(e.properties) && Nr(e.newProperties);
      case "split_node":
        return _e.isPath(e.path) && typeof e.position == "number" && Nr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Gl.isOperation(t));
  },
  isSelectionOperation(e) {
    return Gl.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Gl.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Fn(Fn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Fn(Fn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Fn(Fn({}, e), {}, {
          type: "split_node",
          path: _e.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (_e.equals(t, n))
          return e;
        if (_e.isSibling(n, t))
          return Fn(Fn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = _e.transform(n, e), o = _e.transform(_e.next(n), e);
        return Fn(Fn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Fn(Fn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Fn(Fn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Fn(Fn({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Fn(Fn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Fn(Fn({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Fn(Fn({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Fn(Fn({}, e), {}, {
          type: "merge_node",
          path: _e.next(e.path)
        });
    }
  }
}, tO = /* @__PURE__ */ new WeakMap(), h6 = (e) => {
  var t = tO.get(e);
  if (t !== void 0)
    return t;
  if (!Nr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Nr(e.marks)) && (e.selection === null || kt.isRange(e.selection)) && ct.isNodeList(e.children) && Gl.isOperationList(e.operations);
  return tO.set(e, n), n;
}, yn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return h6(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function nO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nO(Object(n), !0).forEach(function(r) {
      rl(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Mn = {
  compare(e, t) {
    var n = _e.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Mn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Mn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && _e.equals(e.path, t.path);
  },
  isPoint(e) {
    return Nr(e) && typeof e.offset == "number" && _e.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return J0(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = _e.transform(i, t, n);
          break;
        }
        case "insert_text": {
          _e.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          _e.equals(t.path, i) && (r.offset += t.position), r.path = _e.transform(i, t, n);
          break;
        }
        case "remove_text": {
          _e.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (_e.equals(t.path, i) || _e.isAncestor(t.path, i))
            return null;
          r.path = _e.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (_e.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = _e.transform(i, t, rO(rO({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = _e.transform(i, t, n);
          break;
        }
      }
    });
  }
}, oO = void 0, po = {
  setScrubber(e) {
    oO = e;
  },
  stringify(e) {
    return JSON.stringify(e, oO);
  }
}, g6 = ["text"], m6 = ["anchor", "focus"];
function iO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iO(Object(n), !0).forEach(function(r) {
      rl(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cr = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Tu(i, g6);
      return a;
    }
    return aI(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Nr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => cr.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [vi({}, e)];
    for (var r of t) {
      var o = Tu(r, m6), [i, a] = kt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, h = void 0;
        if (c < l) {
          var E = c - g;
          h = vi(vi({}, f), {}, {
            text: f.text.slice(E)
          }), f = vi(vi({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = vi(vi({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = vi(vi({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), h && s.push(h);
      }
      n = s;
    }
    return n;
  }
}, v6 = (e) => e.selection ? e.selection : e.children.length > 0 ? yn.end(e, []) : [0], Ln;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Ln || (Ln = {}));
Ln.L, Ln.L | Ln.V | Ln.LV | Ln.LVT, Ln.LV | Ln.V, Ln.V | Ln.T, Ln.LVT | Ln.T, Ln.T, Ln.Any, Ln.Extend | Ln.ZWJ, Ln.Any, Ln.SpacingMark, Ln.Prepend, Ln.Any, Ln.ZWJ, Ln.ExtPict, Ln.RI, Ln.RI;
var y6 = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    yn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = v6(e)
      } = n;
      if (_e.isPath(o) && (o = yn.range(e, o)), kt.isRange(o))
        if (kt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = kt.end(o);
          if (!r && yn.void(e, {
            at: i
          }))
            return;
          var a = kt.start(o), s = yn.pointRef(e, a), l = yn.pointRef(e, i);
          Zd.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Zd.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && yn.void(e, {
        at: o
      }) || yn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function sO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sO(Object(n), !0).forEach(function(r) {
      rl(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zd = Qc(Qc(Qc(Qc({}, s6), a6), l6), y6), lI = {}, Q0 = {}, ew = {}, Ma = {}, tw = {}, nw = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(nw);
var Mt = {}, xs = En && En.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), ru = En && En.__assign || function() {
  return ru = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, ru.apply(this, arguments);
};
Object.defineProperty(Mt, "__esModule", { value: !0 });
Mt.cloneNode = Mt.hasChildren = Mt.isDocument = Mt.isDirective = Mt.isComment = Mt.isText = Mt.isCDATA = Mt.isTag = Mt.Element = Mt.Document = Mt.CDATA = Mt.NodeWithChildren = Mt.ProcessingInstruction = Mt.Comment = Mt.Text = Mt.DataNode = Mt.Node = void 0;
var ao = nw, rw = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), ow(this, t);
    }, e;
  }()
);
Mt.Node = rw;
var Mh = (
  /** @class */
  function(e) {
    xs(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rw)
);
Mt.DataNode = Mh;
var uI = (
  /** @class */
  function(e) {
    xs(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ao.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Mh)
);
Mt.Text = uI;
var cI = (
  /** @class */
  function(e) {
    xs(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ao.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Mh)
);
Mt.Comment = cI;
var pI = (
  /** @class */
  function(e) {
    xs(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = ao.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Mh)
);
Mt.ProcessingInstruction = pI;
var Th = (
  /** @class */
  function(e) {
    xs(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rw)
);
Mt.NodeWithChildren = Th;
var dI = (
  /** @class */
  function(e) {
    xs(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ao.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Th)
);
Mt.CDATA = dI;
var fI = (
  /** @class */
  function(e) {
    xs(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ao.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Th)
);
Mt.Document = fI;
var hI = (
  /** @class */
  function(e) {
    xs(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? ao.ElementType.Script : n === "style" ? ao.ElementType.Style : ao.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Th)
);
Mt.Element = hI;
function gI(e) {
  return (0, ao.isTag)(e);
}
Mt.isTag = gI;
function mI(e) {
  return e.type === ao.ElementType.CDATA;
}
Mt.isCDATA = mI;
function vI(e) {
  return e.type === ao.ElementType.Text;
}
Mt.isText = vI;
function yI(e) {
  return e.type === ao.ElementType.Comment;
}
Mt.isComment = yI;
function bI(e) {
  return e.type === ao.ElementType.Directive;
}
Mt.isDirective = bI;
function wI(e) {
  return e.type === ao.ElementType.Root;
}
Mt.isDocument = wI;
function b6(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Mt.hasChildren = b6;
function ow(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (vI(e))
    n = new uI(e.data);
  else if (yI(e))
    n = new cI(e.data);
  else if (gI(e)) {
    var r = t ? vm(e.children) : [], o = new hI(e.name, ru({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = ru({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = ru({}, e["x-attribsPrefix"])), n = o;
  } else if (mI(e)) {
    var r = t ? vm(e.children) : [], i = new dI(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (wI(e)) {
    var r = t ? vm(e.children) : [], a = new fI(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (bI(e)) {
    var s = new pI(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Mt.cloneNode = ow;
function vm(e) {
  for (var t = e.map(function(r) {
    return ow(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = En && En.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = En && En.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = nw, o = Mt;
  n(Mt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(tw);
var CI = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(CI);
Object.defineProperty(Ma, "__esModule", { value: !0 });
Ma.formatAttributes = xI;
Ma.escapeSpecialCharacters = x6;
Ma.revertEscapedCharacters = EI;
Ma.formatDOM = OI;
var ep = tw, ju = CI;
function w6(e) {
  return ju.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function xI(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function C6(e) {
  e = e.toLowerCase();
  var t = w6(e);
  return t || e;
}
function x6(e) {
  return e.replace(ju.CARRIAGE_RETURN_REGEX, ju.CARRIAGE_RETURN_PLACEHOLDER);
}
function EI(e) {
  return e.replace(ju.CARRIAGE_RETURN_PLACEHOLDER_REGEX, ju.CARRIAGE_RETURN);
}
function OI(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = C6(s.nodeName);
        o = new ep.Element(l, xI(s.attributes)), o.children = OI(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new ep.Text(EI(s.nodeValue));
        break;
      case 8:
        o = new ep.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new ep.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(ew, "__esModule", { value: !0 });
ew.default = L6;
var E6 = Ma, aO = "html", lO = "head", tp = "body", O6 = /<([a-zA-Z]+[0-9]?)/, uO = /<head[^]*>/i, cO = /<body[^]*>/i, Kd = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Yy = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, pO = typeof window == "object" && window.DOMParser;
if (typeof pO == "function") {
  var k6 = new pO(), _6 = "text/html";
  Yy = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), k6.parseFromString(e, _6);
  }, Kd = Yy;
}
if (typeof document == "object" && document.implementation) {
  var np = document.implementation.createHTMLDocument();
  Kd = function(e, t) {
    if (t) {
      var n = np.documentElement.querySelector(t);
      return n && (n.innerHTML = e), np;
    }
    return np.documentElement.innerHTML = e, np;
  };
}
var rp = typeof document == "object" && document.createElement("template"), Jy;
rp && rp.content && (Jy = function(e) {
  return rp.innerHTML = e, rp.content.childNodes;
});
function L6(e) {
  var t, n;
  e = (0, E6.escapeSpecialCharacters)(e);
  var r = e.match(O6), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case aO: {
      var i = Yy(e);
      if (!uO.test(e)) {
        var a = i.querySelector(lO);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!cO.test(e)) {
        var a = i.querySelector(tp);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(aO);
    }
    case lO:
    case tp: {
      var s = Kd(e).querySelectorAll(o);
      return cO.test(e) && uO.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (Jy)
        return Jy(e);
      var a = Kd(e, tp).querySelector(tp);
      return a.childNodes;
    }
  }
}
var P6 = En && En.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Q0, "__esModule", { value: !0 });
Q0.default = T6;
var S6 = P6(ew), D6 = Ma, M6 = /<(![a-zA-Z\s]+)>/;
function T6(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(M6), n = t ? t[1] : void 0;
  return (0, D6.formatDOM)((0, S6.default)(e), null, n);
}
var jh = {}, zo = {}, Ah = {}, j6 = 0;
Ah.SAME = j6;
var A6 = 1;
Ah.CAMELCASE = A6;
Ah.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const kI = 0, Es = 1, Bh = 2, Rh = 3, iw = 4, _I = 5, LI = 6;
function B6(e) {
  return jr.hasOwnProperty(e) ? jr[e] : null;
}
function Zr(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Bh || t === Rh || t === iw, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const jr = {}, R6 = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
R6.forEach((e) => {
  jr[e] = new Zr(
    e,
    kI,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  jr[e] = new Zr(
    e,
    Es,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  jr[e] = new Zr(
    e,
    Bh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  jr[e] = new Zr(
    e,
    Bh,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  jr[e] = new Zr(
    e,
    Rh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  jr[e] = new Zr(
    e,
    Rh,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  jr[e] = new Zr(
    e,
    iw,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  jr[e] = new Zr(
    e,
    LI,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  jr[e] = new Zr(
    e,
    _I,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const sw = /[\-\:]([a-z])/g, aw = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(sw, aw);
  jr[t] = new Zr(
    t,
    Es,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(sw, aw);
  jr[t] = new Zr(
    t,
    Es,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(sw, aw);
  jr[t] = new Zr(
    t,
    Es,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  jr[e] = new Zr(
    e,
    Es,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const I6 = "xlinkHref";
jr[I6] = new Zr(
  "xlinkHref",
  Es,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  jr[e] = new Zr(
    e,
    Es,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: N6,
  SAME: F6,
  possibleStandardNames: dO
} = Ah, z6 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", U6 = z6 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", $6 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + U6 + "]*$")
), W6 = Object.keys(
  dO
).reduce((e, t) => {
  const n = dO[t];
  return n === F6 ? e[t] = t : n === N6 ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
zo.BOOLEAN = Rh;
zo.BOOLEANISH_STRING = Bh;
zo.NUMERIC = _I;
zo.OVERLOADED_BOOLEAN = iw;
zo.POSITIVE_NUMERIC = LI;
zo.RESERVED = kI;
zo.STRING = Es;
zo.getPropertyInfo = B6;
zo.isCustomAttribute = $6;
zo.possibleStandardNames = W6;
var lw = {}, uw = {}, fO = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, V6 = /\n/g, H6 = /^\s*/, G6 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, q6 = /^:\s*/, Z6 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, K6 = /^[;\s]*/, X6 = /^\s+|\s+$/g, Y6 = `
`, hO = "/", gO = "*", ea = "", J6 = "comment", Q6 = "declaration", e8 = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(V6);
    m && (n += m.length);
    var h = f.lastIndexOf(Y6);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var h = m[0];
      return o(h), e = e.slice(h.length), m;
    }
  }
  function u() {
    l(H6);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(hO != e.charAt(0) || gO != e.charAt(1))) {
      for (var m = 2; ea != e.charAt(m) && (gO != e.charAt(m) || hO != e.charAt(m + 1)); )
        ++m;
      if (m += 2, ea === e.charAt(m - 1))
        return s("End of comment missing");
      var h = e.slice(2, m - 2);
      return r += 2, o(h), e = e.slice(m), r += 2, f({
        type: J6,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), m = l(G6);
    if (m) {
      if (p(), !l(q6)) return s("property missing ':'");
      var h = l(Z6), E = f({
        type: Q6,
        property: mO(m[0].replace(fO, ea)),
        value: h ? mO(h[0].replace(fO, ea)) : ea
      });
      return l(K6), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function mO(e) {
  return e ? e.replace(X6, ea) : ea;
}
var t8 = En && En.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(uw, "__esModule", { value: !0 });
uw.default = r8;
var n8 = t8(e8);
function r8(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, n8.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Ih = {};
Object.defineProperty(Ih, "__esModule", { value: !0 });
Ih.camelCase = void 0;
var o8 = /^--[a-zA-Z0-9_-]+$/, i8 = /-([a-z])/g, s8 = /^[^-]+$/, a8 = /^-(webkit|moz|ms|o|khtml)-/, l8 = /^-(ms)-/, u8 = function(e) {
  return !e || s8.test(e) || o8.test(e);
}, c8 = function(e, t) {
  return t.toUpperCase();
}, vO = function(e, t) {
  return "".concat(t, "-");
}, p8 = function(e, t) {
  return t === void 0 && (t = {}), u8(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(l8, vO) : e = e.replace(a8, vO), e.replace(i8, c8));
};
Ih.camelCase = p8;
var d8 = En && En.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, f8 = d8(uw), h8 = Ih;
function Qy(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, f8.default)(e, function(r, o) {
    r && o && (n[(0, h8.camelCase)(r, t)] = o);
  }), n;
}
Qy.default = Qy;
var g8 = Qy;
(function(e) {
  var t = En && En.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(g8), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(lw);
Object.defineProperty(jh, "__esModule", { value: !0 });
jh.default = b8;
var ql = zo, yO = lw, m8 = ["checked", "value"], v8 = ["input", "select", "textarea"], y8 = {
  reset: !0,
  submit: !0
};
function b8(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && y8[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, ql.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = bO(a);
    if (s) {
      var l = (0, ql.getPropertyInfo)(s);
      switch (m8.includes(s) && v8.includes(t) && !r && (s = bO("default" + a)), n[s] = i, l && l.type) {
        case ql.BOOLEAN:
          n[s] = !0;
          break;
        case ql.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    yO.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, yO.setStyleProp)(e.style, n), n;
}
function bO(e) {
  return ql.possibleStandardNames[e];
}
var cw = {}, w8 = En && En.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(cw, "__esModule", { value: !0 });
cw.default = PI;
var ym = Oe, C8 = w8(jh), ou = lw, x8 = {
  cloneElement: ym.cloneElement,
  createElement: ym.createElement,
  isValidElement: ym.isValidElement
};
function PI(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || ou.returnFirstArg, i = t.library || x8, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, ou.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    E8(f) ? ((0, ou.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, C8.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (h = PI(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function E8(e) {
  return ou.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, ou.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = En && En.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(Q0);
  e.htmlToDOM = n.default;
  var r = t(jh);
  e.attributesToProps = r.default;
  var o = t(cw);
  e.domToReact = o.default;
  var i = tw;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(lI);
const wO = /* @__PURE__ */ WH(lI);
wO.default;
function O8(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ on.jsx("div", { className: o.trim(), ...r });
}
var On = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function k8(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var eb = { exports: {} }, xl = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var CO;
function _8() {
  if (CO) return xl;
  CO = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return xl.Fragment = n, xl.jsx = a, xl.jsxs = a, xl;
}
var op = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xO;
function L8() {
  return xO || (xO = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var R = f && b[f] || b[m];
      return typeof R == "function" ? R : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var R = arguments.length, Y = new Array(R > 1 ? R - 1 : 0), ne = 1; ne < R; ne++)
          Y[ne - 1] = arguments[ne];
        S("error", b, Y);
      }
    }
    function S(b, R, Y) {
      {
        var ne = E.ReactDebugCurrentFrame, ue = ne.getStackAddendum();
        ue !== "" && (R += "%s", Y = Y.concat([ue]));
        var ce = Y.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + R), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, y = !1, C = !1, P = !1, F = !1, _;
    _ = Symbol.for("react.module.reference");
    function I(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || P || b === g || x || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === _ || b.getModuleId !== void 0));
    }
    function B(b, R, Y) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var ue = R.displayName || R.name || "";
      return ue !== "" ? Y + "(" + ue + ")" : Y;
    }
    function $(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var R = b;
            return $(R) + ".Consumer";
          case a:
            var Y = b;
            return $(Y._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var ue = b, ce = ue._payload, ae = ue._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, H = 0, X, J, te, ee, L, T, W;
    function D() {
    }
    D.__reactDisabledLog = !0;
    function G() {
      {
        if (H === 0) {
          X = console.log, J = console.info, te = console.warn, ee = console.error, L = console.group, T = console.groupCollapsed, W = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: D,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        H++;
      }
    }
    function O() {
      {
        if (H--, H === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: X
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: L
            }),
            groupCollapsed: z({}, b, {
              value: T
            }),
            groupEnd: z({}, b, {
              value: W
            })
          });
        }
        H < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = E.ReactCurrentDispatcher, U;
    function j(b, R, Y) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ue) {
            var ne = ue.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var Z = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function N(b, R) {
      if (!b || Z)
        return "";
      {
        var Y = A.get(b);
        if (Y !== void 0)
          return Y;
      }
      var ne;
      Z = !0;
      var ue = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = M.current, M.current = null, G();
      try {
        if (R) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Ne) {
              ne = Ne;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Ne) {
              ne = Ne;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            ne = Ne;
          }
          b();
        }
      } catch (Ne) {
        if (Ne && ne && typeof Ne.stack == "string") {
          for (var se = Ne.stack.split(`
`), Ae = ne.stack.split(`
`), we = se.length - 1, xe = Ae.length - 1; we >= 1 && xe >= 0 && se[we] !== Ae[xe]; )
            xe--;
          for (; we >= 1 && xe >= 0; we--, xe--)
            if (se[we] !== Ae[xe]) {
              if (we !== 1 || xe !== 1)
                do
                  if (we--, xe--, xe < 0 || se[we] !== Ae[xe]) {
                    var Ge = `
` + se[we].replace(" at new ", " at ");
                    return b.displayName && Ge.includes("<anonymous>") && (Ge = Ge.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ge), Ge;
                  }
                while (we >= 1 && xe >= 0);
              break;
            }
        }
      } finally {
        Z = !1, M.current = ce, O(), Error.prepareStackTrace = ue;
      }
      var Jt = b ? b.displayName || b.name : "", Et = Jt ? j(Jt) : "";
      return typeof b == "function" && A.set(b, Et), Et;
    }
    function le(b, R, Y) {
      return N(b, !1);
    }
    function ye(b) {
      var R = b.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(b, R, Y) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, ye(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return le(b.render);
          case p:
            return oe(b.type, R, Y);
          case d: {
            var ne = b, ue = ne._payload, ce = ne._init;
            try {
              return oe(ce(ue), R, Y);
            } catch {
            }
          }
        }
      return "";
    }
    var Be = Object.prototype.hasOwnProperty, Ue = {}, $e = E.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var R = b._owner, Y = oe(b.type, b._source, R ? R.type : null);
        $e.setExtraStackFrame(Y);
      } else
        $e.setExtraStackFrame(null);
    }
    function Je(b, R, Y, ne, ue) {
      {
        var ce = Function.call.bind(Be);
        for (var ae in b)
          if (ce(b, ae)) {
            var se = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Ae = Error((ne || "React class") + ": " + Y + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ae.name = "Invariant Violation", Ae;
              }
              se = b[ae](R, ae, ne, Y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (we) {
              se = we;
            }
            se && !(se instanceof Error) && (Ie(ue), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", Y, ae, typeof se), Ie(null)), se instanceof Error && !(se.message in Ue) && (Ue[se.message] = !0, Ie(ue), w("Failed %s type: %s", Y, se.message), Ie(null));
          }
      }
    }
    var Ze = Array.isArray;
    function Me(b) {
      return Ze(b);
    }
    function Ye(b) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, Y = R && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Y;
      }
    }
    function nt(b) {
      try {
        return De(b), !1;
      } catch {
        return !0;
      }
    }
    function De(b) {
      return "" + b;
    }
    function je(b) {
      if (nt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ye(b)), De(b);
    }
    var Ke = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Fe, et;
    function Re(b) {
      if (Be.call(b, "ref")) {
        var R = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function Rt(b) {
      if (Be.call(b, "key")) {
        var R = Object.getOwnPropertyDescriptor(b, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function rt(b, R) {
      typeof b.ref == "string" && Ke.current;
    }
    function ot(b, R) {
      {
        var Y = function() {
          Fe || (Fe = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Y,
          configurable: !0
        });
      }
    }
    function at(b, R) {
      {
        var Y = function() {
          et || (et = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Y,
          configurable: !0
        });
      }
    }
    var Kt = function(b, R, Y, ne, ue, ce, ae) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: R,
        ref: Y,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ue
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function lt(b, R, Y, ne, ue) {
      {
        var ce, ae = {}, se = null, Ae = null;
        Y !== void 0 && (je(Y), se = "" + Y), Rt(R) && (je(R.key), se = "" + R.key), Re(R) && (Ae = R.ref, rt(R));
        for (ce in R)
          Be.call(R, ce) && !We.hasOwnProperty(ce) && (ae[ce] = R[ce]);
        if (b && b.defaultProps) {
          var we = b.defaultProps;
          for (ce in we)
            ae[ce] === void 0 && (ae[ce] = we[ce]);
        }
        if (se || Ae) {
          var xe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && ot(ae, xe), Ae && at(ae, xe);
        }
        return Kt(b, se, Ae, ue, ne, Ke.current, ae);
      }
    }
    var ut = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var R = b._owner, Y = oe(b.type, b._source, R ? R.type : null);
        tt.setExtraStackFrame(Y);
      } else
        tt.setExtraStackFrame(null);
    }
    var Xt;
    Xt = !1;
    function Yt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function bt() {
      {
        if (ut.current) {
          var b = V(ut.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Rn(b) {
      return "";
    }
    var wt = {};
    function In(b) {
      {
        var R = bt();
        if (!R) {
          var Y = typeof b == "string" ? b : b.displayName || b.name;
          Y && (R = `

Check the top-level render call using <` + Y + ">.");
        }
        return R;
      }
    }
    function Ct(b, R) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Y = In(R);
        if (wt[Y])
          return;
        wt[Y] = !0;
        var ne = "";
        b && b._owner && b._owner !== ut.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Y, ne), Xe(null);
      }
    }
    function fn(b, R) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var Y = 0; Y < b.length; Y++) {
            var ne = b[Y];
            Yt(ne) && Ct(ne, R);
          }
        else if (Yt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ue = h(b);
          if (typeof ue == "function" && ue !== b.entries)
            for (var ce = ue.call(b), ae; !(ae = ce.next()).done; )
              Yt(ae.value) && Ct(ae.value, R);
        }
      }
    }
    function wr(b) {
      {
        var R = b.type;
        if (R == null || typeof R == "string")
          return;
        var Y;
        if (typeof R == "function")
          Y = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          Y = R.propTypes;
        else
          return;
        if (Y) {
          var ne = V(R);
          Je(Y, b.props, "prop", ne, b);
        } else if (R.PropTypes !== void 0 && !Xt) {
          Xt = !0;
          var ue = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ue || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function xt(b) {
      {
        for (var R = Object.keys(b.props), Y = 0; Y < R.length; Y++) {
          var ne = R[Y];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function Qr(b, R, Y, ne, ue, ce) {
      {
        var ae = I(b);
        if (!ae) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ae = Rn();
          Ae ? se += Ae : se += bt();
          var we;
          b === null ? we = "null" : Me(b) ? we = "array" : b !== void 0 && b.$$typeof === t ? (we = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : we = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", we, se);
        }
        var xe = lt(b, R, Y, ue, ce);
        if (xe == null)
          return xe;
        if (ae) {
          var Ge = R.children;
          if (Ge !== void 0)
            if (ne)
              if (Me(Ge)) {
                for (var Jt = 0; Jt < Ge.length; Jt++)
                  fn(Ge[Jt], b);
                Object.freeze && Object.freeze(Ge);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              fn(Ge, b);
        }
        if (Be.call(R, "key")) {
          var Et = V(b), Ne = Object.keys(R).filter(function(gi) {
            return gi !== "key";
          }), Cr = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[Et + Cr]) {
            var hi = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Cr, Et, hi, Et), re[Et + Cr] = !0;
          }
        }
        return b === r ? xt(xe) : wr(xe), xe;
      }
    }
    function ci(b, R, Y) {
      return Qr(b, R, Y, !0);
    }
    function pi(b, R, Y) {
      return Qr(b, R, Y, !1);
    }
    var di = pi, fi = ci;
    op.Fragment = r, op.jsx = di, op.jsxs = fi;
  }()), op;
}
process.env.NODE_ENV === "production" ? eb.exports = _8() : eb.exports = L8();
var Sr = eb.exports;
qe({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function EO(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Fr(e) {
  var t, n;
  return EO(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(EO(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var SI = Symbol.for("immer-nothing"), OO = Symbol.for("immer-draftable"), ko = Symbol.for("immer-state"), P8 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ro(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = P8[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Ka = Object.getPrototypeOf;
function Ca(e) {
  return !!e && !!e[ko];
}
function xa(e) {
  var t;
  return e ? DI(e) || Array.isArray(e) || !!e[OO] || !!((t = e.constructor) != null && t[OO]) || Fh(e) || zh(e) : !1;
}
var S8 = Object.prototype.constructor.toString();
function DI(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Ka(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === S8;
}
function Xd(e, t) {
  Nh(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Nh(e) {
  const t = e[ko];
  return t ? t.type_ : Array.isArray(e) ? 1 : Fh(e) ? 2 : zh(e) ? 3 : 0;
}
function tb(e, t) {
  return Nh(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function MI(e, t, n) {
  const r = Nh(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function D8(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Fh(e) {
  return e instanceof Map;
}
function zh(e) {
  return e instanceof Set;
}
function Ks(e) {
  return e.copy_ || e.base_;
}
function nb(e, t) {
  if (Fh(e))
    return new Map(e);
  if (zh(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = DI(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ko];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Ka(e), r);
  } else {
    const r = Ka(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function pw(e, t = !1) {
  return Uh(e) || Ca(e) || !xa(e) || (Nh(e) > 1 && (e.set = e.add = e.clear = e.delete = M8), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => pw(r, !0))), e;
}
function M8() {
  ro(2);
}
function Uh(e) {
  return Object.isFrozen(e);
}
var T8 = {};
function Ea(e) {
  const t = T8[e];
  return t || ro(0, e), t;
}
var Au;
function TI() {
  return Au;
}
function j8(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function kO(e, t) {
  t && (Ea("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function rb(e) {
  ob(e), e.drafts_.forEach(A8), e.drafts_ = null;
}
function ob(e) {
  e === Au && (Au = e.parent_);
}
function _O(e) {
  return Au = j8(Au, e);
}
function A8(e) {
  const t = e[ko];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function LO(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ko].modified_ && (rb(t), ro(4)), xa(e) && (e = Yd(t, e), t.parent_ || Jd(t, e)), t.patches_ && Ea("Patches").generateReplacementPatches_(
    n[ko].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Yd(t, n, []), rb(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== SI ? e : void 0;
}
function Yd(e, t, n) {
  if (Uh(t))
    return t;
  const r = t[ko];
  if (!r)
    return Xd(
      t,
      (o, i) => PO(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Jd(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Xd(
      i,
      (s, l) => PO(e, r, o, s, l, n, a)
    ), Jd(e, o, !1), n && e.patches_ && Ea("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function PO(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ro(5), Ca(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !tb(t.assigned_, r) ? i.concat(r) : void 0, l = Yd(e, o, s);
    if (MI(n, r, l), Ca(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (xa(o) && !Uh(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Yd(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Jd(e, o);
  }
}
function Jd(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && pw(t, n);
}
function B8(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : TI(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = dw;
  n && (o = [r], i = Bu);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var dw = {
  get(e, t) {
    if (t === ko)
      return e;
    const n = Ks(e);
    if (!tb(n, t))
      return R8(e, n, t);
    const r = n[t];
    return e.finalized_ || !xa(r) ? r : r === bm(e.base_, t) ? (wm(e), e.copy_[t] = sb(r, e)) : r;
  },
  has(e, t) {
    return t in Ks(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ks(e));
  },
  set(e, t, n) {
    const r = jI(Ks(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = bm(Ks(e), t), i = o == null ? void 0 : o[ko];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (D8(n, o) && (n !== void 0 || tb(e.base_, t)))
        return !0;
      wm(e), ib(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return bm(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, wm(e), ib(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ks(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ro(11);
  },
  getPrototypeOf(e) {
    return Ka(e.base_);
  },
  setPrototypeOf() {
    ro(12);
  }
}, Bu = {};
Xd(dw, (e, t) => {
  Bu[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Bu.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ro(13), Bu.set.call(this, e, t, void 0);
};
Bu.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ro(14), dw.set.call(this, e[0], t, n, e[0]);
};
function bm(e, t) {
  const n = e[ko];
  return (n ? Ks(n) : e)[t];
}
function R8(e, t, n) {
  var r;
  const o = jI(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function jI(e, t) {
  if (!(t in e))
    return;
  let n = Ka(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Ka(n);
  }
}
function ib(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && ib(e.parent_));
}
function wm(e) {
  e.copy_ || (e.copy_ = nb(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var I8 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ro(6), r !== void 0 && typeof r != "function" && ro(7);
      let o;
      if (xa(t)) {
        const i = _O(this), a = sb(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? rb(i) : ob(i);
        }
        return kO(i, r), LO(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === SI && (o = void 0), this.autoFreeze_ && pw(o, !0), r) {
          const i = [], a = [];
          Ea("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ro(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    xa(e) || ro(8), Ca(e) && (e = N8(e));
    const t = _O(this), n = sb(e, void 0);
    return n[ko].isManual_ = !0, ob(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ko];
    (!n || !n.isManual_) && ro(9);
    const { scope_: r } = n;
    return kO(r, t), LO(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Ea("Patches").applyPatches_;
    return Ca(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function sb(e, t) {
  const n = Fh(e) ? Ea("MapSet").proxyMap_(e, t) : zh(e) ? Ea("MapSet").proxySet_(e, t) : B8(e, t);
  return (t ? t.scope_ : TI()).drafts_.push(n), n;
}
function N8(e) {
  return Ca(e) || ro(10, e), AI(e);
}
function AI(e) {
  if (!xa(e) || Uh(e))
    return e;
  const t = e[ko];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = nb(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = nb(e, !0);
  return Xd(n, (r, o) => {
    MI(n, r, AI(o));
  }), t && (t.finalized_ = !1), n;
}
var _o = new I8(), fw = _o.produce;
_o.produceWithPatches.bind(
  _o
);
_o.setAutoFreeze.bind(_o);
_o.setUseStrictShallowCopy.bind(_o);
_o.applyPatches.bind(_o);
var SO = _o.createDraft.bind(_o), DO = _o.finishDraft.bind(_o), Le = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Le.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Le.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Le.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Le.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Le.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Le.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Le.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Le.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Le.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Le.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Le.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Le.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Le.isAncestor(t, e) && !Le.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Le.equals(i, r) || Le.endsBefore(i, r) || Le.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Le.equals(a, r) || Le.isAncestor(a, r))
          return null;
        Le.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Le.equals(s, r) || Le.endsBefore(s, r) ? r[s.length - 1] -= 1 : Le.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Le.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Le.endsBefore(u, r) ? r[u.length - 1] += 1 : Le.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Le.equals(p, d))
          return r;
        if (Le.isAncestor(p, r) || Le.equals(p, r)) {
          var g = d.slice();
          return Le.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Le.isSibling(p, d) && (Le.isAncestor(d, r) || Le.equals(d, r)) ? Le.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Le.endsBefore(d, r) || Le.equals(d, r) || Le.isAncestor(d, r) ? (Le.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Le.endsBefore(p, r) && (Le.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Ru(e) {
  "@babel/helpers - typeof";
  return Ru = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ru(e);
}
function F8(e, t) {
  if (Ru(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ru(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function z8(e) {
  var t = F8(e, "string");
  return Ru(t) === "symbol" ? t : String(t);
}
function ol(e, t, n) {
  return t = z8(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function MO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function El(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MO(Object(n), !0).forEach(function(r) {
      ol(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var U8 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = pt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of _t.points(t))
          t[l] = Tn.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = pt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, h] of _t.points(t))
          t[h] = Tn.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = pt.get(e, E), S = Le.previous(E), x = pt.get(e, S), y = pt.parent(e, E), C = E[E.length - 1];
      if (pr.isText(w) && pr.isText(x))
        x.text += w.text;
      else if (!pr.isText(w) && !pr.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(fo.stringify(w), " ").concat(fo.stringify(x)));
      if (y.children.splice(C, 1), t)
        for (var [P, F] of _t.points(t))
          t[F] = Tn.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: _,
        newPath: I
      } = n;
      if (Le.isAncestor(_, I))
        throw new Error("Cannot move a path [".concat(_, "] to new path [").concat(I, "] because the destination is inside itself."));
      var B = pt.get(e, _), $ = pt.parent(e, _), V = _[_.length - 1];
      $.children.splice(V, 1);
      var z = Le.transform(_, n), H = pt.get(e, Le.parent(z)), X = z[z.length - 1];
      if (H.children.splice(X, 0, B), t)
        for (var [J, te] of _t.points(t))
          t[te] = Tn.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, L = ee[ee.length - 1], T = pt.parent(e, ee);
      if (T.children.splice(L, 1), t)
        for (var [W, D] of _t.points(t)) {
          var G = Tn.transform(W, n);
          if (t != null && G != null)
            t[D] = G;
          else {
            var O = void 0, M = void 0;
            for (var [U, j] of pt.texts(e))
              if (Le.compare(j, ee) === -1)
                O = [U, j];
              else {
                M = [U, j];
                break;
              }
            var Z = !1;
            O && M && (Le.equals(M[1], ee) ? Z = !Le.hasPrevious(M[1]) : Z = Le.common(O[1], ee).length < Le.common(M[1], ee).length), O && !Z ? (W.path = O[1], W.offset = O[0].text.length) : M ? (W.path = M[1], W.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: N
      } = n;
      if (N.length === 0) break;
      var le = pt.leaf(e, A), ye = le.text.slice(0, Q), oe = le.text.slice(Q + N.length);
      if (le.text = ye + oe, t)
        for (var [Be, Ue] of _t.points(t))
          t[Ue] = Tn.transform(Be, n);
      break;
    }
    case "set_node": {
      var {
        path: $e,
        properties: Ie,
        newProperties: Je
      } = n;
      if ($e.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ze = pt.get(e, $e);
      for (var Me in Je) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Ye = Je[Me];
        Ye == null ? delete Ze[Me] : Ze[Me] = Ye;
      }
      for (var nt in Ie)
        Je.hasOwnProperty(nt) || delete Ze[nt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: De
      } = n;
      if (De == null)
        t = De;
      else {
        if (t == null) {
          if (!_t.isRange(De))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(fo.stringify(De), " when there is no current selection."));
          t = El({}, De);
        }
        for (var je in De) {
          var Ke = De[je];
          if (Ke == null) {
            if (je === "anchor" || je === "focus")
              throw new Error('Cannot remove the "'.concat(je, '" selection property'));
            delete t[je];
          } else
            t[je] = Ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Fe,
        properties: et
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var Re = pt.get(e, We), Rt = pt.parent(e, We), rt = We[We.length - 1], ot;
      if (pr.isText(Re)) {
        var at = Re.text.slice(0, Fe), Kt = Re.text.slice(Fe);
        Re.text = at, ot = El(El({}, et), {}, {
          text: Kt
        });
      } else {
        var lt = Re.children.slice(0, Fe), ut = Re.children.slice(Fe);
        Re.children = lt, ot = El(El({}, et), {}, {
          children: ut
        });
      }
      if (Rt.children.splice(rt + 1, 0, ot), t)
        for (var [tt, Xe] of _t.points(t))
          t[Xe] = Tn.transform(tt, n);
      break;
    }
  }
  return t;
}, $8 = {
  transform(e, t) {
    e.children = SO(e.children);
    var n = e.selection && SO(e.selection);
    try {
      n = U8(e, n, t);
    } finally {
      e.children = DO(e.children), n ? e.selection = Ca(n) ? DO(n) : n : e.selection = null;
    }
  }
}, W8 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, V8 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, BI = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Fr(r) && Fr(o)) {
      if (!BI(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function H8(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Iu(e, t) {
  if (e == null) return {};
  var n = H8(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var G8 = ["anchor", "focus"];
function TO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function q8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TO(Object(n), !0).forEach(function(r) {
      ol(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _t = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return _t.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = _t.edges(e);
    return t;
  },
  equals(e, t) {
    return Tn.equals(e.anchor, t.anchor) && Tn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (_t.isRange(t)) {
      if (_t.includes(e, t.anchor) || _t.includes(e, t.focus))
        return !0;
      var [n, r] = _t.edges(e), [o, i] = _t.edges(t);
      return Tn.isBefore(n, o) && Tn.isAfter(r, i);
    }
    var [a, s] = _t.edges(e), l = !1, u = !1;
    return Tn.isPoint(t) ? (l = Tn.compare(t, a) >= 0, u = Tn.compare(t, s) <= 0) : (l = Le.compare(t, a.path) >= 0, u = Le.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Iu(e, G8), [r, o] = _t.edges(e), [i, a] = _t.edges(t), s = Tn.isBefore(r, i) ? i : r, l = Tn.isBefore(o, a) ? o : a;
    return Tn.isBefore(l, s) ? null : q8({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Tn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Tn.equals(t, n);
  },
  isExpanded(e) {
    return !_t.isCollapsed(e);
  },
  isForward(e) {
    return !_t.isBackward(e);
  },
  isRange(e) {
    return Fr(e) && Tn.isPoint(e.anchor) && Tn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = _t.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fw(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = _t.isCollapsed(r);
        _t.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? _t.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Tn.transform(r.anchor, t, {
        affinity: i
      }), u = Tn.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, jO = (e) => Fr(e) && pt.isNodeList(e.children) && !bn.isEditor(e), Li = {
  isAncestor(e) {
    return Fr(e) && pt.isNodeList(e.children);
  },
  isElement: jO,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Li.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return jO(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Z8 = ["children"], K8 = ["text"], AO = /* @__PURE__ */ new WeakMap(), pt = {
  ancestor(e, t) {
    var n = pt.get(e, t);
    if (pr.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(fo.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Le.ancestors(t, n)) {
        var o = pt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (pr.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(fo.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(fo.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = pt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = pt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Le.common(t, n), o = pt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = pt.get(e, t);
    if (bn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(fo.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of pt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of pt.nodes(e, t))
        Li.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Li.isAncestor(e)) {
      var t = Iu(e, Z8);
      return t;
    } else {
      var t = Iu(e, K8);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = pt.get(e, n); r && !(pr.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (pr.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(fo.stringify(e)));
    var n = fw({
      children: e.children
    }, (r) => {
      var [o, i] = _t.edges(t), a = pt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !_t.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!_t.includes(t, s)) {
          var l = pt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Le.equals(s, i.path)) {
          var c = pt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Le.equals(s, o.path)) {
          var p = pt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      bn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (pr.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(fo.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (pr.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return pr.isText(e) || Li.isElement(e) || bn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = AO.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => pt.isNode(r));
    return AO.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = pt.get(e, n); r && !(pr.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = pt.get(e, t);
    if (!pr.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(fo.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Le.levels(t, n)) {
        var o = pt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Li.isElement(e) && Li.isElementProps(t) && Li.matches(e, t) || pr.isText(e) && pr.isTextProps(t) && pr.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Le.isBefore(s, i) : Le.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !pr.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Le.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = pt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Le.next(s);
          if (pt.has(e, c)) {
            s = c, l = pt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Le.previous(s);
          s = p, l = pt.get(e, s);
          continue;
        }
        s = Le.parent(s), l = pt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Le.parent(t), r = pt.get(e, n);
    if (pr.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return pr.isText(e) ? e.text : e.children.map(pt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of pt.nodes(e, t))
        pr.isText(n) && (yield [n, r]);
    }();
  }
};
function BO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BO(Object(n), !0).forEach(function(r) {
      ol(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zl = {
  isNodeOperation(e) {
    return Zl.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Fr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Le.isPath(e.path) && pt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Le.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Le.isPath(e.path) && Fr(e.properties);
      case "move_node":
        return Le.isPath(e.path) && Le.isPath(e.newPath);
      case "remove_node":
        return Le.isPath(e.path) && pt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Le.isPath(e.path);
      case "set_node":
        return Le.isPath(e.path) && Fr(e.properties) && Fr(e.newProperties);
      case "set_selection":
        return e.properties === null && _t.isRange(e.newProperties) || e.newProperties === null && _t.isRange(e.properties) || Fr(e.properties) && Fr(e.newProperties);
      case "split_node":
        return Le.isPath(e.path) && typeof e.position == "number" && Fr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Zl.isOperation(t));
  },
  isSelectionOperation(e) {
    return Zl.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Zl.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return zn(zn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return zn(zn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return zn(zn({}, e), {}, {
          type: "split_node",
          path: Le.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Le.equals(t, n))
          return e;
        if (Le.isSibling(n, t))
          return zn(zn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Le.transform(n, e), o = Le.transform(Le.next(n), e);
        return zn(zn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return zn(zn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return zn(zn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return zn(zn({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? zn(zn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? zn(zn({}, e), {}, {
          properties: null,
          newProperties: s
        }) : zn(zn({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return zn(zn({}, e), {}, {
          type: "merge_node",
          path: Le.next(e.path)
        });
    }
  }
}, RO = /* @__PURE__ */ new WeakMap(), X8 = (e) => {
  var t = RO.get(e);
  if (t !== void 0)
    return t;
  if (!Fr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Fr(e.marks)) && (e.selection === null || _t.isRange(e.selection)) && pt.isNodeList(e.children) && Zl.isOperationList(e.operations);
  return RO.set(e, n), n;
}, bn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return X8(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function IO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function NO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IO(Object(n), !0).forEach(function(r) {
      ol(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Tn = {
  compare(e, t) {
    var n = Le.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Tn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Tn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Le.equals(e.path, t.path);
  },
  isPoint(e) {
    return Fr(e) && typeof e.offset == "number" && Le.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fw(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Le.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Le.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Le.equals(t.path, i) && (r.offset += t.position), r.path = Le.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Le.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Le.equals(t.path, i) || Le.isAncestor(t.path, i))
            return null;
          r.path = Le.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Le.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Le.transform(i, t, NO(NO({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Le.transform(i, t, n);
          break;
        }
      }
    });
  }
}, FO = void 0, fo = {
  setScrubber(e) {
    FO = e;
  },
  stringify(e) {
    return JSON.stringify(e, FO);
  }
}, Y8 = ["text"], J8 = ["anchor", "focus"];
function zO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zO(Object(n), !0).forEach(function(r) {
      ol(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pr = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Iu(i, Y8);
      return a;
    }
    return BI(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Fr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => pr.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [yi({}, e)];
    for (var r of t) {
      var o = Iu(r, J8), [i, a] = _t.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, h = void 0;
        if (c < l) {
          var E = c - g;
          h = yi(yi({}, f), {}, {
            text: f.text.slice(E)
          }), f = yi(yi({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = yi(yi({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = yi(yi({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), h && s.push(h);
      }
      n = s;
    }
    return n;
  }
}, Q8 = (e) => e.selection ? e.selection : e.children.length > 0 ? bn.end(e, []) : [0], Pn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Pn || (Pn = {}));
Pn.L, Pn.L | Pn.V | Pn.LV | Pn.LVT, Pn.LV | Pn.V, Pn.V | Pn.T, Pn.LVT | Pn.T, Pn.T, Pn.Any, Pn.Extend | Pn.ZWJ, Pn.Any, Pn.SpacingMark, Pn.Prepend, Pn.Any, Pn.ZWJ, Pn.ExtPict, Pn.RI, Pn.RI;
var e5 = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    bn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Q8(e)
      } = n;
      if (Le.isPath(o) && (o = bn.range(e, o)), _t.isRange(o))
        if (_t.isCollapsed(o))
          o = o.anchor;
        else {
          var i = _t.end(o);
          if (!r && bn.void(e, {
            at: i
          }))
            return;
          var a = _t.start(o), s = bn.pointRef(e, a), l = bn.pointRef(e, i);
          Qd.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Qd.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && bn.void(e, {
        at: o
      }) || bn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function UO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ip(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UO(Object(n), !0).forEach(function(r) {
      ol(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qd = ip(ip(ip(ip({}, $8), W8), V8), e5), RI = {}, hw = {}, gw = {}, Ta = {}, mw = {}, vw = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(vw);
var Tt = {}, Os = On && On.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), iu = On && On.__assign || function() {
  return iu = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, iu.apply(this, arguments);
};
Object.defineProperty(Tt, "__esModule", { value: !0 });
Tt.cloneNode = Tt.hasChildren = Tt.isDocument = Tt.isDirective = Tt.isComment = Tt.isText = Tt.isCDATA = Tt.isTag = Tt.Element = Tt.Document = Tt.CDATA = Tt.NodeWithChildren = Tt.ProcessingInstruction = Tt.Comment = Tt.Text = Tt.DataNode = Tt.Node = void 0;
var lo = vw, yw = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), bw(this, t);
    }, e;
  }()
);
Tt.Node = yw;
var $h = (
  /** @class */
  function(e) {
    Os(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(yw)
);
Tt.DataNode = $h;
var II = (
  /** @class */
  function(e) {
    Os(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = lo.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }($h)
);
Tt.Text = II;
var NI = (
  /** @class */
  function(e) {
    Os(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = lo.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }($h)
);
Tt.Comment = NI;
var FI = (
  /** @class */
  function(e) {
    Os(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = lo.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }($h)
);
Tt.ProcessingInstruction = FI;
var Wh = (
  /** @class */
  function(e) {
    Os(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(yw)
);
Tt.NodeWithChildren = Wh;
var zI = (
  /** @class */
  function(e) {
    Os(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = lo.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Wh)
);
Tt.CDATA = zI;
var UI = (
  /** @class */
  function(e) {
    Os(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = lo.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Wh)
);
Tt.Document = UI;
var $I = (
  /** @class */
  function(e) {
    Os(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? lo.ElementType.Script : n === "style" ? lo.ElementType.Style : lo.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Wh)
);
Tt.Element = $I;
function WI(e) {
  return (0, lo.isTag)(e);
}
Tt.isTag = WI;
function VI(e) {
  return e.type === lo.ElementType.CDATA;
}
Tt.isCDATA = VI;
function HI(e) {
  return e.type === lo.ElementType.Text;
}
Tt.isText = HI;
function GI(e) {
  return e.type === lo.ElementType.Comment;
}
Tt.isComment = GI;
function qI(e) {
  return e.type === lo.ElementType.Directive;
}
Tt.isDirective = qI;
function ZI(e) {
  return e.type === lo.ElementType.Root;
}
Tt.isDocument = ZI;
function t5(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Tt.hasChildren = t5;
function bw(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (HI(e))
    n = new II(e.data);
  else if (GI(e))
    n = new NI(e.data);
  else if (WI(e)) {
    var r = t ? Cm(e.children) : [], o = new $I(e.name, iu({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = iu({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = iu({}, e["x-attribsPrefix"])), n = o;
  } else if (VI(e)) {
    var r = t ? Cm(e.children) : [], i = new zI(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (ZI(e)) {
    var r = t ? Cm(e.children) : [], a = new UI(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (qI(e)) {
    var s = new FI(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Tt.cloneNode = bw;
function Cm(e) {
  for (var t = e.map(function(r) {
    return bw(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = On && On.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = On && On.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = vw, o = Tt;
  n(Tt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(mw);
var KI = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(KI);
Object.defineProperty(Ta, "__esModule", { value: !0 });
Ta.formatAttributes = XI;
Ta.escapeSpecialCharacters = o5;
Ta.revertEscapedCharacters = YI;
Ta.formatDOM = JI;
var sp = mw, Nu = KI;
function n5(e) {
  return Nu.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function XI(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function r5(e) {
  e = e.toLowerCase();
  var t = n5(e);
  return t || e;
}
function o5(e) {
  return e.replace(Nu.CARRIAGE_RETURN_REGEX, Nu.CARRIAGE_RETURN_PLACEHOLDER);
}
function YI(e) {
  return e.replace(Nu.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Nu.CARRIAGE_RETURN);
}
function JI(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = r5(s.nodeName);
        o = new sp.Element(l, XI(s.attributes)), o.children = JI(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new sp.Text(YI(s.nodeValue));
        break;
      case 8:
        o = new sp.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new sp.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(gw, "__esModule", { value: !0 });
gw.default = u5;
var i5 = Ta, $O = "html", WO = "head", ap = "body", s5 = /<([a-zA-Z]+[0-9]?)/, VO = /<head[^]*>/i, HO = /<body[^]*>/i, ef = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, ab = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, GO = typeof window == "object" && window.DOMParser;
if (typeof GO == "function") {
  var a5 = new GO(), l5 = "text/html";
  ab = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), a5.parseFromString(e, l5);
  }, ef = ab;
}
if (typeof document == "object" && document.implementation) {
  var lp = document.implementation.createHTMLDocument();
  ef = function(e, t) {
    if (t) {
      var n = lp.documentElement.querySelector(t);
      return n && (n.innerHTML = e), lp;
    }
    return lp.documentElement.innerHTML = e, lp;
  };
}
var up = typeof document == "object" && document.createElement("template"), lb;
up && up.content && (lb = function(e) {
  return up.innerHTML = e, up.content.childNodes;
});
function u5(e) {
  var t, n;
  e = (0, i5.escapeSpecialCharacters)(e);
  var r = e.match(s5), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case $O: {
      var i = ab(e);
      if (!VO.test(e)) {
        var a = i.querySelector(WO);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!HO.test(e)) {
        var a = i.querySelector(ap);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll($O);
    }
    case WO:
    case ap: {
      var s = ef(e).querySelectorAll(o);
      return HO.test(e) && VO.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (lb)
        return lb(e);
      var a = ef(e, ap).querySelector(ap);
      return a.childNodes;
    }
  }
}
var c5 = On && On.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(hw, "__esModule", { value: !0 });
hw.default = h5;
var p5 = c5(gw), d5 = Ta, f5 = /<(![a-zA-Z\s]+)>/;
function h5(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(f5), n = t ? t[1] : void 0;
  return (0, d5.formatDOM)((0, p5.default)(e), null, n);
}
var Vh = {}, Uo = {}, Hh = {}, g5 = 0;
Hh.SAME = g5;
var m5 = 1;
Hh.CAMELCASE = m5;
Hh.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const QI = 0, ks = 1, Gh = 2, qh = 3, ww = 4, eN = 5, tN = 6;
function v5(e) {
  return Ar.hasOwnProperty(e) ? Ar[e] : null;
}
function Kr(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Gh || t === qh || t === ww, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Ar = {}, y5 = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
y5.forEach((e) => {
  Ar[e] = new Kr(
    e,
    QI,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Ar[e] = new Kr(
    e,
    ks,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Ar[e] = new Kr(
    e,
    Gh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Ar[e] = new Kr(
    e,
    Gh,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Ar[e] = new Kr(
    e,
    qh,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ar[e] = new Kr(
    e,
    qh,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ar[e] = new Kr(
    e,
    ww,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ar[e] = new Kr(
    e,
    tN,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Ar[e] = new Kr(
    e,
    eN,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Cw = /[\-\:]([a-z])/g, xw = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Cw, xw);
  Ar[t] = new Kr(
    t,
    ks,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Cw, xw);
  Ar[t] = new Kr(
    t,
    ks,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Cw, xw);
  Ar[t] = new Kr(
    t,
    ks,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Ar[e] = new Kr(
    e,
    ks,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const b5 = "xlinkHref";
Ar[b5] = new Kr(
  "xlinkHref",
  ks,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Ar[e] = new Kr(
    e,
    ks,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: w5,
  SAME: C5,
  possibleStandardNames: qO
} = Hh, x5 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", E5 = x5 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", O5 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + E5 + "]*$")
), k5 = Object.keys(
  qO
).reduce((e, t) => {
  const n = qO[t];
  return n === C5 ? e[t] = t : n === w5 ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Uo.BOOLEAN = qh;
Uo.BOOLEANISH_STRING = Gh;
Uo.NUMERIC = eN;
Uo.OVERLOADED_BOOLEAN = ww;
Uo.POSITIVE_NUMERIC = tN;
Uo.RESERVED = QI;
Uo.STRING = ks;
Uo.getPropertyInfo = v5;
Uo.isCustomAttribute = O5;
Uo.possibleStandardNames = k5;
var Ew = {}, Ow = {}, ZO = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, _5 = /\n/g, L5 = /^\s*/, P5 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, S5 = /^:\s*/, D5 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, M5 = /^[;\s]*/, T5 = /^\s+|\s+$/g, j5 = `
`, KO = "/", XO = "*", ta = "", A5 = "comment", B5 = "declaration", R5 = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(_5);
    m && (n += m.length);
    var h = f.lastIndexOf(j5);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var h = m[0];
      return o(h), e = e.slice(h.length), m;
    }
  }
  function u() {
    l(L5);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(KO != e.charAt(0) || XO != e.charAt(1))) {
      for (var m = 2; ta != e.charAt(m) && (XO != e.charAt(m) || KO != e.charAt(m + 1)); )
        ++m;
      if (m += 2, ta === e.charAt(m - 1))
        return s("End of comment missing");
      var h = e.slice(2, m - 2);
      return r += 2, o(h), e = e.slice(m), r += 2, f({
        type: A5,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), m = l(P5);
    if (m) {
      if (p(), !l(S5)) return s("property missing ':'");
      var h = l(D5), E = f({
        type: B5,
        property: YO(m[0].replace(ZO, ta)),
        value: h ? YO(h[0].replace(ZO, ta)) : ta
      });
      return l(M5), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function YO(e) {
  return e ? e.replace(T5, ta) : ta;
}
var I5 = On && On.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ow, "__esModule", { value: !0 });
Ow.default = F5;
var N5 = I5(R5);
function F5(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, N5.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Zh = {};
Object.defineProperty(Zh, "__esModule", { value: !0 });
Zh.camelCase = void 0;
var z5 = /^--[a-zA-Z0-9_-]+$/, U5 = /-([a-z])/g, $5 = /^[^-]+$/, W5 = /^-(webkit|moz|ms|o|khtml)-/, V5 = /^-(ms)-/, H5 = function(e) {
  return !e || $5.test(e) || z5.test(e);
}, G5 = function(e, t) {
  return t.toUpperCase();
}, JO = function(e, t) {
  return "".concat(t, "-");
}, q5 = function(e, t) {
  return t === void 0 && (t = {}), H5(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(V5, JO) : e = e.replace(W5, JO), e.replace(U5, G5));
};
Zh.camelCase = q5;
var Z5 = On && On.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, K5 = Z5(Ow), X5 = Zh;
function ub(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, K5.default)(e, function(r, o) {
    r && o && (n[(0, X5.camelCase)(r, t)] = o);
  }), n;
}
ub.default = ub;
var Y5 = ub;
(function(e) {
  var t = On && On.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(Y5), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Ew);
Object.defineProperty(Vh, "__esModule", { value: !0 });
Vh.default = t4;
var Kl = Uo, QO = Ew, J5 = ["checked", "value"], Q5 = ["input", "select", "textarea"], e4 = {
  reset: !0,
  submit: !0
};
function t4(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && e4[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Kl.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = e1(a);
    if (s) {
      var l = (0, Kl.getPropertyInfo)(s);
      switch (J5.includes(s) && Q5.includes(t) && !r && (s = e1("default" + a)), n[s] = i, l && l.type) {
        case Kl.BOOLEAN:
          n[s] = !0;
          break;
        case Kl.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    QO.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, QO.setStyleProp)(e.style, n), n;
}
function e1(e) {
  return Kl.possibleStandardNames[e];
}
var kw = {}, n4 = On && On.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(kw, "__esModule", { value: !0 });
kw.default = nN;
var xm = Oe, r4 = n4(Vh), su = Ew, o4 = {
  cloneElement: xm.cloneElement,
  createElement: xm.createElement,
  isValidElement: xm.isValidElement
};
function nN(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || su.returnFirstArg, i = t.library || o4, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, su.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    i4(f) ? ((0, su.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, r4.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (h = nN(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function i4(e) {
  return su.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, su.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = On && On.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(hw);
  e.htmlToDOM = n.default;
  var r = t(Vh);
  e.attributesToProps = r.default;
  var o = t(kw);
  e.domToReact = o.default;
  var i = mw;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(RI);
const s4 = /* @__PURE__ */ k8(RI);
s4.default;
var kn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function a4(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var cb = { exports: {} }, Ol = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var t1;
function l4() {
  if (t1) return Ol;
  t1 = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return Ol.Fragment = n, Ol.jsx = a, Ol.jsxs = a, Ol;
}
var cp = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var n1;
function u4() {
  return n1 || (n1 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var R = f && b[f] || b[m];
      return typeof R == "function" ? R : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var R = arguments.length, Y = new Array(R > 1 ? R - 1 : 0), ne = 1; ne < R; ne++)
          Y[ne - 1] = arguments[ne];
        S("error", b, Y);
      }
    }
    function S(b, R, Y) {
      {
        var ne = E.ReactDebugCurrentFrame, ue = ne.getStackAddendum();
        ue !== "" && (R += "%s", Y = Y.concat([ue]));
        var ce = Y.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + R), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, y = !1, C = !1, P = !1, F = !1, _;
    _ = Symbol.for("react.module.reference");
    function I(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || P || b === g || x || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === _ || b.getModuleId !== void 0));
    }
    function B(b, R, Y) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var ue = R.displayName || R.name || "";
      return ue !== "" ? Y + "(" + ue + ")" : Y;
    }
    function $(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var R = b;
            return $(R) + ".Consumer";
          case a:
            var Y = b;
            return $(Y._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var ue = b, ce = ue._payload, ae = ue._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, H = 0, X, J, te, ee, L, T, W;
    function D() {
    }
    D.__reactDisabledLog = !0;
    function G() {
      {
        if (H === 0) {
          X = console.log, J = console.info, te = console.warn, ee = console.error, L = console.group, T = console.groupCollapsed, W = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: D,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        H++;
      }
    }
    function O() {
      {
        if (H--, H === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: X
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: L
            }),
            groupCollapsed: z({}, b, {
              value: T
            }),
            groupEnd: z({}, b, {
              value: W
            })
          });
        }
        H < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = E.ReactCurrentDispatcher, U;
    function j(b, R, Y) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ue) {
            var ne = ue.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var Z = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function N(b, R) {
      if (!b || Z)
        return "";
      {
        var Y = A.get(b);
        if (Y !== void 0)
          return Y;
      }
      var ne;
      Z = !0;
      var ue = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = M.current, M.current = null, G();
      try {
        if (R) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Ne) {
              ne = Ne;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Ne) {
              ne = Ne;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            ne = Ne;
          }
          b();
        }
      } catch (Ne) {
        if (Ne && ne && typeof Ne.stack == "string") {
          for (var se = Ne.stack.split(`
`), Ae = ne.stack.split(`
`), we = se.length - 1, xe = Ae.length - 1; we >= 1 && xe >= 0 && se[we] !== Ae[xe]; )
            xe--;
          for (; we >= 1 && xe >= 0; we--, xe--)
            if (se[we] !== Ae[xe]) {
              if (we !== 1 || xe !== 1)
                do
                  if (we--, xe--, xe < 0 || se[we] !== Ae[xe]) {
                    var Ge = `
` + se[we].replace(" at new ", " at ");
                    return b.displayName && Ge.includes("<anonymous>") && (Ge = Ge.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ge), Ge;
                  }
                while (we >= 1 && xe >= 0);
              break;
            }
        }
      } finally {
        Z = !1, M.current = ce, O(), Error.prepareStackTrace = ue;
      }
      var Jt = b ? b.displayName || b.name : "", Et = Jt ? j(Jt) : "";
      return typeof b == "function" && A.set(b, Et), Et;
    }
    function le(b, R, Y) {
      return N(b, !1);
    }
    function ye(b) {
      var R = b.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(b, R, Y) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, ye(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return le(b.render);
          case p:
            return oe(b.type, R, Y);
          case d: {
            var ne = b, ue = ne._payload, ce = ne._init;
            try {
              return oe(ce(ue), R, Y);
            } catch {
            }
          }
        }
      return "";
    }
    var Be = Object.prototype.hasOwnProperty, Ue = {}, $e = E.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var R = b._owner, Y = oe(b.type, b._source, R ? R.type : null);
        $e.setExtraStackFrame(Y);
      } else
        $e.setExtraStackFrame(null);
    }
    function Je(b, R, Y, ne, ue) {
      {
        var ce = Function.call.bind(Be);
        for (var ae in b)
          if (ce(b, ae)) {
            var se = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Ae = Error((ne || "React class") + ": " + Y + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ae.name = "Invariant Violation", Ae;
              }
              se = b[ae](R, ae, ne, Y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (we) {
              se = we;
            }
            se && !(se instanceof Error) && (Ie(ue), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", Y, ae, typeof se), Ie(null)), se instanceof Error && !(se.message in Ue) && (Ue[se.message] = !0, Ie(ue), w("Failed %s type: %s", Y, se.message), Ie(null));
          }
      }
    }
    var Ze = Array.isArray;
    function Me(b) {
      return Ze(b);
    }
    function Ye(b) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, Y = R && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Y;
      }
    }
    function nt(b) {
      try {
        return De(b), !1;
      } catch {
        return !0;
      }
    }
    function De(b) {
      return "" + b;
    }
    function je(b) {
      if (nt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ye(b)), De(b);
    }
    var Ke = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Fe, et;
    function Re(b) {
      if (Be.call(b, "ref")) {
        var R = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function Rt(b) {
      if (Be.call(b, "key")) {
        var R = Object.getOwnPropertyDescriptor(b, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function rt(b, R) {
      typeof b.ref == "string" && Ke.current;
    }
    function ot(b, R) {
      {
        var Y = function() {
          Fe || (Fe = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Y,
          configurable: !0
        });
      }
    }
    function at(b, R) {
      {
        var Y = function() {
          et || (et = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Y,
          configurable: !0
        });
      }
    }
    var Kt = function(b, R, Y, ne, ue, ce, ae) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: R,
        ref: Y,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ue
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function lt(b, R, Y, ne, ue) {
      {
        var ce, ae = {}, se = null, Ae = null;
        Y !== void 0 && (je(Y), se = "" + Y), Rt(R) && (je(R.key), se = "" + R.key), Re(R) && (Ae = R.ref, rt(R));
        for (ce in R)
          Be.call(R, ce) && !We.hasOwnProperty(ce) && (ae[ce] = R[ce]);
        if (b && b.defaultProps) {
          var we = b.defaultProps;
          for (ce in we)
            ae[ce] === void 0 && (ae[ce] = we[ce]);
        }
        if (se || Ae) {
          var xe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && ot(ae, xe), Ae && at(ae, xe);
        }
        return Kt(b, se, Ae, ue, ne, Ke.current, ae);
      }
    }
    var ut = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var R = b._owner, Y = oe(b.type, b._source, R ? R.type : null);
        tt.setExtraStackFrame(Y);
      } else
        tt.setExtraStackFrame(null);
    }
    var Xt;
    Xt = !1;
    function Yt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function bt() {
      {
        if (ut.current) {
          var b = V(ut.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Rn(b) {
      return "";
    }
    var wt = {};
    function In(b) {
      {
        var R = bt();
        if (!R) {
          var Y = typeof b == "string" ? b : b.displayName || b.name;
          Y && (R = `

Check the top-level render call using <` + Y + ">.");
        }
        return R;
      }
    }
    function Ct(b, R) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Y = In(R);
        if (wt[Y])
          return;
        wt[Y] = !0;
        var ne = "";
        b && b._owner && b._owner !== ut.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Y, ne), Xe(null);
      }
    }
    function fn(b, R) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var Y = 0; Y < b.length; Y++) {
            var ne = b[Y];
            Yt(ne) && Ct(ne, R);
          }
        else if (Yt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ue = h(b);
          if (typeof ue == "function" && ue !== b.entries)
            for (var ce = ue.call(b), ae; !(ae = ce.next()).done; )
              Yt(ae.value) && Ct(ae.value, R);
        }
      }
    }
    function wr(b) {
      {
        var R = b.type;
        if (R == null || typeof R == "string")
          return;
        var Y;
        if (typeof R == "function")
          Y = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          Y = R.propTypes;
        else
          return;
        if (Y) {
          var ne = V(R);
          Je(Y, b.props, "prop", ne, b);
        } else if (R.PropTypes !== void 0 && !Xt) {
          Xt = !0;
          var ue = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ue || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function xt(b) {
      {
        for (var R = Object.keys(b.props), Y = 0; Y < R.length; Y++) {
          var ne = R[Y];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function Qr(b, R, Y, ne, ue, ce) {
      {
        var ae = I(b);
        if (!ae) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ae = Rn();
          Ae ? se += Ae : se += bt();
          var we;
          b === null ? we = "null" : Me(b) ? we = "array" : b !== void 0 && b.$$typeof === t ? (we = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : we = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", we, se);
        }
        var xe = lt(b, R, Y, ue, ce);
        if (xe == null)
          return xe;
        if (ae) {
          var Ge = R.children;
          if (Ge !== void 0)
            if (ne)
              if (Me(Ge)) {
                for (var Jt = 0; Jt < Ge.length; Jt++)
                  fn(Ge[Jt], b);
                Object.freeze && Object.freeze(Ge);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              fn(Ge, b);
        }
        if (Be.call(R, "key")) {
          var Et = V(b), Ne = Object.keys(R).filter(function(gi) {
            return gi !== "key";
          }), Cr = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[Et + Cr]) {
            var hi = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Cr, Et, hi, Et), re[Et + Cr] = !0;
          }
        }
        return b === r ? xt(xe) : wr(xe), xe;
      }
    }
    function ci(b, R, Y) {
      return Qr(b, R, Y, !0);
    }
    function pi(b, R, Y) {
      return Qr(b, R, Y, !1);
    }
    var di = pi, fi = ci;
    cp.Fragment = r, cp.jsx = di, cp.jsxs = fi;
  }()), cp;
}
process.env.NODE_ENV === "production" ? cb.exports = l4() : cb.exports = u4();
var Dr = cb.exports;
qe({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function r1(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function zr(e) {
  var t, n;
  return r1(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(r1(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var rN = Symbol.for("immer-nothing"), o1 = Symbol.for("immer-draftable"), Lo = Symbol.for("immer-state"), c4 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function oo(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = c4[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Xa = Object.getPrototypeOf;
function Oa(e) {
  return !!e && !!e[Lo];
}
function ka(e) {
  var t;
  return e ? oN(e) || Array.isArray(e) || !!e[o1] || !!((t = e.constructor) != null && t[o1]) || Xh(e) || Yh(e) : !1;
}
var p4 = Object.prototype.constructor.toString();
function oN(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Xa(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === p4;
}
function tf(e, t) {
  Kh(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Kh(e) {
  const t = e[Lo];
  return t ? t.type_ : Array.isArray(e) ? 1 : Xh(e) ? 2 : Yh(e) ? 3 : 0;
}
function pb(e, t) {
  return Kh(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function iN(e, t, n) {
  const r = Kh(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function d4(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Xh(e) {
  return e instanceof Map;
}
function Yh(e) {
  return e instanceof Set;
}
function Xs(e) {
  return e.copy_ || e.base_;
}
function db(e, t) {
  if (Xh(e))
    return new Map(e);
  if (Yh(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = oN(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Lo];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Xa(e), r);
  } else {
    const r = Xa(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function _w(e, t = !1) {
  return Jh(e) || Oa(e) || !ka(e) || (Kh(e) > 1 && (e.set = e.add = e.clear = e.delete = f4), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => _w(r, !0))), e;
}
function f4() {
  oo(2);
}
function Jh(e) {
  return Object.isFrozen(e);
}
var h4 = {};
function _a(e) {
  const t = h4[e];
  return t || oo(0, e), t;
}
var Fu;
function sN() {
  return Fu;
}
function g4(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function i1(e, t) {
  t && (_a("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function fb(e) {
  hb(e), e.drafts_.forEach(m4), e.drafts_ = null;
}
function hb(e) {
  e === Fu && (Fu = e.parent_);
}
function s1(e) {
  return Fu = g4(Fu, e);
}
function m4(e) {
  const t = e[Lo];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function a1(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Lo].modified_ && (fb(t), oo(4)), ka(e) && (e = nf(t, e), t.parent_ || rf(t, e)), t.patches_ && _a("Patches").generateReplacementPatches_(
    n[Lo].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = nf(t, n, []), fb(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== rN ? e : void 0;
}
function nf(e, t, n) {
  if (Jh(t))
    return t;
  const r = t[Lo];
  if (!r)
    return tf(
      t,
      (o, i) => l1(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return rf(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), tf(
      i,
      (s, l) => l1(e, r, o, s, l, n, a)
    ), rf(e, o, !1), n && e.patches_ && _a("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function l1(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && oo(5), Oa(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !pb(t.assigned_, r) ? i.concat(r) : void 0, l = nf(e, o, s);
    if (iN(n, r, l), Oa(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (ka(o) && !Jh(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    nf(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && rf(e, o);
  }
}
function rf(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && _w(t, n);
}
function v4(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : sN(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Lw;
  n && (o = [r], i = zu);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var Lw = {
  get(e, t) {
    if (t === Lo)
      return e;
    const n = Xs(e);
    if (!pb(n, t))
      return y4(e, n, t);
    const r = n[t];
    return e.finalized_ || !ka(r) ? r : r === Em(e.base_, t) ? (Om(e), e.copy_[t] = mb(r, e)) : r;
  },
  has(e, t) {
    return t in Xs(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Xs(e));
  },
  set(e, t, n) {
    const r = aN(Xs(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Em(Xs(e), t), i = o == null ? void 0 : o[Lo];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (d4(n, o) && (n !== void 0 || pb(e.base_, t)))
        return !0;
      Om(e), gb(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Em(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Om(e), gb(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Xs(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    oo(11);
  },
  getPrototypeOf(e) {
    return Xa(e.base_);
  },
  setPrototypeOf() {
    oo(12);
  }
}, zu = {};
tf(Lw, (e, t) => {
  zu[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
zu.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && oo(13), zu.set.call(this, e, t, void 0);
};
zu.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && oo(14), Lw.set.call(this, e[0], t, n, e[0]);
};
function Em(e, t) {
  const n = e[Lo];
  return (n ? Xs(n) : e)[t];
}
function y4(e, t, n) {
  var r;
  const o = aN(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function aN(e, t) {
  if (!(t in e))
    return;
  let n = Xa(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Xa(n);
  }
}
function gb(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && gb(e.parent_));
}
function Om(e) {
  e.copy_ || (e.copy_ = db(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var b4 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && oo(6), r !== void 0 && typeof r != "function" && oo(7);
      let o;
      if (ka(t)) {
        const i = s1(this), a = mb(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? fb(i) : hb(i);
        }
        return i1(i, r), a1(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === rN && (o = void 0), this.autoFreeze_ && _w(o, !0), r) {
          const i = [], a = [];
          _a("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        oo(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ka(e) || oo(8), Oa(e) && (e = w4(e));
    const t = s1(this), n = mb(e, void 0);
    return n[Lo].isManual_ = !0, hb(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Lo];
    (!n || !n.isManual_) && oo(9);
    const { scope_: r } = n;
    return i1(r, t), a1(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = _a("Patches").applyPatches_;
    return Oa(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function mb(e, t) {
  const n = Xh(e) ? _a("MapSet").proxyMap_(e, t) : Yh(e) ? _a("MapSet").proxySet_(e, t) : v4(e, t);
  return (t ? t.scope_ : sN()).drafts_.push(n), n;
}
function w4(e) {
  return Oa(e) || oo(10, e), lN(e);
}
function lN(e) {
  if (!ka(e) || Jh(e))
    return e;
  const t = e[Lo];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = db(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = db(e, !0);
  return tf(n, (r, o) => {
    iN(n, r, lN(o));
  }), t && (t.finalized_ = !1), n;
}
var Po = new b4(), Pw = Po.produce;
Po.produceWithPatches.bind(
  Po
);
Po.setAutoFreeze.bind(Po);
Po.setUseStrictShallowCopy.bind(Po);
Po.applyPatches.bind(Po);
var u1 = Po.createDraft.bind(Po), c1 = Po.finishDraft.bind(Po), Pe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Pe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Pe.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Pe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Pe.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Pe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Pe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Pe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Pe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Pe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Pe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Pe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Pe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Pe.isAncestor(t, e) && !Pe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Pe.equals(i, r) || Pe.endsBefore(i, r) || Pe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Pe.equals(a, r) || Pe.isAncestor(a, r))
          return null;
        Pe.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Pe.equals(s, r) || Pe.endsBefore(s, r) ? r[s.length - 1] -= 1 : Pe.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Pe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Pe.endsBefore(u, r) ? r[u.length - 1] += 1 : Pe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Pe.equals(p, d))
          return r;
        if (Pe.isAncestor(p, r) || Pe.equals(p, r)) {
          var g = d.slice();
          return Pe.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Pe.isSibling(p, d) && (Pe.isAncestor(d, r) || Pe.equals(d, r)) ? Pe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Pe.endsBefore(d, r) || Pe.equals(d, r) || Pe.isAncestor(d, r) ? (Pe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Pe.endsBefore(p, r) && (Pe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Uu(e) {
  "@babel/helpers - typeof";
  return Uu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Uu(e);
}
function C4(e, t) {
  if (Uu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Uu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function x4(e) {
  var t = C4(e, "string");
  return Uu(t) === "symbol" ? t : String(t);
}
function il(e, t, n) {
  return t = x4(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function p1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? p1(Object(n), !0).forEach(function(r) {
      il(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : p1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var E4 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = dt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Lt.points(t))
          t[l] = jn.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = dt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, h] of Lt.points(t))
          t[h] = jn.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = dt.get(e, E), S = Pe.previous(E), x = dt.get(e, S), y = dt.parent(e, E), C = E[E.length - 1];
      if (dr.isText(w) && dr.isText(x))
        x.text += w.text;
      else if (!dr.isText(w) && !dr.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(ho.stringify(w), " ").concat(ho.stringify(x)));
      if (y.children.splice(C, 1), t)
        for (var [P, F] of Lt.points(t))
          t[F] = jn.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: _,
        newPath: I
      } = n;
      if (Pe.isAncestor(_, I))
        throw new Error("Cannot move a path [".concat(_, "] to new path [").concat(I, "] because the destination is inside itself."));
      var B = dt.get(e, _), $ = dt.parent(e, _), V = _[_.length - 1];
      $.children.splice(V, 1);
      var z = Pe.transform(_, n), H = dt.get(e, Pe.parent(z)), X = z[z.length - 1];
      if (H.children.splice(X, 0, B), t)
        for (var [J, te] of Lt.points(t))
          t[te] = jn.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, L = ee[ee.length - 1], T = dt.parent(e, ee);
      if (T.children.splice(L, 1), t)
        for (var [W, D] of Lt.points(t)) {
          var G = jn.transform(W, n);
          if (t != null && G != null)
            t[D] = G;
          else {
            var O = void 0, M = void 0;
            for (var [U, j] of dt.texts(e))
              if (Pe.compare(j, ee) === -1)
                O = [U, j];
              else {
                M = [U, j];
                break;
              }
            var Z = !1;
            O && M && (Pe.equals(M[1], ee) ? Z = !Pe.hasPrevious(M[1]) : Z = Pe.common(O[1], ee).length < Pe.common(M[1], ee).length), O && !Z ? (W.path = O[1], W.offset = O[0].text.length) : M ? (W.path = M[1], W.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: N
      } = n;
      if (N.length === 0) break;
      var le = dt.leaf(e, A), ye = le.text.slice(0, Q), oe = le.text.slice(Q + N.length);
      if (le.text = ye + oe, t)
        for (var [Be, Ue] of Lt.points(t))
          t[Ue] = jn.transform(Be, n);
      break;
    }
    case "set_node": {
      var {
        path: $e,
        properties: Ie,
        newProperties: Je
      } = n;
      if ($e.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ze = dt.get(e, $e);
      for (var Me in Je) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Ye = Je[Me];
        Ye == null ? delete Ze[Me] : Ze[Me] = Ye;
      }
      for (var nt in Ie)
        Je.hasOwnProperty(nt) || delete Ze[nt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: De
      } = n;
      if (De == null)
        t = De;
      else {
        if (t == null) {
          if (!Lt.isRange(De))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(ho.stringify(De), " when there is no current selection."));
          t = kl({}, De);
        }
        for (var je in De) {
          var Ke = De[je];
          if (Ke == null) {
            if (je === "anchor" || je === "focus")
              throw new Error('Cannot remove the "'.concat(je, '" selection property'));
            delete t[je];
          } else
            t[je] = Ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Fe,
        properties: et
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var Re = dt.get(e, We), Rt = dt.parent(e, We), rt = We[We.length - 1], ot;
      if (dr.isText(Re)) {
        var at = Re.text.slice(0, Fe), Kt = Re.text.slice(Fe);
        Re.text = at, ot = kl(kl({}, et), {}, {
          text: Kt
        });
      } else {
        var lt = Re.children.slice(0, Fe), ut = Re.children.slice(Fe);
        Re.children = lt, ot = kl(kl({}, et), {}, {
          children: ut
        });
      }
      if (Rt.children.splice(rt + 1, 0, ot), t)
        for (var [tt, Xe] of Lt.points(t))
          t[Xe] = jn.transform(tt, n);
      break;
    }
  }
  return t;
}, O4 = {
  transform(e, t) {
    e.children = u1(e.children);
    var n = e.selection && u1(e.selection);
    try {
      n = E4(e, n, t);
    } finally {
      e.children = c1(e.children), n ? e.selection = Oa(n) ? c1(n) : n : e.selection = null;
    }
  }
}, k4 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, _4 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, uN = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (zr(r) && zr(o)) {
      if (!uN(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function L4(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function $u(e, t) {
  if (e == null) return {};
  var n = L4(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var P4 = ["anchor", "focus"];
function d1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function S4(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? d1(Object(n), !0).forEach(function(r) {
      il(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : d1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Lt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Lt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Lt.edges(e);
    return t;
  },
  equals(e, t) {
    return jn.equals(e.anchor, t.anchor) && jn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Lt.isRange(t)) {
      if (Lt.includes(e, t.anchor) || Lt.includes(e, t.focus))
        return !0;
      var [n, r] = Lt.edges(e), [o, i] = Lt.edges(t);
      return jn.isBefore(n, o) && jn.isAfter(r, i);
    }
    var [a, s] = Lt.edges(e), l = !1, u = !1;
    return jn.isPoint(t) ? (l = jn.compare(t, a) >= 0, u = jn.compare(t, s) <= 0) : (l = Pe.compare(t, a.path) >= 0, u = Pe.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = $u(e, P4), [r, o] = Lt.edges(e), [i, a] = Lt.edges(t), s = jn.isBefore(r, i) ? i : r, l = jn.isBefore(o, a) ? o : a;
    return jn.isBefore(l, s) ? null : S4({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return jn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return jn.equals(t, n);
  },
  isExpanded(e) {
    return !Lt.isCollapsed(e);
  },
  isForward(e) {
    return !Lt.isBackward(e);
  },
  isRange(e) {
    return zr(e) && jn.isPoint(e.anchor) && jn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Lt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Pw(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Lt.isCollapsed(r);
        Lt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Lt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = jn.transform(r.anchor, t, {
        affinity: i
      }), u = jn.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, f1 = (e) => zr(e) && dt.isNodeList(e.children) && !wn.isEditor(e), Pi = {
  isAncestor(e) {
    return zr(e) && dt.isNodeList(e.children);
  },
  isElement: f1,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Pi.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return f1(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, D4 = ["children"], M4 = ["text"], h1 = /* @__PURE__ */ new WeakMap(), dt = {
  ancestor(e, t) {
    var n = dt.get(e, t);
    if (dr.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(ho.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Pe.ancestors(t, n)) {
        var o = dt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (dr.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(ho.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(ho.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = dt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = dt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Pe.common(t, n), o = dt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = dt.get(e, t);
    if (wn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(ho.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of dt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of dt.nodes(e, t))
        Pi.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Pi.isAncestor(e)) {
      var t = $u(e, D4);
      return t;
    } else {
      var t = $u(e, M4);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = dt.get(e, n); r && !(dr.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (dr.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(ho.stringify(e)));
    var n = Pw({
      children: e.children
    }, (r) => {
      var [o, i] = Lt.edges(t), a = dt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Lt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Lt.includes(t, s)) {
          var l = dt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Pe.equals(s, i.path)) {
          var c = dt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Pe.equals(s, o.path)) {
          var p = dt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      wn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (dr.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(ho.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (dr.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return dr.isText(e) || Pi.isElement(e) || wn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = h1.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => dt.isNode(r));
    return h1.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = dt.get(e, n); r && !(dr.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = dt.get(e, t);
    if (!dr.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(ho.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Pe.levels(t, n)) {
        var o = dt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Pi.isElement(e) && Pi.isElementProps(t) && Pi.matches(e, t) || dr.isText(e) && dr.isTextProps(t) && dr.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Pe.isBefore(s, i) : Pe.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !dr.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Pe.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = dt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Pe.next(s);
          if (dt.has(e, c)) {
            s = c, l = dt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Pe.previous(s);
          s = p, l = dt.get(e, s);
          continue;
        }
        s = Pe.parent(s), l = dt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Pe.parent(t), r = dt.get(e, n);
    if (dr.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return dr.isText(e) ? e.text : e.children.map(dt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of dt.nodes(e, t))
        dr.isText(n) && (yield [n, r]);
    }();
  }
};
function g1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Un(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? g1(Object(n), !0).forEach(function(r) {
      il(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : g1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xl = {
  isNodeOperation(e) {
    return Xl.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!zr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Pe.isPath(e.path) && dt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Pe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Pe.isPath(e.path) && zr(e.properties);
      case "move_node":
        return Pe.isPath(e.path) && Pe.isPath(e.newPath);
      case "remove_node":
        return Pe.isPath(e.path) && dt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Pe.isPath(e.path);
      case "set_node":
        return Pe.isPath(e.path) && zr(e.properties) && zr(e.newProperties);
      case "set_selection":
        return e.properties === null && Lt.isRange(e.newProperties) || e.newProperties === null && Lt.isRange(e.properties) || zr(e.properties) && zr(e.newProperties);
      case "split_node":
        return Pe.isPath(e.path) && typeof e.position == "number" && zr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Xl.isOperation(t));
  },
  isSelectionOperation(e) {
    return Xl.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Xl.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Un(Un({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Un(Un({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Un(Un({}, e), {}, {
          type: "split_node",
          path: Pe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Pe.equals(t, n))
          return e;
        if (Pe.isSibling(n, t))
          return Un(Un({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Pe.transform(n, e), o = Pe.transform(Pe.next(n), e);
        return Un(Un({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Un(Un({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Un(Un({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Un(Un({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Un(Un({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Un(Un({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Un(Un({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Un(Un({}, e), {}, {
          type: "merge_node",
          path: Pe.next(e.path)
        });
    }
  }
}, m1 = /* @__PURE__ */ new WeakMap(), T4 = (e) => {
  var t = m1.get(e);
  if (t !== void 0)
    return t;
  if (!zr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || zr(e.marks)) && (e.selection === null || Lt.isRange(e.selection)) && dt.isNodeList(e.children) && Xl.isOperationList(e.operations);
  return m1.set(e, n), n;
}, wn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return T4(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function v1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function y1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? v1(Object(n), !0).forEach(function(r) {
      il(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : v1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jn = {
  compare(e, t) {
    var n = Pe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return jn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return jn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Pe.equals(e.path, t.path);
  },
  isPoint(e) {
    return zr(e) && typeof e.offset == "number" && Pe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Pw(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Pe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Pe.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Pe.equals(t.path, i) && (r.offset += t.position), r.path = Pe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Pe.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Pe.equals(t.path, i) || Pe.isAncestor(t.path, i))
            return null;
          r.path = Pe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Pe.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Pe.transform(i, t, y1(y1({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Pe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, b1 = void 0, ho = {
  setScrubber(e) {
    b1 = e;
  },
  stringify(e) {
    return JSON.stringify(e, b1);
  }
}, j4 = ["text"], A4 = ["anchor", "focus"];
function w1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? w1(Object(n), !0).forEach(function(r) {
      il(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : w1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dr = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = $u(i, j4);
      return a;
    }
    return uN(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return zr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => dr.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [bi({}, e)];
    for (var r of t) {
      var o = $u(r, A4), [i, a] = Lt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, h = void 0;
        if (c < l) {
          var E = c - g;
          h = bi(bi({}, f), {}, {
            text: f.text.slice(E)
          }), f = bi(bi({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = bi(bi({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = bi(bi({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), h && s.push(h);
      }
      n = s;
    }
    return n;
  }
}, B4 = (e) => e.selection ? e.selection : e.children.length > 0 ? wn.end(e, []) : [0], Sn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Sn || (Sn = {}));
Sn.L, Sn.L | Sn.V | Sn.LV | Sn.LVT, Sn.LV | Sn.V, Sn.V | Sn.T, Sn.LVT | Sn.T, Sn.T, Sn.Any, Sn.Extend | Sn.ZWJ, Sn.Any, Sn.SpacingMark, Sn.Prepend, Sn.Any, Sn.ZWJ, Sn.ExtPict, Sn.RI, Sn.RI;
var R4 = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    wn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = B4(e)
      } = n;
      if (Pe.isPath(o) && (o = wn.range(e, o)), Lt.isRange(o))
        if (Lt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Lt.end(o);
          if (!r && wn.void(e, {
            at: i
          }))
            return;
          var a = Lt.start(o), s = wn.pointRef(e, a), l = wn.pointRef(e, i);
          of.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, of.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && wn.void(e, {
        at: o
      }) || wn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function C1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? C1(Object(n), !0).forEach(function(r) {
      il(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : C1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var of = pp(pp(pp(pp({}, O4), k4), _4), R4), cN = {}, Sw = {}, Dw = {}, ja = {}, Mw = {}, Tw = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Tw);
var jt = {}, _s = kn && kn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), au = kn && kn.__assign || function() {
  return au = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, au.apply(this, arguments);
};
Object.defineProperty(jt, "__esModule", { value: !0 });
jt.cloneNode = jt.hasChildren = jt.isDocument = jt.isDirective = jt.isComment = jt.isText = jt.isCDATA = jt.isTag = jt.Element = jt.Document = jt.CDATA = jt.NodeWithChildren = jt.ProcessingInstruction = jt.Comment = jt.Text = jt.DataNode = jt.Node = void 0;
var uo = Tw, jw = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Aw(this, t);
    }, e;
  }()
);
jt.Node = jw;
var Qh = (
  /** @class */
  function(e) {
    _s(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(jw)
);
jt.DataNode = Qh;
var pN = (
  /** @class */
  function(e) {
    _s(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = uo.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qh)
);
jt.Text = pN;
var dN = (
  /** @class */
  function(e) {
    _s(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = uo.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qh)
);
jt.Comment = dN;
var fN = (
  /** @class */
  function(e) {
    _s(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = uo.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qh)
);
jt.ProcessingInstruction = fN;
var eg = (
  /** @class */
  function(e) {
    _s(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(jw)
);
jt.NodeWithChildren = eg;
var hN = (
  /** @class */
  function(e) {
    _s(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = uo.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(eg)
);
jt.CDATA = hN;
var gN = (
  /** @class */
  function(e) {
    _s(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = uo.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(eg)
);
jt.Document = gN;
var mN = (
  /** @class */
  function(e) {
    _s(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? uo.ElementType.Script : n === "style" ? uo.ElementType.Style : uo.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(eg)
);
jt.Element = mN;
function vN(e) {
  return (0, uo.isTag)(e);
}
jt.isTag = vN;
function yN(e) {
  return e.type === uo.ElementType.CDATA;
}
jt.isCDATA = yN;
function bN(e) {
  return e.type === uo.ElementType.Text;
}
jt.isText = bN;
function wN(e) {
  return e.type === uo.ElementType.Comment;
}
jt.isComment = wN;
function CN(e) {
  return e.type === uo.ElementType.Directive;
}
jt.isDirective = CN;
function xN(e) {
  return e.type === uo.ElementType.Root;
}
jt.isDocument = xN;
function I4(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
jt.hasChildren = I4;
function Aw(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (bN(e))
    n = new pN(e.data);
  else if (wN(e))
    n = new dN(e.data);
  else if (vN(e)) {
    var r = t ? km(e.children) : [], o = new mN(e.name, au({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = au({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = au({}, e["x-attribsPrefix"])), n = o;
  } else if (yN(e)) {
    var r = t ? km(e.children) : [], i = new hN(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (xN(e)) {
    var r = t ? km(e.children) : [], a = new gN(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (CN(e)) {
    var s = new fN(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
jt.cloneNode = Aw;
function km(e) {
  for (var t = e.map(function(r) {
    return Aw(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = kn && kn.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = kn && kn.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Tw, o = jt;
  n(jt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(Mw);
var EN = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(EN);
Object.defineProperty(ja, "__esModule", { value: !0 });
ja.formatAttributes = ON;
ja.escapeSpecialCharacters = z4;
ja.revertEscapedCharacters = kN;
ja.formatDOM = _N;
var dp = Mw, Wu = EN;
function N4(e) {
  return Wu.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function ON(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function F4(e) {
  e = e.toLowerCase();
  var t = N4(e);
  return t || e;
}
function z4(e) {
  return e.replace(Wu.CARRIAGE_RETURN_REGEX, Wu.CARRIAGE_RETURN_PLACEHOLDER);
}
function kN(e) {
  return e.replace(Wu.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Wu.CARRIAGE_RETURN);
}
function _N(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = F4(s.nodeName);
        o = new dp.Element(l, ON(s.attributes)), o.children = _N(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new dp.Text(kN(s.nodeValue));
        break;
      case 8:
        o = new dp.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new dp.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(Dw, "__esModule", { value: !0 });
Dw.default = H4;
var U4 = ja, x1 = "html", E1 = "head", fp = "body", $4 = /<([a-zA-Z]+[0-9]?)/, O1 = /<head[^]*>/i, k1 = /<body[^]*>/i, sf = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, vb = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, _1 = typeof window == "object" && window.DOMParser;
if (typeof _1 == "function") {
  var W4 = new _1(), V4 = "text/html";
  vb = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), W4.parseFromString(e, V4);
  }, sf = vb;
}
if (typeof document == "object" && document.implementation) {
  var hp = document.implementation.createHTMLDocument();
  sf = function(e, t) {
    if (t) {
      var n = hp.documentElement.querySelector(t);
      return n && (n.innerHTML = e), hp;
    }
    return hp.documentElement.innerHTML = e, hp;
  };
}
var gp = typeof document == "object" && document.createElement("template"), yb;
gp && gp.content && (yb = function(e) {
  return gp.innerHTML = e, gp.content.childNodes;
});
function H4(e) {
  var t, n;
  e = (0, U4.escapeSpecialCharacters)(e);
  var r = e.match($4), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case x1: {
      var i = vb(e);
      if (!O1.test(e)) {
        var a = i.querySelector(E1);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!k1.test(e)) {
        var a = i.querySelector(fp);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(x1);
    }
    case E1:
    case fp: {
      var s = sf(e).querySelectorAll(o);
      return k1.test(e) && O1.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (yb)
        return yb(e);
      var a = sf(e, fp).querySelector(fp);
      return a.childNodes;
    }
  }
}
var G4 = kn && kn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Sw, "__esModule", { value: !0 });
Sw.default = X4;
var q4 = G4(Dw), Z4 = ja, K4 = /<(![a-zA-Z\s]+)>/;
function X4(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(K4), n = t ? t[1] : void 0;
  return (0, Z4.formatDOM)((0, q4.default)(e), null, n);
}
var tg = {}, $o = {}, ng = {}, Y4 = 0;
ng.SAME = Y4;
var J4 = 1;
ng.CAMELCASE = J4;
ng.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const LN = 0, Ls = 1, rg = 2, og = 3, Bw = 4, PN = 5, SN = 6;
function Q4(e) {
  return Br.hasOwnProperty(e) ? Br[e] : null;
}
function Xr(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === rg || t === og || t === Bw, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Br = {}, e7 = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
e7.forEach((e) => {
  Br[e] = new Xr(
    e,
    LN,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Br[e] = new Xr(
    e,
    Ls,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Br[e] = new Xr(
    e,
    rg,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Br[e] = new Xr(
    e,
    rg,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Br[e] = new Xr(
    e,
    og,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Br[e] = new Xr(
    e,
    og,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Br[e] = new Xr(
    e,
    Bw,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Br[e] = new Xr(
    e,
    SN,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Br[e] = new Xr(
    e,
    PN,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Rw = /[\-\:]([a-z])/g, Iw = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Rw, Iw);
  Br[t] = new Xr(
    t,
    Ls,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Rw, Iw);
  Br[t] = new Xr(
    t,
    Ls,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Rw, Iw);
  Br[t] = new Xr(
    t,
    Ls,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Br[e] = new Xr(
    e,
    Ls,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const t7 = "xlinkHref";
Br[t7] = new Xr(
  "xlinkHref",
  Ls,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Br[e] = new Xr(
    e,
    Ls,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: n7,
  SAME: r7,
  possibleStandardNames: L1
} = ng, o7 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", i7 = o7 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", s7 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + i7 + "]*$")
), a7 = Object.keys(
  L1
).reduce((e, t) => {
  const n = L1[t];
  return n === r7 ? e[t] = t : n === n7 ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
$o.BOOLEAN = og;
$o.BOOLEANISH_STRING = rg;
$o.NUMERIC = PN;
$o.OVERLOADED_BOOLEAN = Bw;
$o.POSITIVE_NUMERIC = SN;
$o.RESERVED = LN;
$o.STRING = Ls;
$o.getPropertyInfo = Q4;
$o.isCustomAttribute = s7;
$o.possibleStandardNames = a7;
var Nw = {}, Fw = {}, P1 = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, l7 = /\n/g, u7 = /^\s*/, c7 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, p7 = /^:\s*/, d7 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, f7 = /^[;\s]*/, h7 = /^\s+|\s+$/g, g7 = `
`, S1 = "/", D1 = "*", na = "", m7 = "comment", v7 = "declaration", y7 = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(l7);
    m && (n += m.length);
    var h = f.lastIndexOf(g7);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var h = m[0];
      return o(h), e = e.slice(h.length), m;
    }
  }
  function u() {
    l(u7);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(S1 != e.charAt(0) || D1 != e.charAt(1))) {
      for (var m = 2; na != e.charAt(m) && (D1 != e.charAt(m) || S1 != e.charAt(m + 1)); )
        ++m;
      if (m += 2, na === e.charAt(m - 1))
        return s("End of comment missing");
      var h = e.slice(2, m - 2);
      return r += 2, o(h), e = e.slice(m), r += 2, f({
        type: m7,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), m = l(c7);
    if (m) {
      if (p(), !l(p7)) return s("property missing ':'");
      var h = l(d7), E = f({
        type: v7,
        property: M1(m[0].replace(P1, na)),
        value: h ? M1(h[0].replace(P1, na)) : na
      });
      return l(f7), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function M1(e) {
  return e ? e.replace(h7, na) : na;
}
var b7 = kn && kn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Fw, "__esModule", { value: !0 });
Fw.default = C7;
var w7 = b7(y7);
function C7(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, w7.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var ig = {};
Object.defineProperty(ig, "__esModule", { value: !0 });
ig.camelCase = void 0;
var x7 = /^--[a-zA-Z0-9_-]+$/, E7 = /-([a-z])/g, O7 = /^[^-]+$/, k7 = /^-(webkit|moz|ms|o|khtml)-/, _7 = /^-(ms)-/, L7 = function(e) {
  return !e || O7.test(e) || x7.test(e);
}, P7 = function(e, t) {
  return t.toUpperCase();
}, T1 = function(e, t) {
  return "".concat(t, "-");
}, S7 = function(e, t) {
  return t === void 0 && (t = {}), L7(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(_7, T1) : e = e.replace(k7, T1), e.replace(E7, P7));
};
ig.camelCase = S7;
var D7 = kn && kn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, M7 = D7(Fw), T7 = ig;
function bb(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, M7.default)(e, function(r, o) {
    r && o && (n[(0, T7.camelCase)(r, t)] = o);
  }), n;
}
bb.default = bb;
var j7 = bb;
(function(e) {
  var t = kn && kn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(j7), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Nw);
Object.defineProperty(tg, "__esModule", { value: !0 });
tg.default = I7;
var Yl = $o, j1 = Nw, A7 = ["checked", "value"], B7 = ["input", "select", "textarea"], R7 = {
  reset: !0,
  submit: !0
};
function I7(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && R7[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Yl.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = A1(a);
    if (s) {
      var l = (0, Yl.getPropertyInfo)(s);
      switch (A7.includes(s) && B7.includes(t) && !r && (s = A1("default" + a)), n[s] = i, l && l.type) {
        case Yl.BOOLEAN:
          n[s] = !0;
          break;
        case Yl.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    j1.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, j1.setStyleProp)(e.style, n), n;
}
function A1(e) {
  return Yl.possibleStandardNames[e];
}
var zw = {}, N7 = kn && kn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(zw, "__esModule", { value: !0 });
zw.default = DN;
var _m = Oe, F7 = N7(tg), lu = Nw, z7 = {
  cloneElement: _m.cloneElement,
  createElement: _m.createElement,
  isValidElement: _m.isValidElement
};
function DN(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || lu.returnFirstArg, i = t.library || z7, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, lu.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    U7(f) ? ((0, lu.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, F7.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (h = DN(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function U7(e) {
  return lu.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, lu.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = kn && kn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(Sw);
  e.htmlToDOM = n.default;
  var r = t(tg);
  e.attributesToProps = r.default;
  var o = t(zw);
  e.domToReact = o.default;
  var i = Mw;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(cN);
const $7 = /* @__PURE__ */ a4(cN);
$7.default;
var _n = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function W7(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var wb = { exports: {} }, _l = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var B1;
function V7() {
  if (B1) return _l;
  B1 = 1;
  var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return _l.Fragment = n, _l.jsx = a, _l.jsxs = a, _l;
}
var mp = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var R1;
function H7() {
  return R1 || (R1 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Oe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var R = f && b[f] || b[m];
      return typeof R == "function" ? R : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var R = arguments.length, Y = new Array(R > 1 ? R - 1 : 0), ne = 1; ne < R; ne++)
          Y[ne - 1] = arguments[ne];
        S("error", b, Y);
      }
    }
    function S(b, R, Y) {
      {
        var ne = E.ReactDebugCurrentFrame, ue = ne.getStackAddendum();
        ue !== "" && (R += "%s", Y = Y.concat([ue]));
        var ce = Y.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + R), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, y = !1, C = !1, P = !1, F = !1, _;
    _ = Symbol.for("react.module.reference");
    function I(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || P || b === g || x || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === _ || b.getModuleId !== void 0));
    }
    function B(b, R, Y) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var ue = R.displayName || R.name || "";
      return ue !== "" ? Y + "(" + ue + ")" : Y;
    }
    function $(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var R = b;
            return $(R) + ".Consumer";
          case a:
            var Y = b;
            return $(Y._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var ue = b, ce = ue._payload, ae = ue._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, H = 0, X, J, te, ee, L, T, W;
    function D() {
    }
    D.__reactDisabledLog = !0;
    function G() {
      {
        if (H === 0) {
          X = console.log, J = console.info, te = console.warn, ee = console.error, L = console.group, T = console.groupCollapsed, W = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: D,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        H++;
      }
    }
    function O() {
      {
        if (H--, H === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: X
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: L
            }),
            groupCollapsed: z({}, b, {
              value: T
            }),
            groupEnd: z({}, b, {
              value: W
            })
          });
        }
        H < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = E.ReactCurrentDispatcher, U;
    function j(b, R, Y) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ue) {
            var ne = ue.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var Z = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function N(b, R) {
      if (!b || Z)
        return "";
      {
        var Y = A.get(b);
        if (Y !== void 0)
          return Y;
      }
      var ne;
      Z = !0;
      var ue = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = M.current, M.current = null, G();
      try {
        if (R) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Ne) {
              ne = Ne;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Ne) {
              ne = Ne;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            ne = Ne;
          }
          b();
        }
      } catch (Ne) {
        if (Ne && ne && typeof Ne.stack == "string") {
          for (var se = Ne.stack.split(`
`), Ae = ne.stack.split(`
`), we = se.length - 1, xe = Ae.length - 1; we >= 1 && xe >= 0 && se[we] !== Ae[xe]; )
            xe--;
          for (; we >= 1 && xe >= 0; we--, xe--)
            if (se[we] !== Ae[xe]) {
              if (we !== 1 || xe !== 1)
                do
                  if (we--, xe--, xe < 0 || se[we] !== Ae[xe]) {
                    var Ge = `
` + se[we].replace(" at new ", " at ");
                    return b.displayName && Ge.includes("<anonymous>") && (Ge = Ge.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ge), Ge;
                  }
                while (we >= 1 && xe >= 0);
              break;
            }
        }
      } finally {
        Z = !1, M.current = ce, O(), Error.prepareStackTrace = ue;
      }
      var Jt = b ? b.displayName || b.name : "", Et = Jt ? j(Jt) : "";
      return typeof b == "function" && A.set(b, Et), Et;
    }
    function le(b, R, Y) {
      return N(b, !1);
    }
    function ye(b) {
      var R = b.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(b, R, Y) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, ye(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return le(b.render);
          case p:
            return oe(b.type, R, Y);
          case d: {
            var ne = b, ue = ne._payload, ce = ne._init;
            try {
              return oe(ce(ue), R, Y);
            } catch {
            }
          }
        }
      return "";
    }
    var Be = Object.prototype.hasOwnProperty, Ue = {}, $e = E.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var R = b._owner, Y = oe(b.type, b._source, R ? R.type : null);
        $e.setExtraStackFrame(Y);
      } else
        $e.setExtraStackFrame(null);
    }
    function Je(b, R, Y, ne, ue) {
      {
        var ce = Function.call.bind(Be);
        for (var ae in b)
          if (ce(b, ae)) {
            var se = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Ae = Error((ne || "React class") + ": " + Y + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ae.name = "Invariant Violation", Ae;
              }
              se = b[ae](R, ae, ne, Y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (we) {
              se = we;
            }
            se && !(se instanceof Error) && (Ie(ue), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", Y, ae, typeof se), Ie(null)), se instanceof Error && !(se.message in Ue) && (Ue[se.message] = !0, Ie(ue), w("Failed %s type: %s", Y, se.message), Ie(null));
          }
      }
    }
    var Ze = Array.isArray;
    function Me(b) {
      return Ze(b);
    }
    function Ye(b) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, Y = R && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return Y;
      }
    }
    function nt(b) {
      try {
        return De(b), !1;
      } catch {
        return !0;
      }
    }
    function De(b) {
      return "" + b;
    }
    function je(b) {
      if (nt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ye(b)), De(b);
    }
    var Ke = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Fe, et;
    function Re(b) {
      if (Be.call(b, "ref")) {
        var R = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function Rt(b) {
      if (Be.call(b, "key")) {
        var R = Object.getOwnPropertyDescriptor(b, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function rt(b, R) {
      typeof b.ref == "string" && Ke.current;
    }
    function ot(b, R) {
      {
        var Y = function() {
          Fe || (Fe = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: Y,
          configurable: !0
        });
      }
    }
    function at(b, R) {
      {
        var Y = function() {
          et || (et = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        Y.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: Y,
          configurable: !0
        });
      }
    }
    var Kt = function(b, R, Y, ne, ue, ce, ae) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: R,
        ref: Y,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ue
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function lt(b, R, Y, ne, ue) {
      {
        var ce, ae = {}, se = null, Ae = null;
        Y !== void 0 && (je(Y), se = "" + Y), Rt(R) && (je(R.key), se = "" + R.key), Re(R) && (Ae = R.ref, rt(R));
        for (ce in R)
          Be.call(R, ce) && !We.hasOwnProperty(ce) && (ae[ce] = R[ce]);
        if (b && b.defaultProps) {
          var we = b.defaultProps;
          for (ce in we)
            ae[ce] === void 0 && (ae[ce] = we[ce]);
        }
        if (se || Ae) {
          var xe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && ot(ae, xe), Ae && at(ae, xe);
        }
        return Kt(b, se, Ae, ue, ne, Ke.current, ae);
      }
    }
    var ut = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var R = b._owner, Y = oe(b.type, b._source, R ? R.type : null);
        tt.setExtraStackFrame(Y);
      } else
        tt.setExtraStackFrame(null);
    }
    var Xt;
    Xt = !1;
    function Yt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function bt() {
      {
        if (ut.current) {
          var b = V(ut.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function Rn(b) {
      return "";
    }
    var wt = {};
    function In(b) {
      {
        var R = bt();
        if (!R) {
          var Y = typeof b == "string" ? b : b.displayName || b.name;
          Y && (R = `

Check the top-level render call using <` + Y + ">.");
        }
        return R;
      }
    }
    function Ct(b, R) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var Y = In(R);
        if (wt[Y])
          return;
        wt[Y] = !0;
        var ne = "";
        b && b._owner && b._owner !== ut.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Y, ne), Xe(null);
      }
    }
    function fn(b, R) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var Y = 0; Y < b.length; Y++) {
            var ne = b[Y];
            Yt(ne) && Ct(ne, R);
          }
        else if (Yt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ue = h(b);
          if (typeof ue == "function" && ue !== b.entries)
            for (var ce = ue.call(b), ae; !(ae = ce.next()).done; )
              Yt(ae.value) && Ct(ae.value, R);
        }
      }
    }
    function wr(b) {
      {
        var R = b.type;
        if (R == null || typeof R == "string")
          return;
        var Y;
        if (typeof R == "function")
          Y = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          Y = R.propTypes;
        else
          return;
        if (Y) {
          var ne = V(R);
          Je(Y, b.props, "prop", ne, b);
        } else if (R.PropTypes !== void 0 && !Xt) {
          Xt = !0;
          var ue = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ue || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function xt(b) {
      {
        for (var R = Object.keys(b.props), Y = 0; Y < R.length; Y++) {
          var ne = R[Y];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function Qr(b, R, Y, ne, ue, ce) {
      {
        var ae = I(b);
        if (!ae) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ae = Rn();
          Ae ? se += Ae : se += bt();
          var we;
          b === null ? we = "null" : Me(b) ? we = "array" : b !== void 0 && b.$$typeof === t ? (we = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : we = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", we, se);
        }
        var xe = lt(b, R, Y, ue, ce);
        if (xe == null)
          return xe;
        if (ae) {
          var Ge = R.children;
          if (Ge !== void 0)
            if (ne)
              if (Me(Ge)) {
                for (var Jt = 0; Jt < Ge.length; Jt++)
                  fn(Ge[Jt], b);
                Object.freeze && Object.freeze(Ge);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              fn(Ge, b);
        }
        if (Be.call(R, "key")) {
          var Et = V(b), Ne = Object.keys(R).filter(function(gi) {
            return gi !== "key";
          }), Cr = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[Et + Cr]) {
            var hi = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Cr, Et, hi, Et), re[Et + Cr] = !0;
          }
        }
        return b === r ? xt(xe) : wr(xe), xe;
      }
    }
    function ci(b, R, Y) {
      return Qr(b, R, Y, !0);
    }
    function pi(b, R, Y) {
      return Qr(b, R, Y, !1);
    }
    var di = pi, fi = ci;
    mp.Fragment = r, mp.jsx = di, mp.jsxs = fi;
  }()), mp;
}
process.env.NODE_ENV === "production" ? wb.exports = V7() : wb.exports = H7();
var Mr = wb.exports;
qe({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function I1(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Ur(e) {
  var t, n;
  return I1(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(I1(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var MN = Symbol.for("immer-nothing"), N1 = Symbol.for("immer-draftable"), So = Symbol.for("immer-state"), G7 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function io(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = G7[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Ya = Object.getPrototypeOf;
function La(e) {
  return !!e && !!e[So];
}
function Pa(e) {
  var t;
  return e ? TN(e) || Array.isArray(e) || !!e[N1] || !!((t = e.constructor) != null && t[N1]) || ag(e) || lg(e) : !1;
}
var q7 = Object.prototype.constructor.toString();
function TN(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Ya(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === q7;
}
function af(e, t) {
  sg(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function sg(e) {
  const t = e[So];
  return t ? t.type_ : Array.isArray(e) ? 1 : ag(e) ? 2 : lg(e) ? 3 : 0;
}
function Cb(e, t) {
  return sg(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function jN(e, t, n) {
  const r = sg(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Z7(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function ag(e) {
  return e instanceof Map;
}
function lg(e) {
  return e instanceof Set;
}
function Ys(e) {
  return e.copy_ || e.base_;
}
function xb(e, t) {
  if (ag(e))
    return new Map(e);
  if (lg(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = TN(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[So];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Ya(e), r);
  } else {
    const r = Ya(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Uw(e, t = !1) {
  return ug(e) || La(e) || !Pa(e) || (sg(e) > 1 && (e.set = e.add = e.clear = e.delete = K7), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Uw(r, !0))), e;
}
function K7() {
  io(2);
}
function ug(e) {
  return Object.isFrozen(e);
}
var X7 = {};
function Sa(e) {
  const t = X7[e];
  return t || io(0, e), t;
}
var Vu;
function AN() {
  return Vu;
}
function Y7(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function F1(e, t) {
  t && (Sa("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Eb(e) {
  Ob(e), e.drafts_.forEach(J7), e.drafts_ = null;
}
function Ob(e) {
  e === Vu && (Vu = e.parent_);
}
function z1(e) {
  return Vu = Y7(Vu, e);
}
function J7(e) {
  const t = e[So];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function U1(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[So].modified_ && (Eb(t), io(4)), Pa(e) && (e = lf(t, e), t.parent_ || uf(t, e)), t.patches_ && Sa("Patches").generateReplacementPatches_(
    n[So].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = lf(t, n, []), Eb(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== MN ? e : void 0;
}
function lf(e, t, n) {
  if (ug(t))
    return t;
  const r = t[So];
  if (!r)
    return af(
      t,
      (o, i) => $1(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return uf(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), af(
      i,
      (s, l) => $1(e, r, o, s, l, n, a)
    ), uf(e, o, !1), n && e.patches_ && Sa("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function $1(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && io(5), La(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Cb(t.assigned_, r) ? i.concat(r) : void 0, l = lf(e, o, s);
    if (jN(n, r, l), La(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Pa(o) && !ug(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    lf(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && uf(e, o);
  }
}
function uf(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Uw(t, n);
}
function Q7(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : AN(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = $w;
  n && (o = [r], i = Hu);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var $w = {
  get(e, t) {
    if (t === So)
      return e;
    const n = Ys(e);
    if (!Cb(n, t))
      return eG(e, n, t);
    const r = n[t];
    return e.finalized_ || !Pa(r) ? r : r === Lm(e.base_, t) ? (Pm(e), e.copy_[t] = _b(r, e)) : r;
  },
  has(e, t) {
    return t in Ys(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ys(e));
  },
  set(e, t, n) {
    const r = BN(Ys(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Lm(Ys(e), t), i = o == null ? void 0 : o[So];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Z7(n, o) && (n !== void 0 || Cb(e.base_, t)))
        return !0;
      Pm(e), kb(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Lm(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Pm(e), kb(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ys(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    io(11);
  },
  getPrototypeOf(e) {
    return Ya(e.base_);
  },
  setPrototypeOf() {
    io(12);
  }
}, Hu = {};
af($w, (e, t) => {
  Hu[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Hu.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && io(13), Hu.set.call(this, e, t, void 0);
};
Hu.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && io(14), $w.set.call(this, e[0], t, n, e[0]);
};
function Lm(e, t) {
  const n = e[So];
  return (n ? Ys(n) : e)[t];
}
function eG(e, t, n) {
  var r;
  const o = BN(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function BN(e, t) {
  if (!(t in e))
    return;
  let n = Ya(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Ya(n);
  }
}
function kb(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && kb(e.parent_));
}
function Pm(e) {
  e.copy_ || (e.copy_ = xb(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var tG = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && io(6), r !== void 0 && typeof r != "function" && io(7);
      let o;
      if (Pa(t)) {
        const i = z1(this), a = _b(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? Eb(i) : Ob(i);
        }
        return F1(i, r), U1(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === MN && (o = void 0), this.autoFreeze_ && Uw(o, !0), r) {
          const i = [], a = [];
          Sa("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        io(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Pa(e) || io(8), La(e) && (e = nG(e));
    const t = z1(this), n = _b(e, void 0);
    return n[So].isManual_ = !0, Ob(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[So];
    (!n || !n.isManual_) && io(9);
    const { scope_: r } = n;
    return F1(r, t), U1(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Sa("Patches").applyPatches_;
    return La(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function _b(e, t) {
  const n = ag(e) ? Sa("MapSet").proxyMap_(e, t) : lg(e) ? Sa("MapSet").proxySet_(e, t) : Q7(e, t);
  return (t ? t.scope_ : AN()).drafts_.push(n), n;
}
function nG(e) {
  return La(e) || io(10, e), RN(e);
}
function RN(e) {
  if (!Pa(e) || ug(e))
    return e;
  const t = e[So];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = xb(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = xb(e, !0);
  return af(n, (r, o) => {
    jN(n, r, RN(o));
  }), t && (t.finalized_ = !1), n;
}
var Do = new tG(), Ww = Do.produce;
Do.produceWithPatches.bind(
  Do
);
Do.setAutoFreeze.bind(Do);
Do.setUseStrictShallowCopy.bind(Do);
Do.applyPatches.bind(Do);
var W1 = Do.createDraft.bind(Do), V1 = Do.finishDraft.bind(Do), Se = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Se.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Se.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Se.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Se.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Se.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Se.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Se.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Se.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Se.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Se.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Se.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Se.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Se.isAncestor(t, e) && !Se.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Se.equals(i, r) || Se.endsBefore(i, r) || Se.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Se.equals(a, r) || Se.isAncestor(a, r))
          return null;
        Se.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Se.equals(s, r) || Se.endsBefore(s, r) ? r[s.length - 1] -= 1 : Se.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Se.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Se.endsBefore(u, r) ? r[u.length - 1] += 1 : Se.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Se.equals(p, d))
          return r;
        if (Se.isAncestor(p, r) || Se.equals(p, r)) {
          var g = d.slice();
          return Se.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Se.isSibling(p, d) && (Se.isAncestor(d, r) || Se.equals(d, r)) ? Se.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Se.endsBefore(d, r) || Se.equals(d, r) || Se.isAncestor(d, r) ? (Se.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Se.endsBefore(p, r) && (Se.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Gu(e) {
  "@babel/helpers - typeof";
  return Gu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Gu(e);
}
function rG(e, t) {
  if (Gu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Gu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function oG(e) {
  var t = rG(e, "string");
  return Gu(t) === "symbol" ? t : String(t);
}
function sl(e, t, n) {
  return t = oG(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function H1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ll(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? H1(Object(n), !0).forEach(function(r) {
      sl(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : H1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var iG = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = ft.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Pt.points(t))
          t[l] = An.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = ft.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, h] of Pt.points(t))
          t[h] = An.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = ft.get(e, E), S = Se.previous(E), x = ft.get(e, S), y = ft.parent(e, E), C = E[E.length - 1];
      if (fr.isText(w) && fr.isText(x))
        x.text += w.text;
      else if (!fr.isText(w) && !fr.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(go.stringify(w), " ").concat(go.stringify(x)));
      if (y.children.splice(C, 1), t)
        for (var [P, F] of Pt.points(t))
          t[F] = An.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: _,
        newPath: I
      } = n;
      if (Se.isAncestor(_, I))
        throw new Error("Cannot move a path [".concat(_, "] to new path [").concat(I, "] because the destination is inside itself."));
      var B = ft.get(e, _), $ = ft.parent(e, _), V = _[_.length - 1];
      $.children.splice(V, 1);
      var z = Se.transform(_, n), H = ft.get(e, Se.parent(z)), X = z[z.length - 1];
      if (H.children.splice(X, 0, B), t)
        for (var [J, te] of Pt.points(t))
          t[te] = An.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, L = ee[ee.length - 1], T = ft.parent(e, ee);
      if (T.children.splice(L, 1), t)
        for (var [W, D] of Pt.points(t)) {
          var G = An.transform(W, n);
          if (t != null && G != null)
            t[D] = G;
          else {
            var O = void 0, M = void 0;
            for (var [U, j] of ft.texts(e))
              if (Se.compare(j, ee) === -1)
                O = [U, j];
              else {
                M = [U, j];
                break;
              }
            var Z = !1;
            O && M && (Se.equals(M[1], ee) ? Z = !Se.hasPrevious(M[1]) : Z = Se.common(O[1], ee).length < Se.common(M[1], ee).length), O && !Z ? (W.path = O[1], W.offset = O[0].text.length) : M ? (W.path = M[1], W.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: N
      } = n;
      if (N.length === 0) break;
      var le = ft.leaf(e, A), ye = le.text.slice(0, Q), oe = le.text.slice(Q + N.length);
      if (le.text = ye + oe, t)
        for (var [Be, Ue] of Pt.points(t))
          t[Ue] = An.transform(Be, n);
      break;
    }
    case "set_node": {
      var {
        path: $e,
        properties: Ie,
        newProperties: Je
      } = n;
      if ($e.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ze = ft.get(e, $e);
      for (var Me in Je) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Ye = Je[Me];
        Ye == null ? delete Ze[Me] : Ze[Me] = Ye;
      }
      for (var nt in Ie)
        Je.hasOwnProperty(nt) || delete Ze[nt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: De
      } = n;
      if (De == null)
        t = De;
      else {
        if (t == null) {
          if (!Pt.isRange(De))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(go.stringify(De), " when there is no current selection."));
          t = Ll({}, De);
        }
        for (var je in De) {
          var Ke = De[je];
          if (Ke == null) {
            if (je === "anchor" || je === "focus")
              throw new Error('Cannot remove the "'.concat(je, '" selection property'));
            delete t[je];
          } else
            t[je] = Ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Fe,
        properties: et
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var Re = ft.get(e, We), Rt = ft.parent(e, We), rt = We[We.length - 1], ot;
      if (fr.isText(Re)) {
        var at = Re.text.slice(0, Fe), Kt = Re.text.slice(Fe);
        Re.text = at, ot = Ll(Ll({}, et), {}, {
          text: Kt
        });
      } else {
        var lt = Re.children.slice(0, Fe), ut = Re.children.slice(Fe);
        Re.children = lt, ot = Ll(Ll({}, et), {}, {
          children: ut
        });
      }
      if (Rt.children.splice(rt + 1, 0, ot), t)
        for (var [tt, Xe] of Pt.points(t))
          t[Xe] = An.transform(tt, n);
      break;
    }
  }
  return t;
}, sG = {
  transform(e, t) {
    e.children = W1(e.children);
    var n = e.selection && W1(e.selection);
    try {
      n = iG(e, n, t);
    } finally {
      e.children = V1(e.children), n ? e.selection = La(n) ? V1(n) : n : e.selection = null;
    }
  }
}, aG = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, lG = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, IN = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Ur(r) && Ur(o)) {
      if (!IN(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function uG(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function qu(e, t) {
  if (e == null) return {};
  var n = uG(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var cG = ["anchor", "focus"];
function G1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pG(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G1(Object(n), !0).forEach(function(r) {
      sl(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Pt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Pt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Pt.edges(e);
    return t;
  },
  equals(e, t) {
    return An.equals(e.anchor, t.anchor) && An.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Pt.isRange(t)) {
      if (Pt.includes(e, t.anchor) || Pt.includes(e, t.focus))
        return !0;
      var [n, r] = Pt.edges(e), [o, i] = Pt.edges(t);
      return An.isBefore(n, o) && An.isAfter(r, i);
    }
    var [a, s] = Pt.edges(e), l = !1, u = !1;
    return An.isPoint(t) ? (l = An.compare(t, a) >= 0, u = An.compare(t, s) <= 0) : (l = Se.compare(t, a.path) >= 0, u = Se.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = qu(e, cG), [r, o] = Pt.edges(e), [i, a] = Pt.edges(t), s = An.isBefore(r, i) ? i : r, l = An.isBefore(o, a) ? o : a;
    return An.isBefore(l, s) ? null : pG({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return An.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return An.equals(t, n);
  },
  isExpanded(e) {
    return !Pt.isCollapsed(e);
  },
  isForward(e) {
    return !Pt.isBackward(e);
  },
  isRange(e) {
    return Ur(e) && An.isPoint(e.anchor) && An.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Pt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Ww(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Pt.isCollapsed(r);
        Pt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Pt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = An.transform(r.anchor, t, {
        affinity: i
      }), u = An.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, q1 = (e) => Ur(e) && ft.isNodeList(e.children) && !Cn.isEditor(e), Si = {
  isAncestor(e) {
    return Ur(e) && ft.isNodeList(e.children);
  },
  isElement: q1,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Si.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return q1(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, dG = ["children"], fG = ["text"], Z1 = /* @__PURE__ */ new WeakMap(), ft = {
  ancestor(e, t) {
    var n = ft.get(e, t);
    if (fr.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(go.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Se.ancestors(t, n)) {
        var o = ft.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (fr.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(go.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(go.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = ft.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = ft.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Se.common(t, n), o = ft.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = ft.get(e, t);
    if (Cn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(go.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ft.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ft.nodes(e, t))
        Si.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Si.isAncestor(e)) {
      var t = qu(e, dG);
      return t;
    } else {
      var t = qu(e, fG);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = ft.get(e, n); r && !(fr.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (fr.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(go.stringify(e)));
    var n = Ww({
      children: e.children
    }, (r) => {
      var [o, i] = Pt.edges(t), a = ft.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Pt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Pt.includes(t, s)) {
          var l = ft.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Se.equals(s, i.path)) {
          var c = ft.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Se.equals(s, o.path)) {
          var p = ft.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Cn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (fr.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(go.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (fr.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return fr.isText(e) || Si.isElement(e) || Cn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = Z1.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => ft.isNode(r));
    return Z1.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = ft.get(e, n); r && !(fr.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = ft.get(e, t);
    if (!fr.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(go.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Se.levels(t, n)) {
        var o = ft.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Si.isElement(e) && Si.isElementProps(t) && Si.matches(e, t) || fr.isText(e) && fr.isTextProps(t) && fr.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Se.isBefore(s, i) : Se.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !fr.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Se.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = ft.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Se.next(s);
          if (ft.has(e, c)) {
            s = c, l = ft.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Se.previous(s);
          s = p, l = ft.get(e, s);
          continue;
        }
        s = Se.parent(s), l = ft.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Se.parent(t), r = ft.get(e, n);
    if (fr.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return fr.isText(e) ? e.text : e.children.map(ft.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ft.nodes(e, t))
        fr.isText(n) && (yield [n, r]);
    }();
  }
};
function K1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $n(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? K1(Object(n), !0).forEach(function(r) {
      sl(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : K1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jl = {
  isNodeOperation(e) {
    return Jl.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Ur(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Se.isPath(e.path) && ft.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Se.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Se.isPath(e.path) && Ur(e.properties);
      case "move_node":
        return Se.isPath(e.path) && Se.isPath(e.newPath);
      case "remove_node":
        return Se.isPath(e.path) && ft.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Se.isPath(e.path);
      case "set_node":
        return Se.isPath(e.path) && Ur(e.properties) && Ur(e.newProperties);
      case "set_selection":
        return e.properties === null && Pt.isRange(e.newProperties) || e.newProperties === null && Pt.isRange(e.properties) || Ur(e.properties) && Ur(e.newProperties);
      case "split_node":
        return Se.isPath(e.path) && typeof e.position == "number" && Ur(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Jl.isOperation(t));
  },
  isSelectionOperation(e) {
    return Jl.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Jl.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return $n($n({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return $n($n({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return $n($n({}, e), {}, {
          type: "split_node",
          path: Se.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Se.equals(t, n))
          return e;
        if (Se.isSibling(n, t))
          return $n($n({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Se.transform(n, e), o = Se.transform(Se.next(n), e);
        return $n($n({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return $n($n({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return $n($n({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return $n($n({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? $n($n({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? $n($n({}, e), {}, {
          properties: null,
          newProperties: s
        }) : $n($n({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return $n($n({}, e), {}, {
          type: "merge_node",
          path: Se.next(e.path)
        });
    }
  }
}, X1 = /* @__PURE__ */ new WeakMap(), hG = (e) => {
  var t = X1.get(e);
  if (t !== void 0)
    return t;
  if (!Ur(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Ur(e.marks)) && (e.selection === null || Pt.isRange(e.selection)) && ft.isNodeList(e.children) && Jl.isOperationList(e.operations);
  return X1.set(e, n), n;
}, Cn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return hG(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function Y1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function J1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Y1(Object(n), !0).forEach(function(r) {
      sl(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Y1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var An = {
  compare(e, t) {
    var n = Se.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return An.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return An.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Se.equals(e.path, t.path);
  },
  isPoint(e) {
    return Ur(e) && typeof e.offset == "number" && Se.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Ww(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Se.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Se.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Se.equals(t.path, i) && (r.offset += t.position), r.path = Se.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Se.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Se.equals(t.path, i) || Se.isAncestor(t.path, i))
            return null;
          r.path = Se.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Se.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Se.transform(i, t, J1(J1({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Se.transform(i, t, n);
          break;
        }
      }
    });
  }
}, Q1 = void 0, go = {
  setScrubber(e) {
    Q1 = e;
  },
  stringify(e) {
    return JSON.stringify(e, Q1);
  }
}, gG = ["text"], mG = ["anchor", "focus"];
function ek(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ek(Object(n), !0).forEach(function(r) {
      sl(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ek(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fr = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = qu(i, gG);
      return a;
    }
    return IN(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Ur(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => fr.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [wi({}, e)];
    for (var r of t) {
      var o = qu(r, mG), [i, a] = Pt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, h = void 0;
        if (c < l) {
          var E = c - g;
          h = wi(wi({}, f), {}, {
            text: f.text.slice(E)
          }), f = wi(wi({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = wi(wi({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = wi(wi({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), h && s.push(h);
      }
      n = s;
    }
    return n;
  }
}, vG = (e) => e.selection ? e.selection : e.children.length > 0 ? Cn.end(e, []) : [0], Dn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Dn || (Dn = {}));
Dn.L, Dn.L | Dn.V | Dn.LV | Dn.LVT, Dn.LV | Dn.V, Dn.V | Dn.T, Dn.LVT | Dn.T, Dn.T, Dn.Any, Dn.Extend | Dn.ZWJ, Dn.Any, Dn.SpacingMark, Dn.Prepend, Dn.Any, Dn.ZWJ, Dn.ExtPict, Dn.RI, Dn.RI;
var yG = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Cn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = vG(e)
      } = n;
      if (Se.isPath(o) && (o = Cn.range(e, o)), Pt.isRange(o))
        if (Pt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Pt.end(o);
          if (!r && Cn.void(e, {
            at: i
          }))
            return;
          var a = Pt.start(o), s = Cn.pointRef(e, a), l = Cn.pointRef(e, i);
          cf.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, cf.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Cn.void(e, {
        at: o
      }) || Cn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function tk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tk(Object(n), !0).forEach(function(r) {
      sl(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cf = vp(vp(vp(vp({}, sG), aG), lG), yG), NN = {}, Vw = {}, Hw = {}, Aa = {}, Gw = {}, qw = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(qw);
var At = {}, Ps = _n && _n.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), uu = _n && _n.__assign || function() {
  return uu = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, uu.apply(this, arguments);
};
Object.defineProperty(At, "__esModule", { value: !0 });
At.cloneNode = At.hasChildren = At.isDocument = At.isDirective = At.isComment = At.isText = At.isCDATA = At.isTag = At.Element = At.Document = At.CDATA = At.NodeWithChildren = At.ProcessingInstruction = At.Comment = At.Text = At.DataNode = At.Node = void 0;
var co = qw, Zw = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Kw(this, t);
    }, e;
  }()
);
At.Node = Zw;
var cg = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zw)
);
At.DataNode = cg;
var FN = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = co.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cg)
);
At.Text = FN;
var zN = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = co.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cg)
);
At.Comment = zN;
var UN = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = co.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cg)
);
At.ProcessingInstruction = UN;
var pg = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zw)
);
At.NodeWithChildren = pg;
var $N = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = co.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(pg)
);
At.CDATA = $N;
var WN = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = co.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(pg)
);
At.Document = WN;
var VN = (
  /** @class */
  function(e) {
    Ps(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? co.ElementType.Script : n === "style" ? co.ElementType.Style : co.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(pg)
);
At.Element = VN;
function HN(e) {
  return (0, co.isTag)(e);
}
At.isTag = HN;
function GN(e) {
  return e.type === co.ElementType.CDATA;
}
At.isCDATA = GN;
function qN(e) {
  return e.type === co.ElementType.Text;
}
At.isText = qN;
function ZN(e) {
  return e.type === co.ElementType.Comment;
}
At.isComment = ZN;
function KN(e) {
  return e.type === co.ElementType.Directive;
}
At.isDirective = KN;
function XN(e) {
  return e.type === co.ElementType.Root;
}
At.isDocument = XN;
function bG(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
At.hasChildren = bG;
function Kw(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (qN(e))
    n = new FN(e.data);
  else if (ZN(e))
    n = new zN(e.data);
  else if (HN(e)) {
    var r = t ? Sm(e.children) : [], o = new VN(e.name, uu({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = uu({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = uu({}, e["x-attribsPrefix"])), n = o;
  } else if (GN(e)) {
    var r = t ? Sm(e.children) : [], i = new $N(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (XN(e)) {
    var r = t ? Sm(e.children) : [], a = new WN(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (KN(e)) {
    var s = new UN(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
At.cloneNode = Kw;
function Sm(e) {
  for (var t = e.map(function(r) {
    return Kw(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = _n && _n.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = _n && _n.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = qw, o = At;
  n(At, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(Gw);
var YN = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(YN);
Object.defineProperty(Aa, "__esModule", { value: !0 });
Aa.formatAttributes = JN;
Aa.escapeSpecialCharacters = xG;
Aa.revertEscapedCharacters = QN;
Aa.formatDOM = eF;
var yp = Gw, Zu = YN;
function wG(e) {
  return Zu.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function JN(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function CG(e) {
  e = e.toLowerCase();
  var t = wG(e);
  return t || e;
}
function xG(e) {
  return e.replace(Zu.CARRIAGE_RETURN_REGEX, Zu.CARRIAGE_RETURN_PLACEHOLDER);
}
function QN(e) {
  return e.replace(Zu.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Zu.CARRIAGE_RETURN);
}
function eF(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = CG(s.nodeName);
        o = new yp.Element(l, JN(s.attributes)), o.children = eF(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new yp.Text(QN(s.nodeValue));
        break;
      case 8:
        o = new yp.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new yp.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(Hw, "__esModule", { value: !0 });
Hw.default = LG;
var EG = Aa, nk = "html", rk = "head", bp = "body", OG = /<([a-zA-Z]+[0-9]?)/, ok = /<head[^]*>/i, ik = /<body[^]*>/i, pf = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Lb = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, sk = typeof window == "object" && window.DOMParser;
if (typeof sk == "function") {
  var kG = new sk(), _G = "text/html";
  Lb = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), kG.parseFromString(e, _G);
  }, pf = Lb;
}
if (typeof document == "object" && document.implementation) {
  var wp = document.implementation.createHTMLDocument();
  pf = function(e, t) {
    if (t) {
      var n = wp.documentElement.querySelector(t);
      return n && (n.innerHTML = e), wp;
    }
    return wp.documentElement.innerHTML = e, wp;
  };
}
var Cp = typeof document == "object" && document.createElement("template"), Pb;
Cp && Cp.content && (Pb = function(e) {
  return Cp.innerHTML = e, Cp.content.childNodes;
});
function LG(e) {
  var t, n;
  e = (0, EG.escapeSpecialCharacters)(e);
  var r = e.match(OG), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case nk: {
      var i = Lb(e);
      if (!ok.test(e)) {
        var a = i.querySelector(rk);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!ik.test(e)) {
        var a = i.querySelector(bp);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(nk);
    }
    case rk:
    case bp: {
      var s = pf(e).querySelectorAll(o);
      return ik.test(e) && ok.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (Pb)
        return Pb(e);
      var a = pf(e, bp).querySelector(bp);
      return a.childNodes;
    }
  }
}
var PG = _n && _n.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Vw, "__esModule", { value: !0 });
Vw.default = TG;
var SG = PG(Hw), DG = Aa, MG = /<(![a-zA-Z\s]+)>/;
function TG(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(MG), n = t ? t[1] : void 0;
  return (0, DG.formatDOM)((0, SG.default)(e), null, n);
}
var dg = {}, Wo = {}, fg = {}, jG = 0;
fg.SAME = jG;
var AG = 1;
fg.CAMELCASE = AG;
fg.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const tF = 0, Ss = 1, hg = 2, gg = 3, Xw = 4, nF = 5, rF = 6;
function BG(e) {
  return Rr.hasOwnProperty(e) ? Rr[e] : null;
}
function Yr(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === hg || t === gg || t === Xw, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Rr = {}, RG = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
RG.forEach((e) => {
  Rr[e] = new Yr(
    e,
    tF,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Rr[e] = new Yr(
    e,
    Ss,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Rr[e] = new Yr(
    e,
    hg,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Rr[e] = new Yr(
    e,
    hg,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Rr[e] = new Yr(
    e,
    gg,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Rr[e] = new Yr(
    e,
    gg,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Rr[e] = new Yr(
    e,
    Xw,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Rr[e] = new Yr(
    e,
    rF,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Rr[e] = new Yr(
    e,
    nF,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Yw = /[\-\:]([a-z])/g, Jw = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Yw, Jw);
  Rr[t] = new Yr(
    t,
    Ss,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Yw, Jw);
  Rr[t] = new Yr(
    t,
    Ss,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Yw, Jw);
  Rr[t] = new Yr(
    t,
    Ss,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Rr[e] = new Yr(
    e,
    Ss,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const IG = "xlinkHref";
Rr[IG] = new Yr(
  "xlinkHref",
  Ss,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Rr[e] = new Yr(
    e,
    Ss,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: NG,
  SAME: FG,
  possibleStandardNames: ak
} = fg, zG = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", UG = zG + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", $G = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + UG + "]*$")
), WG = Object.keys(
  ak
).reduce((e, t) => {
  const n = ak[t];
  return n === FG ? e[t] = t : n === NG ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Wo.BOOLEAN = gg;
Wo.BOOLEANISH_STRING = hg;
Wo.NUMERIC = nF;
Wo.OVERLOADED_BOOLEAN = Xw;
Wo.POSITIVE_NUMERIC = rF;
Wo.RESERVED = tF;
Wo.STRING = Ss;
Wo.getPropertyInfo = BG;
Wo.isCustomAttribute = $G;
Wo.possibleStandardNames = WG;
var Qw = {}, eC = {}, lk = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, VG = /\n/g, HG = /^\s*/, GG = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, qG = /^:\s*/, ZG = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, KG = /^[;\s]*/, XG = /^\s+|\s+$/g, YG = `
`, uk = "/", ck = "*", ra = "", JG = "comment", QG = "declaration", eq = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(VG);
    m && (n += m.length);
    var h = f.lastIndexOf(YG);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var h = m[0];
      return o(h), e = e.slice(h.length), m;
    }
  }
  function u() {
    l(HG);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(uk != e.charAt(0) || ck != e.charAt(1))) {
      for (var m = 2; ra != e.charAt(m) && (ck != e.charAt(m) || uk != e.charAt(m + 1)); )
        ++m;
      if (m += 2, ra === e.charAt(m - 1))
        return s("End of comment missing");
      var h = e.slice(2, m - 2);
      return r += 2, o(h), e = e.slice(m), r += 2, f({
        type: JG,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), m = l(GG);
    if (m) {
      if (p(), !l(qG)) return s("property missing ':'");
      var h = l(ZG), E = f({
        type: QG,
        property: pk(m[0].replace(lk, ra)),
        value: h ? pk(h[0].replace(lk, ra)) : ra
      });
      return l(KG), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function pk(e) {
  return e ? e.replace(XG, ra) : ra;
}
var tq = _n && _n.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(eC, "__esModule", { value: !0 });
eC.default = rq;
var nq = tq(eq);
function rq(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, nq.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var mg = {};
Object.defineProperty(mg, "__esModule", { value: !0 });
mg.camelCase = void 0;
var oq = /^--[a-zA-Z0-9_-]+$/, iq = /-([a-z])/g, sq = /^[^-]+$/, aq = /^-(webkit|moz|ms|o|khtml)-/, lq = /^-(ms)-/, uq = function(e) {
  return !e || sq.test(e) || oq.test(e);
}, cq = function(e, t) {
  return t.toUpperCase();
}, dk = function(e, t) {
  return "".concat(t, "-");
}, pq = function(e, t) {
  return t === void 0 && (t = {}), uq(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(lq, dk) : e = e.replace(aq, dk), e.replace(iq, cq));
};
mg.camelCase = pq;
var dq = _n && _n.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, fq = dq(eC), hq = mg;
function Sb(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, fq.default)(e, function(r, o) {
    r && o && (n[(0, hq.camelCase)(r, t)] = o);
  }), n;
}
Sb.default = Sb;
var gq = Sb;
(function(e) {
  var t = _n && _n.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Oe, r = t(gq), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Qw);
Object.defineProperty(dg, "__esModule", { value: !0 });
dg.default = bq;
var Ql = Wo, fk = Qw, mq = ["checked", "value"], vq = ["input", "select", "textarea"], yq = {
  reset: !0,
  submit: !0
};
function bq(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && yq[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Ql.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = hk(a);
    if (s) {
      var l = (0, Ql.getPropertyInfo)(s);
      switch (mq.includes(s) && vq.includes(t) && !r && (s = hk("default" + a)), n[s] = i, l && l.type) {
        case Ql.BOOLEAN:
          n[s] = !0;
          break;
        case Ql.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    fk.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, fk.setStyleProp)(e.style, n), n;
}
function hk(e) {
  return Ql.possibleStandardNames[e];
}
var tC = {}, wq = _n && _n.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(tC, "__esModule", { value: !0 });
tC.default = oF;
var Dm = Oe, Cq = wq(dg), cu = Qw, xq = {
  cloneElement: Dm.cloneElement,
  createElement: Dm.createElement,
  isValidElement: Dm.isValidElement
};
function oF(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || cu.returnFirstArg, i = t.library || xq, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, cu.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    Eq(f) ? ((0, cu.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, Cq.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (h = oF(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Eq(e) {
  return cu.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, cu.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = _n && _n.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(Vw);
  e.htmlToDOM = n.default;
  var r = t(dg);
  e.attributesToProps = r.default;
  var o = t(tC);
  e.domToReact = o.default;
  var i = Gw;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(NN);
const Oq = /* @__PURE__ */ W7(NN);
Oq.default;
qe({});
function kq(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const _q = {
  CNPJ: "99.999.999/9999-99"
};
kq(_q.CNPJ).length;
Ir((e, t) => /* @__PURE__ */ Mr.jsx("input", { ref: t, ...e }));
function iF(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const sF = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function Lq(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function Pq(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const Sq = iF(sF.NINE).length, Dq = Ir((e, t) => /* @__PURE__ */ Mr.jsx("input", { ref: t, ...e }));
Ir(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    v(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = iF(g.target.value);
      const m = Pq(f);
      f.length > Sq || (f = Lq(f, sF[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Mr.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Mr.jsx(
      el,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: Dq,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
qe({});
var Ii = {};
Object.defineProperty(Ii, "__esModule", {
  value: !0
});
var Mq = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Mm = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, aF = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Mq ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, nC = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var xp = 1; xp < 20; xp++)
  nC["f" + xp] = 111 + xp;
function vg(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return lF(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return uF(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function Tq(e, t) {
  return vg(e, t);
}
function jq(e, t) {
  return vg(e, { byKey: !0 }, t);
}
function lF(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in Mm)
    r[Mm[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = rC(d), m = Mm[f];
      if (d.length > 1 && !m && !aF[d] && !nC[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = cF(d)), m && (r[m] = g ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function uF(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function cF(e) {
  e = rC(e);
  var t = nC[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function rC(e) {
  return e = e.toLowerCase(), e = aF[e] || e, e;
}
Ii.default = vg;
var Tm = Ii.isHotkey = vg;
Ii.isCodeHotkey = Tq;
Ii.isKeyHotkey = jq;
Ii.parseHotkey = lF;
Ii.compareHotkey = uF;
Ii.toKeyCode = cF;
Ii.toKeyName = rC;
var Aq = typeof _n == "object" && _n && _n.Object === Object && _n, Bq = Aq, Rq = Bq, Iq = typeof self == "object" && self && self.Object === Object && self, Nq = Rq || Iq || Function("return this")(), Fq = Nq, zq = Fq, Uq = zq.Symbol, pF = Uq, gk = pF;
gk && gk.toStringTag;
var mk = pF;
mk && mk.toStringTag;
var vk;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(vk || (vk = {}));
var oC = function(e) {
  return Object.freeze(e);
}, $q = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, oC(this);
  }
  return e;
}(), Wq = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, oC(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), yk = typeof window < "u" ? window : {};
/msie|trident/i.test(yk.navigator && yk.navigator.userAgent);
var jm = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new $q((n ? t : e) || 0, (n ? e : t) || 0);
};
oC({
  devicePixelContentBoxSize: jm(),
  borderBoxSize: jm(),
  contentBoxSize: jm(),
  contentRect: new Wq(0, 0, 0, 0)
});
function Ku(e) {
  "@babel/helpers - typeof";
  return Ku = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ku(e);
}
function Vq(e, t) {
  if (Ku(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ku(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Hq(e) {
  var t = Vq(e, "string");
  return Ku(t) === "symbol" ? t : String(t);
}
function pu(e, t, n) {
  return t = Hq(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Gq = /* @__PURE__ */ qe(null), Am, Bm;
parseInt(Oe.version.split(".")[0], 10);
var bk = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Rm = typeof navigator < "u" && /Android/.test(navigator.userAgent), Ep = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), qq = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Am = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Am !== void 0 && Am[1] && parseInt((Bm = navigator.userAgent.match(/Version\/(\d+)/)) === null || Bm === void 0 ? void 0 : Bm[1], 10) < 17;
var Zq = /* @__PURE__ */ new WeakMap(), Kq = /* @__PURE__ */ new WeakMap(), Xq = /* @__PURE__ */ new WeakMap(), Yq = /* @__PURE__ */ new WeakMap(), Jq = /* @__PURE__ */ new WeakMap(), wk = /* @__PURE__ */ new WeakMap(), Qq = /* @__PURE__ */ new WeakMap(), Ck = /* @__PURE__ */ new WeakMap(), Op = /* @__PURE__ */ new WeakMap(), eZ = /* @__PURE__ */ new WeakMap(), tZ = /* @__PURE__ */ new WeakMap(), nZ = /* @__PURE__ */ new WeakMap(), dF = globalThis.Node, rZ = globalThis.Text, fF = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, oZ = (e) => df(e) && e.nodeType === 8, Yo = (e) => df(e) && e.nodeType === 1, df = (e) => {
  var t = fF(e);
  return !!t && e instanceof t.Node;
}, xk = (e) => {
  var t = e && e.anchorNode && fF(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, iZ = (e) => {
  var [t, n] = e;
  if (Yo(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = hF(t, o, r ? "backward" : "forward"), r = o < n; Yo(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = aZ(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, sZ = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, hF = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (oZ(o) || Yo(o) && o.childNodes.length === 0 || Yo(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, aZ = (e, t, n) => {
  var [r] = hF(e, t, n);
  return r;
}, Ek = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), gF = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Yo(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = It.getWindow(e);
  if (o.contains(r))
    return It.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : gF(e, i, n);
}, Ok = (e, t) => !!(e.compareDocumentPosition(t) & dF.DOCUMENT_POSITION_PRECEDING), lZ = (e, t) => !!(e.compareDocumentPosition(t) & dF.DOCUMENT_POSITION_FOLLOWING), uZ = 0;
class cZ {
  constructor() {
    pu(this, "id", void 0), this.id = "".concat(uZ++);
  }
}
var It = {
  androidPendingDiffs: (e) => nZ.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = tZ.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = It.toDOMNode(e, e), n = It.findDocumentOrShadowRoot(e);
    Op.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = It.findDocumentOrShadowRoot(e), r = Ek(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && cf.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = It.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = It.toSlateNode(e, t.target), a = It.findPath(e, i);
    if (Si.isElement(i) && Cn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Cn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Cn.before(e, u) : Cn.after(e, u);
      if (c) {
        var p = Cn.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = It.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = It.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = wk.get(t);
    return n || (n = new cZ(), wk.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = Kq.get(r);
      if (o == null) {
        if (Cn.isEditor(r))
          return n;
        break;
      }
      var i = Zq.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(go.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Op.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          It.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = It.toDOMNode(e, e), r = It.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = Ek(r), i = It.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || cf.select(e, Cn.start(e, [])), Op.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Xq.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = It.toDOMNode(e, e), i;
    try {
      i = Yo(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => df(t) && It.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Cn.hasPath(e, n.path) && Cn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => It.hasEditableTarget(e, t) || It.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => df(t) && It.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!eZ.get(e),
  isFocused: (e) => !!Op.get(e),
  isReadOnly: (e) => !!Ck.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (Ck.get(e)) return !1;
    var n = It.hasTarget(e, t) && It.toSlateNode(e, t);
    return Si.isElement(n) && Cn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Qq.get(e), r = Cn.isEditor(t) ? Yq.get(e) : n == null ? void 0 : n.get(It.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(go.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Cn.node(e, t.path), r = It.toDOMNode(e, n), o;
    Cn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var h, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof rZ ? E : m,
            (h = m.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(go.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Pt.isBackward(t), i = It.toDOMPoint(e, n), a = Pt.isCollapsed(t) ? i : It.toDOMPoint(e, r), s = It.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Yo(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = Yo(p) ? p : p.parentElement, h = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Yo(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Jq.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : iZ(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = It.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), E = h && g.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), S = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = It.getWindow(e), y = x.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((D) => {
            if (Rm && !r && D.hasAttribute("data-slate-zero-width") && D.textContent.length > 0 && D.textContext !== "\uFEFF") {
              D.textContent.startsWith("\uFEFF") && (D.textContent = D.textContent.slice(1));
              return;
            }
            D.parentNode.removeChild(D);
          }), c = C.textContent.length, S = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), _ = 0; _ < F.length; _++) {
          var I = F[_];
          if (It.hasDOMNode(e, I)) {
            w = I;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), S = w, c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((D) => {
          c -= D.textContent.length;
        })) : c = 1;
      } else if (E) {
        var B = (D) => D ? D.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...B($), ...B($ == null ? void 0 : $.nextElementSibling)];
          w = (V = z.find((D) => lZ(E, D))) !== null && V !== void 0 ? V : null;
        } else {
          var H, X = [...B($ == null ? void 0 : $.previousElementSibling), ...B($)];
          w = (H = X.findLast((D) => Ok(E, D))) !== null && H !== void 0 ? H : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), S = w, i === "forward" ? c = 0 : (c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((D) => {
          c -= D.textContent.length;
        })));
      }
      S && c === S.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Rm && S.getAttribute("data-slate-zero-width") === "z" && (p = S.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Ep && (d = S.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Rm && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && It.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = It.toSlateNode(e, J), {
          path: ee,
          offset: L
        } = Cn.start(e, It.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (L = s), {
          path: ee,
          offset: L
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var T = It.toSlateNode(e, u), W = It.findPath(e, T);
    return {
      path: W,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = xk(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (xk(t)) {
        if (Ep && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = g.startContainer, h = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        qq && sZ(s) || Ep ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Ep && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = It.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var S = Ok(s, u) || s === u && c < l, x = p ? w : It.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: S ? "forward" : "backward"
    });
    if (!x)
      return null;
    var y = {
      anchor: w,
      focus: x
    };
    return Pt.isExpanded(y) && Pt.isForward(y) && Yo(u) && Cn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = Cn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, pZ = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, dZ = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, fZ = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Wn = (e) => {
  var t = pZ[e], n = dZ[e], r = fZ[e], o = t && Tm(t), i = n && Tm(n), a = r && Tm(r);
  return (s) => !!(o && o(s) || bk && i && i(s) || !bk && a && a(s));
};
Wn("bold"), Wn("compose"), Wn("moveBackward"), Wn("moveForward"), Wn("deleteBackward"), Wn("deleteForward"), Wn("deleteLineBackward"), Wn("deleteLineForward"), Wn("deleteWordBackward"), Wn("deleteWordForward"), Wn("extendBackward"), Wn("extendForward"), Wn("extendLineBackward"), Wn("extendLineForward"), Wn("italic"), Wn("moveLineBackward"), Wn("moveLineForward"), Wn("moveWordBackward"), Wn("moveWordForward"), Wn("redo"), Wn("insertSoftBreak"), Wn("splitBlock"), Wn("transposeCharacter"), Wn("undo");
var hZ = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => gF(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, gZ = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class mZ extends uc {
  constructor() {
    super(...arguments), pu(this, "context", null), pu(this, "manager", null), pu(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, gZ);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = hZ(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
pu(mZ, "contextType", Gq);
qe({});
qe({});
qe({});
var hr = {}, iC = {}, cc = {}, pc = {}, mF = "Expected a function", kk = NaN, vZ = "[object Symbol]", yZ = /^\s+|\s+$/g, bZ = /^[-+]0x[0-9a-f]+$/i, wZ = /^0b[01]+$/i, CZ = /^0o[0-7]+$/i, xZ = parseInt, EZ = typeof _n == "object" && _n && _n.Object === Object && _n, OZ = typeof self == "object" && self && self.Object === Object && self, kZ = EZ || OZ || Function("return this")(), _Z = Object.prototype, LZ = _Z.toString, PZ = Math.max, SZ = Math.min, Im = function() {
  return kZ.Date.now();
};
function DZ(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(mF);
  t = _k(t) || 0, ff(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? PZ(_k(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, _ = t - P;
    return p ? SZ(_, i - F) : _;
  }
  function h(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = Im();
    if (h(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function S() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(Im());
  }
  function y() {
    var C = Im(), P = h(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = S, y.flush = x, y;
}
function MZ(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(mF);
  return ff(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), DZ(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function ff(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function TZ(e) {
  return !!e && typeof e == "object";
}
function jZ(e) {
  return typeof e == "symbol" || TZ(e) && LZ.call(e) == vZ;
}
function _k(e) {
  if (typeof e == "number")
    return e;
  if (jZ(e))
    return kk;
  if (ff(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = ff(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(yZ, "");
  var n = wZ.test(e);
  return n || CZ.test(e) ? xZ(e.slice(2), n ? 2 : 8) : bZ.test(e) ? kk : +e;
}
var AZ = MZ, dc = {};
Object.defineProperty(dc, "__esModule", {
  value: !0
});
dc.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Pd.has(t) || Pd.set(t, /* @__PURE__ */ new Set());
  var o = Pd.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
dc.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Pd.get(t).delete(n.name || t);
};
var Pd = /* @__PURE__ */ new Map();
Object.defineProperty(pc, "__esModule", {
  value: !0
});
var BZ = AZ, RZ = IZ(BZ), Lk = dc;
function IZ(e) {
  return e && e.__esModule ? e : { default: e };
}
var NZ = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, RZ.default)(e, t);
}, er = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = NZ(function(r) {
        er.scrollHandler(e);
      }, t);
      return er.scrollSpyContainers.push(e), (0, Lk.addPassiveEventListener)(e, "scroll", n), function() {
        (0, Lk.removePassiveEventListener)(e, "scroll", n), er.scrollSpyContainers.splice(er.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return er.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = er.scrollSpyContainers[er.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(er.currentPositionX(e), er.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    er.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = er.scrollSpyContainers[er.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    er.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    er.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), er.spySetState && er.spySetState.length && er.spySetState.indexOf(e) > -1 && er.spySetState.splice(er.spySetState.indexOf(e), 1), document.removeEventListener("scroll", er.scrollHandler);
  },
  update: function() {
    return er.scrollSpyContainers.forEach(function(e) {
      return er.scrollHandler(e);
    });
  }
};
pc.default = er;
var al = {}, fc = {};
Object.defineProperty(fc, "__esModule", {
  value: !0
});
var FZ = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, zZ = function() {
  return window.location.hash.replace(/^#/, "");
}, UZ = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, $Z = function(e) {
  return getComputedStyle(e).position !== "static";
}, Nm = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, WZ = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if ($Z(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Nm(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return Nm(t, s).offsetTop - Nm(e, s).offsetTop;
};
fc.default = {
  updateHash: FZ,
  getHash: zZ,
  filterElementInContainer: UZ,
  scrollOffset: WZ
};
var yg = {}, sC = {};
Object.defineProperty(sC, "__esModule", {
  value: !0
});
sC.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var aC = {};
Object.defineProperty(aC, "__esModule", {
  value: !0
});
var VZ = dc, HZ = ["mousedown", "wheel", "touchmove", "keydown"];
aC.default = {
  subscribe: function(e) {
    return typeof document < "u" && HZ.forEach(function(t) {
      return (0, VZ.addPassiveEventListener)(document, t, e);
    });
  }
};
var hc = {};
Object.defineProperty(hc, "__esModule", {
  value: !0
});
var Db = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Db.registered[e] = t;
    },
    remove: function(e) {
      Db.registered[e] = null;
    }
  }
};
hc.default = Db;
Object.defineProperty(yg, "__esModule", {
  value: !0
});
var GZ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, qZ = fc;
bg(qZ);
var ZZ = sC, Pk = bg(ZZ), KZ = aC, XZ = bg(KZ), YZ = hc, Go = bg(YZ);
function bg(e) {
  return e && e.__esModule ? e : { default: e };
}
var vF = function(e) {
  return Pk.default[e.smooth] || Pk.default.defaultEasing;
}, JZ = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, QZ = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Mb = function() {
  return QZ() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), yF = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, bF = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, wF = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, eK = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, tK = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, nK = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Go.default.registered.end && Go.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Mb.call(window, i);
    return;
  }
  Go.default.registered.end && Go.default.registered.end(o.to, o.target, o.currentPosition);
}, lC = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, gc = function(e, t, n, r) {
  t.data = t.data || yF(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (XZ.default.subscribe(o), lC(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? bF(t) : wF(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Go.default.registered.end && Go.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = JZ(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = vF(t), a = nK.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Go.default.registered.begin && Go.default.registered.begin(t.data.to, t.data.target), Mb.call(window, a);
    }, t.delay);
    return;
  }
  Go.default.registered.begin && Go.default.registered.begin(t.data.to, t.data.target), Mb.call(window, a);
}, wg = function(e) {
  return e = GZ({}, e), e.data = e.data || yF(), e.absolute = !0, e;
}, rK = function(e) {
  gc(0, wg(e));
}, oK = function(e, t) {
  gc(e, wg(t));
}, iK = function(e) {
  e = wg(e), lC(e), gc(e.horizontal ? eK(e) : tK(e), e);
}, sK = function(e, t) {
  t = wg(t), lC(t);
  var n = t.horizontal ? bF(t) : wF(t);
  gc(e + n, t);
};
yg.default = {
  animateTopScroll: gc,
  getAnimationType: vF,
  scrollToTop: rK,
  scrollToBottom: iK,
  scrollTo: oK,
  scrollMore: sK
};
Object.defineProperty(al, "__esModule", {
  value: !0
});
var aK = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, lK = fc, uK = uC(lK), cK = yg, pK = uC(cK), dK = hc, kp = uC(dK);
function uC(e) {
  return e && e.__esModule ? e : { default: e };
}
var _p = {}, Sk = void 0;
al.default = {
  unmount: function() {
    _p = {};
  },
  register: function(e, t) {
    _p[e] = t;
  },
  unregister: function(e) {
    delete _p[e];
  },
  get: function(e) {
    return _p[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return Sk = e;
  },
  getActiveLink: function() {
    return Sk;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = aK({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = uK.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      kp.default.registered.begin && kp.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, kp.default.registered.end && kp.default.registered.end(e, n);
      return;
    }
    pK.default.animateTopScroll(s, t, e, n);
  }
};
var Tb = { exports: {} }, Fm = { exports: {} }, sn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Dk;
function fK() {
  if (Dk) return sn;
  Dk = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function S(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(y) {
    return S(y) === u;
  }
  return sn.AsyncMode = l, sn.ConcurrentMode = u, sn.ContextConsumer = s, sn.ContextProvider = a, sn.Element = t, sn.ForwardRef = c, sn.Fragment = r, sn.Lazy = f, sn.Memo = g, sn.Portal = n, sn.Profiler = i, sn.StrictMode = o, sn.Suspense = p, sn.isAsyncMode = function(y) {
    return x(y) || S(y) === l;
  }, sn.isConcurrentMode = x, sn.isContextConsumer = function(y) {
    return S(y) === s;
  }, sn.isContextProvider = function(y) {
    return S(y) === a;
  }, sn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, sn.isForwardRef = function(y) {
    return S(y) === c;
  }, sn.isFragment = function(y) {
    return S(y) === r;
  }, sn.isLazy = function(y) {
    return S(y) === f;
  }, sn.isMemo = function(y) {
    return S(y) === g;
  }, sn.isPortal = function(y) {
    return S(y) === n;
  }, sn.isProfiler = function(y) {
    return S(y) === i;
  }, sn.isStrictMode = function(y) {
    return S(y) === o;
  }, sn.isSuspense = function(y) {
    return S(y) === p;
  }, sn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === g || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === h || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, sn.typeOf = S, sn;
}
var hn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Mk;
function hK() {
  return Mk || (Mk = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function S(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === g || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === h || N.$$typeof === E || N.$$typeof === w || N.$$typeof === m);
    }
    function x(N) {
      if (typeof N == "object" && N !== null) {
        var le = N.$$typeof;
        switch (le) {
          case t:
            var ye = N.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var y = l, C = u, P = s, F = a, _ = t, I = c, B = r, $ = f, V = g, z = n, H = i, X = o, J = p, te = !1;
    function ee(N) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), L(N) || x(N) === l;
    }
    function L(N) {
      return x(N) === u;
    }
    function T(N) {
      return x(N) === s;
    }
    function W(N) {
      return x(N) === a;
    }
    function D(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function G(N) {
      return x(N) === c;
    }
    function O(N) {
      return x(N) === r;
    }
    function M(N) {
      return x(N) === f;
    }
    function U(N) {
      return x(N) === g;
    }
    function j(N) {
      return x(N) === n;
    }
    function Z(N) {
      return x(N) === i;
    }
    function A(N) {
      return x(N) === o;
    }
    function Q(N) {
      return x(N) === p;
    }
    hn.AsyncMode = y, hn.ConcurrentMode = C, hn.ContextConsumer = P, hn.ContextProvider = F, hn.Element = _, hn.ForwardRef = I, hn.Fragment = B, hn.Lazy = $, hn.Memo = V, hn.Portal = z, hn.Profiler = H, hn.StrictMode = X, hn.Suspense = J, hn.isAsyncMode = ee, hn.isConcurrentMode = L, hn.isContextConsumer = T, hn.isContextProvider = W, hn.isElement = D, hn.isForwardRef = G, hn.isFragment = O, hn.isLazy = M, hn.isMemo = U, hn.isPortal = j, hn.isProfiler = Z, hn.isStrictMode = A, hn.isSuspense = Q, hn.isValidElementType = S, hn.typeOf = x;
  }()), hn;
}
var Tk;
function CF() {
  return Tk || (Tk = 1, process.env.NODE_ENV === "production" ? Fm.exports = fK() : Fm.exports = hK()), Fm.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var zm, jk;
function gK() {
  if (jk) return zm;
  jk = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return zm = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, zm;
}
var Um, Ak;
function cC() {
  if (Ak) return Um;
  Ak = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Um = e, Um;
}
var Bk, Rk;
function xF() {
  return Rk || (Rk = 1, Bk = Function.call.bind(Object.prototype.hasOwnProperty)), Bk;
}
var $m, Ik;
function mK() {
  if (Ik) return $m;
  Ik = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = cC(), n = {}, r = xF();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, $m = o, $m;
}
var Wm, Nk;
function vK() {
  if (Nk) return Wm;
  Nk = 1;
  var e = CF(), t = gK(), n = cC(), r = xF(), o = mK(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Wm = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(L) {
      var T = L && (u && L[u] || L[c]);
      if (typeof T == "function")
        return T;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: S,
      element: x(),
      elementType: y(),
      instanceOf: C,
      node: I(),
      objectOf: F,
      oneOf: P,
      oneOfType: _,
      shape: $,
      exact: V
    };
    function f(L, T) {
      return L === T ? L !== 0 || 1 / L === 1 / T : L !== L && T !== T;
    }
    function m(L, T) {
      this.message = L, this.data = T && typeof T == "object" ? T : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function h(L) {
      if (process.env.NODE_ENV !== "production")
        var T = {}, W = 0;
      function D(O, M, U, j, Z, A, Q) {
        if (j = j || d, A = A || U, Q !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + U;
            !T[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            W < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), T[le] = !0, W++);
          }
        }
        return M[U] == null ? O ? M[U] === null ? new m("The " + Z + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new m("The " + Z + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : L(M, U, j, Z, A);
      }
      var G = D.bind(null, !1);
      return G.isRequired = D.bind(null, !0), G;
    }
    function E(L) {
      function T(W, D, G, O, M, U) {
        var j = W[D], Z = X(j);
        if (Z !== L) {
          var A = J(j);
          return new m(
            "Invalid " + O + " `" + M + "` of type " + ("`" + A + "` supplied to `" + G + "`, expected ") + ("`" + L + "`."),
            { expectedType: L }
          );
        }
        return null;
      }
      return h(T);
    }
    function w() {
      return h(a);
    }
    function S(L) {
      function T(W, D, G, O, M) {
        if (typeof L != "function")
          return new m("Property `" + M + "` of component `" + G + "` has invalid PropType notation inside arrayOf.");
        var U = W[D];
        if (!Array.isArray(U)) {
          var j = X(U);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an array."));
        }
        for (var Z = 0; Z < U.length; Z++) {
          var A = L(U, Z, G, O, M + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return h(T);
    }
    function x() {
      function L(T, W, D, G, O) {
        var M = T[W];
        if (!s(M)) {
          var U = X(M);
          return new m("Invalid " + G + " `" + O + "` of type " + ("`" + U + "` supplied to `" + D + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(L);
    }
    function y() {
      function L(T, W, D, G, O) {
        var M = T[W];
        if (!e.isValidElementType(M)) {
          var U = X(M);
          return new m("Invalid " + G + " `" + O + "` of type " + ("`" + U + "` supplied to `" + D + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(L);
    }
    function C(L) {
      function T(W, D, G, O, M) {
        if (!(W[D] instanceof L)) {
          var U = L.name || d, j = ee(W[D]);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return h(T);
    }
    function P(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function T(W, D, G, O, M) {
        for (var U = W[D], j = 0; j < L.length; j++)
          if (f(U, L[j]))
            return null;
        var Z = JSON.stringify(L, function(A, Q) {
          var N = J(Q);
          return N === "symbol" ? String(Q) : Q;
        });
        return new m("Invalid " + O + " `" + M + "` of value `" + String(U) + "` " + ("supplied to `" + G + "`, expected one of " + Z + "."));
      }
      return h(T);
    }
    function F(L) {
      function T(W, D, G, O, M) {
        if (typeof L != "function")
          return new m("Property `" + M + "` of component `" + G + "` has invalid PropType notation inside objectOf.");
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an object."));
        for (var Z in U)
          if (r(U, Z)) {
            var A = L(U, Z, G, O, M + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return h(T);
    }
    function _(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var T = 0; T < L.length; T++) {
        var W = L[T];
        if (typeof W != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(W) + " at index " + T + "."
          ), a;
      }
      function D(G, O, M, U, j) {
        for (var Z = [], A = 0; A < L.length; A++) {
          var Q = L[A], N = Q(G, O, M, U, j, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && Z.push(N.data.expectedType);
        }
        var le = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + j + "` supplied to " + ("`" + M + "`" + le + "."));
      }
      return h(D);
    }
    function I() {
      function L(T, W, D, G, O) {
        return z(T[W]) ? null : new m("Invalid " + G + " `" + O + "` supplied to " + ("`" + D + "`, expected a ReactNode."));
      }
      return h(L);
    }
    function B(L, T, W, D, G) {
      return new m(
        (L || "React class") + ": " + T + " type `" + W + "." + D + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + G + "`."
      );
    }
    function $(L) {
      function T(W, D, G, O, M) {
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        for (var Z in L) {
          var A = L[Z];
          if (typeof A != "function")
            return B(G, O, M, Z, J(A));
          var Q = A(U, Z, G, O, M + "." + Z, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(T);
    }
    function V(L) {
      function T(W, D, G, O, M) {
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        var Z = t({}, W[D], L);
        for (var A in Z) {
          var Q = L[A];
          if (r(L, A) && typeof Q != "function")
            return B(G, O, M, A, J(Q));
          if (!Q)
            return new m(
              "Invalid " + O + " `" + M + "` key `" + A + "` supplied to `" + G + "`.\nBad object: " + JSON.stringify(W[D], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(L), null, "  ")
            );
          var N = Q(U, A, G, O, M + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return h(T);
    }
    function z(L) {
      switch (typeof L) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !L;
        case "object":
          if (Array.isArray(L))
            return L.every(z);
          if (L === null || s(L))
            return !0;
          var T = p(L);
          if (T) {
            var W = T.call(L), D;
            if (T !== L.entries) {
              for (; !(D = W.next()).done; )
                if (!z(D.value))
                  return !1;
            } else
              for (; !(D = W.next()).done; ) {
                var G = D.value;
                if (G && !z(G[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function H(L, T) {
      return L === "symbol" ? !0 : T ? T["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && T instanceof Symbol : !1;
    }
    function X(L) {
      var T = typeof L;
      return Array.isArray(L) ? "array" : L instanceof RegExp ? "object" : H(T, L) ? "symbol" : T;
    }
    function J(L) {
      if (typeof L > "u" || L === null)
        return "" + L;
      var T = X(L);
      if (T === "object") {
        if (L instanceof Date)
          return "date";
        if (L instanceof RegExp)
          return "regexp";
      }
      return T;
    }
    function te(L) {
      var T = J(L);
      switch (T) {
        case "array":
        case "object":
          return "an " + T;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + T;
        default:
          return T;
      }
    }
    function ee(L) {
      return !L.constructor || !L.constructor.name ? d : L.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, Wm;
}
var Vm, Fk;
function yK() {
  if (Fk) return Vm;
  Fk = 1;
  var e = cC();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Vm = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Vm;
}
if (process.env.NODE_ENV !== "production") {
  var bK = CF(), wK = !0;
  Tb.exports = vK()(bK.isElement, wK);
} else
  Tb.exports = yK()();
var Cg = Tb.exports, xg = {};
Object.defineProperty(xg, "__esModule", {
  value: !0
});
var CK = fc, Hm = xK(CK);
function xK(e) {
  return e && e.__esModule ? e : { default: e };
}
var EK = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Hm.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Hm.default.getHash() !== e && Hm.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
xg.default = EK;
Object.defineProperty(cc, "__esModule", {
  value: !0
});
var Lp = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, OK = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), kK = Oe, zk = mc(kK), _K = pc, Pp = mc(_K), LK = al, PK = mc(LK), SK = Cg, Vn = mc(SK), DK = xg, $i = mc(DK);
function mc(e) {
  return e && e.__esModule ? e : { default: e };
}
function MK(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function TK(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function jK(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Uk = {
  to: Vn.default.string.isRequired,
  containerId: Vn.default.string,
  container: Vn.default.object,
  activeClass: Vn.default.string,
  activeStyle: Vn.default.object,
  spy: Vn.default.bool,
  horizontal: Vn.default.bool,
  smooth: Vn.default.oneOfType([Vn.default.bool, Vn.default.string]),
  offset: Vn.default.number,
  delay: Vn.default.number,
  isDynamic: Vn.default.bool,
  onClick: Vn.default.func,
  duration: Vn.default.oneOfType([Vn.default.number, Vn.default.func]),
  absolute: Vn.default.bool,
  onSetActive: Vn.default.func,
  onSetInactive: Vn.default.func,
  ignoreCancelEvents: Vn.default.bool,
  hashSpy: Vn.default.bool,
  saveHashHistory: Vn.default.bool,
  spyThrottle: Vn.default.number
};
cc.default = function(e, t) {
  var n = t || PK.default, r = function(i) {
    jK(a, i);
    function a(s) {
      MK(this, a);
      var l = TK(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return OK(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Pp.default.isMounted(s)) {
            var l = Pp.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && ($i.default.isMounted() || $i.default.mount(n), $i.default.mapContainer(this.props.to, s)), Pp.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Pp.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Lp({}, this.props.style, this.props.activeStyle) : l = Lp({}, this.props.style);
        var u = Lp({}, this.props);
        for (var c in Uk)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, zk.default.createElement(e, u);
      }
    }]), a;
  }(zk.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Lp({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!($i.default.isMounted() && !$i.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, h = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            h = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - h + a, m = f + w.width;
          }
          var S = a - i.props.offset;
          d = S >= Math.floor(f) && S < Math.floor(m), g = S < Math.floor(f) || S >= Math.floor(m);
        } else {
          var x = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, y = x + F.height;
          }
          var _ = s - i.props.offset;
          d = _ >= Math.floor(x) && _ < Math.floor(y), g = _ < Math.floor(x) || _ >= Math.floor(y);
        }
        var I = n.getActiveLink();
        if (g) {
          if (c === I && n.setActiveLink(void 0), i.props.hashSpy && $i.default.getHash() === c) {
            var B = i.props.saveHashHistory, $ = B === void 0 ? !1 : B;
            $i.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (I !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && $i.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = Uk, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(iC, "__esModule", {
  value: !0
});
var AK = Oe, $k = EF(AK), BK = cc, RK = EF(BK);
function EF(e) {
  return e && e.__esModule ? e : { default: e };
}
function IK(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Wk(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function NK(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var FK = function(e) {
  NK(t, e);
  function t() {
    var n, r, o, i;
    IK(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = Wk(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return $k.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), Wk(o, i);
  }
  return t;
}($k.default.Component);
iC.default = (0, RK.default)(FK);
var pC = {};
Object.defineProperty(pC, "__esModule", {
  value: !0
});
var zK = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), UK = Oe, Vk = OF(UK), $K = cc, WK = OF($K);
function OF(e) {
  return e && e.__esModule ? e : { default: e };
}
function VK(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function HK(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function GK(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var qK = function(e) {
  GK(t, e);
  function t() {
    return VK(this, t), HK(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return zK(t, [{
    key: "render",
    value: function() {
      return Vk.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(Vk.default.Component);
pC.default = (0, WK.default)(qK);
var dC = {}, Eg = {};
Object.defineProperty(Eg, "__esModule", {
  value: !0
});
var ZK = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, KK = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), XK = Oe, Hk = Og(XK), YK = tl;
Og(YK);
var JK = al, Gk = Og(JK), QK = Cg, qk = Og(QK);
function Og(e) {
  return e && e.__esModule ? e : { default: e };
}
function eX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function tX(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function nX(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Eg.default = function(e) {
  var t = function(n) {
    nX(r, n);
    function r(o) {
      eX(this, r);
      var i = tX(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return KK(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        Gk.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        Gk.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return Hk.default.createElement(e, ZK({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(Hk.default.Component);
  return t.propTypes = {
    name: qk.default.string,
    id: qk.default.string
  }, t;
};
Object.defineProperty(dC, "__esModule", {
  value: !0
});
var Zk = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, rX = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), oX = Oe, Kk = fC(oX), iX = Eg, sX = fC(iX), aX = Cg, Xk = fC(aX);
function fC(e) {
  return e && e.__esModule ? e : { default: e };
}
function lX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function uX(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function cX(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var kF = function(e) {
  cX(t, e);
  function t() {
    return lX(this, t), uX(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return rX(t, [{
    key: "render",
    value: function() {
      var n = this, r = Zk({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, Kk.default.createElement(
        "div",
        Zk({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(Kk.default.Component);
kF.propTypes = {
  name: Xk.default.string,
  id: Xk.default.string
};
dC.default = (0, sX.default)(kF);
var Gm = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Yk = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function Jk(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Qk(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function e_(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Sp = Oe, Rs = pc, qm = al, ir = Cg, Wi = xg, t_ = {
  to: ir.string.isRequired,
  containerId: ir.string,
  container: ir.object,
  activeClass: ir.string,
  spy: ir.bool,
  smooth: ir.oneOfType([ir.bool, ir.string]),
  offset: ir.number,
  delay: ir.number,
  isDynamic: ir.bool,
  onClick: ir.func,
  duration: ir.oneOfType([ir.number, ir.func]),
  absolute: ir.bool,
  onSetActive: ir.func,
  onSetInactive: ir.func,
  ignoreCancelEvents: ir.bool,
  hashSpy: ir.bool,
  spyThrottle: ir.number
}, pX = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || qm, r = function(i) {
      e_(a, i);
      function a(s) {
        Jk(this, a);
        var l = Qk(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return Yk(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Rs.isMounted(s) || Rs.mount(s, this.props.spyThrottle), this.props.hashSpy && (Wi.isMounted() || Wi.mount(n), Wi.mapContainer(this.props.to, s)), this.props.spy && Rs.addStateHandler(this.stateHandler), Rs.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Rs.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = Gm({}, this.props);
          for (var u in t_)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Sp.createElement(e, l);
        }
      }]), a;
    }(Sp.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, Gm({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Wi.isMounted() && !Wi.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, h = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Wi.getHash() === l && Wi.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Rs.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Wi.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Rs.updateStates();
        }
      };
    };
    return r.propTypes = t_, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      e_(r, n);
      function r(o) {
        Jk(this, r);
        var i = Qk(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return Yk(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          qm.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          qm.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Sp.createElement(e, Gm({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Sp.Component);
    return t.propTypes = {
      name: ir.string,
      id: ir.string
    }, t;
  }
}, dX = pX;
Object.defineProperty(hr, "__esModule", {
  value: !0
});
hr.Helpers = hr.ScrollElement = hr.ScrollLink = hr.animateScroll = hr.scrollSpy = hr.Events = hr.scroller = hr.Element = hr.Button = hr.Link = void 0;
var fX = iC, _F = ii(fX), hX = pC, LF = ii(hX), gX = dC, PF = ii(gX), mX = al, SF = ii(mX), vX = hc, DF = ii(vX), yX = pc, MF = ii(yX), bX = yg, TF = ii(bX), wX = cc, jF = ii(wX), CX = Eg, AF = ii(CX), xX = dX, BF = ii(xX);
function ii(e) {
  return e && e.__esModule ? e : { default: e };
}
hr.Link = _F.default;
hr.Button = LF.default;
hr.Element = PF.default;
hr.scroller = SF.default;
hr.Events = DF.default;
hr.scrollSpy = MF.default;
hr.animateScroll = TF.default;
hr.ScrollLink = jF.default;
hr.ScrollElement = AF.default;
hr.Helpers = BF.default;
hr.default = { Link: _F.default, Button: LF.default, Element: PF.default, scroller: SF.default, Events: DF.default, scrollSpy: MF.default, animateScroll: TF.default, ScrollLink: jF.default, ScrollElement: AF.default, Helpers: BF.default };
qe({});
qe({});
qe({});
function Xu(e) {
  "@babel/helpers - typeof";
  return Xu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Xu(e);
}
function EX(e, t) {
  if (Xu(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Xu(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function OX(e) {
  var t = EX(e, "string");
  return Xu(t) == "symbol" ? t : t + "";
}
function he(e, t, n) {
  return (t = OX(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function RF(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Zm, n_;
function kX() {
  if (n_) return Zm;
  n_ = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Zm = t, Zm;
}
var _X = kX(), xr = /* @__PURE__ */ RF(_X), gt = qe(null);
function LX() {
  xr(!!Ee, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Ee(gt);
  return xr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function PX(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function SX(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function DX(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return SX(e, i), o;
}
function MX(e, t, n) {
  var r = PX(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function TX(e) {
  google.maps.event.removeListener(e);
}
function Ht() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(TX);
}
function Ut(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = MX(o, i, n);
  return DX(t, r, o, i), a;
}
function jX(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: h,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: S,
    onUnmount: x
  } = e, [y, C] = k(null), P = Qe(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null), [A, Q] = k(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), v(() => {
    y && l && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && m && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && g && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(y, "mouseout", g)));
  }, [g]), v(() => {
    y && f && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && h && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && E && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), v(() => {
    y && s && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(y, "click", s)));
  }, [s]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), v(() => {
    var N = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(N), N !== null && S && S(N), () => {
      N !== null && x && x(N);
    };
  }, []), Mr.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: Mr.jsx(gt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
ke(jX);
function r_(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function IF(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        r_(i, r, o, a, s, "next", l);
      }
      function s(l) {
        r_(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function NF(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return xr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var oa = typeof document < "u";
function FF(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return oa ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function o_(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function zF() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return o_(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return o_(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Pl = !1;
function UF() {
  return Mr.jsx("div", {
    children: "Loading..."
  });
}
var jb = {
  id: "script-loader",
  version: "weekly"
};
class AX extends be {
  constructor() {
    super(...arguments), he(this, "check", null), he(this, "state", {
      loaded: !1
    }), he(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), he(this, "isCleaningUp", /* @__PURE__ */ IF(function* () {
      function t(n) {
        if (!Pl)
          n();
        else if (oa)
          var r = window.setInterval(function() {
            Pl || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), he(this, "cleanup", () => {
      Pl = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), he(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && zF(), xr(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: NF(this.props)
      };
      FF(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), he(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (oa) {
      if (window.google && window.google.maps && !Pl) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), oa && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (oa) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Pl = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Mr.jsxs(Mr.Fragment, {
      children: [Mr.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Mr.jsx(UF, {})]
    });
  }
}
he(AX, "defaultProps", jb);
function BX(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function hC(e, t) {
  if (e == null) return {};
  var n, r, o = BX(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var i_;
function RX(e) {
  var {
    id: t = jb.id,
    version: n = jb.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = Qe(!1), [f, m] = k(!1), [h, E] = k(void 0);
  v(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), v(function() {
    oa && u && zF();
  }, [u]), v(function() {
    f && xr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = NF({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!oa)
      return;
    function x() {
      g.current && (m(!0), i_ = w);
    }
    if (window.google && window.google.maps && i_ === w) {
      x();
      return;
    }
    FF({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(y) {
      g.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var S = Qe(void 0);
  return v(function() {
    S.current && l !== S.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), S.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var IX = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], NX = Mr.jsx(UF, {});
function FX(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = hC(e, IX), {
    isLoaded: s,
    loadError: l
  } = RX(a);
  return v(function() {
    s && typeof n == "function" && n();
  }, [s, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || NX;
}
ke(FX);
var s_;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(s_ || (s_ = {}));
function a_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var l_ = {}, u_ = {
  options(e, t) {
    e.setOptions(t);
  }
};
function zX(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = Ee(gt), [i, a] = k(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var s = new google.maps.TrafficLayer(hf(hf({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ke(zX);
class UX extends be {
  constructor() {
    super(...arguments), he(this, "state", {
      trafficLayer: null
    }), he(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), he(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(hf(hf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: u_,
      eventMap: l_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: u_,
      eventMap: l_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Ht(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(UX, "contextType", gt);
function $X(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Ee(gt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ke($X);
class WX extends be {
  constructor() {
    super(...arguments), he(this, "state", {
      bicyclingLayer: null
    }), he(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(WX, "contextType", gt);
function VX(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Ee(gt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ke(VX);
class HX extends be {
  constructor() {
    super(...arguments), he(this, "state", {
      transitLayer: null
    }), he(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(HX, "contextType", gt);
function c_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? c_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var p_ = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, d_ = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function GX(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = Ee(gt), [d, g] = k(null), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), v(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), v(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    xr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var I = new google.maps.drawing.DrawingManager(gf(gf({}, t), {}, {
      map: p
    }));
    return n && I.setDrawingMode(n), r && m(google.maps.event.addListener(I, "circlecomplete", r)), o && E(google.maps.event.addListener(I, "markercomplete", o)), i && S(google.maps.event.addListener(I, "overlaycomplete", i)), a && y(google.maps.event.addListener(I, "polygoncomplete", a)), s && P(google.maps.event.addListener(I, "polylinecomplete", s)), l && _(google.maps.event.addListener(I, "rectanglecomplete", l)), g(I), u && u(I), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ke(GX);
class qX extends be {
  constructor(t) {
    super(t), he(this, "registeredEvents", []), he(this, "state", {
      drawingManager: null
    }), he(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), xr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(gf(gf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: d_,
      eventMap: p_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: d_,
      eventMap: p_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Ht(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
he(qX, "contextType", gt);
function f_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function za(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? f_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : f_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var h_ = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, g_ = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, mf = {};
function ZX(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: h,
    onClick: E,
    onDblClick: w,
    onDrag: S,
    onDragEnd: x,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: _,
    onRightClick: I,
    onClickableChanged: B,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: H,
    onIconChanged: X,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: L,
    onZindexChanged: T,
    onLoad: W,
    onUnmount: D
  } = e, G = Ee(gt), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, N] = k(null), [le, ye] = k(null), [oe, Be] = k(null), [Ue, $e] = k(null), [Ie, Je] = k(null), [Ze, Me] = k(null), [Ye, nt] = k(null), [De, je] = k(null), [Ke, We] = k(null), [Fe, et] = k(null), [Re, Rt] = k(null), [rt, ot] = k(null), [at, Kt] = k(null), [lt, ut] = k(null), [tt, Xe] = k(null), [Xt, Yt] = k(null), [bt, Rn] = k(null), [wt, In] = k(null), [Ct, fn] = k(null);
  v(() => {
    O !== null && O.setMap(G);
  }, [G]), v(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), v(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), v(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), v(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), v(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), v(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), v(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), v(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), v(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), v(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), v(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), v(() => {
    O && h !== void 0 && O.setZIndex(h);
  }, [O, h]), v(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), v(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), v(() => {
    O && y && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(O, "dragstart", y)));
  }, [y]), v(() => {
    O && _ && (le !== null && google.maps.event.removeListener(le), ye(google.maps.event.addListener(O, "mousedown", _)));
  }, [_]), v(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Be(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), v(() => {
    O && P && (Ue !== null && google.maps.event.removeListener(Ue), $e(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), v(() => {
    O && F && (Ie !== null && google.maps.event.removeListener(Ie), Je(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), v(() => {
    O && I && (Ze !== null && google.maps.event.removeListener(Ze), Me(google.maps.event.addListener(O, "rightclick", I)));
  }, [I]), v(() => {
    O && E && (Ye !== null && google.maps.event.removeListener(Ye), nt(google.maps.event.addListener(O, "click", E)));
  }, [E]), v(() => {
    O && S && (De !== null && google.maps.event.removeListener(De), je(google.maps.event.addListener(O, "drag", S)));
  }, [S]), v(() => {
    O && B && (Ke !== null && google.maps.event.removeListener(Ke), We(google.maps.event.addListener(O, "clickable_changed", B)));
  }, [B]), v(() => {
    O && $ && (Fe !== null && google.maps.event.removeListener(Fe), et(google.maps.event.addListener(O, "cursor_changed", $)));
  }, [$]), v(() => {
    O && V && (Re !== null && google.maps.event.removeListener(Re), Rt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), v(() => {
    O && z && (rt !== null && google.maps.event.removeListener(rt), ot(google.maps.event.addListener(O, "draggable_changed", z)));
  }, [z]), v(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), Kt(google.maps.event.addListener(O, "flat_changed", H)));
  }, [H]), v(() => {
    O && X && (lt !== null && google.maps.event.removeListener(lt), ut(google.maps.event.addListener(O, "icon_changed", X)));
  }, [X]), v(() => {
    O && J && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(O, "position_changed", J)));
  }, [J]), v(() => {
    O && te && (Xt !== null && google.maps.event.removeListener(Xt), Yt(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), v(() => {
    O && ee && (bt !== null && google.maps.event.removeListener(bt), Rn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), v(() => {
    O && L && (wt !== null && google.maps.event.removeListener(wt), In(google.maps.event.addListener(O, "visible_changed", L)));
  }, [L]), v(() => {
    O && T && (Ct !== null && google.maps.event.removeListener(Ct), fn(google.maps.event.addListener(O, "zindex_changed", T)));
  }, [T]), v(() => {
    var xt = za(za(za({}, n || mf), r ? mf : {
      map: G
    }), {}, {
      position: t
    }), re = new google.maps.Marker(xt);
    return r ? r.addMarker(re, !!o) : re.setMap(G), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof h == "number" && re.setZIndex(h), w && j(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), y && N(google.maps.event.addListener(re, "dragstart", y)), _ && ye(google.maps.event.addListener(re, "mousedown", _)), C && Be(google.maps.event.addListener(re, "mouseout", C)), P && $e(google.maps.event.addListener(re, "mouseover", P)), F && Je(google.maps.event.addListener(re, "mouseup", F)), I && Me(google.maps.event.addListener(re, "rightclick", I)), E && nt(google.maps.event.addListener(re, "click", E)), S && je(google.maps.event.addListener(re, "drag", S)), B && We(google.maps.event.addListener(re, "clickable_changed", B)), $ && et(google.maps.event.addListener(re, "cursor_changed", $)), V && Rt(google.maps.event.addListener(re, "animation_changed", V)), z && ot(google.maps.event.addListener(re, "draggable_changed", z)), H && Kt(google.maps.event.addListener(re, "flat_changed", H)), X && ut(google.maps.event.addListener(re, "icon_changed", X)), J && Xe(google.maps.event.addListener(re, "position_changed", J)), te && Yt(google.maps.event.addListener(re, "shape_changed", te)), ee && Rn(google.maps.event.addListener(re, "title_changed", ee)), L && In(google.maps.event.addListener(re, "visible_changed", L)), T && fn(google.maps.event.addListener(re, "zindex_changed", T)), M(re), W && W(re), () => {
      U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), Q !== null && google.maps.event.removeListener(Q), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), Ie !== null && google.maps.event.removeListener(Ie), Ze !== null && google.maps.event.removeListener(Ze), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Fe !== null && google.maps.event.removeListener(Fe), Re !== null && google.maps.event.removeListener(Re), rt !== null && google.maps.event.removeListener(rt), at !== null && google.maps.event.removeListener(at), lt !== null && google.maps.event.removeListener(lt), tt !== null && google.maps.event.removeListener(tt), bt !== null && google.maps.event.removeListener(bt), wt !== null && google.maps.event.removeListener(wt), Ct !== null && google.maps.event.removeListener(Ct), D && D(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var wr = Bn(() => i ? it.map(i, (xt) => {
    if (!ti(xt))
      return xt;
    var re = xt;
    return ni(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return Mr.jsx(Mr.Fragment, {
    children: wr
  }) || null;
}
ke(ZX);
class KX extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return IF(function* () {
      var n = za(za(za({}, t.props.options || mf), t.props.clusterer ? mf : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Ut({
        updaterMap: g_,
        eventMap: h_,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: g_,
      eventMap: h_,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Ht(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? it.map(this.props.children, (n) => {
      if (!ti(n))
        return n;
      var r = n;
      return ni(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
he(KX, "contextType", gt);
var XX = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), YX = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new XX(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function JX(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var QX = 2e3, eY = 500, tY = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", nY = "png", rY = [53, 56, 66, 78, 90], oY = "cluster", $F = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || tY, this.imageExtension = r.imageExtension || nY, this.imageSizes = r.imageSizes || rY, this.calculator = r.calculator || JX, this.batchSize = r.batchSize || QX, this.batchSizeIE = r.batchSizeIE || eY, this.clusterClass = r.clusterClass || oY, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new YX(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function m_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iY(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Mo = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Qt = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, sY = {};
function aY(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: h,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: S,
    onClusteringEnd: x,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [_, I] = k(null), B = Ee(gt), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null);
  return v(() => {
    _ && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(_, Mo.onMouseOut, C)));
  }, [C]), v(() => {
    _ && y && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(_, Mo.onMouseOver, y)));
  }, [y]), v(() => {
    _ && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(_, Mo.onClick, w)));
  }, [w]), v(() => {
    _ && S && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(_, Mo.onClusteringBegin, S)));
  }, [S]), v(() => {
    _ && x && (X !== null && google.maps.event.removeListener(X), H(google.maps.event.addListener(_, Mo.onClusteringEnd, x)));
  }, [x]), v(() => {
    typeof r < "u" && _ !== null && Qt.averageCenter(_, r);
  }, [_, r]), v(() => {
    typeof o < "u" && _ !== null && Qt.batchSizeIE(_, o);
  }, [_, o]), v(() => {
    typeof i < "u" && _ !== null && Qt.calculator(_, i);
  }, [_, i]), v(() => {
    typeof a < "u" && _ !== null && Qt.clusterClass(_, a);
  }, [_, a]), v(() => {
    typeof s < "u" && _ !== null && Qt.enableRetinaIcons(_, s);
  }, [_, s]), v(() => {
    typeof l < "u" && _ !== null && Qt.gridSize(_, l);
  }, [_, l]), v(() => {
    typeof u < "u" && _ !== null && Qt.ignoreHidden(_, u);
  }, [_, u]), v(() => {
    typeof c < "u" && _ !== null && Qt.imageExtension(_, c);
  }, [_, c]), v(() => {
    typeof p < "u" && _ !== null && Qt.imagePath(_, p);
  }, [_, p]), v(() => {
    typeof d < "u" && _ !== null && Qt.imageSizes(_, d);
  }, [_, d]), v(() => {
    typeof g < "u" && _ !== null && Qt.maxZoom(_, g);
  }, [_, g]), v(() => {
    typeof f < "u" && _ !== null && Qt.minimumClusterSize(_, f);
  }, [_, f]), v(() => {
    typeof m < "u" && _ !== null && Qt.styles(_, m);
  }, [_, m]), v(() => {
    typeof h < "u" && _ !== null && Qt.title(_, h);
  }, [_, h]), v(() => {
    typeof E < "u" && _ !== null && Qt.zoomOnClick(_, E);
  }, [_, E]), v(() => {
    if (B) {
      var W = iY({}, n || sY), D = new $F(B, [], W);
      return r && Qt.averageCenter(D, r), o && Qt.batchSizeIE(D, o), i && Qt.calculator(D, i), a && Qt.clusterClass(D, a), s && Qt.enableRetinaIcons(D, s), l && Qt.gridSize(D, l), u && Qt.ignoreHidden(D, u), c && Qt.imageExtension(D, c), p && Qt.imagePath(D, p), d && Qt.imageSizes(D, d), g && Qt.maxZoom(D, g), f && Qt.minimumClusterSize(D, f), m && Qt.styles(D, m), h && Qt.title(D, h), E && Qt.zoomOnClick(D, E), C && ee(google.maps.event.addListener(D, Mo.onMouseOut, C)), y && T(google.maps.event.addListener(D, Mo.onMouseOver, y)), w && V(google.maps.event.addListener(D, Mo.onClick, w)), S && H(google.maps.event.addListener(D, Mo.onClusteringBegin, S)), x && J(google.maps.event.addListener(D, Mo.onClusteringEnd, x)), I(D), P && P(D), () => {
        te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), F && F(D);
      };
    }
  }, []), _ !== null && t(_) || null;
}
ke(aY);
class lY extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      markerClusterer: null
    }), he(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new $F(this.context, [], this.props.options);
      this.registeredEvents = Ut({
        updaterMap: Qt,
        eventMap: Mo,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: Qt,
      eventMap: Mo,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Ht(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
he(lY, "contextType", gt);
function v_(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var WF = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || v_(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, v_));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), h = m.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + g ? r = h.x + u - g : h.x + p + u + g > s && (r = h.x + p + u + g - s), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), uY = ["position"], cY = ["position"];
function y_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? y_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : y_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var b_ = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, w_ = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, pY = {};
function dY(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = Ee(gt), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), I = Qe(null);
  return v(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (g) {
      var B = r || pY, {
        position: $
      } = B, V = hC(B, uY), z;
      $ && !($ instanceof google.maps.LatLng) && (z = new google.maps.LatLng($.lat, $.lng));
      var H = new WF(vf(vf({}, V), z ? {
        position: z
      } : {}));
      I.current = document.createElement("div"), m(H), a && E(google.maps.event.addListener(H, "closeclick", a)), s && S(google.maps.event.addListener(H, "domready", s)), l && y(google.maps.event.addListener(H, "content_changed", l)), u && P(google.maps.event.addListener(H, "position_changed", u)), c && _(google.maps.event.addListener(H, "zindex_changed", c)), H.setContent(I.current), n ? H.open(g, n) : H.getPosition() ? H.open(g) : xr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(H);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), I.current ? br(it.only(t), I.current) : null;
}
ke(dY);
class fY extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", null), he(this, "state", {
      infoBox: null
    }), he(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : xr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), he(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = hC(t, cY), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new WF(vf(vf({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Ut({
      updaterMap: w_,
      eventMap: b_,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: w_,
      eventMap: b_,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Ht(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? br(it.only(this.props.children), this.containerElement) : null;
  }
}
he(fY, "contextType", gt);
var C_, x_;
function hY() {
  return x_ || (x_ = 1, C_ = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), C_;
}
var gY = hY(), E_ = /* @__PURE__ */ RF(gY), O_ = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Km = 1, Sl = 8;
class gC {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Km)
      throw new Error("Got v".concat(o, " data when expected v").concat(Km, "."));
    var i = O_[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new gC(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = O_.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Sl, t), this.coords = new this.ArrayType(this.data, Sl + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Sl + a + s + l), this.ids = new this.IndexArrayType(this.data, Sl, t), this.coords = new this.ArrayType(this.data, Sl + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Km << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Ab(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var h = d + p >> 1, E = a[2 * h], w = a[2 * h + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          k_(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], h = i[2 * f + 1];
      k_(m, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= h) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= h) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function Ab(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    VF(e, t, a, r, o, i), Ab(e, t, n, r, a - 1, 1 - i), Ab(e, t, n, a + 1, o, 1 - i);
  }
}
function VF(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      VF(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (Dl(e, t, r, n), t[2 * o + i] > g && Dl(e, t, r, o); f < m; ) {
      for (Dl(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? Dl(e, t, r, m) : (m++, Dl(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function Dl(e, t, n, r) {
  Xm(e, n, r), Xm(t, 2 * n, 2 * r), Xm(t, 2 * n + 1, 2 * r + 1);
}
function Xm(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function k_(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var mY = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, __ = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Is = 2, os = 3, Ym = 4, Qi = 5, HF = 6;
class vY {
  constructor(t) {
    this.options = Object.assign(Object.create(mY), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = __(Dp(u)), d = __(Mp(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Dp(r), Mp(a), Dp(i), Mp(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Qi] > 1 ? L_(p, f, this.clusterProps) : this.points[p[f + os]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + Ym] === t && p.push(a[g + Qi] > 1 ? L_(a, g, this.clusterProps) : this.points[a[g + os]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new gC(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Qi] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = GF(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + os]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = Dp(f), d = Mp(m);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + os] : E = this.points[n[l + os]].id, E !== void 0 && (h.id = E), a.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Is] <= n)) {
        l[p + Is] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Qi], h = m;
        for (var E of f) {
          var w = E * c;
          l[w + Is] > n && (h += l[w + Qi]);
        }
        if (h > m && h >= a) {
          var S = d * m, x = g * m, y = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var _ = F * c;
            if (!(l[_ + Is] <= n)) {
              l[_ + Is] = n;
              var I = l[_ + Qi];
              S += l[_] * I, x += l[_ + 1] * I, l[_ + Ym] = P, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, _)));
            }
          }
          l[p + Ym] = P, u.push(S / h, x / h, 1 / 0, P, -1, h), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (h > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Is] <= n)) {
                l[V + Is] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Qi] > 1) {
      var o = this.clusterProps[t[n + HF]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + os]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function L_(e, t, n) {
  return {
    type: "Feature",
    id: e[t + os],
    properties: GF(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [yY(e[t]), bY(e[t + 1])]
    }
  };
}
function GF(e, t, n) {
  var r = e[t + Qi], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + HF], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + os],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Dp(e) {
  return e / 360 + 0.5;
}
function Mp(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function yY(e) {
  return (e - 0.5) * 360;
}
function bY(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function wY(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class mo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Bb {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(mo.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => mo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (mo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
let CY = class {
  constructor(e) {
    var {
      maxZoom: t = 16
    } = e;
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(e) {
    var {
      markers: t
    } = e;
    return xY(t);
  }
};
var xY = (e) => {
  var t = e.map((n) => new Bb({
    position: mo.getPosition(n),
    markers: [n]
  }));
  return t;
};
class EY extends CY {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = wY(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new vY(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!E_(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = mo.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !E_(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Bb({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Bb({
      markers: [i],
      position: mo.getPosition(i)
    });
  }
}
class OY {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class kY {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (mo.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function _Y(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class mC {
  constructor() {
    _Y(mC, google.maps.OverlayView);
  }
}
var du;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(du || (du = {}));
var LY = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class PY extends mC {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new EY(o),
      renderer: a = new kY(),
      onClusterClick: s = LY
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (mo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, du.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || mo.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => mo.setMap(l, null)));
      }
      google.maps.event.trigger(this, du.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => mo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new OY(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => mo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, du.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), mo.setMap(r.marker, n);
    });
  }
}
function P_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function S_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? P_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : P_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function SY(e) {
  var t = LX(), [n, r] = k(null);
  return v(() => {
    if (t && n === null) {
      var o = new PY(S_(S_({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function DY(e) {
  var {
    children: t,
    options: n
  } = e, r = SY(n);
  return r !== null ? t(r) : null;
}
ke(DY);
var D_ = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, M_ = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function MY(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = Ee(gt), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), I = Qe(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var B = new google.maps.InfoWindow(r);
    return m(B), I.current = document.createElement("div"), a && E(google.maps.event.addListener(B, "closeclick", a)), s && S(google.maps.event.addListener(B, "domready", s)), l && y(google.maps.event.addListener(B, "content_changed", l)), u && P(google.maps.event.addListener(B, "position_changed", u)), c && _(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(I.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(g, n) : B.getPosition() ? B.open(g) : xr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(B), B.close();
    };
  }, []), I.current ? br(it.only(t), I.current) : null;
}
ke(MY);
class TY extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", null), he(this, "state", {
      infoWindow: null
    }), he(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : xr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), he(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Ut({
      updaterMap: M_,
      eventMap: D_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: M_,
      eventMap: D_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Ht(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? br(it.only(this.props.children), this.containerElement) : null;
  }
}
he(TY, "contextType", gt);
function T_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? T_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : T_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var j_ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, A_ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, jY = {};
function AY(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onLoad: E,
    onUnmount: w
  } = e, S = Ee(gt), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null);
  return v(() => {
    x !== null && x.setMap(S);
  }, [S]), v(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), v(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), v(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), v(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), v(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), v(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), v(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), v(() => {
    x && l && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), v(() => {
    x && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), v(() => {
    x && c && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), v(() => {
    x && p && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), v(() => {
    x && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), v(() => {
    x && g && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(x, "mouseup", g)));
  }, [g]), v(() => {
    x && f && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), v(() => {
    x && m && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), v(() => {
    x && h && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(x, "drag", h)));
  }, [h]), v(() => {
    var j = new google.maps.Polyline(yf(yf({}, t || jY), {}, {
      map: S
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && P(google.maps.event.addListener(j, "dblclick", a)), s && _(google.maps.event.addListener(j, "dragend", s)), l && B(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && H(google.maps.event.addListener(j, "mousemove", c)), p && J(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), g && T(google.maps.event.addListener(j, "mouseup", g)), f && D(google.maps.event.addListener(j, "rightclick", f)), m && O(google.maps.event.addListener(j, "click", m)), h && U(google.maps.event.addListener(j, "drag", h)), y(j), E && E(j), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), w && w(j), j.setMap(null);
    };
  }, []), null;
}
ke(AY);
class BY extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      polyline: null
    }), he(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(yf(yf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: A_,
      eventMap: j_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: A_,
      eventMap: j_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Ht(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
he(BY, "contextType", gt);
function B_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function R_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? B_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : B_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var I_ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, N_ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function RY(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: E,
    onLoad: w,
    onUnmount: S,
    onEdit: x
  } = e, y = Ee(gt), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), v(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), v(() => {
    C && typeof l == "function" && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof g == "function" && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), v(() => {
    C && typeof f == "function" && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof m == "function" && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(() => {
    C && typeof h == "function" && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(C, "click", h)));
  }, [h]), v(() => {
    C && typeof E == "function" && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), v(() => {
    var A = new google.maps.Polygon(R_(R_({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && _(google.maps.event.addListener(A, "dblclick", s)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && H(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), g && T(google.maps.event.addListener(A, "mouseover", g)), f && D(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), h && U(google.maps.event.addListener(A, "click", h)), E && Z(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), M !== null && google.maps.event.removeListener(M), S && S(A), A.setMap(null);
    };
  }, []), null;
}
ke(RY);
class IY extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Ut({
      updaterMap: N_,
      eventMap: I_,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: N_,
      eventMap: I_,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Ht(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
he(IY, "contextType", gt);
function F_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? F_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : F_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var z_ = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, U_ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function NY(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: S
  } = e, x = Ee(gt), [y, C] = k(null), [P, F] = k(null), [_, I] = k(null), [B, $] = k(null), [V, z] = k(null), [H, X] = k(null), [J, te] = k(null), [ee, L] = k(null), [T, W] = k(null), [D, G] = k(null), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null);
  return v(() => {
    y !== null && y.setMap(x);
  }, [x]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), v(() => {
    y && s && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), v(() => {
    y && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), L(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && g && (T !== null && google.maps.event.removeListener(T), W(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), v(() => {
    y && f && (D !== null && google.maps.event.removeListener(D), G(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(y, "click", m)));
  }, [m]), v(() => {
    y && h && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(y, "drag", h)));
  }, [h]), v(() => {
    y && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), v(() => {
    var Q = new google.maps.Rectangle(bf(bf({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), a && F(google.maps.event.addListener(Q, "dblclick", a)), s && I(google.maps.event.addListener(Q, "dragend", s)), l && $(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && X(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && L(google.maps.event.addListener(Q, "mouseover", d)), g && W(google.maps.event.addListener(Q, "mouseup", g)), f && G(google.maps.event.addListener(Q, "rightclick", f)), m && M(google.maps.event.addListener(Q, "click", m)), h && j(google.maps.event.addListener(Q, "drag", h)), E && A(google.maps.event.addListener(Q, "bounds_changed", E)), C(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), _ !== null && google.maps.event.removeListener(_), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), T !== null && google.maps.event.removeListener(T), D !== null && google.maps.event.removeListener(D), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), S && S(Q), Q.setMap(null);
    };
  }, []), null;
}
ke(NY);
class FY extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      rectangle: null
    }), he(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(bf(bf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: U_,
      eventMap: z_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: U_,
      eventMap: z_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Ht(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
he(FY, "contextType", gt);
function $_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var W_ = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, V_ = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, zY = {};
function UY(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: S,
    onLoad: x,
    onUnmount: y
  } = e, C = Ee(gt), [P, F] = k(null), [_, I] = k(null), [B, $] = k(null), [V, z] = k(null), [H, X] = k(null), [J, te] = k(null), [ee, L] = k(null), [T, W] = k(null), [D, G] = k(null), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, N] = k(null), [le, ye] = k(null);
  return v(() => {
    P !== null && P.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), v(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), v(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), v(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), v(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), v(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), v(() => {
    P && s && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), v(() => {
    P && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), v(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), v(() => {
    P && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), v(() => {
    P && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), v(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), L(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), v(() => {
    P && g && (T !== null && google.maps.event.removeListener(T), W(google.maps.event.addListener(P, "mouseover", g)));
  }, [g]), v(() => {
    P && f && (D !== null && google.maps.event.removeListener(D), G(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), v(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), v(() => {
    P && h && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(P, "click", h)));
  }, [h]), v(() => {
    P && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), v(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(P, "center_changed", w)));
  }, [h]), v(() => {
    P && S && (le !== null && google.maps.event.removeListener(le), ye(google.maps.event.addListener(P, "radius_changed", S)));
  }, [S]), v(() => {
    var oe = new google.maps.Circle(wf(wf({}, t || zY), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && I(google.maps.event.addListener(oe, "dblclick", s)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && L(google.maps.event.addListener(oe, "mouseout", d)), g && W(google.maps.event.addListener(oe, "mouseover", g)), f && G(google.maps.event.addListener(oe, "mouseup", f)), m && M(google.maps.event.addListener(oe, "rightclick", m)), h && j(google.maps.event.addListener(oe, "click", h)), E && A(google.maps.event.addListener(oe, "drag", E)), w && N(google.maps.event.addListener(oe, "center_changed", w)), S && ye(google.maps.event.addListener(oe, "radius_changed", S)), F(oe), x && x(oe), () => {
      _ !== null && google.maps.event.removeListener(_), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), T !== null && google.maps.event.removeListener(T), D !== null && google.maps.event.removeListener(D), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Q !== null && google.maps.event.removeListener(Q), le !== null && google.maps.event.removeListener(le), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
ke(UY);
class $Y extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      circle: null
    }), he(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(wf(wf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: V_,
      eventMap: W_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: V_,
      eventMap: W_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Ht(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
he($Y, "contextType", gt);
function H_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? H_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : H_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var G_ = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, q_ = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function WY(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: h
  } = e, E = Ee(gt), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null);
  return v(() => {
    w !== null && w.setMap(E);
  }, [E]), v(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && a && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), v(() => {
    w && s && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && g && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), v(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (E !== null) {
      var A = new google.maps.Data(Cf(Cf({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && _(google.maps.event.addListener(A, "mousemove", i)), a && B(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && H(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && T(google.maps.event.addListener(A, "addfeature", c)), p && D(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && Z(google.maps.event.addListener(A, "setproperty", f)), S(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), M !== null && google.maps.event.removeListener(M), j !== null && google.maps.event.removeListener(j), h && h(w), w.setMap(null));
    };
  }, []), null;
}
ke(WY);
class VY extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      data: null
    }), he(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Cf(Cf({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Ut({
        updaterMap: q_,
        eventMap: G_,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: q_,
      eventMap: G_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Ht(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
he(VY, "contextType", gt);
function Z_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function K_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Z_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Z_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var X_ = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Y_ = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class HY extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      kmlLayer: null
    }), he(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(K_(K_({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: Y_,
      eventMap: X_,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: Y_,
      eventMap: X_,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Ht(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(HY, "contextType", gt);
function qF(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function GY(e, t) {
  return new t(e.lat, e.lng);
}
function qY(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function ZY(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function KY(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function XY(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function YY(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function ZF(e, t, n, r) {
  return n !== void 0 ? XY(e, t, KY(n, google.maps.LatLngBounds, qY)) : YY(e, t, ZY(r, google.maps.LatLng, GY));
}
function JY(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function J_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function QY(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? J_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : J_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function eJ(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = QY({}, this.container ? qF(this.container, o) : {
        x: 0,
        y: 0
      }), u = ZF(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function Q_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tJ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Q_(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Q_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function eL(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function tL(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function nJ(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = Ee(gt), c = Bn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Bn(() => eJ(c, r, t, n, s), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), oi.createPortal(l, c);
}
ke(nJ);
class ll extends be {
  constructor(t) {
    super(t), he(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), he(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      xr(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), he(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), he(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = tJ({
        x: 0,
        y: 0
      }, this.containerRef.current ? qF(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = ZF(r, o, this.props.bounds, this.props.position);
      if (!JY(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), he(this, "draw", () => {
      this.onPositionElement();
    }), he(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Hr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = eL(t.position), r = eL(this.props.position), o = tL(t.bounds), i = tL(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? oi.createPortal(Mr.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: it.only(this.props.children)
    }), t) : null;
  }
}
he(ll, "FLOAT_PANE", "floatPane");
he(ll, "MAP_PANE", "mapPane");
he(ll, "MARKER_LAYER", "markerLayer");
he(ll, "OVERLAY_LAYER", "overlayLayer");
he(ll, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
he(ll, "contextType", gt);
function rJ() {
}
function nL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nL(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oL = {
  onDblClick: "dblclick",
  onClick: "click"
}, iL = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function oJ(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = Ee(gt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Bn(() => new google.maps.GroundOverlay(t, a, r), []);
  return v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), v(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ke(oJ);
class KF extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      groundOverlay: null
    }), he(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    xr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, rL(rL({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: iL,
      eventMap: oL,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: iL,
      eventMap: oL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
he(KF, "defaultProps", {
  onLoad: rJ
});
he(KF, "contextType", gt);
function sL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sL(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aL = {}, lL = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function iJ(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = Ee(gt), [a, s] = k(null);
  return v(() => {
    google.maps.visualization || xr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    xr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(xf(xf({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ke(iJ);
class sJ extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      heatmapLayer: null
    }), he(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    xr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), xr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(xf(xf({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Ut({
      updaterMap: lL,
      eventMap: aL,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: lL,
      eventMap: aL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Ht(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(sJ, "contextType", gt);
var uL = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, cL = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class aJ extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      streetViewPanorama: null
    }), he(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Ut({
      updaterMap: cL,
      eventMap: uL,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: cL,
      eventMap: uL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Ht(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
he(aJ, "contextType", gt);
class lJ extends be {
  constructor() {
    super(...arguments), he(this, "state", {
      streetViewService: null
    }), he(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
he(lJ, "contextType", gt);
var pL = {
  onDirectionsChanged: "directions_changed"
}, dL = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class uJ extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      directionsRenderer: null
    }), he(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Ut({
      updaterMap: dL,
      eventMap: pL,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: dL,
      eventMap: pL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Ht(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
he(uJ, "contextType", gt);
var fL = {
  onPlacesChanged: "places_changed"
}, hL = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class cJ extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", Hr()), he(this, "state", {
      searchBox: null
    }), he(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (xr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Ut({
          updaterMap: hL,
          eventMap: fL,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: hL,
      eventMap: fL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Ht(this.registeredEvents));
  }
  render() {
    return Mr.jsx("div", {
      ref: this.containerElement,
      children: it.only(this.props.children)
    });
  }
}
he(cJ, "contextType", gt);
var gL = {
  onPlaceChanged: "place_changed"
}, mL = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class XF extends be {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", Hr()), he(this, "state", {
      autocomplete: null
    }), he(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    xr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Ut({
        updaterMap: mL,
        eventMap: gL,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Ht(this.registeredEvents), this.registeredEvents = Ut({
      updaterMap: mL,
      eventMap: gL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Ht(this.registeredEvents);
  }
  render() {
    return Mr.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: it.only(this.props.children)
    });
  }
}
he(XF, "defaultProps", {
  className: ""
});
he(XF, "contextType", gt);
let pJ = { data: "" }, dJ = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || pJ, fJ = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, hJ = /\/\*[^]*?\*\/|  +/g, vL = /\n+/g, ps = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? ps(a, i) : i + "{" + ps(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += ps(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ps.p ? ps.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ci = {}, YF = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + YF(e[n]);
    return t;
  }
  return e;
}, gJ = (e, t, n, r, o) => {
  let i = YF(e), a = Ci[i] || (Ci[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ci[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = fJ.exec(u.replace(hJ, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(vL, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(vL, " ").trim();
      return d[0];
    })(e);
    Ci[a] = ps(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ci.g ? Ci.g : null;
  return n && (Ci.g = Ci[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ci[a], t, r, s), a;
}, mJ = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : ps(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function kg(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return gJ(n.unshift ? n.raw ? mJ(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, dJ(t.target), t.g, t.o, t.k);
}
let JF, Rb, Ib;
kg.bind({ g: 1 });
let Ti = kg.bind({ k: 1 });
function vJ(e, t, n, r) {
  ps.p = t, JF = e, Rb = n, Ib = r;
}
function Ds(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: Rb && Rb() }, s), n.o = / *go\d+/.test(l), s.className = kg.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), Ib && u[0] && Ib(s), JF(u, s);
    }
    return o;
  };
}
var yJ = (e) => typeof e == "function", bJ = (e, t) => yJ(e) ? e(t) : e, wJ = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), CJ = Ti`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, xJ = Ti`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, EJ = Ti`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, OJ = Ds("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${CJ} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${xJ} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${EJ} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, kJ = Ti`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, _J = Ds("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${kJ} 1s linear infinite;
`, LJ = Ti`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, PJ = Ti`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, SJ = Ds("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${LJ} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${PJ} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, DJ = Ds("div")`
  position: absolute;
`, MJ = Ds("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, TJ = Ti`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, jJ = Ds("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${TJ} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, AJ = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? ze.createElement(jJ, null, t) : t : n === "blank" ? null : ze.createElement(MJ, null, ze.createElement(_J, { ...r }), n !== "loading" && ze.createElement(DJ, null, n === "error" ? ze.createElement(OJ, { ...r }) : ze.createElement(SJ, { ...r })));
}, BJ = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, RJ = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, IJ = "0%{opacity:0;} 100%{opacity:1;}", NJ = "0%{opacity:1;} 100%{opacity:0;}", FJ = Ds("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, zJ = Ds("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, UJ = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = wJ() ? [IJ, NJ] : [BJ(n), RJ(n)];
  return { animation: t ? `${Ti(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ti(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
ze.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? UJ(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = ze.createElement(AJ, { toast: e }), a = ze.createElement(zJ, { ...e.ariaProps }, bJ(e.message, e));
  return ze.createElement(FJ, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : ze.createElement(ze.Fragment, null, i, a));
});
vJ(ze.createElement);
kg`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
qe({});
function $J(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const WJ = {
  CNPJ: "99.999.999/9999-99"
};
$J(WJ.CNPJ).length;
Ir((e, t) => /* @__PURE__ */ Dr.jsx("input", { ref: t, ...e }));
function QF(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const e2 = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function VJ(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function HJ(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const GJ = QF(e2.NINE).length, qJ = Ir((e, t) => /* @__PURE__ */ Dr.jsx("input", { ref: t, ...e }));
Ir(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    v(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = QF(g.target.value);
      const m = HJ(f);
      f.length > GJ || (f = VJ(f, e2[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Dr.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Dr.jsx(
      el,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: qJ,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
qe({});
var Ni = {};
Object.defineProperty(Ni, "__esModule", {
  value: !0
});
var ZJ = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Jm = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, t2 = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: ZJ ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, vC = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Tp = 1; Tp < 20; Tp++)
  vC["f" + Tp] = 111 + Tp;
function _g(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return n2(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return r2(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function KJ(e, t) {
  return _g(e, t);
}
function XJ(e, t) {
  return _g(e, { byKey: !0 }, t);
}
function n2(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in Jm)
    r[Jm[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = yC(d), m = Jm[f];
      if (d.length > 1 && !m && !t2[d] && !vC[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = o2(d)), m && (r[m] = g ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function r2(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function o2(e) {
  e = yC(e);
  var t = vC[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function yC(e) {
  return e = e.toLowerCase(), e = t2[e] || e, e;
}
Ni.default = _g;
var Qm = Ni.isHotkey = _g;
Ni.isCodeHotkey = KJ;
Ni.isKeyHotkey = XJ;
Ni.parseHotkey = n2;
Ni.compareHotkey = r2;
Ni.toKeyCode = o2;
Ni.toKeyName = yC;
var YJ = typeof kn == "object" && kn && kn.Object === Object && kn, JJ = YJ, QJ = JJ, eQ = typeof self == "object" && self && self.Object === Object && self, tQ = QJ || eQ || Function("return this")(), nQ = tQ, rQ = nQ, oQ = rQ.Symbol, i2 = oQ, yL = i2;
yL && yL.toStringTag;
var bL = i2;
bL && bL.toStringTag;
var wL;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(wL || (wL = {}));
var bC = function(e) {
  return Object.freeze(e);
}, iQ = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, bC(this);
  }
  return e;
}(), sQ = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, bC(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), CL = typeof window < "u" ? window : {};
/msie|trident/i.test(CL.navigator && CL.navigator.userAgent);
var ev = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new iQ((n ? t : e) || 0, (n ? e : t) || 0);
};
bC({
  devicePixelContentBoxSize: ev(),
  borderBoxSize: ev(),
  contentBoxSize: ev(),
  contentRect: new sQ(0, 0, 0, 0)
});
function Yu(e) {
  "@babel/helpers - typeof";
  return Yu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Yu(e);
}
function aQ(e, t) {
  if (Yu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Yu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function lQ(e) {
  var t = aQ(e, "string");
  return Yu(t) === "symbol" ? t : String(t);
}
function fu(e, t, n) {
  return t = lQ(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var uQ = /* @__PURE__ */ qe(null), tv, nv;
parseInt(Oe.version.split(".")[0], 10);
var xL = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), rv = typeof navigator < "u" && /Android/.test(navigator.userAgent), jp = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), cQ = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (tv = navigator.userAgent.match(/Version\/(\d+)/)) !== null && tv !== void 0 && tv[1] && parseInt((nv = navigator.userAgent.match(/Version\/(\d+)/)) === null || nv === void 0 ? void 0 : nv[1], 10) < 17;
var pQ = /* @__PURE__ */ new WeakMap(), dQ = /* @__PURE__ */ new WeakMap(), fQ = /* @__PURE__ */ new WeakMap(), hQ = /* @__PURE__ */ new WeakMap(), gQ = /* @__PURE__ */ new WeakMap(), EL = /* @__PURE__ */ new WeakMap(), mQ = /* @__PURE__ */ new WeakMap(), OL = /* @__PURE__ */ new WeakMap(), Ap = /* @__PURE__ */ new WeakMap(), vQ = /* @__PURE__ */ new WeakMap(), yQ = /* @__PURE__ */ new WeakMap(), bQ = /* @__PURE__ */ new WeakMap(), s2 = globalThis.Node, wQ = globalThis.Text, a2 = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, CQ = (e) => Ef(e) && e.nodeType === 8, Jo = (e) => Ef(e) && e.nodeType === 1, Ef = (e) => {
  var t = a2(e);
  return !!t && e instanceof t.Node;
}, kL = (e) => {
  var t = e && e.anchorNode && a2(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, xQ = (e) => {
  var [t, n] = e;
  if (Jo(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = l2(t, o, r ? "backward" : "forward"), r = o < n; Jo(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = OQ(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, EQ = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, l2 = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (CQ(o) || Jo(o) && o.childNodes.length === 0 || Jo(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, OQ = (e, t, n) => {
  var [r] = l2(e, t, n);
  return r;
}, _L = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), u2 = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Jo(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Nt.getWindow(e);
  if (o.contains(r))
    return Nt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : u2(e, i, n);
}, LL = (e, t) => !!(e.compareDocumentPosition(t) & s2.DOCUMENT_POSITION_PRECEDING), kQ = (e, t) => !!(e.compareDocumentPosition(t) & s2.DOCUMENT_POSITION_FOLLOWING), _Q = 0;
class LQ {
  constructor() {
    fu(this, "id", void 0), this.id = "".concat(_Q++);
  }
}
var Nt = {
  androidPendingDiffs: (e) => bQ.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = yQ.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Nt.toDOMNode(e, e), n = Nt.findDocumentOrShadowRoot(e);
    Ap.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Nt.findDocumentOrShadowRoot(e), r = _L(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && of.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Nt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Nt.toSlateNode(e, t.target), a = Nt.findPath(e, i);
    if (Pi.isElement(i) && wn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = wn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? wn.before(e, u) : wn.after(e, u);
      if (c) {
        var p = wn.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = Nt.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = Nt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = EL.get(t);
    return n || (n = new LQ(), EL.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = dQ.get(r);
      if (o == null) {
        if (wn.isEditor(r))
          return n;
        break;
      }
      var i = pQ.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(ho.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Ap.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Nt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Nt.toDOMNode(e, e), r = Nt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = _L(r), i = Nt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || of.select(e, wn.start(e, [])), Ap.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = fQ.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Nt.toDOMNode(e, e), i;
    try {
      i = Jo(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Ef(t) && Nt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return wn.hasPath(e, n.path) && wn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Nt.hasEditableTarget(e, t) || Nt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Ef(t) && Nt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!vQ.get(e),
  isFocused: (e) => !!Ap.get(e),
  isReadOnly: (e) => !!OL.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (OL.get(e)) return !1;
    var n = Nt.hasTarget(e, t) && Nt.toSlateNode(e, t);
    return Pi.isElement(n) && wn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = mQ.get(e), r = wn.isEditor(t) ? hQ.get(e) : n == null ? void 0 : n.get(Nt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(ho.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = wn.node(e, t.path), r = Nt.toDOMNode(e, n), o;
    wn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var h, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof wQ ? E : m,
            (h = m.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(ho.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Lt.isBackward(t), i = Nt.toDOMPoint(e, n), a = Lt.isCollapsed(t) ? i : Nt.toDOMPoint(e, r), s = Nt.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Jo(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = Jo(p) ? p : p.parentElement, h = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Jo(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? gQ.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : xQ(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = Nt.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), E = h && g.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), S = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = Nt.getWindow(e), y = x.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((D) => {
            if (rv && !r && D.hasAttribute("data-slate-zero-width") && D.textContent.length > 0 && D.textContext !== "\uFEFF") {
              D.textContent.startsWith("\uFEFF") && (D.textContent = D.textContent.slice(1));
              return;
            }
            D.parentNode.removeChild(D);
          }), c = C.textContent.length, S = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), _ = 0; _ < F.length; _++) {
          var I = F[_];
          if (Nt.hasDOMNode(e, I)) {
            w = I;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), S = w, c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((D) => {
          c -= D.textContent.length;
        })) : c = 1;
      } else if (E) {
        var B = (D) => D ? D.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...B($), ...B($ == null ? void 0 : $.nextElementSibling)];
          w = (V = z.find((D) => kQ(E, D))) !== null && V !== void 0 ? V : null;
        } else {
          var H, X = [...B($ == null ? void 0 : $.previousElementSibling), ...B($)];
          w = (H = X.findLast((D) => LL(E, D))) !== null && H !== void 0 ? H : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), S = w, i === "forward" ? c = 0 : (c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((D) => {
          c -= D.textContent.length;
        })));
      }
      S && c === S.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      rv && S.getAttribute("data-slate-zero-width") === "z" && (p = S.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      jp && (d = S.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (rv && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && Nt.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = Nt.toSlateNode(e, J), {
          path: ee,
          offset: L
        } = wn.start(e, Nt.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (L = s), {
          path: ee,
          offset: L
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var T = Nt.toSlateNode(e, u), W = Nt.findPath(e, T);
    return {
      path: W,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = kL(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (kL(t)) {
        if (jp && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = g.startContainer, h = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        cQ && EQ(s) || jp ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    jp && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Nt.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var S = LL(s, u) || s === u && c < l, x = p ? w : Nt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: S ? "forward" : "backward"
    });
    if (!x)
      return null;
    var y = {
      anchor: w,
      focus: x
    };
    return Lt.isExpanded(y) && Lt.isForward(y) && Jo(u) && wn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = wn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, PQ = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, SQ = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, DQ = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Hn = (e) => {
  var t = PQ[e], n = SQ[e], r = DQ[e], o = t && Qm(t), i = n && Qm(n), a = r && Qm(r);
  return (s) => !!(o && o(s) || xL && i && i(s) || !xL && a && a(s));
};
Hn("bold"), Hn("compose"), Hn("moveBackward"), Hn("moveForward"), Hn("deleteBackward"), Hn("deleteForward"), Hn("deleteLineBackward"), Hn("deleteLineForward"), Hn("deleteWordBackward"), Hn("deleteWordForward"), Hn("extendBackward"), Hn("extendForward"), Hn("extendLineBackward"), Hn("extendLineForward"), Hn("italic"), Hn("moveLineBackward"), Hn("moveLineForward"), Hn("moveWordBackward"), Hn("moveWordForward"), Hn("redo"), Hn("insertSoftBreak"), Hn("splitBlock"), Hn("transposeCharacter"), Hn("undo");
var MQ = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => u2(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, TQ = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class jQ extends uc {
  constructor() {
    super(...arguments), fu(this, "context", null), fu(this, "manager", null), fu(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, TQ);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = MQ(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
fu(jQ, "contextType", uQ);
qe({});
qe({});
qe({});
var gr = {}, wC = {}, vc = {}, yc = {}, c2 = "Expected a function", PL = NaN, AQ = "[object Symbol]", BQ = /^\s+|\s+$/g, RQ = /^[-+]0x[0-9a-f]+$/i, IQ = /^0b[01]+$/i, NQ = /^0o[0-7]+$/i, FQ = parseInt, zQ = typeof kn == "object" && kn && kn.Object === Object && kn, UQ = typeof self == "object" && self && self.Object === Object && self, $Q = zQ || UQ || Function("return this")(), WQ = Object.prototype, VQ = WQ.toString, HQ = Math.max, GQ = Math.min, ov = function() {
  return $Q.Date.now();
};
function qQ(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(c2);
  t = SL(t) || 0, Of(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? HQ(SL(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, _ = t - P;
    return p ? GQ(_, i - F) : _;
  }
  function h(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = ov();
    if (h(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function S() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(ov());
  }
  function y() {
    var C = ov(), P = h(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = S, y.flush = x, y;
}
function ZQ(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(c2);
  return Of(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), qQ(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Of(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function KQ(e) {
  return !!e && typeof e == "object";
}
function XQ(e) {
  return typeof e == "symbol" || KQ(e) && VQ.call(e) == AQ;
}
function SL(e) {
  if (typeof e == "number")
    return e;
  if (XQ(e))
    return PL;
  if (Of(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Of(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(BQ, "");
  var n = IQ.test(e);
  return n || NQ.test(e) ? FQ(e.slice(2), n ? 2 : 8) : RQ.test(e) ? PL : +e;
}
var YQ = ZQ, bc = {};
Object.defineProperty(bc, "__esModule", {
  value: !0
});
bc.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Sd.has(t) || Sd.set(t, /* @__PURE__ */ new Set());
  var o = Sd.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
bc.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Sd.get(t).delete(n.name || t);
};
var Sd = /* @__PURE__ */ new Map();
Object.defineProperty(yc, "__esModule", {
  value: !0
});
var JQ = YQ, QQ = eee(JQ), DL = bc;
function eee(e) {
  return e && e.__esModule ? e : { default: e };
}
var tee = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, QQ.default)(e, t);
}, tr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = tee(function(r) {
        tr.scrollHandler(e);
      }, t);
      return tr.scrollSpyContainers.push(e), (0, DL.addPassiveEventListener)(e, "scroll", n), function() {
        (0, DL.removePassiveEventListener)(e, "scroll", n), tr.scrollSpyContainers.splice(tr.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return tr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = tr.scrollSpyContainers[tr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(tr.currentPositionX(e), tr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    tr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = tr.scrollSpyContainers[tr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    tr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    tr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), tr.spySetState && tr.spySetState.length && tr.spySetState.indexOf(e) > -1 && tr.spySetState.splice(tr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", tr.scrollHandler);
  },
  update: function() {
    return tr.scrollSpyContainers.forEach(function(e) {
      return tr.scrollHandler(e);
    });
  }
};
yc.default = tr;
var ul = {}, wc = {};
Object.defineProperty(wc, "__esModule", {
  value: !0
});
var nee = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, ree = function() {
  return window.location.hash.replace(/^#/, "");
}, oee = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, iee = function(e) {
  return getComputedStyle(e).position !== "static";
}, iv = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, see = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (iee(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = iv(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return iv(t, s).offsetTop - iv(e, s).offsetTop;
};
wc.default = {
  updateHash: nee,
  getHash: ree,
  filterElementInContainer: oee,
  scrollOffset: see
};
var Lg = {}, CC = {};
Object.defineProperty(CC, "__esModule", {
  value: !0
});
CC.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var xC = {};
Object.defineProperty(xC, "__esModule", {
  value: !0
});
var aee = bc, lee = ["mousedown", "wheel", "touchmove", "keydown"];
xC.default = {
  subscribe: function(e) {
    return typeof document < "u" && lee.forEach(function(t) {
      return (0, aee.addPassiveEventListener)(document, t, e);
    });
  }
};
var Cc = {};
Object.defineProperty(Cc, "__esModule", {
  value: !0
});
var Nb = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Nb.registered[e] = t;
    },
    remove: function(e) {
      Nb.registered[e] = null;
    }
  }
};
Cc.default = Nb;
Object.defineProperty(Lg, "__esModule", {
  value: !0
});
var uee = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, cee = wc;
Pg(cee);
var pee = CC, ML = Pg(pee), dee = xC, fee = Pg(dee), hee = Cc, qo = Pg(hee);
function Pg(e) {
  return e && e.__esModule ? e : { default: e };
}
var p2 = function(e) {
  return ML.default[e.smooth] || ML.default.defaultEasing;
}, gee = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, mee = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Fb = function() {
  return mee() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), d2 = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, f2 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, h2 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, vee = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, yee = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, bee = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    qo.default.registered.end && qo.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Fb.call(window, i);
    return;
  }
  qo.default.registered.end && qo.default.registered.end(o.to, o.target, o.currentPosition);
}, EC = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, xc = function(e, t, n, r) {
  t.data = t.data || d2(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (fee.default.subscribe(o), EC(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? f2(t) : h2(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    qo.default.registered.end && qo.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = gee(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = p2(t), a = bee.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      qo.default.registered.begin && qo.default.registered.begin(t.data.to, t.data.target), Fb.call(window, a);
    }, t.delay);
    return;
  }
  qo.default.registered.begin && qo.default.registered.begin(t.data.to, t.data.target), Fb.call(window, a);
}, Sg = function(e) {
  return e = uee({}, e), e.data = e.data || d2(), e.absolute = !0, e;
}, wee = function(e) {
  xc(0, Sg(e));
}, Cee = function(e, t) {
  xc(e, Sg(t));
}, xee = function(e) {
  e = Sg(e), EC(e), xc(e.horizontal ? vee(e) : yee(e), e);
}, Eee = function(e, t) {
  t = Sg(t), EC(t);
  var n = t.horizontal ? f2(t) : h2(t);
  xc(e + n, t);
};
Lg.default = {
  animateTopScroll: xc,
  getAnimationType: p2,
  scrollToTop: wee,
  scrollToBottom: xee,
  scrollTo: Cee,
  scrollMore: Eee
};
Object.defineProperty(ul, "__esModule", {
  value: !0
});
var Oee = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, kee = wc, _ee = OC(kee), Lee = Lg, Pee = OC(Lee), See = Cc, Bp = OC(See);
function OC(e) {
  return e && e.__esModule ? e : { default: e };
}
var Rp = {}, TL = void 0;
ul.default = {
  unmount: function() {
    Rp = {};
  },
  register: function(e, t) {
    Rp[e] = t;
  },
  unregister: function(e) {
    delete Rp[e];
  },
  get: function(e) {
    return Rp[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return TL = e;
  },
  getActiveLink: function() {
    return TL;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Oee({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = _ee.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Bp.default.registered.begin && Bp.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Bp.default.registered.end && Bp.default.registered.end(e, n);
      return;
    }
    Pee.default.animateTopScroll(s, t, e, n);
  }
};
var zb = { exports: {} }, sv = { exports: {} }, an = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jL;
function Dee() {
  if (jL) return an;
  jL = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function S(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(y) {
    return S(y) === u;
  }
  return an.AsyncMode = l, an.ConcurrentMode = u, an.ContextConsumer = s, an.ContextProvider = a, an.Element = t, an.ForwardRef = c, an.Fragment = r, an.Lazy = f, an.Memo = g, an.Portal = n, an.Profiler = i, an.StrictMode = o, an.Suspense = p, an.isAsyncMode = function(y) {
    return x(y) || S(y) === l;
  }, an.isConcurrentMode = x, an.isContextConsumer = function(y) {
    return S(y) === s;
  }, an.isContextProvider = function(y) {
    return S(y) === a;
  }, an.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, an.isForwardRef = function(y) {
    return S(y) === c;
  }, an.isFragment = function(y) {
    return S(y) === r;
  }, an.isLazy = function(y) {
    return S(y) === f;
  }, an.isMemo = function(y) {
    return S(y) === g;
  }, an.isPortal = function(y) {
    return S(y) === n;
  }, an.isProfiler = function(y) {
    return S(y) === i;
  }, an.isStrictMode = function(y) {
    return S(y) === o;
  }, an.isSuspense = function(y) {
    return S(y) === p;
  }, an.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === g || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === h || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, an.typeOf = S, an;
}
var gn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var AL;
function Mee() {
  return AL || (AL = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function S(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === g || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === h || N.$$typeof === E || N.$$typeof === w || N.$$typeof === m);
    }
    function x(N) {
      if (typeof N == "object" && N !== null) {
        var le = N.$$typeof;
        switch (le) {
          case t:
            var ye = N.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var y = l, C = u, P = s, F = a, _ = t, I = c, B = r, $ = f, V = g, z = n, H = i, X = o, J = p, te = !1;
    function ee(N) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), L(N) || x(N) === l;
    }
    function L(N) {
      return x(N) === u;
    }
    function T(N) {
      return x(N) === s;
    }
    function W(N) {
      return x(N) === a;
    }
    function D(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function G(N) {
      return x(N) === c;
    }
    function O(N) {
      return x(N) === r;
    }
    function M(N) {
      return x(N) === f;
    }
    function U(N) {
      return x(N) === g;
    }
    function j(N) {
      return x(N) === n;
    }
    function Z(N) {
      return x(N) === i;
    }
    function A(N) {
      return x(N) === o;
    }
    function Q(N) {
      return x(N) === p;
    }
    gn.AsyncMode = y, gn.ConcurrentMode = C, gn.ContextConsumer = P, gn.ContextProvider = F, gn.Element = _, gn.ForwardRef = I, gn.Fragment = B, gn.Lazy = $, gn.Memo = V, gn.Portal = z, gn.Profiler = H, gn.StrictMode = X, gn.Suspense = J, gn.isAsyncMode = ee, gn.isConcurrentMode = L, gn.isContextConsumer = T, gn.isContextProvider = W, gn.isElement = D, gn.isForwardRef = G, gn.isFragment = O, gn.isLazy = M, gn.isMemo = U, gn.isPortal = j, gn.isProfiler = Z, gn.isStrictMode = A, gn.isSuspense = Q, gn.isValidElementType = S, gn.typeOf = x;
  }()), gn;
}
var BL;
function g2() {
  return BL || (BL = 1, process.env.NODE_ENV === "production" ? sv.exports = Dee() : sv.exports = Mee()), sv.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var av, RL;
function Tee() {
  if (RL) return av;
  RL = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return av = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, av;
}
var lv, IL;
function kC() {
  if (IL) return lv;
  IL = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return lv = e, lv;
}
var NL, FL;
function m2() {
  return FL || (FL = 1, NL = Function.call.bind(Object.prototype.hasOwnProperty)), NL;
}
var uv, zL;
function jee() {
  if (zL) return uv;
  zL = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = kC(), n = {}, r = m2();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, uv = o, uv;
}
var cv, UL;
function Aee() {
  if (UL) return cv;
  UL = 1;
  var e = g2(), t = Tee(), n = kC(), r = m2(), o = jee(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return cv = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(L) {
      var T = L && (u && L[u] || L[c]);
      if (typeof T == "function")
        return T;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: S,
      element: x(),
      elementType: y(),
      instanceOf: C,
      node: I(),
      objectOf: F,
      oneOf: P,
      oneOfType: _,
      shape: $,
      exact: V
    };
    function f(L, T) {
      return L === T ? L !== 0 || 1 / L === 1 / T : L !== L && T !== T;
    }
    function m(L, T) {
      this.message = L, this.data = T && typeof T == "object" ? T : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function h(L) {
      if (process.env.NODE_ENV !== "production")
        var T = {}, W = 0;
      function D(O, M, U, j, Z, A, Q) {
        if (j = j || d, A = A || U, Q !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + U;
            !T[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            W < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), T[le] = !0, W++);
          }
        }
        return M[U] == null ? O ? M[U] === null ? new m("The " + Z + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new m("The " + Z + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : L(M, U, j, Z, A);
      }
      var G = D.bind(null, !1);
      return G.isRequired = D.bind(null, !0), G;
    }
    function E(L) {
      function T(W, D, G, O, M, U) {
        var j = W[D], Z = X(j);
        if (Z !== L) {
          var A = J(j);
          return new m(
            "Invalid " + O + " `" + M + "` of type " + ("`" + A + "` supplied to `" + G + "`, expected ") + ("`" + L + "`."),
            { expectedType: L }
          );
        }
        return null;
      }
      return h(T);
    }
    function w() {
      return h(a);
    }
    function S(L) {
      function T(W, D, G, O, M) {
        if (typeof L != "function")
          return new m("Property `" + M + "` of component `" + G + "` has invalid PropType notation inside arrayOf.");
        var U = W[D];
        if (!Array.isArray(U)) {
          var j = X(U);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an array."));
        }
        for (var Z = 0; Z < U.length; Z++) {
          var A = L(U, Z, G, O, M + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return h(T);
    }
    function x() {
      function L(T, W, D, G, O) {
        var M = T[W];
        if (!s(M)) {
          var U = X(M);
          return new m("Invalid " + G + " `" + O + "` of type " + ("`" + U + "` supplied to `" + D + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(L);
    }
    function y() {
      function L(T, W, D, G, O) {
        var M = T[W];
        if (!e.isValidElementType(M)) {
          var U = X(M);
          return new m("Invalid " + G + " `" + O + "` of type " + ("`" + U + "` supplied to `" + D + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(L);
    }
    function C(L) {
      function T(W, D, G, O, M) {
        if (!(W[D] instanceof L)) {
          var U = L.name || d, j = ee(W[D]);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return h(T);
    }
    function P(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function T(W, D, G, O, M) {
        for (var U = W[D], j = 0; j < L.length; j++)
          if (f(U, L[j]))
            return null;
        var Z = JSON.stringify(L, function(A, Q) {
          var N = J(Q);
          return N === "symbol" ? String(Q) : Q;
        });
        return new m("Invalid " + O + " `" + M + "` of value `" + String(U) + "` " + ("supplied to `" + G + "`, expected one of " + Z + "."));
      }
      return h(T);
    }
    function F(L) {
      function T(W, D, G, O, M) {
        if (typeof L != "function")
          return new m("Property `" + M + "` of component `" + G + "` has invalid PropType notation inside objectOf.");
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an object."));
        for (var Z in U)
          if (r(U, Z)) {
            var A = L(U, Z, G, O, M + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return h(T);
    }
    function _(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var T = 0; T < L.length; T++) {
        var W = L[T];
        if (typeof W != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(W) + " at index " + T + "."
          ), a;
      }
      function D(G, O, M, U, j) {
        for (var Z = [], A = 0; A < L.length; A++) {
          var Q = L[A], N = Q(G, O, M, U, j, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && Z.push(N.data.expectedType);
        }
        var le = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + j + "` supplied to " + ("`" + M + "`" + le + "."));
      }
      return h(D);
    }
    function I() {
      function L(T, W, D, G, O) {
        return z(T[W]) ? null : new m("Invalid " + G + " `" + O + "` supplied to " + ("`" + D + "`, expected a ReactNode."));
      }
      return h(L);
    }
    function B(L, T, W, D, G) {
      return new m(
        (L || "React class") + ": " + T + " type `" + W + "." + D + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + G + "`."
      );
    }
    function $(L) {
      function T(W, D, G, O, M) {
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        for (var Z in L) {
          var A = L[Z];
          if (typeof A != "function")
            return B(G, O, M, Z, J(A));
          var Q = A(U, Z, G, O, M + "." + Z, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(T);
    }
    function V(L) {
      function T(W, D, G, O, M) {
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        var Z = t({}, W[D], L);
        for (var A in Z) {
          var Q = L[A];
          if (r(L, A) && typeof Q != "function")
            return B(G, O, M, A, J(Q));
          if (!Q)
            return new m(
              "Invalid " + O + " `" + M + "` key `" + A + "` supplied to `" + G + "`.\nBad object: " + JSON.stringify(W[D], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(L), null, "  ")
            );
          var N = Q(U, A, G, O, M + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return h(T);
    }
    function z(L) {
      switch (typeof L) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !L;
        case "object":
          if (Array.isArray(L))
            return L.every(z);
          if (L === null || s(L))
            return !0;
          var T = p(L);
          if (T) {
            var W = T.call(L), D;
            if (T !== L.entries) {
              for (; !(D = W.next()).done; )
                if (!z(D.value))
                  return !1;
            } else
              for (; !(D = W.next()).done; ) {
                var G = D.value;
                if (G && !z(G[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function H(L, T) {
      return L === "symbol" ? !0 : T ? T["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && T instanceof Symbol : !1;
    }
    function X(L) {
      var T = typeof L;
      return Array.isArray(L) ? "array" : L instanceof RegExp ? "object" : H(T, L) ? "symbol" : T;
    }
    function J(L) {
      if (typeof L > "u" || L === null)
        return "" + L;
      var T = X(L);
      if (T === "object") {
        if (L instanceof Date)
          return "date";
        if (L instanceof RegExp)
          return "regexp";
      }
      return T;
    }
    function te(L) {
      var T = J(L);
      switch (T) {
        case "array":
        case "object":
          return "an " + T;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + T;
        default:
          return T;
      }
    }
    function ee(L) {
      return !L.constructor || !L.constructor.name ? d : L.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, cv;
}
var pv, $L;
function Bee() {
  if ($L) return pv;
  $L = 1;
  var e = kC();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, pv = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, pv;
}
if (process.env.NODE_ENV !== "production") {
  var Ree = g2(), Iee = !0;
  zb.exports = Aee()(Ree.isElement, Iee);
} else
  zb.exports = Bee()();
var Dg = zb.exports, Mg = {};
Object.defineProperty(Mg, "__esModule", {
  value: !0
});
var Nee = wc, dv = Fee(Nee);
function Fee(e) {
  return e && e.__esModule ? e : { default: e };
}
var zee = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return dv.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && dv.default.getHash() !== e && dv.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Mg.default = zee;
Object.defineProperty(vc, "__esModule", {
  value: !0
});
var Ip = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Uee = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), $ee = Oe, WL = Ec($ee), Wee = yc, Np = Ec(Wee), Vee = ul, Hee = Ec(Vee), Gee = Dg, Gn = Ec(Gee), qee = Mg, Vi = Ec(qee);
function Ec(e) {
  return e && e.__esModule ? e : { default: e };
}
function Zee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Kee(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Xee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var VL = {
  to: Gn.default.string.isRequired,
  containerId: Gn.default.string,
  container: Gn.default.object,
  activeClass: Gn.default.string,
  activeStyle: Gn.default.object,
  spy: Gn.default.bool,
  horizontal: Gn.default.bool,
  smooth: Gn.default.oneOfType([Gn.default.bool, Gn.default.string]),
  offset: Gn.default.number,
  delay: Gn.default.number,
  isDynamic: Gn.default.bool,
  onClick: Gn.default.func,
  duration: Gn.default.oneOfType([Gn.default.number, Gn.default.func]),
  absolute: Gn.default.bool,
  onSetActive: Gn.default.func,
  onSetInactive: Gn.default.func,
  ignoreCancelEvents: Gn.default.bool,
  hashSpy: Gn.default.bool,
  saveHashHistory: Gn.default.bool,
  spyThrottle: Gn.default.number
};
vc.default = function(e, t) {
  var n = t || Hee.default, r = function(i) {
    Xee(a, i);
    function a(s) {
      Zee(this, a);
      var l = Kee(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return Uee(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Np.default.isMounted(s)) {
            var l = Np.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (Vi.default.isMounted() || Vi.default.mount(n), Vi.default.mapContainer(this.props.to, s)), Np.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Np.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Ip({}, this.props.style, this.props.activeStyle) : l = Ip({}, this.props.style);
        var u = Ip({}, this.props);
        for (var c in VL)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, WL.default.createElement(e, u);
      }
    }]), a;
  }(WL.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Ip({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Vi.default.isMounted() && !Vi.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, h = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            h = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - h + a, m = f + w.width;
          }
          var S = a - i.props.offset;
          d = S >= Math.floor(f) && S < Math.floor(m), g = S < Math.floor(f) || S >= Math.floor(m);
        } else {
          var x = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, y = x + F.height;
          }
          var _ = s - i.props.offset;
          d = _ >= Math.floor(x) && _ < Math.floor(y), g = _ < Math.floor(x) || _ >= Math.floor(y);
        }
        var I = n.getActiveLink();
        if (g) {
          if (c === I && n.setActiveLink(void 0), i.props.hashSpy && Vi.default.getHash() === c) {
            var B = i.props.saveHashHistory, $ = B === void 0 ? !1 : B;
            Vi.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (I !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && Vi.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = VL, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(wC, "__esModule", {
  value: !0
});
var Yee = Oe, HL = v2(Yee), Jee = vc, Qee = v2(Jee);
function v2(e) {
  return e && e.__esModule ? e : { default: e };
}
function ete(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function GL(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function tte(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var nte = function(e) {
  tte(t, e);
  function t() {
    var n, r, o, i;
    ete(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = GL(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return HL.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), GL(o, i);
  }
  return t;
}(HL.default.Component);
wC.default = (0, Qee.default)(nte);
var _C = {};
Object.defineProperty(_C, "__esModule", {
  value: !0
});
var rte = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ote = Oe, qL = y2(ote), ite = vc, ste = y2(ite);
function y2(e) {
  return e && e.__esModule ? e : { default: e };
}
function ate(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lte(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ute(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var cte = function(e) {
  ute(t, e);
  function t() {
    return ate(this, t), lte(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return rte(t, [{
    key: "render",
    value: function() {
      return qL.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(qL.default.Component);
_C.default = (0, ste.default)(cte);
var LC = {}, Tg = {};
Object.defineProperty(Tg, "__esModule", {
  value: !0
});
var pte = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, dte = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), fte = Oe, ZL = jg(fte), hte = tl;
jg(hte);
var gte = ul, KL = jg(gte), mte = Dg, XL = jg(mte);
function jg(e) {
  return e && e.__esModule ? e : { default: e };
}
function vte(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function yte(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function bte(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Tg.default = function(e) {
  var t = function(n) {
    bte(r, n);
    function r(o) {
      vte(this, r);
      var i = yte(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return dte(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        KL.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        KL.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return ZL.default.createElement(e, pte({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(ZL.default.Component);
  return t.propTypes = {
    name: XL.default.string,
    id: XL.default.string
  }, t;
};
Object.defineProperty(LC, "__esModule", {
  value: !0
});
var YL = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, wte = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Cte = Oe, JL = PC(Cte), xte = Tg, Ete = PC(xte), Ote = Dg, QL = PC(Ote);
function PC(e) {
  return e && e.__esModule ? e : { default: e };
}
function kte(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _te(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Lte(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var b2 = function(e) {
  Lte(t, e);
  function t() {
    return kte(this, t), _te(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return wte(t, [{
    key: "render",
    value: function() {
      var n = this, r = YL({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, JL.default.createElement(
        "div",
        YL({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(JL.default.Component);
b2.propTypes = {
  name: QL.default.string,
  id: QL.default.string
};
LC.default = (0, Ete.default)(b2);
var fv = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, eP = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function tP(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function nP(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function rP(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Fp = Oe, Ns = yc, hv = ul, sr = Dg, Hi = Mg, oP = {
  to: sr.string.isRequired,
  containerId: sr.string,
  container: sr.object,
  activeClass: sr.string,
  spy: sr.bool,
  smooth: sr.oneOfType([sr.bool, sr.string]),
  offset: sr.number,
  delay: sr.number,
  isDynamic: sr.bool,
  onClick: sr.func,
  duration: sr.oneOfType([sr.number, sr.func]),
  absolute: sr.bool,
  onSetActive: sr.func,
  onSetInactive: sr.func,
  ignoreCancelEvents: sr.bool,
  hashSpy: sr.bool,
  spyThrottle: sr.number
}, Pte = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || hv, r = function(i) {
      rP(a, i);
      function a(s) {
        tP(this, a);
        var l = nP(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return eP(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Ns.isMounted(s) || Ns.mount(s, this.props.spyThrottle), this.props.hashSpy && (Hi.isMounted() || Hi.mount(n), Hi.mapContainer(this.props.to, s)), this.props.spy && Ns.addStateHandler(this.stateHandler), Ns.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ns.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = fv({}, this.props);
          for (var u in oP)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Fp.createElement(e, l);
        }
      }]), a;
    }(Fp.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, fv({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Hi.isMounted() && !Hi.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, h = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Hi.getHash() === l && Hi.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Ns.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Hi.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Ns.updateStates();
        }
      };
    };
    return r.propTypes = oP, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      rP(r, n);
      function r(o) {
        tP(this, r);
        var i = nP(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return eP(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          hv.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          hv.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Fp.createElement(e, fv({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Fp.Component);
    return t.propTypes = {
      name: sr.string,
      id: sr.string
    }, t;
  }
}, Ste = Pte;
Object.defineProperty(gr, "__esModule", {
  value: !0
});
gr.Helpers = gr.ScrollElement = gr.ScrollLink = gr.animateScroll = gr.scrollSpy = gr.Events = gr.scroller = gr.Element = gr.Button = gr.Link = void 0;
var Dte = wC, w2 = si(Dte), Mte = _C, C2 = si(Mte), Tte = LC, x2 = si(Tte), jte = ul, E2 = si(jte), Ate = Cc, O2 = si(Ate), Bte = yc, k2 = si(Bte), Rte = Lg, _2 = si(Rte), Ite = vc, L2 = si(Ite), Nte = Tg, P2 = si(Nte), Fte = Ste, S2 = si(Fte);
function si(e) {
  return e && e.__esModule ? e : { default: e };
}
gr.Link = w2.default;
gr.Button = C2.default;
gr.Element = x2.default;
gr.scroller = E2.default;
gr.Events = O2.default;
gr.scrollSpy = k2.default;
gr.animateScroll = _2.default;
gr.ScrollLink = L2.default;
gr.ScrollElement = P2.default;
gr.Helpers = S2.default;
gr.default = { Link: w2.default, Button: C2.default, Element: x2.default, scroller: E2.default, Events: O2.default, scrollSpy: k2.default, animateScroll: _2.default, ScrollLink: L2.default, ScrollElement: P2.default, Helpers: S2.default };
qe({});
qe({});
qe({});
function Ju(e) {
  "@babel/helpers - typeof";
  return Ju = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ju(e);
}
function zte(e, t) {
  if (Ju(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ju(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Ute(e) {
  var t = zte(e, "string");
  return Ju(t) == "symbol" ? t : t + "";
}
function ge(e, t, n) {
  return (t = Ute(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function D2(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var gv, iP;
function $te() {
  if (iP) return gv;
  iP = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return gv = t, gv;
}
var Wte = $te(), Er = /* @__PURE__ */ D2(Wte), mt = qe(null);
function Vte() {
  Er(!!Ee, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Ee(mt);
  return Er(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Hte(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Gte(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function qte(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Gte(e, i), o;
}
function Zte(e, t, n) {
  var r = Hte(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function Kte(e) {
  google.maps.event.removeListener(e);
}
function Gt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(Kte);
}
function $t(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = Zte(o, i, n);
  return qte(t, r, o, i), a;
}
function Xte(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: h,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: S,
    onUnmount: x
  } = e, [y, C] = k(null), P = Qe(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null), [A, Q] = k(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), v(() => {
    y && l && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && m && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && g && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(y, "mouseout", g)));
  }, [g]), v(() => {
    y && f && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && h && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && E && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), v(() => {
    y && s && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(y, "click", s)));
  }, [s]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), v(() => {
    var N = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(N), N !== null && S && S(N), () => {
      N !== null && x && x(N);
    };
  }, []), Dr.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: Dr.jsx(mt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
ke(Xte);
function sP(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function M2(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        sP(i, r, o, a, s, "next", l);
      }
      function s(l) {
        sP(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function T2(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Er(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var ia = typeof document < "u";
function j2(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return ia ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function aP(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function A2() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return aP(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return aP(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Ml = !1;
function B2() {
  return Dr.jsx("div", {
    children: "Loading..."
  });
}
var Ub = {
  id: "script-loader",
  version: "weekly"
};
class Yte extends be {
  constructor() {
    super(...arguments), ge(this, "check", null), ge(this, "state", {
      loaded: !1
    }), ge(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ge(this, "isCleaningUp", /* @__PURE__ */ M2(function* () {
      function t(n) {
        if (!Ml)
          n();
        else if (ia)
          var r = window.setInterval(function() {
            Ml || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ge(this, "cleanup", () => {
      Ml = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), ge(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && A2(), Er(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: T2(this.props)
      };
      j2(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), ge(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (ia) {
      if (window.google && window.google.maps && !Ml) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), ia && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (ia) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Ml = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Dr.jsxs(Dr.Fragment, {
      children: [Dr.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Dr.jsx(B2, {})]
    });
  }
}
ge(Yte, "defaultProps", Ub);
function Jte(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function SC(e, t) {
  if (e == null) return {};
  var n, r, o = Jte(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var lP;
function Qte(e) {
  var {
    id: t = Ub.id,
    version: n = Ub.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = Qe(!1), [f, m] = k(!1), [h, E] = k(void 0);
  v(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), v(function() {
    ia && u && A2();
  }, [u]), v(function() {
    f && Er(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = T2({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!ia)
      return;
    function x() {
      g.current && (m(!0), lP = w);
    }
    if (window.google && window.google.maps && lP === w) {
      x();
      return;
    }
    j2({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(y) {
      g.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var S = Qe(void 0);
  return v(function() {
    S.current && l !== S.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), S.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var ene = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], tne = Dr.jsx(B2, {});
function nne(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = SC(e, ene), {
    isLoaded: s,
    loadError: l
  } = Qte(a);
  return v(function() {
    s && typeof n == "function" && n();
  }, [s, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || tne;
}
ke(nne);
var uP;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(uP || (uP = {}));
function cP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cP(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pP = {}, dP = {
  options(e, t) {
    e.setOptions(t);
  }
};
function rne(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = Ee(mt), [i, a] = k(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var s = new google.maps.TrafficLayer(kf(kf({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ke(rne);
class one extends be {
  constructor() {
    super(...arguments), ge(this, "state", {
      trafficLayer: null
    }), ge(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ge(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(kf(kf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: dP,
      eventMap: pP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: dP,
      eventMap: pP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Gt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(one, "contextType", mt);
function ine(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Ee(mt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ke(ine);
class sne extends be {
  constructor() {
    super(...arguments), ge(this, "state", {
      bicyclingLayer: null
    }), ge(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(sne, "contextType", mt);
function ane(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Ee(mt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ke(ane);
class lne extends be {
  constructor() {
    super(...arguments), ge(this, "state", {
      transitLayer: null
    }), ge(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(lne, "contextType", mt);
function fP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _f(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fP(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hP = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, gP = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function une(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = Ee(mt), [d, g] = k(null), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), v(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), v(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    Er(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var I = new google.maps.drawing.DrawingManager(_f(_f({}, t), {}, {
      map: p
    }));
    return n && I.setDrawingMode(n), r && m(google.maps.event.addListener(I, "circlecomplete", r)), o && E(google.maps.event.addListener(I, "markercomplete", o)), i && S(google.maps.event.addListener(I, "overlaycomplete", i)), a && y(google.maps.event.addListener(I, "polygoncomplete", a)), s && P(google.maps.event.addListener(I, "polylinecomplete", s)), l && _(google.maps.event.addListener(I, "rectanglecomplete", l)), g(I), u && u(I), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ke(une);
class cne extends be {
  constructor(t) {
    super(t), ge(this, "registeredEvents", []), ge(this, "state", {
      drawingManager: null
    }), ge(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Er(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(_f(_f({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: gP,
      eventMap: hP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: gP,
      eventMap: hP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Gt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ge(cne, "contextType", mt);
function mP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ua(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mP(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vP = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, yP = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Lf = {};
function pne(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: h,
    onClick: E,
    onDblClick: w,
    onDrag: S,
    onDragEnd: x,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: _,
    onRightClick: I,
    onClickableChanged: B,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: H,
    onIconChanged: X,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: L,
    onZindexChanged: T,
    onLoad: W,
    onUnmount: D
  } = e, G = Ee(mt), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, N] = k(null), [le, ye] = k(null), [oe, Be] = k(null), [Ue, $e] = k(null), [Ie, Je] = k(null), [Ze, Me] = k(null), [Ye, nt] = k(null), [De, je] = k(null), [Ke, We] = k(null), [Fe, et] = k(null), [Re, Rt] = k(null), [rt, ot] = k(null), [at, Kt] = k(null), [lt, ut] = k(null), [tt, Xe] = k(null), [Xt, Yt] = k(null), [bt, Rn] = k(null), [wt, In] = k(null), [Ct, fn] = k(null);
  v(() => {
    O !== null && O.setMap(G);
  }, [G]), v(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), v(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), v(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), v(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), v(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), v(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), v(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), v(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), v(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), v(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), v(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), v(() => {
    O && h !== void 0 && O.setZIndex(h);
  }, [O, h]), v(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), v(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), v(() => {
    O && y && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(O, "dragstart", y)));
  }, [y]), v(() => {
    O && _ && (le !== null && google.maps.event.removeListener(le), ye(google.maps.event.addListener(O, "mousedown", _)));
  }, [_]), v(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Be(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), v(() => {
    O && P && (Ue !== null && google.maps.event.removeListener(Ue), $e(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), v(() => {
    O && F && (Ie !== null && google.maps.event.removeListener(Ie), Je(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), v(() => {
    O && I && (Ze !== null && google.maps.event.removeListener(Ze), Me(google.maps.event.addListener(O, "rightclick", I)));
  }, [I]), v(() => {
    O && E && (Ye !== null && google.maps.event.removeListener(Ye), nt(google.maps.event.addListener(O, "click", E)));
  }, [E]), v(() => {
    O && S && (De !== null && google.maps.event.removeListener(De), je(google.maps.event.addListener(O, "drag", S)));
  }, [S]), v(() => {
    O && B && (Ke !== null && google.maps.event.removeListener(Ke), We(google.maps.event.addListener(O, "clickable_changed", B)));
  }, [B]), v(() => {
    O && $ && (Fe !== null && google.maps.event.removeListener(Fe), et(google.maps.event.addListener(O, "cursor_changed", $)));
  }, [$]), v(() => {
    O && V && (Re !== null && google.maps.event.removeListener(Re), Rt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), v(() => {
    O && z && (rt !== null && google.maps.event.removeListener(rt), ot(google.maps.event.addListener(O, "draggable_changed", z)));
  }, [z]), v(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), Kt(google.maps.event.addListener(O, "flat_changed", H)));
  }, [H]), v(() => {
    O && X && (lt !== null && google.maps.event.removeListener(lt), ut(google.maps.event.addListener(O, "icon_changed", X)));
  }, [X]), v(() => {
    O && J && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(O, "position_changed", J)));
  }, [J]), v(() => {
    O && te && (Xt !== null && google.maps.event.removeListener(Xt), Yt(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), v(() => {
    O && ee && (bt !== null && google.maps.event.removeListener(bt), Rn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), v(() => {
    O && L && (wt !== null && google.maps.event.removeListener(wt), In(google.maps.event.addListener(O, "visible_changed", L)));
  }, [L]), v(() => {
    O && T && (Ct !== null && google.maps.event.removeListener(Ct), fn(google.maps.event.addListener(O, "zindex_changed", T)));
  }, [T]), v(() => {
    var xt = Ua(Ua(Ua({}, n || Lf), r ? Lf : {
      map: G
    }), {}, {
      position: t
    }), re = new google.maps.Marker(xt);
    return r ? r.addMarker(re, !!o) : re.setMap(G), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof h == "number" && re.setZIndex(h), w && j(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), y && N(google.maps.event.addListener(re, "dragstart", y)), _ && ye(google.maps.event.addListener(re, "mousedown", _)), C && Be(google.maps.event.addListener(re, "mouseout", C)), P && $e(google.maps.event.addListener(re, "mouseover", P)), F && Je(google.maps.event.addListener(re, "mouseup", F)), I && Me(google.maps.event.addListener(re, "rightclick", I)), E && nt(google.maps.event.addListener(re, "click", E)), S && je(google.maps.event.addListener(re, "drag", S)), B && We(google.maps.event.addListener(re, "clickable_changed", B)), $ && et(google.maps.event.addListener(re, "cursor_changed", $)), V && Rt(google.maps.event.addListener(re, "animation_changed", V)), z && ot(google.maps.event.addListener(re, "draggable_changed", z)), H && Kt(google.maps.event.addListener(re, "flat_changed", H)), X && ut(google.maps.event.addListener(re, "icon_changed", X)), J && Xe(google.maps.event.addListener(re, "position_changed", J)), te && Yt(google.maps.event.addListener(re, "shape_changed", te)), ee && Rn(google.maps.event.addListener(re, "title_changed", ee)), L && In(google.maps.event.addListener(re, "visible_changed", L)), T && fn(google.maps.event.addListener(re, "zindex_changed", T)), M(re), W && W(re), () => {
      U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), Q !== null && google.maps.event.removeListener(Q), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), Ie !== null && google.maps.event.removeListener(Ie), Ze !== null && google.maps.event.removeListener(Ze), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Fe !== null && google.maps.event.removeListener(Fe), Re !== null && google.maps.event.removeListener(Re), rt !== null && google.maps.event.removeListener(rt), at !== null && google.maps.event.removeListener(at), lt !== null && google.maps.event.removeListener(lt), tt !== null && google.maps.event.removeListener(tt), bt !== null && google.maps.event.removeListener(bt), wt !== null && google.maps.event.removeListener(wt), Ct !== null && google.maps.event.removeListener(Ct), D && D(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var wr = Bn(() => i ? it.map(i, (xt) => {
    if (!ti(xt))
      return xt;
    var re = xt;
    return ni(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return Dr.jsx(Dr.Fragment, {
    children: wr
  }) || null;
}
ke(pne);
class dne extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return M2(function* () {
      var n = Ua(Ua(Ua({}, t.props.options || Lf), t.props.clusterer ? Lf : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = $t({
        updaterMap: yP,
        eventMap: vP,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: yP,
      eventMap: vP,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Gt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? it.map(this.props.children, (n) => {
      if (!ti(n))
        return n;
      var r = n;
      return ni(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ge(dne, "contextType", mt);
var fne = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), hne = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new fne(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function gne(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var mne = 2e3, vne = 500, yne = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", bne = "png", wne = [53, 56, 66, 78, 90], Cne = "cluster", R2 = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || yne, this.imageExtension = r.imageExtension || bne, this.imageSizes = r.imageSizes || wne, this.calculator = r.calculator || gne, this.batchSize = r.batchSize || mne, this.batchSizeIE = r.batchSizeIE || vne, this.clusterClass = r.clusterClass || Cne, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new hne(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function bP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xne(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bP(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var To = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, en = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Ene = {};
function One(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: h,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: S,
    onClusteringEnd: x,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [_, I] = k(null), B = Ee(mt), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null);
  return v(() => {
    _ && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(_, To.onMouseOut, C)));
  }, [C]), v(() => {
    _ && y && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(_, To.onMouseOver, y)));
  }, [y]), v(() => {
    _ && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(_, To.onClick, w)));
  }, [w]), v(() => {
    _ && S && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(_, To.onClusteringBegin, S)));
  }, [S]), v(() => {
    _ && x && (X !== null && google.maps.event.removeListener(X), H(google.maps.event.addListener(_, To.onClusteringEnd, x)));
  }, [x]), v(() => {
    typeof r < "u" && _ !== null && en.averageCenter(_, r);
  }, [_, r]), v(() => {
    typeof o < "u" && _ !== null && en.batchSizeIE(_, o);
  }, [_, o]), v(() => {
    typeof i < "u" && _ !== null && en.calculator(_, i);
  }, [_, i]), v(() => {
    typeof a < "u" && _ !== null && en.clusterClass(_, a);
  }, [_, a]), v(() => {
    typeof s < "u" && _ !== null && en.enableRetinaIcons(_, s);
  }, [_, s]), v(() => {
    typeof l < "u" && _ !== null && en.gridSize(_, l);
  }, [_, l]), v(() => {
    typeof u < "u" && _ !== null && en.ignoreHidden(_, u);
  }, [_, u]), v(() => {
    typeof c < "u" && _ !== null && en.imageExtension(_, c);
  }, [_, c]), v(() => {
    typeof p < "u" && _ !== null && en.imagePath(_, p);
  }, [_, p]), v(() => {
    typeof d < "u" && _ !== null && en.imageSizes(_, d);
  }, [_, d]), v(() => {
    typeof g < "u" && _ !== null && en.maxZoom(_, g);
  }, [_, g]), v(() => {
    typeof f < "u" && _ !== null && en.minimumClusterSize(_, f);
  }, [_, f]), v(() => {
    typeof m < "u" && _ !== null && en.styles(_, m);
  }, [_, m]), v(() => {
    typeof h < "u" && _ !== null && en.title(_, h);
  }, [_, h]), v(() => {
    typeof E < "u" && _ !== null && en.zoomOnClick(_, E);
  }, [_, E]), v(() => {
    if (B) {
      var W = xne({}, n || Ene), D = new R2(B, [], W);
      return r && en.averageCenter(D, r), o && en.batchSizeIE(D, o), i && en.calculator(D, i), a && en.clusterClass(D, a), s && en.enableRetinaIcons(D, s), l && en.gridSize(D, l), u && en.ignoreHidden(D, u), c && en.imageExtension(D, c), p && en.imagePath(D, p), d && en.imageSizes(D, d), g && en.maxZoom(D, g), f && en.minimumClusterSize(D, f), m && en.styles(D, m), h && en.title(D, h), E && en.zoomOnClick(D, E), C && ee(google.maps.event.addListener(D, To.onMouseOut, C)), y && T(google.maps.event.addListener(D, To.onMouseOver, y)), w && V(google.maps.event.addListener(D, To.onClick, w)), S && H(google.maps.event.addListener(D, To.onClusteringBegin, S)), x && J(google.maps.event.addListener(D, To.onClusteringEnd, x)), I(D), P && P(D), () => {
        te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), F && F(D);
      };
    }
  }, []), _ !== null && t(_) || null;
}
ke(One);
class kne extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      markerClusterer: null
    }), ge(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new R2(this.context, [], this.props.options);
      this.registeredEvents = $t({
        updaterMap: en,
        eventMap: To,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: en,
      eventMap: To,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Gt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ge(kne, "contextType", mt);
function wP(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var I2 = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || wP(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, wP));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), h = m.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + g ? r = h.x + u - g : h.x + p + u + g > s && (r = h.x + p + u + g - s), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), _ne = ["position"], Lne = ["position"];
function CP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CP(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xP = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, EP = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Pne = {};
function Sne(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = Ee(mt), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), I = Qe(null);
  return v(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (g) {
      var B = r || Pne, {
        position: $
      } = B, V = SC(B, _ne), z;
      $ && !($ instanceof google.maps.LatLng) && (z = new google.maps.LatLng($.lat, $.lng));
      var H = new I2(Pf(Pf({}, V), z ? {
        position: z
      } : {}));
      I.current = document.createElement("div"), m(H), a && E(google.maps.event.addListener(H, "closeclick", a)), s && S(google.maps.event.addListener(H, "domready", s)), l && y(google.maps.event.addListener(H, "content_changed", l)), u && P(google.maps.event.addListener(H, "position_changed", u)), c && _(google.maps.event.addListener(H, "zindex_changed", c)), H.setContent(I.current), n ? H.open(g, n) : H.getPosition() ? H.open(g) : Er(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(H);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), I.current ? br(it.only(t), I.current) : null;
}
ke(Sne);
class Dne extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", null), ge(this, "state", {
      infoBox: null
    }), ge(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Er(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ge(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = SC(t, Lne), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new I2(Pf(Pf({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = $t({
      updaterMap: EP,
      eventMap: xP,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: EP,
      eventMap: xP,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Gt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? br(it.only(this.props.children), this.containerElement) : null;
  }
}
ge(Dne, "contextType", mt);
var OP, kP;
function Mne() {
  return kP || (kP = 1, OP = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), OP;
}
var Tne = Mne(), _P = /* @__PURE__ */ D2(Tne), LP = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], mv = 1, Tl = 8;
class DC {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== mv)
      throw new Error("Got v".concat(o, " data when expected v").concat(mv, "."));
    var i = LP[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new DC(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = LP.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Tl, t), this.coords = new this.ArrayType(this.data, Tl + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Tl + a + s + l), this.ids = new this.IndexArrayType(this.data, Tl, t), this.coords = new this.ArrayType(this.data, Tl + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (mv << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return $b(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var h = d + p >> 1, E = a[2 * h], w = a[2 * h + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          PP(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], h = i[2 * f + 1];
      PP(m, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= h) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= h) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function $b(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    N2(e, t, a, r, o, i), $b(e, t, n, r, a - 1, 1 - i), $b(e, t, n, a + 1, o, 1 - i);
  }
}
function N2(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      N2(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (jl(e, t, r, n), t[2 * o + i] > g && jl(e, t, r, o); f < m; ) {
      for (jl(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? jl(e, t, r, m) : (m++, jl(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function jl(e, t, n, r) {
  vv(e, n, r), vv(t, 2 * n, 2 * r), vv(t, 2 * n + 1, 2 * r + 1);
}
function vv(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function PP(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var jne = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, SP = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Fs = 2, is = 3, yv = 4, es = 5, F2 = 6;
class Ane {
  constructor(t) {
    this.options = Object.assign(Object.create(jne), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = SP(zp(u)), d = SP(Up(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(zp(r), Up(a), zp(i), Up(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + es] > 1 ? DP(p, f, this.clusterProps) : this.points[p[f + is]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + yv] === t && p.push(a[g + es] > 1 ? DP(a, g, this.clusterProps) : this.points[a[g + is]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new DC(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + es] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = z2(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + is]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = zp(f), d = Up(m);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + is] : E = this.points[n[l + is]].id, E !== void 0 && (h.id = E), a.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Fs] <= n)) {
        l[p + Fs] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + es], h = m;
        for (var E of f) {
          var w = E * c;
          l[w + Fs] > n && (h += l[w + es]);
        }
        if (h > m && h >= a) {
          var S = d * m, x = g * m, y = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var _ = F * c;
            if (!(l[_ + Fs] <= n)) {
              l[_ + Fs] = n;
              var I = l[_ + es];
              S += l[_] * I, x += l[_ + 1] * I, l[_ + yv] = P, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, _)));
            }
          }
          l[p + yv] = P, u.push(S / h, x / h, 1 / 0, P, -1, h), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (h > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Fs] <= n)) {
                l[V + Fs] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + es] > 1) {
      var o = this.clusterProps[t[n + F2]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + is]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function DP(e, t, n) {
  return {
    type: "Feature",
    id: e[t + is],
    properties: z2(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [Bne(e[t]), Rne(e[t + 1])]
    }
  };
}
function z2(e, t, n) {
  var r = e[t + es], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + F2], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + is],
    point_count: r,
    point_count_abbreviated: o
  });
}
function zp(e) {
  return e / 360 + 0.5;
}
function Up(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Bne(e) {
  return (e - 0.5) * 360;
}
function Rne(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Ine(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class vo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Wb {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(vo.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => vo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (vo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Nne {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return Fne(n);
  }
}
var Fne = (e) => {
  var t = e.map((n) => new Wb({
    position: vo.getPosition(n),
    markers: [n]
  }));
  return t;
};
class zne extends Nne {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Ine(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Ane(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!_P(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = vo.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !_P(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Wb({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Wb({
      markers: [i],
      position: vo.getPosition(i)
    });
  }
}
class Une {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class $ne {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (vo.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function Wne(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class MC {
  constructor() {
    Wne(MC, google.maps.OverlayView);
  }
}
var hu;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(hu || (hu = {}));
var Vne = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Hne extends MC {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new zne(o),
      renderer: a = new $ne(),
      onClusterClick: s = Vne
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (vo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, hu.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || vo.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => vo.setMap(l, null)));
      }
      google.maps.event.trigger(this, hu.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => vo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Une(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => vo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, hu.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), vo.setMap(r.marker, n);
    });
  }
}
function MP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function TP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MP(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Gne(e) {
  var t = Vte(), [n, r] = k(null);
  return v(() => {
    if (t && n === null) {
      var o = new Hne(TP(TP({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function qne(e) {
  var {
    children: t,
    options: n
  } = e, r = Gne(n);
  return r !== null ? t(r) : null;
}
ke(qne);
var jP = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, AP = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Zne(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = Ee(mt), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), I = Qe(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var B = new google.maps.InfoWindow(r);
    return m(B), I.current = document.createElement("div"), a && E(google.maps.event.addListener(B, "closeclick", a)), s && S(google.maps.event.addListener(B, "domready", s)), l && y(google.maps.event.addListener(B, "content_changed", l)), u && P(google.maps.event.addListener(B, "position_changed", u)), c && _(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(I.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(g, n) : B.getPosition() ? B.open(g) : Er(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(B), B.close();
    };
  }, []), I.current ? br(it.only(t), I.current) : null;
}
ke(Zne);
class Kne extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", null), ge(this, "state", {
      infoWindow: null
    }), ge(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Er(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ge(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = $t({
      updaterMap: AP,
      eventMap: jP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: AP,
      eventMap: jP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Gt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? br(it.only(this.props.children), this.containerElement) : null;
  }
}
ge(Kne, "contextType", mt);
function BP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BP(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var RP = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, IP = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Xne = {};
function Yne(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onLoad: E,
    onUnmount: w
  } = e, S = Ee(mt), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null);
  return v(() => {
    x !== null && x.setMap(S);
  }, [S]), v(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), v(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), v(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), v(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), v(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), v(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), v(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), v(() => {
    x && l && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), v(() => {
    x && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), v(() => {
    x && c && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), v(() => {
    x && p && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), v(() => {
    x && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), v(() => {
    x && g && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(x, "mouseup", g)));
  }, [g]), v(() => {
    x && f && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), v(() => {
    x && m && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), v(() => {
    x && h && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(x, "drag", h)));
  }, [h]), v(() => {
    var j = new google.maps.Polyline(Sf(Sf({}, t || Xne), {}, {
      map: S
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && P(google.maps.event.addListener(j, "dblclick", a)), s && _(google.maps.event.addListener(j, "dragend", s)), l && B(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && H(google.maps.event.addListener(j, "mousemove", c)), p && J(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), g && T(google.maps.event.addListener(j, "mouseup", g)), f && D(google.maps.event.addListener(j, "rightclick", f)), m && O(google.maps.event.addListener(j, "click", m)), h && U(google.maps.event.addListener(j, "drag", h)), y(j), E && E(j), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), w && w(j), j.setMap(null);
    };
  }, []), null;
}
ke(Yne);
class Jne extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      polyline: null
    }), ge(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Sf(Sf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: IP,
      eventMap: RP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: IP,
      eventMap: RP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Gt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ge(Jne, "contextType", mt);
function NP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function FP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NP(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zP = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, UP = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Qne(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: E,
    onLoad: w,
    onUnmount: S,
    onEdit: x
  } = e, y = Ee(mt), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), v(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), v(() => {
    C && typeof l == "function" && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof g == "function" && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), v(() => {
    C && typeof f == "function" && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof m == "function" && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(() => {
    C && typeof h == "function" && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(C, "click", h)));
  }, [h]), v(() => {
    C && typeof E == "function" && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), v(() => {
    var A = new google.maps.Polygon(FP(FP({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && _(google.maps.event.addListener(A, "dblclick", s)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && H(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), g && T(google.maps.event.addListener(A, "mouseover", g)), f && D(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), h && U(google.maps.event.addListener(A, "click", h)), E && Z(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), M !== null && google.maps.event.removeListener(M), S && S(A), A.setMap(null);
    };
  }, []), null;
}
ke(Qne);
class ere extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = $t({
      updaterMap: UP,
      eventMap: zP,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: UP,
      eventMap: zP,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Gt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ge(ere, "contextType", mt);
function $P(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Df(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $P(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $P(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WP = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, VP = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function tre(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: S
  } = e, x = Ee(mt), [y, C] = k(null), [P, F] = k(null), [_, I] = k(null), [B, $] = k(null), [V, z] = k(null), [H, X] = k(null), [J, te] = k(null), [ee, L] = k(null), [T, W] = k(null), [D, G] = k(null), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null);
  return v(() => {
    y !== null && y.setMap(x);
  }, [x]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), v(() => {
    y && s && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), v(() => {
    y && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), L(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && g && (T !== null && google.maps.event.removeListener(T), W(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), v(() => {
    y && f && (D !== null && google.maps.event.removeListener(D), G(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(y, "click", m)));
  }, [m]), v(() => {
    y && h && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(y, "drag", h)));
  }, [h]), v(() => {
    y && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), v(() => {
    var Q = new google.maps.Rectangle(Df(Df({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), a && F(google.maps.event.addListener(Q, "dblclick", a)), s && I(google.maps.event.addListener(Q, "dragend", s)), l && $(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && X(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && L(google.maps.event.addListener(Q, "mouseover", d)), g && W(google.maps.event.addListener(Q, "mouseup", g)), f && G(google.maps.event.addListener(Q, "rightclick", f)), m && M(google.maps.event.addListener(Q, "click", m)), h && j(google.maps.event.addListener(Q, "drag", h)), E && A(google.maps.event.addListener(Q, "bounds_changed", E)), C(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), _ !== null && google.maps.event.removeListener(_), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), T !== null && google.maps.event.removeListener(T), D !== null && google.maps.event.removeListener(D), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), S && S(Q), Q.setMap(null);
    };
  }, []), null;
}
ke(tre);
class nre extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      rectangle: null
    }), ge(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Df(Df({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: VP,
      eventMap: WP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: VP,
      eventMap: WP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Gt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ge(nre, "contextType", mt);
function HP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HP(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GP = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, qP = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, rre = {};
function ore(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: S,
    onLoad: x,
    onUnmount: y
  } = e, C = Ee(mt), [P, F] = k(null), [_, I] = k(null), [B, $] = k(null), [V, z] = k(null), [H, X] = k(null), [J, te] = k(null), [ee, L] = k(null), [T, W] = k(null), [D, G] = k(null), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, N] = k(null), [le, ye] = k(null);
  return v(() => {
    P !== null && P.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), v(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), v(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), v(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), v(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), v(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), v(() => {
    P && s && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), v(() => {
    P && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), v(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), v(() => {
    P && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), v(() => {
    P && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), v(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), L(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), v(() => {
    P && g && (T !== null && google.maps.event.removeListener(T), W(google.maps.event.addListener(P, "mouseover", g)));
  }, [g]), v(() => {
    P && f && (D !== null && google.maps.event.removeListener(D), G(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), v(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), v(() => {
    P && h && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(P, "click", h)));
  }, [h]), v(() => {
    P && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), v(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(P, "center_changed", w)));
  }, [h]), v(() => {
    P && S && (le !== null && google.maps.event.removeListener(le), ye(google.maps.event.addListener(P, "radius_changed", S)));
  }, [S]), v(() => {
    var oe = new google.maps.Circle(Mf(Mf({}, t || rre), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && I(google.maps.event.addListener(oe, "dblclick", s)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && L(google.maps.event.addListener(oe, "mouseout", d)), g && W(google.maps.event.addListener(oe, "mouseover", g)), f && G(google.maps.event.addListener(oe, "mouseup", f)), m && M(google.maps.event.addListener(oe, "rightclick", m)), h && j(google.maps.event.addListener(oe, "click", h)), E && A(google.maps.event.addListener(oe, "drag", E)), w && N(google.maps.event.addListener(oe, "center_changed", w)), S && ye(google.maps.event.addListener(oe, "radius_changed", S)), F(oe), x && x(oe), () => {
      _ !== null && google.maps.event.removeListener(_), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), T !== null && google.maps.event.removeListener(T), D !== null && google.maps.event.removeListener(D), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Q !== null && google.maps.event.removeListener(Q), le !== null && google.maps.event.removeListener(le), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
ke(ore);
class ire extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      circle: null
    }), ge(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Mf(Mf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: qP,
      eventMap: GP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: qP,
      eventMap: GP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Gt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ge(ire, "contextType", mt);
function ZP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Tf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZP(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var KP = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, XP = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function sre(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: h
  } = e, E = Ee(mt), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null);
  return v(() => {
    w !== null && w.setMap(E);
  }, [E]), v(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && a && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), v(() => {
    w && s && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && g && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), v(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (E !== null) {
      var A = new google.maps.Data(Tf(Tf({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && _(google.maps.event.addListener(A, "mousemove", i)), a && B(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && H(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && T(google.maps.event.addListener(A, "addfeature", c)), p && D(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && Z(google.maps.event.addListener(A, "setproperty", f)), S(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), M !== null && google.maps.event.removeListener(M), j !== null && google.maps.event.removeListener(j), h && h(w), w.setMap(null));
    };
  }, []), null;
}
ke(sre);
class are extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      data: null
    }), ge(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Tf(Tf({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = $t({
        updaterMap: XP,
        eventMap: KP,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: XP,
      eventMap: KP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Gt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ge(are, "contextType", mt);
function YP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function JP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YP(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var QP = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, eS = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class lre extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      kmlLayer: null
    }), ge(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(JP(JP({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: eS,
      eventMap: QP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: eS,
      eventMap: QP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Gt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(lre, "contextType", mt);
function U2(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function ure(e, t) {
  return new t(e.lat, e.lng);
}
function cre(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function pre(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function dre(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function fre(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function hre(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function $2(e, t, n, r) {
  return n !== void 0 ? fre(e, t, dre(n, google.maps.LatLngBounds, cre)) : hre(e, t, pre(r, google.maps.LatLng, ure));
}
function gre(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function tS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mre(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function vre(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = mre({}, this.container ? U2(this.container, o) : {
        x: 0,
        y: 0
      }), u = $2(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function nS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yre(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function rS(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function oS(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function bre(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = Ee(mt), c = Bn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Bn(() => vre(c, r, t, n, s), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), oi.createPortal(l, c);
}
ke(bre);
class cl extends be {
  constructor(t) {
    super(t), ge(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ge(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Er(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ge(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ge(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = yre({
        x: 0,
        y: 0
      }, this.containerRef.current ? U2(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = $2(r, o, this.props.bounds, this.props.position);
      if (!gre(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ge(this, "draw", () => {
      this.onPositionElement();
    }), ge(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Hr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = rS(t.position), r = rS(this.props.position), o = oS(t.bounds), i = oS(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? oi.createPortal(Dr.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: it.only(this.props.children)
    }), t) : null;
  }
}
ge(cl, "FLOAT_PANE", "floatPane");
ge(cl, "MAP_PANE", "mapPane");
ge(cl, "MARKER_LAYER", "markerLayer");
ge(cl, "OVERLAY_LAYER", "overlayLayer");
ge(cl, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ge(cl, "contextType", mt);
function wre() {
}
function iS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aS = {
  onDblClick: "dblclick",
  onClick: "click"
}, lS = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Cre(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = Ee(mt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Bn(() => new google.maps.GroundOverlay(t, a, r), []);
  return v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), v(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ke(Cre);
class W2 extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      groundOverlay: null
    }), ge(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Er(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, sS(sS({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: lS,
      eventMap: aS,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: lS,
      eventMap: aS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ge(W2, "defaultProps", {
  onLoad: wre
});
ge(W2, "contextType", mt);
function uS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uS(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cS = {}, pS = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function xre(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = Ee(mt), [a, s] = k(null);
  return v(() => {
    google.maps.visualization || Er(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    Er(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(jf(jf({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ke(xre);
class Ere extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      heatmapLayer: null
    }), ge(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Er(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Er(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(jf(jf({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = $t({
      updaterMap: pS,
      eventMap: cS,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: pS,
      eventMap: cS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Gt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(Ere, "contextType", mt);
var dS = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, fS = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Ore extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      streetViewPanorama: null
    }), ge(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = $t({
      updaterMap: fS,
      eventMap: dS,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: fS,
      eventMap: dS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Gt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ge(Ore, "contextType", mt);
class kre extends be {
  constructor() {
    super(...arguments), ge(this, "state", {
      streetViewService: null
    }), ge(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ge(kre, "contextType", mt);
var hS = {
  onDirectionsChanged: "directions_changed"
}, gS = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class _re extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      directionsRenderer: null
    }), ge(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = $t({
      updaterMap: gS,
      eventMap: hS,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: gS,
      eventMap: hS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Gt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(_re, "contextType", mt);
var mS = {
  onPlacesChanged: "places_changed"
}, vS = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Lre extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", Hr()), ge(this, "state", {
      searchBox: null
    }), ge(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Er(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = $t({
          updaterMap: vS,
          eventMap: mS,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: vS,
      eventMap: mS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Gt(this.registeredEvents));
  }
  render() {
    return Dr.jsx("div", {
      ref: this.containerElement,
      children: it.only(this.props.children)
    });
  }
}
ge(Lre, "contextType", mt);
var yS = {
  onPlaceChanged: "place_changed"
}, bS = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class V2 extends be {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", Hr()), ge(this, "state", {
      autocomplete: null
    }), ge(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Er(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = $t({
        updaterMap: bS,
        eventMap: yS,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Gt(this.registeredEvents), this.registeredEvents = $t({
      updaterMap: bS,
      eventMap: yS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Gt(this.registeredEvents);
  }
  render() {
    return Dr.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: it.only(this.props.children)
    });
  }
}
ge(V2, "defaultProps", {
  className: ""
});
ge(V2, "contextType", mt);
let Pre = { data: "" }, Sre = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Pre, Dre = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Mre = /\/\*[^]*?\*\/|  +/g, wS = /\n+/g, ds = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? ds(a, i) : i + "{" + ds(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += ds(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ds.p ? ds.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, xi = {}, H2 = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + H2(e[n]);
    return t;
  }
  return e;
}, Tre = (e, t, n, r, o) => {
  let i = H2(e), a = xi[i] || (xi[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!xi[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Dre.exec(u.replace(Mre, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(wS, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(wS, " ").trim();
      return d[0];
    })(e);
    xi[a] = ds(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && xi.g ? xi.g : null;
  return n && (xi.g = xi[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(xi[a], t, r, s), a;
}, jre = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : ds(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Ag(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Tre(n.unshift ? n.raw ? jre(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Sre(t.target), t.g, t.o, t.k);
}
let G2, Vb, Hb;
Ag.bind({ g: 1 });
let ji = Ag.bind({ k: 1 });
function Are(e, t, n, r) {
  ds.p = t, G2 = e, Vb = n, Hb = r;
}
function Ms(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: Vb && Vb() }, s), n.o = / *go\d+/.test(l), s.className = Ag.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), Hb && u[0] && Hb(s), G2(u, s);
    }
    return o;
  };
}
var Bre = (e) => typeof e == "function", Rre = (e, t) => Bre(e) ? e(t) : e, Ire = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Nre = ji`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Fre = ji`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, zre = ji`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Ure = Ms("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Nre} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Fre} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${zre} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, $re = ji`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Wre = Ms("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${$re} 1s linear infinite;
`, Vre = ji`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Hre = ji`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, Gre = Ms("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Vre} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Hre} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, qre = Ms("div")`
  position: absolute;
`, Zre = Ms("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Kre = ji`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Xre = Ms("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Kre} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, Yre = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? ze.createElement(Xre, null, t) : t : n === "blank" ? null : ze.createElement(Zre, null, ze.createElement(Wre, { ...r }), n !== "loading" && ze.createElement(qre, null, n === "error" ? ze.createElement(Ure, { ...r }) : ze.createElement(Gre, { ...r })));
}, Jre = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Qre = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, eoe = "0%{opacity:0;} 100%{opacity:1;}", toe = "0%{opacity:1;} 100%{opacity:0;}", noe = Ms("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, roe = Ms("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, ooe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Ire() ? [eoe, toe] : [Jre(n), Qre(n)];
  return { animation: t ? `${ji(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ji(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
ze.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? ooe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = ze.createElement(Yre, { toast: e }), a = ze.createElement(roe, { ...e.ariaProps }, Rre(e.message, e));
  return ze.createElement(noe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : ze.createElement(ze.Fragment, null, i, a));
});
Are(ze.createElement);
Ag`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
qe({});
function ioe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const soe = {
  CNPJ: "99.999.999/9999-99"
};
ioe(soe.CNPJ).length;
Ir((e, t) => /* @__PURE__ */ Sr.jsx("input", { ref: t, ...e }));
function q2(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Z2 = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function aoe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function loe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const uoe = q2(Z2.NINE).length, coe = Ir((e, t) => /* @__PURE__ */ Sr.jsx("input", { ref: t, ...e }));
Ir(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    v(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = q2(g.target.value);
      const m = loe(f);
      f.length > uoe || (f = aoe(f, Z2[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Sr.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Sr.jsx(
      el,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: coe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
qe({});
var Fi = {};
Object.defineProperty(Fi, "__esModule", {
  value: !0
});
var poe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), bv = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, K2 = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: poe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, TC = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var $p = 1; $p < 20; $p++)
  TC["f" + $p] = 111 + $p;
function Bg(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return X2(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Y2(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function doe(e, t) {
  return Bg(e, t);
}
function foe(e, t) {
  return Bg(e, { byKey: !0 }, t);
}
function X2(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in bv)
    r[bv[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = jC(d), m = bv[f];
      if (d.length > 1 && !m && !K2[d] && !TC[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = J2(d)), m && (r[m] = g ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Y2(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function J2(e) {
  e = jC(e);
  var t = TC[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function jC(e) {
  return e = e.toLowerCase(), e = K2[e] || e, e;
}
Fi.default = Bg;
var wv = Fi.isHotkey = Bg;
Fi.isCodeHotkey = doe;
Fi.isKeyHotkey = foe;
Fi.parseHotkey = X2;
Fi.compareHotkey = Y2;
Fi.toKeyCode = J2;
Fi.toKeyName = jC;
var hoe = typeof On == "object" && On && On.Object === Object && On, goe = hoe, moe = goe, voe = typeof self == "object" && self && self.Object === Object && self, yoe = moe || voe || Function("return this")(), boe = yoe, woe = boe, Coe = woe.Symbol, Q2 = Coe, CS = Q2;
CS && CS.toStringTag;
var xS = Q2;
xS && xS.toStringTag;
var ES;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(ES || (ES = {}));
var AC = function(e) {
  return Object.freeze(e);
}, xoe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, AC(this);
  }
  return e;
}(), Eoe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, AC(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), OS = typeof window < "u" ? window : {};
/msie|trident/i.test(OS.navigator && OS.navigator.userAgent);
var Cv = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new xoe((n ? t : e) || 0, (n ? e : t) || 0);
};
AC({
  devicePixelContentBoxSize: Cv(),
  borderBoxSize: Cv(),
  contentBoxSize: Cv(),
  contentRect: new Eoe(0, 0, 0, 0)
});
function Qu(e) {
  "@babel/helpers - typeof";
  return Qu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Qu(e);
}
function Ooe(e, t) {
  if (Qu(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Qu(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function koe(e) {
  var t = Ooe(e, "string");
  return Qu(t) === "symbol" ? t : String(t);
}
function gu(e, t, n) {
  return t = koe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var _oe = /* @__PURE__ */ qe(null), xv, Ev;
parseInt(Oe.version.split(".")[0], 10);
var kS = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Ov = typeof navigator < "u" && /Android/.test(navigator.userAgent), Wp = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Loe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (xv = navigator.userAgent.match(/Version\/(\d+)/)) !== null && xv !== void 0 && xv[1] && parseInt((Ev = navigator.userAgent.match(/Version\/(\d+)/)) === null || Ev === void 0 ? void 0 : Ev[1], 10) < 17;
var Poe = /* @__PURE__ */ new WeakMap(), Soe = /* @__PURE__ */ new WeakMap(), Doe = /* @__PURE__ */ new WeakMap(), Moe = /* @__PURE__ */ new WeakMap(), Toe = /* @__PURE__ */ new WeakMap(), _S = /* @__PURE__ */ new WeakMap(), joe = /* @__PURE__ */ new WeakMap(), LS = /* @__PURE__ */ new WeakMap(), Vp = /* @__PURE__ */ new WeakMap(), Aoe = /* @__PURE__ */ new WeakMap(), Boe = /* @__PURE__ */ new WeakMap(), Roe = /* @__PURE__ */ new WeakMap(), ez = globalThis.Node, Ioe = globalThis.Text, tz = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Noe = (e) => Af(e) && e.nodeType === 8, Qo = (e) => Af(e) && e.nodeType === 1, Af = (e) => {
  var t = tz(e);
  return !!t && e instanceof t.Node;
}, PS = (e) => {
  var t = e && e.anchorNode && tz(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Foe = (e) => {
  var [t, n] = e;
  if (Qo(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = nz(t, o, r ? "backward" : "forward"), r = o < n; Qo(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = Uoe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, zoe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, nz = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (Noe(o) || Qo(o) && o.childNodes.length === 0 || Qo(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, Uoe = (e, t, n) => {
  var [r] = nz(e, t, n);
  return r;
}, SS = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), rz = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Qo(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Ft.getWindow(e);
  if (o.contains(r))
    return Ft.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : rz(e, i, n);
}, DS = (e, t) => !!(e.compareDocumentPosition(t) & ez.DOCUMENT_POSITION_PRECEDING), $oe = (e, t) => !!(e.compareDocumentPosition(t) & ez.DOCUMENT_POSITION_FOLLOWING), Woe = 0;
class Voe {
  constructor() {
    gu(this, "id", void 0), this.id = "".concat(Woe++);
  }
}
var Ft = {
  androidPendingDiffs: (e) => Roe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = Boe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Ft.toDOMNode(e, e), n = Ft.findDocumentOrShadowRoot(e);
    Vp.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Ft.findDocumentOrShadowRoot(e), r = SS(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Qd.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Ft.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Ft.toSlateNode(e, t.target), a = Ft.findPath(e, i);
    if (Li.isElement(i) && bn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = bn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? bn.before(e, u) : bn.after(e, u);
      if (c) {
        var p = bn.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = Ft.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = Ft.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = _S.get(t);
    return n || (n = new Voe(), _S.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = Soe.get(r);
      if (o == null) {
        if (bn.isEditor(r))
          return n;
        break;
      }
      var i = Poe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(fo.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Vp.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Ft.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Ft.toDOMNode(e, e), r = Ft.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = SS(r), i = Ft.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Qd.select(e, bn.start(e, [])), Vp.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Doe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Ft.toDOMNode(e, e), i;
    try {
      i = Qo(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Af(t) && Ft.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return bn.hasPath(e, n.path) && bn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Ft.hasEditableTarget(e, t) || Ft.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Af(t) && Ft.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Aoe.get(e),
  isFocused: (e) => !!Vp.get(e),
  isReadOnly: (e) => !!LS.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (LS.get(e)) return !1;
    var n = Ft.hasTarget(e, t) && Ft.toSlateNode(e, t);
    return Li.isElement(n) && bn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = joe.get(e), r = bn.isEditor(t) ? Moe.get(e) : n == null ? void 0 : n.get(Ft.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(fo.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = bn.node(e, t.path), r = Ft.toDOMNode(e, n), o;
    bn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var h, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof Ioe ? E : m,
            (h = m.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(fo.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = _t.isBackward(t), i = Ft.toDOMPoint(e, n), a = _t.isCollapsed(t) ? i : Ft.toDOMPoint(e, r), s = Ft.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Qo(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = Qo(p) ? p : p.parentElement, h = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Qo(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Toe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : Foe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = Ft.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), E = h && g.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), S = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = Ft.getWindow(e), y = x.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((D) => {
            if (Ov && !r && D.hasAttribute("data-slate-zero-width") && D.textContent.length > 0 && D.textContext !== "\uFEFF") {
              D.textContent.startsWith("\uFEFF") && (D.textContent = D.textContent.slice(1));
              return;
            }
            D.parentNode.removeChild(D);
          }), c = C.textContent.length, S = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), _ = 0; _ < F.length; _++) {
          var I = F[_];
          if (Ft.hasDOMNode(e, I)) {
            w = I;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), S = w, c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((D) => {
          c -= D.textContent.length;
        })) : c = 1;
      } else if (E) {
        var B = (D) => D ? D.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...B($), ...B($ == null ? void 0 : $.nextElementSibling)];
          w = (V = z.find((D) => $oe(E, D))) !== null && V !== void 0 ? V : null;
        } else {
          var H, X = [...B($ == null ? void 0 : $.previousElementSibling), ...B($)];
          w = (H = X.findLast((D) => DS(E, D))) !== null && H !== void 0 ? H : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), S = w, i === "forward" ? c = 0 : (c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((D) => {
          c -= D.textContent.length;
        })));
      }
      S && c === S.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Ov && S.getAttribute("data-slate-zero-width") === "z" && (p = S.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Wp && (d = S.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Ov && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && Ft.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = Ft.toSlateNode(e, J), {
          path: ee,
          offset: L
        } = bn.start(e, Ft.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (L = s), {
          path: ee,
          offset: L
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var T = Ft.toSlateNode(e, u), W = Ft.findPath(e, T);
    return {
      path: W,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = PS(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (PS(t)) {
        if (Wp && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = g.startContainer, h = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Loe && zoe(s) || Wp ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Wp && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Ft.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var S = DS(s, u) || s === u && c < l, x = p ? w : Ft.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: S ? "forward" : "backward"
    });
    if (!x)
      return null;
    var y = {
      anchor: w,
      focus: x
    };
    return _t.isExpanded(y) && _t.isForward(y) && Qo(u) && bn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = bn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, Hoe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, Goe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, qoe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, qn = (e) => {
  var t = Hoe[e], n = Goe[e], r = qoe[e], o = t && wv(t), i = n && wv(n), a = r && wv(r);
  return (s) => !!(o && o(s) || kS && i && i(s) || !kS && a && a(s));
};
qn("bold"), qn("compose"), qn("moveBackward"), qn("moveForward"), qn("deleteBackward"), qn("deleteForward"), qn("deleteLineBackward"), qn("deleteLineForward"), qn("deleteWordBackward"), qn("deleteWordForward"), qn("extendBackward"), qn("extendForward"), qn("extendLineBackward"), qn("extendLineForward"), qn("italic"), qn("moveLineBackward"), qn("moveLineForward"), qn("moveWordBackward"), qn("moveWordForward"), qn("redo"), qn("insertSoftBreak"), qn("splitBlock"), qn("transposeCharacter"), qn("undo");
var Zoe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => rz(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, Koe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class Xoe extends uc {
  constructor() {
    super(...arguments), gu(this, "context", null), gu(this, "manager", null), gu(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, Koe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = Zoe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
gu(Xoe, "contextType", _oe);
qe({});
qe({});
qe({});
var mr = {}, BC = {}, Oc = {}, kc = {}, oz = "Expected a function", MS = NaN, Yoe = "[object Symbol]", Joe = /^\s+|\s+$/g, Qoe = /^[-+]0x[0-9a-f]+$/i, eie = /^0b[01]+$/i, tie = /^0o[0-7]+$/i, nie = parseInt, rie = typeof On == "object" && On && On.Object === Object && On, oie = typeof self == "object" && self && self.Object === Object && self, iie = rie || oie || Function("return this")(), sie = Object.prototype, aie = sie.toString, lie = Math.max, uie = Math.min, kv = function() {
  return iie.Date.now();
};
function cie(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(oz);
  t = TS(t) || 0, Bf(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? lie(TS(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, _ = t - P;
    return p ? uie(_, i - F) : _;
  }
  function h(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = kv();
    if (h(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function S() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(kv());
  }
  function y() {
    var C = kv(), P = h(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = S, y.flush = x, y;
}
function pie(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(oz);
  return Bf(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), cie(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Bf(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function die(e) {
  return !!e && typeof e == "object";
}
function fie(e) {
  return typeof e == "symbol" || die(e) && aie.call(e) == Yoe;
}
function TS(e) {
  if (typeof e == "number")
    return e;
  if (fie(e))
    return MS;
  if (Bf(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Bf(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Joe, "");
  var n = eie.test(e);
  return n || tie.test(e) ? nie(e.slice(2), n ? 2 : 8) : Qoe.test(e) ? MS : +e;
}
var hie = pie, _c = {};
Object.defineProperty(_c, "__esModule", {
  value: !0
});
_c.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Dd.has(t) || Dd.set(t, /* @__PURE__ */ new Set());
  var o = Dd.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
_c.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Dd.get(t).delete(n.name || t);
};
var Dd = /* @__PURE__ */ new Map();
Object.defineProperty(kc, "__esModule", {
  value: !0
});
var gie = hie, mie = vie(gie), jS = _c;
function vie(e) {
  return e && e.__esModule ? e : { default: e };
}
var yie = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, mie.default)(e, t);
}, nr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = yie(function(r) {
        nr.scrollHandler(e);
      }, t);
      return nr.scrollSpyContainers.push(e), (0, jS.addPassiveEventListener)(e, "scroll", n), function() {
        (0, jS.removePassiveEventListener)(e, "scroll", n), nr.scrollSpyContainers.splice(nr.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return nr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = nr.scrollSpyContainers[nr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(nr.currentPositionX(e), nr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    nr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = nr.scrollSpyContainers[nr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    nr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    nr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), nr.spySetState && nr.spySetState.length && nr.spySetState.indexOf(e) > -1 && nr.spySetState.splice(nr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", nr.scrollHandler);
  },
  update: function() {
    return nr.scrollSpyContainers.forEach(function(e) {
      return nr.scrollHandler(e);
    });
  }
};
kc.default = nr;
var pl = {}, Lc = {};
Object.defineProperty(Lc, "__esModule", {
  value: !0
});
var bie = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, wie = function() {
  return window.location.hash.replace(/^#/, "");
}, Cie = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, xie = function(e) {
  return getComputedStyle(e).position !== "static";
}, _v = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, Eie = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (xie(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = _v(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return _v(t, s).offsetTop - _v(e, s).offsetTop;
};
Lc.default = {
  updateHash: bie,
  getHash: wie,
  filterElementInContainer: Cie,
  scrollOffset: Eie
};
var Rg = {}, RC = {};
Object.defineProperty(RC, "__esModule", {
  value: !0
});
RC.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var IC = {};
Object.defineProperty(IC, "__esModule", {
  value: !0
});
var Oie = _c, kie = ["mousedown", "wheel", "touchmove", "keydown"];
IC.default = {
  subscribe: function(e) {
    return typeof document < "u" && kie.forEach(function(t) {
      return (0, Oie.addPassiveEventListener)(document, t, e);
    });
  }
};
var Pc = {};
Object.defineProperty(Pc, "__esModule", {
  value: !0
});
var Gb = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Gb.registered[e] = t;
    },
    remove: function(e) {
      Gb.registered[e] = null;
    }
  }
};
Pc.default = Gb;
Object.defineProperty(Rg, "__esModule", {
  value: !0
});
var _ie = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Lie = Lc;
Ig(Lie);
var Pie = RC, AS = Ig(Pie), Sie = IC, Die = Ig(Sie), Mie = Pc, Zo = Ig(Mie);
function Ig(e) {
  return e && e.__esModule ? e : { default: e };
}
var iz = function(e) {
  return AS.default[e.smooth] || AS.default.defaultEasing;
}, Tie = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, jie = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, qb = function() {
  return jie() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), sz = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, az = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, lz = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, Aie = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, Bie = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Rie = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Zo.default.registered.end && Zo.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    qb.call(window, i);
    return;
  }
  Zo.default.registered.end && Zo.default.registered.end(o.to, o.target, o.currentPosition);
}, NC = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Sc = function(e, t, n, r) {
  t.data = t.data || sz(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (Die.default.subscribe(o), NC(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? az(t) : lz(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Zo.default.registered.end && Zo.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = Tie(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = iz(t), a = Rie.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Zo.default.registered.begin && Zo.default.registered.begin(t.data.to, t.data.target), qb.call(window, a);
    }, t.delay);
    return;
  }
  Zo.default.registered.begin && Zo.default.registered.begin(t.data.to, t.data.target), qb.call(window, a);
}, Ng = function(e) {
  return e = _ie({}, e), e.data = e.data || sz(), e.absolute = !0, e;
}, Iie = function(e) {
  Sc(0, Ng(e));
}, Nie = function(e, t) {
  Sc(e, Ng(t));
}, Fie = function(e) {
  e = Ng(e), NC(e), Sc(e.horizontal ? Aie(e) : Bie(e), e);
}, zie = function(e, t) {
  t = Ng(t), NC(t);
  var n = t.horizontal ? az(t) : lz(t);
  Sc(e + n, t);
};
Rg.default = {
  animateTopScroll: Sc,
  getAnimationType: iz,
  scrollToTop: Iie,
  scrollToBottom: Fie,
  scrollTo: Nie,
  scrollMore: zie
};
Object.defineProperty(pl, "__esModule", {
  value: !0
});
var Uie = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, $ie = Lc, Wie = FC($ie), Vie = Rg, Hie = FC(Vie), Gie = Pc, Hp = FC(Gie);
function FC(e) {
  return e && e.__esModule ? e : { default: e };
}
var Gp = {}, BS = void 0;
pl.default = {
  unmount: function() {
    Gp = {};
  },
  register: function(e, t) {
    Gp[e] = t;
  },
  unregister: function(e) {
    delete Gp[e];
  },
  get: function(e) {
    return Gp[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return BS = e;
  },
  getActiveLink: function() {
    return BS;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Uie({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = Wie.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Hp.default.registered.begin && Hp.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Hp.default.registered.end && Hp.default.registered.end(e, n);
      return;
    }
    Hie.default.animateTopScroll(s, t, e, n);
  }
};
var Zb = { exports: {} }, Lv = { exports: {} }, ln = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var RS;
function qie() {
  if (RS) return ln;
  RS = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function S(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(y) {
    return S(y) === u;
  }
  return ln.AsyncMode = l, ln.ConcurrentMode = u, ln.ContextConsumer = s, ln.ContextProvider = a, ln.Element = t, ln.ForwardRef = c, ln.Fragment = r, ln.Lazy = f, ln.Memo = g, ln.Portal = n, ln.Profiler = i, ln.StrictMode = o, ln.Suspense = p, ln.isAsyncMode = function(y) {
    return x(y) || S(y) === l;
  }, ln.isConcurrentMode = x, ln.isContextConsumer = function(y) {
    return S(y) === s;
  }, ln.isContextProvider = function(y) {
    return S(y) === a;
  }, ln.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, ln.isForwardRef = function(y) {
    return S(y) === c;
  }, ln.isFragment = function(y) {
    return S(y) === r;
  }, ln.isLazy = function(y) {
    return S(y) === f;
  }, ln.isMemo = function(y) {
    return S(y) === g;
  }, ln.isPortal = function(y) {
    return S(y) === n;
  }, ln.isProfiler = function(y) {
    return S(y) === i;
  }, ln.isStrictMode = function(y) {
    return S(y) === o;
  }, ln.isSuspense = function(y) {
    return S(y) === p;
  }, ln.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === g || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === h || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, ln.typeOf = S, ln;
}
var mn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var IS;
function Zie() {
  return IS || (IS = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function S(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === g || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === h || N.$$typeof === E || N.$$typeof === w || N.$$typeof === m);
    }
    function x(N) {
      if (typeof N == "object" && N !== null) {
        var le = N.$$typeof;
        switch (le) {
          case t:
            var ye = N.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var y = l, C = u, P = s, F = a, _ = t, I = c, B = r, $ = f, V = g, z = n, H = i, X = o, J = p, te = !1;
    function ee(N) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), L(N) || x(N) === l;
    }
    function L(N) {
      return x(N) === u;
    }
    function T(N) {
      return x(N) === s;
    }
    function W(N) {
      return x(N) === a;
    }
    function D(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function G(N) {
      return x(N) === c;
    }
    function O(N) {
      return x(N) === r;
    }
    function M(N) {
      return x(N) === f;
    }
    function U(N) {
      return x(N) === g;
    }
    function j(N) {
      return x(N) === n;
    }
    function Z(N) {
      return x(N) === i;
    }
    function A(N) {
      return x(N) === o;
    }
    function Q(N) {
      return x(N) === p;
    }
    mn.AsyncMode = y, mn.ConcurrentMode = C, mn.ContextConsumer = P, mn.ContextProvider = F, mn.Element = _, mn.ForwardRef = I, mn.Fragment = B, mn.Lazy = $, mn.Memo = V, mn.Portal = z, mn.Profiler = H, mn.StrictMode = X, mn.Suspense = J, mn.isAsyncMode = ee, mn.isConcurrentMode = L, mn.isContextConsumer = T, mn.isContextProvider = W, mn.isElement = D, mn.isForwardRef = G, mn.isFragment = O, mn.isLazy = M, mn.isMemo = U, mn.isPortal = j, mn.isProfiler = Z, mn.isStrictMode = A, mn.isSuspense = Q, mn.isValidElementType = S, mn.typeOf = x;
  }()), mn;
}
var NS;
function uz() {
  return NS || (NS = 1, process.env.NODE_ENV === "production" ? Lv.exports = qie() : Lv.exports = Zie()), Lv.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Pv, FS;
function Kie() {
  if (FS) return Pv;
  FS = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Pv = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, Pv;
}
var Sv, zS;
function zC() {
  if (zS) return Sv;
  zS = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Sv = e, Sv;
}
var US, $S;
function cz() {
  return $S || ($S = 1, US = Function.call.bind(Object.prototype.hasOwnProperty)), US;
}
var Dv, WS;
function Xie() {
  if (WS) return Dv;
  WS = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = zC(), n = {}, r = cz();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Dv = o, Dv;
}
var Mv, VS;
function Yie() {
  if (VS) return Mv;
  VS = 1;
  var e = uz(), t = Kie(), n = zC(), r = cz(), o = Xie(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Mv = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(L) {
      var T = L && (u && L[u] || L[c]);
      if (typeof T == "function")
        return T;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: S,
      element: x(),
      elementType: y(),
      instanceOf: C,
      node: I(),
      objectOf: F,
      oneOf: P,
      oneOfType: _,
      shape: $,
      exact: V
    };
    function f(L, T) {
      return L === T ? L !== 0 || 1 / L === 1 / T : L !== L && T !== T;
    }
    function m(L, T) {
      this.message = L, this.data = T && typeof T == "object" ? T : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function h(L) {
      if (process.env.NODE_ENV !== "production")
        var T = {}, W = 0;
      function D(O, M, U, j, Z, A, Q) {
        if (j = j || d, A = A || U, Q !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + U;
            !T[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            W < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), T[le] = !0, W++);
          }
        }
        return M[U] == null ? O ? M[U] === null ? new m("The " + Z + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new m("The " + Z + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : L(M, U, j, Z, A);
      }
      var G = D.bind(null, !1);
      return G.isRequired = D.bind(null, !0), G;
    }
    function E(L) {
      function T(W, D, G, O, M, U) {
        var j = W[D], Z = X(j);
        if (Z !== L) {
          var A = J(j);
          return new m(
            "Invalid " + O + " `" + M + "` of type " + ("`" + A + "` supplied to `" + G + "`, expected ") + ("`" + L + "`."),
            { expectedType: L }
          );
        }
        return null;
      }
      return h(T);
    }
    function w() {
      return h(a);
    }
    function S(L) {
      function T(W, D, G, O, M) {
        if (typeof L != "function")
          return new m("Property `" + M + "` of component `" + G + "` has invalid PropType notation inside arrayOf.");
        var U = W[D];
        if (!Array.isArray(U)) {
          var j = X(U);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an array."));
        }
        for (var Z = 0; Z < U.length; Z++) {
          var A = L(U, Z, G, O, M + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return h(T);
    }
    function x() {
      function L(T, W, D, G, O) {
        var M = T[W];
        if (!s(M)) {
          var U = X(M);
          return new m("Invalid " + G + " `" + O + "` of type " + ("`" + U + "` supplied to `" + D + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(L);
    }
    function y() {
      function L(T, W, D, G, O) {
        var M = T[W];
        if (!e.isValidElementType(M)) {
          var U = X(M);
          return new m("Invalid " + G + " `" + O + "` of type " + ("`" + U + "` supplied to `" + D + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(L);
    }
    function C(L) {
      function T(W, D, G, O, M) {
        if (!(W[D] instanceof L)) {
          var U = L.name || d, j = ee(W[D]);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return h(T);
    }
    function P(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function T(W, D, G, O, M) {
        for (var U = W[D], j = 0; j < L.length; j++)
          if (f(U, L[j]))
            return null;
        var Z = JSON.stringify(L, function(A, Q) {
          var N = J(Q);
          return N === "symbol" ? String(Q) : Q;
        });
        return new m("Invalid " + O + " `" + M + "` of value `" + String(U) + "` " + ("supplied to `" + G + "`, expected one of " + Z + "."));
      }
      return h(T);
    }
    function F(L) {
      function T(W, D, G, O, M) {
        if (typeof L != "function")
          return new m("Property `" + M + "` of component `" + G + "` has invalid PropType notation inside objectOf.");
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an object."));
        for (var Z in U)
          if (r(U, Z)) {
            var A = L(U, Z, G, O, M + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return h(T);
    }
    function _(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var T = 0; T < L.length; T++) {
        var W = L[T];
        if (typeof W != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(W) + " at index " + T + "."
          ), a;
      }
      function D(G, O, M, U, j) {
        for (var Z = [], A = 0; A < L.length; A++) {
          var Q = L[A], N = Q(G, O, M, U, j, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && Z.push(N.data.expectedType);
        }
        var le = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + j + "` supplied to " + ("`" + M + "`" + le + "."));
      }
      return h(D);
    }
    function I() {
      function L(T, W, D, G, O) {
        return z(T[W]) ? null : new m("Invalid " + G + " `" + O + "` supplied to " + ("`" + D + "`, expected a ReactNode."));
      }
      return h(L);
    }
    function B(L, T, W, D, G) {
      return new m(
        (L || "React class") + ": " + T + " type `" + W + "." + D + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + G + "`."
      );
    }
    function $(L) {
      function T(W, D, G, O, M) {
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        for (var Z in L) {
          var A = L[Z];
          if (typeof A != "function")
            return B(G, O, M, Z, J(A));
          var Q = A(U, Z, G, O, M + "." + Z, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(T);
    }
    function V(L) {
      function T(W, D, G, O, M) {
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        var Z = t({}, W[D], L);
        for (var A in Z) {
          var Q = L[A];
          if (r(L, A) && typeof Q != "function")
            return B(G, O, M, A, J(Q));
          if (!Q)
            return new m(
              "Invalid " + O + " `" + M + "` key `" + A + "` supplied to `" + G + "`.\nBad object: " + JSON.stringify(W[D], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(L), null, "  ")
            );
          var N = Q(U, A, G, O, M + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return h(T);
    }
    function z(L) {
      switch (typeof L) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !L;
        case "object":
          if (Array.isArray(L))
            return L.every(z);
          if (L === null || s(L))
            return !0;
          var T = p(L);
          if (T) {
            var W = T.call(L), D;
            if (T !== L.entries) {
              for (; !(D = W.next()).done; )
                if (!z(D.value))
                  return !1;
            } else
              for (; !(D = W.next()).done; ) {
                var G = D.value;
                if (G && !z(G[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function H(L, T) {
      return L === "symbol" ? !0 : T ? T["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && T instanceof Symbol : !1;
    }
    function X(L) {
      var T = typeof L;
      return Array.isArray(L) ? "array" : L instanceof RegExp ? "object" : H(T, L) ? "symbol" : T;
    }
    function J(L) {
      if (typeof L > "u" || L === null)
        return "" + L;
      var T = X(L);
      if (T === "object") {
        if (L instanceof Date)
          return "date";
        if (L instanceof RegExp)
          return "regexp";
      }
      return T;
    }
    function te(L) {
      var T = J(L);
      switch (T) {
        case "array":
        case "object":
          return "an " + T;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + T;
        default:
          return T;
      }
    }
    function ee(L) {
      return !L.constructor || !L.constructor.name ? d : L.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, Mv;
}
var Tv, HS;
function Jie() {
  if (HS) return Tv;
  HS = 1;
  var e = zC();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Tv = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Tv;
}
if (process.env.NODE_ENV !== "production") {
  var Qie = uz(), ese = !0;
  Zb.exports = Yie()(Qie.isElement, ese);
} else
  Zb.exports = Jie()();
var Fg = Zb.exports, zg = {};
Object.defineProperty(zg, "__esModule", {
  value: !0
});
var tse = Lc, jv = nse(tse);
function nse(e) {
  return e && e.__esModule ? e : { default: e };
}
var rse = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return jv.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && jv.default.getHash() !== e && jv.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
zg.default = rse;
Object.defineProperty(Oc, "__esModule", {
  value: !0
});
var qp = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ose = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ise = Oe, GS = Dc(ise), sse = kc, Zp = Dc(sse), ase = pl, lse = Dc(ase), use = Fg, Zn = Dc(use), cse = zg, Gi = Dc(cse);
function Dc(e) {
  return e && e.__esModule ? e : { default: e };
}
function pse(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function dse(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function fse(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var qS = {
  to: Zn.default.string.isRequired,
  containerId: Zn.default.string,
  container: Zn.default.object,
  activeClass: Zn.default.string,
  activeStyle: Zn.default.object,
  spy: Zn.default.bool,
  horizontal: Zn.default.bool,
  smooth: Zn.default.oneOfType([Zn.default.bool, Zn.default.string]),
  offset: Zn.default.number,
  delay: Zn.default.number,
  isDynamic: Zn.default.bool,
  onClick: Zn.default.func,
  duration: Zn.default.oneOfType([Zn.default.number, Zn.default.func]),
  absolute: Zn.default.bool,
  onSetActive: Zn.default.func,
  onSetInactive: Zn.default.func,
  ignoreCancelEvents: Zn.default.bool,
  hashSpy: Zn.default.bool,
  saveHashHistory: Zn.default.bool,
  spyThrottle: Zn.default.number
};
Oc.default = function(e, t) {
  var n = t || lse.default, r = function(i) {
    fse(a, i);
    function a(s) {
      pse(this, a);
      var l = dse(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return ose(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Zp.default.isMounted(s)) {
            var l = Zp.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (Gi.default.isMounted() || Gi.default.mount(n), Gi.default.mapContainer(this.props.to, s)), Zp.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Zp.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = qp({}, this.props.style, this.props.activeStyle) : l = qp({}, this.props.style);
        var u = qp({}, this.props);
        for (var c in qS)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, GS.default.createElement(e, u);
      }
    }]), a;
  }(GS.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, qp({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Gi.default.isMounted() && !Gi.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, h = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            h = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - h + a, m = f + w.width;
          }
          var S = a - i.props.offset;
          d = S >= Math.floor(f) && S < Math.floor(m), g = S < Math.floor(f) || S >= Math.floor(m);
        } else {
          var x = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, y = x + F.height;
          }
          var _ = s - i.props.offset;
          d = _ >= Math.floor(x) && _ < Math.floor(y), g = _ < Math.floor(x) || _ >= Math.floor(y);
        }
        var I = n.getActiveLink();
        if (g) {
          if (c === I && n.setActiveLink(void 0), i.props.hashSpy && Gi.default.getHash() === c) {
            var B = i.props.saveHashHistory, $ = B === void 0 ? !1 : B;
            Gi.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (I !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && Gi.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = qS, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(BC, "__esModule", {
  value: !0
});
var hse = Oe, ZS = pz(hse), gse = Oc, mse = pz(gse);
function pz(e) {
  return e && e.__esModule ? e : { default: e };
}
function vse(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function KS(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function yse(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var bse = function(e) {
  yse(t, e);
  function t() {
    var n, r, o, i;
    vse(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = KS(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return ZS.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), KS(o, i);
  }
  return t;
}(ZS.default.Component);
BC.default = (0, mse.default)(bse);
var UC = {};
Object.defineProperty(UC, "__esModule", {
  value: !0
});
var wse = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Cse = Oe, XS = dz(Cse), xse = Oc, Ese = dz(xse);
function dz(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ose(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function kse(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function _se(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Lse = function(e) {
  _se(t, e);
  function t() {
    return Ose(this, t), kse(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return wse(t, [{
    key: "render",
    value: function() {
      return XS.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(XS.default.Component);
UC.default = (0, Ese.default)(Lse);
var $C = {}, Ug = {};
Object.defineProperty(Ug, "__esModule", {
  value: !0
});
var Pse = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Sse = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Dse = Oe, YS = $g(Dse), Mse = tl;
$g(Mse);
var Tse = pl, JS = $g(Tse), jse = Fg, QS = $g(jse);
function $g(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ase(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Bse(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Rse(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Ug.default = function(e) {
  var t = function(n) {
    Rse(r, n);
    function r(o) {
      Ase(this, r);
      var i = Bse(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Sse(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        JS.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        JS.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return YS.default.createElement(e, Pse({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(YS.default.Component);
  return t.propTypes = {
    name: QS.default.string,
    id: QS.default.string
  }, t;
};
Object.defineProperty($C, "__esModule", {
  value: !0
});
var eD = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Ise = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Nse = Oe, tD = WC(Nse), Fse = Ug, zse = WC(Fse), Use = Fg, nD = WC(Use);
function WC(e) {
  return e && e.__esModule ? e : { default: e };
}
function $se(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Wse(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Vse(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var fz = function(e) {
  Vse(t, e);
  function t() {
    return $se(this, t), Wse(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Ise(t, [{
    key: "render",
    value: function() {
      var n = this, r = eD({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, tD.default.createElement(
        "div",
        eD({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(tD.default.Component);
fz.propTypes = {
  name: nD.default.string,
  id: nD.default.string
};
$C.default = (0, zse.default)(fz);
var Av = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, rD = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function oD(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function iD(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function sD(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Kp = Oe, zs = kc, Bv = pl, ar = Fg, qi = zg, aD = {
  to: ar.string.isRequired,
  containerId: ar.string,
  container: ar.object,
  activeClass: ar.string,
  spy: ar.bool,
  smooth: ar.oneOfType([ar.bool, ar.string]),
  offset: ar.number,
  delay: ar.number,
  isDynamic: ar.bool,
  onClick: ar.func,
  duration: ar.oneOfType([ar.number, ar.func]),
  absolute: ar.bool,
  onSetActive: ar.func,
  onSetInactive: ar.func,
  ignoreCancelEvents: ar.bool,
  hashSpy: ar.bool,
  spyThrottle: ar.number
}, Hse = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Bv, r = function(i) {
      sD(a, i);
      function a(s) {
        oD(this, a);
        var l = iD(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return rD(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            zs.isMounted(s) || zs.mount(s, this.props.spyThrottle), this.props.hashSpy && (qi.isMounted() || qi.mount(n), qi.mapContainer(this.props.to, s)), this.props.spy && zs.addStateHandler(this.stateHandler), zs.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          zs.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = Av({}, this.props);
          for (var u in aD)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Kp.createElement(e, l);
        }
      }]), a;
    }(Kp.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, Av({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(qi.isMounted() && !qi.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, h = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && qi.getHash() === l && qi.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), zs.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && qi.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), zs.updateStates();
        }
      };
    };
    return r.propTypes = aD, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      sD(r, n);
      function r(o) {
        oD(this, r);
        var i = iD(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return rD(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Bv.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Bv.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Kp.createElement(e, Av({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Kp.Component);
    return t.propTypes = {
      name: ar.string,
      id: ar.string
    }, t;
  }
}, Gse = Hse;
Object.defineProperty(mr, "__esModule", {
  value: !0
});
mr.Helpers = mr.ScrollElement = mr.ScrollLink = mr.animateScroll = mr.scrollSpy = mr.Events = mr.scroller = mr.Element = mr.Button = mr.Link = void 0;
var qse = BC, hz = ai(qse), Zse = UC, gz = ai(Zse), Kse = $C, mz = ai(Kse), Xse = pl, vz = ai(Xse), Yse = Pc, yz = ai(Yse), Jse = kc, bz = ai(Jse), Qse = Rg, wz = ai(Qse), eae = Oc, Cz = ai(eae), tae = Ug, xz = ai(tae), nae = Gse, Ez = ai(nae);
function ai(e) {
  return e && e.__esModule ? e : { default: e };
}
mr.Link = hz.default;
mr.Button = gz.default;
mr.Element = mz.default;
mr.scroller = vz.default;
mr.Events = yz.default;
mr.scrollSpy = bz.default;
mr.animateScroll = wz.default;
mr.ScrollLink = Cz.default;
mr.ScrollElement = xz.default;
mr.Helpers = Ez.default;
mr.default = { Link: hz.default, Button: gz.default, Element: mz.default, scroller: vz.default, Events: yz.default, scrollSpy: bz.default, animateScroll: wz.default, ScrollLink: Cz.default, ScrollElement: xz.default, Helpers: Ez.default };
qe({});
qe({});
qe({});
function ec(e) {
  "@babel/helpers - typeof";
  return ec = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ec(e);
}
function rae(e, t) {
  if (ec(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (ec(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function oae(e) {
  var t = rae(e, "string");
  return ec(t) == "symbol" ? t : t + "";
}
function me(e, t, n) {
  return (t = oae(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Oz(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Rv, lD;
function iae() {
  if (lD) return Rv;
  lD = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Rv = t, Rv;
}
var sae = iae(), Or = /* @__PURE__ */ Oz(sae), vt = qe(null);
function aae() {
  Or(!!Ee, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Ee(vt);
  return Or(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function lae(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function uae(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function cae(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return uae(e, i), o;
}
function pae(e, t, n) {
  var r = lae(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function dae(e) {
  google.maps.event.removeListener(e);
}
function qt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(dae);
}
function Wt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = pae(o, i, n);
  return cae(t, r, o, i), a;
}
function fae(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: h,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: S,
    onUnmount: x
  } = e, [y, C] = k(null), P = Qe(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null), [A, Q] = k(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), v(() => {
    y && l && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && m && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && g && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(y, "mouseout", g)));
  }, [g]), v(() => {
    y && f && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && h && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && E && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), v(() => {
    y && s && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(y, "click", s)));
  }, [s]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), v(() => {
    var N = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(N), N !== null && S && S(N), () => {
      N !== null && x && x(N);
    };
  }, []), Sr.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: Sr.jsx(vt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
ke(fae);
function uD(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function kz(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        uD(i, r, o, a, s, "next", l);
      }
      function s(l) {
        uD(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function _z(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Or(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var sa = typeof document < "u";
function Lz(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return sa ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function cD(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Pz() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return cD(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return cD(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Al = !1;
function Sz() {
  return Sr.jsx("div", {
    children: "Loading..."
  });
}
var Kb = {
  id: "script-loader",
  version: "weekly"
};
class hae extends be {
  constructor() {
    super(...arguments), me(this, "check", null), me(this, "state", {
      loaded: !1
    }), me(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), me(this, "isCleaningUp", /* @__PURE__ */ kz(function* () {
      function t(n) {
        if (!Al)
          n();
        else if (sa)
          var r = window.setInterval(function() {
            Al || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), me(this, "cleanup", () => {
      Al = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), me(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Pz(), Or(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: _z(this.props)
      };
      Lz(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), me(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (sa) {
      if (window.google && window.google.maps && !Al) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), sa && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (sa) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Al = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Sr.jsxs(Sr.Fragment, {
      children: [Sr.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Sr.jsx(Sz, {})]
    });
  }
}
me(hae, "defaultProps", Kb);
function gae(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function VC(e, t) {
  if (e == null) return {};
  var n, r, o = gae(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var pD;
function mae(e) {
  var {
    id: t = Kb.id,
    version: n = Kb.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = Qe(!1), [f, m] = k(!1), [h, E] = k(void 0);
  v(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), v(function() {
    sa && u && Pz();
  }, [u]), v(function() {
    f && Or(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = _z({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!sa)
      return;
    function x() {
      g.current && (m(!0), pD = w);
    }
    if (window.google && window.google.maps && pD === w) {
      x();
      return;
    }
    Lz({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(y) {
      g.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var S = Qe(void 0);
  return v(function() {
    S.current && l !== S.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), S.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var vae = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], yae = Sr.jsx(Sz, {});
function bae(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = VC(e, vae), {
    isLoaded: s,
    loadError: l
  } = mae(a);
  return v(function() {
    s && typeof n == "function" && n();
  }, [s, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || yae;
}
ke(bae);
var dD;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(dD || (dD = {}));
function fD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fD(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hD = {}, gD = {
  options(e, t) {
    e.setOptions(t);
  }
};
function wae(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = Ee(vt), [i, a] = k(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var s = new google.maps.TrafficLayer(Rf(Rf({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ke(wae);
class Cae extends be {
  constructor() {
    super(...arguments), me(this, "state", {
      trafficLayer: null
    }), me(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), me(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Rf(Rf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Wt({
      updaterMap: gD,
      eventMap: hD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: gD,
      eventMap: hD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), qt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
me(Cae, "contextType", vt);
function xae(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Ee(vt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ke(xae);
class Eae extends be {
  constructor() {
    super(...arguments), me(this, "state", {
      bicyclingLayer: null
    }), me(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
me(Eae, "contextType", vt);
function Oae(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Ee(vt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ke(Oae);
class kae extends be {
  constructor() {
    super(...arguments), me(this, "state", {
      transitLayer: null
    }), me(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
me(kae, "contextType", vt);
function mD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function If(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mD(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vD = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, yD = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function _ae(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = Ee(vt), [d, g] = k(null), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), v(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), v(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    Or(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var I = new google.maps.drawing.DrawingManager(If(If({}, t), {}, {
      map: p
    }));
    return n && I.setDrawingMode(n), r && m(google.maps.event.addListener(I, "circlecomplete", r)), o && E(google.maps.event.addListener(I, "markercomplete", o)), i && S(google.maps.event.addListener(I, "overlaycomplete", i)), a && y(google.maps.event.addListener(I, "polygoncomplete", a)), s && P(google.maps.event.addListener(I, "polylinecomplete", s)), l && _(google.maps.event.addListener(I, "rectanglecomplete", l)), g(I), u && u(I), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ke(_ae);
class Lae extends be {
  constructor(t) {
    super(t), me(this, "registeredEvents", []), me(this, "state", {
      drawingManager: null
    }), me(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Or(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(If(If({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Wt({
      updaterMap: yD,
      eventMap: vD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: yD,
      eventMap: vD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), qt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
me(Lae, "contextType", vt);
function bD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $a(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bD(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wD = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, CD = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Nf = {};
function Pae(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: h,
    onClick: E,
    onDblClick: w,
    onDrag: S,
    onDragEnd: x,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: _,
    onRightClick: I,
    onClickableChanged: B,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: H,
    onIconChanged: X,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: L,
    onZindexChanged: T,
    onLoad: W,
    onUnmount: D
  } = e, G = Ee(vt), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, N] = k(null), [le, ye] = k(null), [oe, Be] = k(null), [Ue, $e] = k(null), [Ie, Je] = k(null), [Ze, Me] = k(null), [Ye, nt] = k(null), [De, je] = k(null), [Ke, We] = k(null), [Fe, et] = k(null), [Re, Rt] = k(null), [rt, ot] = k(null), [at, Kt] = k(null), [lt, ut] = k(null), [tt, Xe] = k(null), [Xt, Yt] = k(null), [bt, Rn] = k(null), [wt, In] = k(null), [Ct, fn] = k(null);
  v(() => {
    O !== null && O.setMap(G);
  }, [G]), v(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), v(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), v(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), v(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), v(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), v(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), v(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), v(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), v(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), v(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), v(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), v(() => {
    O && h !== void 0 && O.setZIndex(h);
  }, [O, h]), v(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), v(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), v(() => {
    O && y && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(O, "dragstart", y)));
  }, [y]), v(() => {
    O && _ && (le !== null && google.maps.event.removeListener(le), ye(google.maps.event.addListener(O, "mousedown", _)));
  }, [_]), v(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Be(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), v(() => {
    O && P && (Ue !== null && google.maps.event.removeListener(Ue), $e(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), v(() => {
    O && F && (Ie !== null && google.maps.event.removeListener(Ie), Je(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), v(() => {
    O && I && (Ze !== null && google.maps.event.removeListener(Ze), Me(google.maps.event.addListener(O, "rightclick", I)));
  }, [I]), v(() => {
    O && E && (Ye !== null && google.maps.event.removeListener(Ye), nt(google.maps.event.addListener(O, "click", E)));
  }, [E]), v(() => {
    O && S && (De !== null && google.maps.event.removeListener(De), je(google.maps.event.addListener(O, "drag", S)));
  }, [S]), v(() => {
    O && B && (Ke !== null && google.maps.event.removeListener(Ke), We(google.maps.event.addListener(O, "clickable_changed", B)));
  }, [B]), v(() => {
    O && $ && (Fe !== null && google.maps.event.removeListener(Fe), et(google.maps.event.addListener(O, "cursor_changed", $)));
  }, [$]), v(() => {
    O && V && (Re !== null && google.maps.event.removeListener(Re), Rt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), v(() => {
    O && z && (rt !== null && google.maps.event.removeListener(rt), ot(google.maps.event.addListener(O, "draggable_changed", z)));
  }, [z]), v(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), Kt(google.maps.event.addListener(O, "flat_changed", H)));
  }, [H]), v(() => {
    O && X && (lt !== null && google.maps.event.removeListener(lt), ut(google.maps.event.addListener(O, "icon_changed", X)));
  }, [X]), v(() => {
    O && J && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(O, "position_changed", J)));
  }, [J]), v(() => {
    O && te && (Xt !== null && google.maps.event.removeListener(Xt), Yt(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), v(() => {
    O && ee && (bt !== null && google.maps.event.removeListener(bt), Rn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), v(() => {
    O && L && (wt !== null && google.maps.event.removeListener(wt), In(google.maps.event.addListener(O, "visible_changed", L)));
  }, [L]), v(() => {
    O && T && (Ct !== null && google.maps.event.removeListener(Ct), fn(google.maps.event.addListener(O, "zindex_changed", T)));
  }, [T]), v(() => {
    var xt = $a($a($a({}, n || Nf), r ? Nf : {
      map: G
    }), {}, {
      position: t
    }), re = new google.maps.Marker(xt);
    return r ? r.addMarker(re, !!o) : re.setMap(G), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof h == "number" && re.setZIndex(h), w && j(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), y && N(google.maps.event.addListener(re, "dragstart", y)), _ && ye(google.maps.event.addListener(re, "mousedown", _)), C && Be(google.maps.event.addListener(re, "mouseout", C)), P && $e(google.maps.event.addListener(re, "mouseover", P)), F && Je(google.maps.event.addListener(re, "mouseup", F)), I && Me(google.maps.event.addListener(re, "rightclick", I)), E && nt(google.maps.event.addListener(re, "click", E)), S && je(google.maps.event.addListener(re, "drag", S)), B && We(google.maps.event.addListener(re, "clickable_changed", B)), $ && et(google.maps.event.addListener(re, "cursor_changed", $)), V && Rt(google.maps.event.addListener(re, "animation_changed", V)), z && ot(google.maps.event.addListener(re, "draggable_changed", z)), H && Kt(google.maps.event.addListener(re, "flat_changed", H)), X && ut(google.maps.event.addListener(re, "icon_changed", X)), J && Xe(google.maps.event.addListener(re, "position_changed", J)), te && Yt(google.maps.event.addListener(re, "shape_changed", te)), ee && Rn(google.maps.event.addListener(re, "title_changed", ee)), L && In(google.maps.event.addListener(re, "visible_changed", L)), T && fn(google.maps.event.addListener(re, "zindex_changed", T)), M(re), W && W(re), () => {
      U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), Q !== null && google.maps.event.removeListener(Q), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), Ie !== null && google.maps.event.removeListener(Ie), Ze !== null && google.maps.event.removeListener(Ze), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Fe !== null && google.maps.event.removeListener(Fe), Re !== null && google.maps.event.removeListener(Re), rt !== null && google.maps.event.removeListener(rt), at !== null && google.maps.event.removeListener(at), lt !== null && google.maps.event.removeListener(lt), tt !== null && google.maps.event.removeListener(tt), bt !== null && google.maps.event.removeListener(bt), wt !== null && google.maps.event.removeListener(wt), Ct !== null && google.maps.event.removeListener(Ct), D && D(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var wr = Bn(() => i ? it.map(i, (xt) => {
    if (!ti(xt))
      return xt;
    var re = xt;
    return ni(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return Sr.jsx(Sr.Fragment, {
    children: wr
  }) || null;
}
ke(Pae);
class Sae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return kz(function* () {
      var n = $a($a($a({}, t.props.options || Nf), t.props.clusterer ? Nf : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Wt({
        updaterMap: CD,
        eventMap: wD,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: CD,
      eventMap: wD,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), qt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? it.map(this.props.children, (n) => {
      if (!ti(n))
        return n;
      var r = n;
      return ni(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
me(Sae, "contextType", vt);
var Dae = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), Mae = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Dae(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Tae(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var jae = 2e3, Aae = 500, Bae = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Rae = "png", Iae = [53, 56, 66, 78, 90], Nae = "cluster", Dz = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Bae, this.imageExtension = r.imageExtension || Rae, this.imageSizes = r.imageSizes || Iae, this.calculator = r.calculator || Tae, this.batchSize = r.batchSize || jae, this.batchSizeIE = r.batchSizeIE || Aae, this.clusterClass = r.clusterClass || Nae, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new Mae(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function xD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fae(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xD(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jo = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, tn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, zae = {};
function Uae(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: h,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: S,
    onClusteringEnd: x,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [_, I] = k(null), B = Ee(vt), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null);
  return v(() => {
    _ && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(_, jo.onMouseOut, C)));
  }, [C]), v(() => {
    _ && y && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(_, jo.onMouseOver, y)));
  }, [y]), v(() => {
    _ && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(_, jo.onClick, w)));
  }, [w]), v(() => {
    _ && S && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(_, jo.onClusteringBegin, S)));
  }, [S]), v(() => {
    _ && x && (X !== null && google.maps.event.removeListener(X), H(google.maps.event.addListener(_, jo.onClusteringEnd, x)));
  }, [x]), v(() => {
    typeof r < "u" && _ !== null && tn.averageCenter(_, r);
  }, [_, r]), v(() => {
    typeof o < "u" && _ !== null && tn.batchSizeIE(_, o);
  }, [_, o]), v(() => {
    typeof i < "u" && _ !== null && tn.calculator(_, i);
  }, [_, i]), v(() => {
    typeof a < "u" && _ !== null && tn.clusterClass(_, a);
  }, [_, a]), v(() => {
    typeof s < "u" && _ !== null && tn.enableRetinaIcons(_, s);
  }, [_, s]), v(() => {
    typeof l < "u" && _ !== null && tn.gridSize(_, l);
  }, [_, l]), v(() => {
    typeof u < "u" && _ !== null && tn.ignoreHidden(_, u);
  }, [_, u]), v(() => {
    typeof c < "u" && _ !== null && tn.imageExtension(_, c);
  }, [_, c]), v(() => {
    typeof p < "u" && _ !== null && tn.imagePath(_, p);
  }, [_, p]), v(() => {
    typeof d < "u" && _ !== null && tn.imageSizes(_, d);
  }, [_, d]), v(() => {
    typeof g < "u" && _ !== null && tn.maxZoom(_, g);
  }, [_, g]), v(() => {
    typeof f < "u" && _ !== null && tn.minimumClusterSize(_, f);
  }, [_, f]), v(() => {
    typeof m < "u" && _ !== null && tn.styles(_, m);
  }, [_, m]), v(() => {
    typeof h < "u" && _ !== null && tn.title(_, h);
  }, [_, h]), v(() => {
    typeof E < "u" && _ !== null && tn.zoomOnClick(_, E);
  }, [_, E]), v(() => {
    if (B) {
      var W = Fae({}, n || zae), D = new Dz(B, [], W);
      return r && tn.averageCenter(D, r), o && tn.batchSizeIE(D, o), i && tn.calculator(D, i), a && tn.clusterClass(D, a), s && tn.enableRetinaIcons(D, s), l && tn.gridSize(D, l), u && tn.ignoreHidden(D, u), c && tn.imageExtension(D, c), p && tn.imagePath(D, p), d && tn.imageSizes(D, d), g && tn.maxZoom(D, g), f && tn.minimumClusterSize(D, f), m && tn.styles(D, m), h && tn.title(D, h), E && tn.zoomOnClick(D, E), C && ee(google.maps.event.addListener(D, jo.onMouseOut, C)), y && T(google.maps.event.addListener(D, jo.onMouseOver, y)), w && V(google.maps.event.addListener(D, jo.onClick, w)), S && H(google.maps.event.addListener(D, jo.onClusteringBegin, S)), x && J(google.maps.event.addListener(D, jo.onClusteringEnd, x)), I(D), P && P(D), () => {
        te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), F && F(D);
      };
    }
  }, []), _ !== null && t(_) || null;
}
ke(Uae);
class $ae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      markerClusterer: null
    }), me(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Dz(this.context, [], this.props.options);
      this.registeredEvents = Wt({
        updaterMap: tn,
        eventMap: jo,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: tn,
      eventMap: jo,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), qt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
me($ae, "contextType", vt);
function ED(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Mz = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || ED(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, ED));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), h = m.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + g ? r = h.x + u - g : h.x + p + u + g > s && (r = h.x + p + u + g - s), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Wae = ["position"], Vae = ["position"];
function OD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ff(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OD(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kD = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, _D = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Hae = {};
function Gae(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = Ee(vt), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), I = Qe(null);
  return v(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (g) {
      var B = r || Hae, {
        position: $
      } = B, V = VC(B, Wae), z;
      $ && !($ instanceof google.maps.LatLng) && (z = new google.maps.LatLng($.lat, $.lng));
      var H = new Mz(Ff(Ff({}, V), z ? {
        position: z
      } : {}));
      I.current = document.createElement("div"), m(H), a && E(google.maps.event.addListener(H, "closeclick", a)), s && S(google.maps.event.addListener(H, "domready", s)), l && y(google.maps.event.addListener(H, "content_changed", l)), u && P(google.maps.event.addListener(H, "position_changed", u)), c && _(google.maps.event.addListener(H, "zindex_changed", c)), H.setContent(I.current), n ? H.open(g, n) : H.getPosition() ? H.open(g) : Or(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(H);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), I.current ? br(it.only(t), I.current) : null;
}
ke(Gae);
class qae extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "containerElement", null), me(this, "state", {
      infoBox: null
    }), me(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Or(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), me(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = VC(t, Vae), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Mz(Ff(Ff({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Wt({
      updaterMap: _D,
      eventMap: kD,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: _D,
      eventMap: kD,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), qt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? br(it.only(this.props.children), this.containerElement) : null;
  }
}
me(qae, "contextType", vt);
var LD, PD;
function Zae() {
  return PD || (PD = 1, LD = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), LD;
}
var Kae = Zae(), SD = /* @__PURE__ */ Oz(Kae), DD = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Iv = 1, Bl = 8;
class HC {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Iv)
      throw new Error("Got v".concat(o, " data when expected v").concat(Iv, "."));
    var i = DD[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new HC(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = DD.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Bl, t), this.coords = new this.ArrayType(this.data, Bl + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Bl + a + s + l), this.ids = new this.IndexArrayType(this.data, Bl, t), this.coords = new this.ArrayType(this.data, Bl + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Iv << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Xb(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var h = d + p >> 1, E = a[2 * h], w = a[2 * h + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          MD(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], h = i[2 * f + 1];
      MD(m, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= h) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= h) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function Xb(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Tz(e, t, a, r, o, i), Xb(e, t, n, r, a - 1, 1 - i), Xb(e, t, n, a + 1, o, 1 - i);
  }
}
function Tz(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Tz(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (Rl(e, t, r, n), t[2 * o + i] > g && Rl(e, t, r, o); f < m; ) {
      for (Rl(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? Rl(e, t, r, m) : (m++, Rl(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function Rl(e, t, n, r) {
  Nv(e, n, r), Nv(t, 2 * n, 2 * r), Nv(t, 2 * n + 1, 2 * r + 1);
}
function Nv(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function MD(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Xae = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, TD = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Us = 2, ss = 3, Fv = 4, ts = 5, jz = 6;
class Yae {
  constructor(t) {
    this.options = Object.assign(Object.create(Xae), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = TD(Xp(u)), d = TD(Yp(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Xp(r), Yp(a), Xp(i), Yp(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + ts] > 1 ? jD(p, f, this.clusterProps) : this.points[p[f + ss]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + Fv] === t && p.push(a[g + ts] > 1 ? jD(a, g, this.clusterProps) : this.points[a[g + ss]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new HC(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + ts] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Az(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + ss]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = Xp(f), d = Yp(m);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + ss] : E = this.points[n[l + ss]].id, E !== void 0 && (h.id = E), a.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Us] <= n)) {
        l[p + Us] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + ts], h = m;
        for (var E of f) {
          var w = E * c;
          l[w + Us] > n && (h += l[w + ts]);
        }
        if (h > m && h >= a) {
          var S = d * m, x = g * m, y = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var _ = F * c;
            if (!(l[_ + Us] <= n)) {
              l[_ + Us] = n;
              var I = l[_ + ts];
              S += l[_] * I, x += l[_ + 1] * I, l[_ + Fv] = P, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, _)));
            }
          }
          l[p + Fv] = P, u.push(S / h, x / h, 1 / 0, P, -1, h), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (h > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Us] <= n)) {
                l[V + Us] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ts] > 1) {
      var o = this.clusterProps[t[n + jz]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + ss]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function jD(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ss],
    properties: Az(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [Jae(e[t]), Qae(e[t + 1])]
    }
  };
}
function Az(e, t, n) {
  var r = e[t + ts], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + jz], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + ss],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Xp(e) {
  return e / 360 + 0.5;
}
function Yp(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Jae(e) {
  return (e - 0.5) * 360;
}
function Qae(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function ele(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class yo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Yb {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(yo.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => yo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (yo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class tle {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return nle(n);
  }
}
var nle = (e) => {
  var t = e.map((n) => new Yb({
    position: yo.getPosition(n),
    markers: [n]
  }));
  return t;
};
class rle extends tle {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = ele(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Yae(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!SD(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = yo.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !SD(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Yb({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Yb({
      markers: [i],
      position: yo.getPosition(i)
    });
  }
}
class ole {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class ile {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (yo.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function sle(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class GC {
  constructor() {
    sle(GC, google.maps.OverlayView);
  }
}
var mu;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(mu || (mu = {}));
var ale = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class lle extends GC {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new rle(o),
      renderer: a = new ile(),
      onClusterClick: s = ale
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (yo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, mu.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || yo.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => yo.setMap(l, null)));
      }
      google.maps.event.trigger(this, mu.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => yo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new ole(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => yo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, mu.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), yo.setMap(r.marker, n);
    });
  }
}
function AD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function BD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AD(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function ule(e) {
  var t = aae(), [n, r] = k(null);
  return v(() => {
    if (t && n === null) {
      var o = new lle(BD(BD({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function cle(e) {
  var {
    children: t,
    options: n
  } = e, r = ule(n);
  return r !== null ? t(r) : null;
}
ke(cle);
var RD = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, ID = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function ple(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = Ee(vt), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), I = Qe(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var B = new google.maps.InfoWindow(r);
    return m(B), I.current = document.createElement("div"), a && E(google.maps.event.addListener(B, "closeclick", a)), s && S(google.maps.event.addListener(B, "domready", s)), l && y(google.maps.event.addListener(B, "content_changed", l)), u && P(google.maps.event.addListener(B, "position_changed", u)), c && _(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(I.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(g, n) : B.getPosition() ? B.open(g) : Or(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(B), B.close();
    };
  }, []), I.current ? br(it.only(t), I.current) : null;
}
ke(ple);
class dle extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "containerElement", null), me(this, "state", {
      infoWindow: null
    }), me(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Or(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), me(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Wt({
      updaterMap: ID,
      eventMap: RD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: ID,
      eventMap: RD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (qt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? br(it.only(this.props.children), this.containerElement) : null;
  }
}
me(dle, "contextType", vt);
function ND(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ND(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ND(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FD = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, zD = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, fle = {};
function hle(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onLoad: E,
    onUnmount: w
  } = e, S = Ee(vt), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null);
  return v(() => {
    x !== null && x.setMap(S);
  }, [S]), v(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), v(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), v(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), v(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), v(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), v(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), v(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), v(() => {
    x && l && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), v(() => {
    x && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), v(() => {
    x && c && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), v(() => {
    x && p && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), v(() => {
    x && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), v(() => {
    x && g && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(x, "mouseup", g)));
  }, [g]), v(() => {
    x && f && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), v(() => {
    x && m && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), v(() => {
    x && h && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(x, "drag", h)));
  }, [h]), v(() => {
    var j = new google.maps.Polyline(zf(zf({}, t || fle), {}, {
      map: S
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && P(google.maps.event.addListener(j, "dblclick", a)), s && _(google.maps.event.addListener(j, "dragend", s)), l && B(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && H(google.maps.event.addListener(j, "mousemove", c)), p && J(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), g && T(google.maps.event.addListener(j, "mouseup", g)), f && D(google.maps.event.addListener(j, "rightclick", f)), m && O(google.maps.event.addListener(j, "click", m)), h && U(google.maps.event.addListener(j, "drag", h)), y(j), E && E(j), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), w && w(j), j.setMap(null);
    };
  }, []), null;
}
ke(hle);
class gle extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      polyline: null
    }), me(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(zf(zf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Wt({
      updaterMap: zD,
      eventMap: FD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: zD,
      eventMap: FD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), qt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
me(gle, "contextType", vt);
function UD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $D(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UD(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WD = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, VD = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function mle(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: E,
    onLoad: w,
    onUnmount: S,
    onEdit: x
  } = e, y = Ee(vt), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), v(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), v(() => {
    C && typeof l == "function" && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof g == "function" && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), v(() => {
    C && typeof f == "function" && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof m == "function" && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(() => {
    C && typeof h == "function" && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(C, "click", h)));
  }, [h]), v(() => {
    C && typeof E == "function" && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), v(() => {
    var A = new google.maps.Polygon($D($D({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && _(google.maps.event.addListener(A, "dblclick", s)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && H(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), g && T(google.maps.event.addListener(A, "mouseover", g)), f && D(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), h && U(google.maps.event.addListener(A, "click", h)), E && Z(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), M !== null && google.maps.event.removeListener(M), S && S(A), A.setMap(null);
    };
  }, []), null;
}
ke(mle);
class vle extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Wt({
      updaterMap: VD,
      eventMap: WD,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: VD,
      eventMap: WD,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), qt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
me(vle, "contextType", vt);
function HD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HD(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GD = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, qD = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function yle(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: S
  } = e, x = Ee(vt), [y, C] = k(null), [P, F] = k(null), [_, I] = k(null), [B, $] = k(null), [V, z] = k(null), [H, X] = k(null), [J, te] = k(null), [ee, L] = k(null), [T, W] = k(null), [D, G] = k(null), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null);
  return v(() => {
    y !== null && y.setMap(x);
  }, [x]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), v(() => {
    y && s && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), v(() => {
    y && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), L(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && g && (T !== null && google.maps.event.removeListener(T), W(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), v(() => {
    y && f && (D !== null && google.maps.event.removeListener(D), G(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(y, "click", m)));
  }, [m]), v(() => {
    y && h && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(y, "drag", h)));
  }, [h]), v(() => {
    y && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), v(() => {
    var Q = new google.maps.Rectangle(Uf(Uf({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), a && F(google.maps.event.addListener(Q, "dblclick", a)), s && I(google.maps.event.addListener(Q, "dragend", s)), l && $(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && X(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && L(google.maps.event.addListener(Q, "mouseover", d)), g && W(google.maps.event.addListener(Q, "mouseup", g)), f && G(google.maps.event.addListener(Q, "rightclick", f)), m && M(google.maps.event.addListener(Q, "click", m)), h && j(google.maps.event.addListener(Q, "drag", h)), E && A(google.maps.event.addListener(Q, "bounds_changed", E)), C(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), _ !== null && google.maps.event.removeListener(_), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), T !== null && google.maps.event.removeListener(T), D !== null && google.maps.event.removeListener(D), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), S && S(Q), Q.setMap(null);
    };
  }, []), null;
}
ke(yle);
class ble extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      rectangle: null
    }), me(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Uf(Uf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Wt({
      updaterMap: qD,
      eventMap: GD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: qD,
      eventMap: GD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), qt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
me(ble, "contextType", vt);
function ZD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $f(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZD(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var KD = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, XD = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, wle = {};
function Cle(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: S,
    onLoad: x,
    onUnmount: y
  } = e, C = Ee(vt), [P, F] = k(null), [_, I] = k(null), [B, $] = k(null), [V, z] = k(null), [H, X] = k(null), [J, te] = k(null), [ee, L] = k(null), [T, W] = k(null), [D, G] = k(null), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, N] = k(null), [le, ye] = k(null);
  return v(() => {
    P !== null && P.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), v(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), v(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), v(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), v(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), v(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), v(() => {
    P && s && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), v(() => {
    P && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), v(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), v(() => {
    P && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), v(() => {
    P && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), v(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), L(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), v(() => {
    P && g && (T !== null && google.maps.event.removeListener(T), W(google.maps.event.addListener(P, "mouseover", g)));
  }, [g]), v(() => {
    P && f && (D !== null && google.maps.event.removeListener(D), G(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), v(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), v(() => {
    P && h && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(P, "click", h)));
  }, [h]), v(() => {
    P && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), v(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(P, "center_changed", w)));
  }, [h]), v(() => {
    P && S && (le !== null && google.maps.event.removeListener(le), ye(google.maps.event.addListener(P, "radius_changed", S)));
  }, [S]), v(() => {
    var oe = new google.maps.Circle($f($f({}, t || wle), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && I(google.maps.event.addListener(oe, "dblclick", s)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && L(google.maps.event.addListener(oe, "mouseout", d)), g && W(google.maps.event.addListener(oe, "mouseover", g)), f && G(google.maps.event.addListener(oe, "mouseup", f)), m && M(google.maps.event.addListener(oe, "rightclick", m)), h && j(google.maps.event.addListener(oe, "click", h)), E && A(google.maps.event.addListener(oe, "drag", E)), w && N(google.maps.event.addListener(oe, "center_changed", w)), S && ye(google.maps.event.addListener(oe, "radius_changed", S)), F(oe), x && x(oe), () => {
      _ !== null && google.maps.event.removeListener(_), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), T !== null && google.maps.event.removeListener(T), D !== null && google.maps.event.removeListener(D), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Q !== null && google.maps.event.removeListener(Q), le !== null && google.maps.event.removeListener(le), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
ke(Cle);
class xle extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      circle: null
    }), me(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle($f($f({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Wt({
      updaterMap: XD,
      eventMap: KD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: XD,
      eventMap: KD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), qt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
me(xle, "contextType", vt);
function YD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YD(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JD = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, QD = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Ele(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: h
  } = e, E = Ee(vt), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null);
  return v(() => {
    w !== null && w.setMap(E);
  }, [E]), v(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && a && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), v(() => {
    w && s && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && g && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), v(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (E !== null) {
      var A = new google.maps.Data(Wf(Wf({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && _(google.maps.event.addListener(A, "mousemove", i)), a && B(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && H(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && T(google.maps.event.addListener(A, "addfeature", c)), p && D(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && Z(google.maps.event.addListener(A, "setproperty", f)), S(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), M !== null && google.maps.event.removeListener(M), j !== null && google.maps.event.removeListener(j), h && h(w), w.setMap(null));
    };
  }, []), null;
}
ke(Ele);
class Ole extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      data: null
    }), me(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Wf(Wf({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Wt({
        updaterMap: QD,
        eventMap: JD,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: QD,
      eventMap: JD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), qt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
me(Ole, "contextType", vt);
function eM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nM = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, rM = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class kle extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      kmlLayer: null
    }), me(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(tM(tM({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Wt({
      updaterMap: rM,
      eventMap: nM,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: rM,
      eventMap: nM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), qt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
me(kle, "contextType", vt);
function Bz(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function _le(e, t) {
  return new t(e.lat, e.lng);
}
function Lle(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Ple(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Sle(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Dle(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Mle(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Rz(e, t, n, r) {
  return n !== void 0 ? Dle(e, t, Sle(n, google.maps.LatLngBounds, Lle)) : Mle(e, t, Ple(r, google.maps.LatLng, _le));
}
function Tle(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function oM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jle(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Ale(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = jle({}, this.container ? Bz(this.container, o) : {
        x: 0,
        y: 0
      }), u = Rz(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function iM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ble(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function sM(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function aM(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Rle(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = Ee(vt), c = Bn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Bn(() => Ale(c, r, t, n, s), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), oi.createPortal(l, c);
}
ke(Rle);
class dl extends be {
  constructor(t) {
    super(t), me(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), me(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Or(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), me(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), me(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Ble({
        x: 0,
        y: 0
      }, this.containerRef.current ? Bz(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Rz(r, o, this.props.bounds, this.props.position);
      if (!Tle(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), me(this, "draw", () => {
      this.onPositionElement();
    }), me(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Hr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = sM(t.position), r = sM(this.props.position), o = aM(t.bounds), i = aM(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? oi.createPortal(Sr.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: it.only(this.props.children)
    }), t) : null;
  }
}
me(dl, "FLOAT_PANE", "floatPane");
me(dl, "MAP_PANE", "mapPane");
me(dl, "MARKER_LAYER", "markerLayer");
me(dl, "OVERLAY_LAYER", "overlayLayer");
me(dl, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
me(dl, "contextType", vt);
function Ile() {
}
function lM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cM = {
  onDblClick: "dblclick",
  onClick: "click"
}, pM = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Nle(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = Ee(vt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Bn(() => new google.maps.GroundOverlay(t, a, r), []);
  return v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), v(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ke(Nle);
class Iz extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      groundOverlay: null
    }), me(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Or(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, uM(uM({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Wt({
      updaterMap: pM,
      eventMap: cM,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: pM,
      eventMap: cM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
me(Iz, "defaultProps", {
  onLoad: Ile
});
me(Iz, "contextType", vt);
function dM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dM(Object(n), !0).forEach(function(r) {
      me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fM = {}, hM = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Fle(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = Ee(vt), [a, s] = k(null);
  return v(() => {
    google.maps.visualization || Or(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    Or(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(Vf(Vf({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ke(Fle);
class zle extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      heatmapLayer: null
    }), me(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Or(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Or(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Vf(Vf({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Wt({
      updaterMap: hM,
      eventMap: fM,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: hM,
      eventMap: fM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), qt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
me(zle, "contextType", vt);
var gM = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, mM = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Ule extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      streetViewPanorama: null
    }), me(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Wt({
      updaterMap: mM,
      eventMap: gM,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: mM,
      eventMap: gM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), qt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
me(Ule, "contextType", vt);
class $le extends be {
  constructor() {
    super(...arguments), me(this, "state", {
      streetViewService: null
    }), me(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
me($le, "contextType", vt);
var vM = {
  onDirectionsChanged: "directions_changed"
}, yM = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Wle extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "state", {
      directionsRenderer: null
    }), me(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Wt({
      updaterMap: yM,
      eventMap: vM,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: yM,
      eventMap: vM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), qt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
me(Wle, "contextType", vt);
var bM = {
  onPlacesChanged: "places_changed"
}, wM = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Vle extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "containerElement", Hr()), me(this, "state", {
      searchBox: null
    }), me(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Or(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Wt({
          updaterMap: wM,
          eventMap: bM,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: wM,
      eventMap: bM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), qt(this.registeredEvents));
  }
  render() {
    return Sr.jsx("div", {
      ref: this.containerElement,
      children: it.only(this.props.children)
    });
  }
}
me(Vle, "contextType", vt);
var CM = {
  onPlaceChanged: "place_changed"
}, xM = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Nz extends be {
  constructor() {
    super(...arguments), me(this, "registeredEvents", []), me(this, "containerElement", Hr()), me(this, "state", {
      autocomplete: null
    }), me(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Or(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Wt({
        updaterMap: xM,
        eventMap: CM,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    qt(this.registeredEvents), this.registeredEvents = Wt({
      updaterMap: xM,
      eventMap: CM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && qt(this.registeredEvents);
  }
  render() {
    return Sr.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: it.only(this.props.children)
    });
  }
}
me(Nz, "defaultProps", {
  className: ""
});
me(Nz, "contextType", vt);
let Hle = { data: "" }, Gle = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Hle, qle = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Zle = /\/\*[^]*?\*\/|  +/g, EM = /\n+/g, fs = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? fs(a, i) : i + "{" + fs(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += fs(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += fs.p ? fs.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ei = {}, Fz = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Fz(e[n]);
    return t;
  }
  return e;
}, Kle = (e, t, n, r, o) => {
  let i = Fz(e), a = Ei[i] || (Ei[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ei[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = qle.exec(u.replace(Zle, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(EM, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(EM, " ").trim();
      return d[0];
    })(e);
    Ei[a] = fs(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ei.g ? Ei.g : null;
  return n && (Ei.g = Ei[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ei[a], t, r, s), a;
}, Xle = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : fs(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Wg(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Kle(n.unshift ? n.raw ? Xle(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Gle(t.target), t.g, t.o, t.k);
}
let zz, Jb, Qb;
Wg.bind({ g: 1 });
let Ai = Wg.bind({ k: 1 });
function Yle(e, t, n, r) {
  fs.p = t, zz = e, Jb = n, Qb = r;
}
function Ts(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: Jb && Jb() }, s), n.o = / *go\d+/.test(l), s.className = Wg.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), Qb && u[0] && Qb(s), zz(u, s);
    }
    return o;
  };
}
var Jle = (e) => typeof e == "function", Qle = (e, t) => Jle(e) ? e(t) : e, eue = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), tue = Ai`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, nue = Ai`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, rue = Ai`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, oue = Ts("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${tue} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${nue} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${rue} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, iue = Ai`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, sue = Ts("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${iue} 1s linear infinite;
`, aue = Ai`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, lue = Ai`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, uue = Ts("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${aue} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${lue} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, cue = Ts("div")`
  position: absolute;
`, pue = Ts("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, due = Ai`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, fue = Ts("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${due} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, hue = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? ze.createElement(fue, null, t) : t : n === "blank" ? null : ze.createElement(pue, null, ze.createElement(sue, { ...r }), n !== "loading" && ze.createElement(cue, null, n === "error" ? ze.createElement(oue, { ...r }) : ze.createElement(uue, { ...r })));
}, gue = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, mue = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, vue = "0%{opacity:0;} 100%{opacity:1;}", yue = "0%{opacity:1;} 100%{opacity:0;}", bue = Ts("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, wue = Ts("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Cue = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = eue() ? [vue, yue] : [gue(n), mue(n)];
  return { animation: t ? `${Ai(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ai(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
ze.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? Cue(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = ze.createElement(hue, { toast: e }), a = ze.createElement(wue, { ...e.ariaProps }, Qle(e.message, e));
  return ze.createElement(bue, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : ze.createElement(ze.Fragment, null, i, a));
});
Yle(ze.createElement);
Wg`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function qC(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, d = { xs: 12, sm: 16, md: 20, lg: 24 }[i], g = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ on.jsxs("button", { className: g, disabled: l || t, ...p, children: [
    /* @__PURE__ */ on.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ on.jsx(ri, { size: d, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ on.jsxs("div", { className: "arkynButtonContent", children: [
      UE(d, a),
      c,
      UE(d, s)
    ] })
  ] });
}
function xue() {
  const e = S0(), t = vR(), n = D0(), [r, o] = k(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  v(() => {
    var u, c;
    let p = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, p) || Object.entries(p).length !== 0 && o(p);
  }, [n, e]), v(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
qe({});
function Eue(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ on.jsxs(
    "button",
    {
      disabled: a || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ on.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ on.jsx(ri, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ on.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ on.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function Oue(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ on.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ on.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function kue(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const _ue = {
  CNPJ: "99.999.999/9999-99"
};
kue(_ue.CNPJ).length;
Ir((e, t) => /* @__PURE__ */ on.jsx("input", { ref: t, ...e }));
function Uz(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const $z = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function Lue(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function Pue(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const Sue = Uz($z.NINE).length, Due = Ir((e, t) => /* @__PURE__ */ on.jsx("input", { ref: t, ...e }));
Ir(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    v(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = Uz(g.target.value);
      const m = Pue(f);
      f.length > Sue || (f = Lue(f, $z[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ on.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ on.jsx(
      el,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: Due,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
qe({});
var zi = {};
Object.defineProperty(zi, "__esModule", {
  value: !0
});
var Mue = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), zv = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Wz = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Mue ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, ZC = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Jp = 1; Jp < 20; Jp++)
  ZC["f" + Jp] = 111 + Jp;
function Vg(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Vz(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Hz(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function Tue(e, t) {
  return Vg(e, t);
}
function jue(e, t) {
  return Vg(e, { byKey: !0 }, t);
}
function Vz(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in zv)
    r[zv[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = KC(d), m = zv[f];
      if (d.length > 1 && !m && !Wz[d] && !ZC[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = Gz(d)), m && (r[m] = g ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Hz(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Gz(e) {
  e = KC(e);
  var t = ZC[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function KC(e) {
  return e = e.toLowerCase(), e = Wz[e] || e, e;
}
zi.default = Vg;
var Uv = zi.isHotkey = Vg;
zi.isCodeHotkey = Tue;
zi.isKeyHotkey = jue;
zi.parseHotkey = Vz;
zi.compareHotkey = Hz;
zi.toKeyCode = Gz;
zi.toKeyName = KC;
var Aue = typeof En == "object" && En && En.Object === Object && En, Bue = Aue, Rue = Bue, Iue = typeof self == "object" && self && self.Object === Object && self, Nue = Rue || Iue || Function("return this")(), Fue = Nue, zue = Fue, Uue = zue.Symbol, qz = Uue, OM = qz;
OM && OM.toStringTag;
var kM = qz;
kM && kM.toStringTag;
var _M;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(_M || (_M = {}));
var XC = function(e) {
  return Object.freeze(e);
}, $ue = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, XC(this);
  }
  return e;
}(), Wue = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, XC(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), LM = typeof window < "u" ? window : {};
/msie|trident/i.test(LM.navigator && LM.navigator.userAgent);
var $v = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new $ue((n ? t : e) || 0, (n ? e : t) || 0);
};
XC({
  devicePixelContentBoxSize: $v(),
  borderBoxSize: $v(),
  contentBoxSize: $v(),
  contentRect: new Wue(0, 0, 0, 0)
});
function tc(e) {
  "@babel/helpers - typeof";
  return tc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, tc(e);
}
function Vue(e, t) {
  if (tc(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (tc(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Hue(e) {
  var t = Vue(e, "string");
  return tc(t) === "symbol" ? t : String(t);
}
function vu(e, t, n) {
  return t = Hue(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Gue = /* @__PURE__ */ qe(null), Wv, Vv;
parseInt(Oe.version.split(".")[0], 10);
var PM = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Hv = typeof navigator < "u" && /Android/.test(navigator.userAgent), Qp = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), que = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Wv = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Wv !== void 0 && Wv[1] && parseInt((Vv = navigator.userAgent.match(/Version\/(\d+)/)) === null || Vv === void 0 ? void 0 : Vv[1], 10) < 17;
var Zue = /* @__PURE__ */ new WeakMap(), Kue = /* @__PURE__ */ new WeakMap(), Xue = /* @__PURE__ */ new WeakMap(), Yue = /* @__PURE__ */ new WeakMap(), Jue = /* @__PURE__ */ new WeakMap(), SM = /* @__PURE__ */ new WeakMap(), Que = /* @__PURE__ */ new WeakMap(), DM = /* @__PURE__ */ new WeakMap(), ed = /* @__PURE__ */ new WeakMap(), ece = /* @__PURE__ */ new WeakMap(), tce = /* @__PURE__ */ new WeakMap(), nce = /* @__PURE__ */ new WeakMap(), Zz = globalThis.Node, rce = globalThis.Text, Kz = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, oce = (e) => Hf(e) && e.nodeType === 8, ei = (e) => Hf(e) && e.nodeType === 1, Hf = (e) => {
  var t = Kz(e);
  return !!t && e instanceof t.Node;
}, MM = (e) => {
  var t = e && e.anchorNode && Kz(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, ice = (e) => {
  var [t, n] = e;
  if (ei(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Xz(t, o, r ? "backward" : "forward"), r = o < n; ei(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = ace(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, sce = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Xz = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (oce(o) || ei(o) && o.childNodes.length === 0 || ei(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, ace = (e, t, n) => {
  var [r] = Xz(e, t, n);
  return r;
}, TM = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Yz = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ei(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = zt.getWindow(e);
  if (o.contains(r))
    return zt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Yz(e, i, n);
}, jM = (e, t) => !!(e.compareDocumentPosition(t) & Zz.DOCUMENT_POSITION_PRECEDING), lce = (e, t) => !!(e.compareDocumentPosition(t) & Zz.DOCUMENT_POSITION_FOLLOWING), uce = 0;
class cce {
  constructor() {
    vu(this, "id", void 0), this.id = "".concat(uce++);
  }
}
var zt = {
  androidPendingDiffs: (e) => nce.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = tce.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = zt.toDOMNode(e, e), n = zt.findDocumentOrShadowRoot(e);
    ed.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = zt.findDocumentOrShadowRoot(e), r = TM(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Zd.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = zt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = zt.toSlateNode(e, t.target), a = zt.findPath(e, i);
    if (_i.isElement(i) && yn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = yn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? yn.before(e, u) : yn.after(e, u);
      if (c) {
        var p = yn.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = zt.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = zt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = SM.get(t);
    return n || (n = new cce(), SM.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = Kue.get(r);
      if (o == null) {
        if (yn.isEditor(r))
          return n;
        break;
      }
      var i = Zue.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(po.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!ed.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          zt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = zt.toDOMNode(e, e), r = zt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = TM(r), i = zt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Zd.select(e, yn.start(e, [])), ed.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Xue.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = zt.toDOMNode(e, e), i;
    try {
      i = ei(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Hf(t) && zt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return yn.hasPath(e, n.path) && yn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => zt.hasEditableTarget(e, t) || zt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Hf(t) && zt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!ece.get(e),
  isFocused: (e) => !!ed.get(e),
  isReadOnly: (e) => !!DM.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (DM.get(e)) return !1;
    var n = zt.hasTarget(e, t) && zt.toSlateNode(e, t);
    return _i.isElement(n) && yn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Que.get(e), r = yn.isEditor(t) ? Yue.get(e) : n == null ? void 0 : n.get(zt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(po.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = yn.node(e, t.path), r = zt.toDOMNode(e, n), o;
    yn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var h, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof rce ? E : m,
            (h = m.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(po.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = kt.isBackward(t), i = zt.toDOMPoint(e, n), a = kt.isCollapsed(t) ? i : zt.toDOMPoint(e, r), s = zt.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = ei(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = ei(p) ? p : p.parentElement, h = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ei(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Jue.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : ice(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = zt.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), E = h && g.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), S = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = zt.getWindow(e), y = x.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((D) => {
            if (Hv && !r && D.hasAttribute("data-slate-zero-width") && D.textContent.length > 0 && D.textContext !== "\uFEFF") {
              D.textContent.startsWith("\uFEFF") && (D.textContent = D.textContent.slice(1));
              return;
            }
            D.parentNode.removeChild(D);
          }), c = C.textContent.length, S = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), _ = 0; _ < F.length; _++) {
          var I = F[_];
          if (zt.hasDOMNode(e, I)) {
            w = I;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), S = w, c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((D) => {
          c -= D.textContent.length;
        })) : c = 1;
      } else if (E) {
        var B = (D) => D ? D.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...B($), ...B($ == null ? void 0 : $.nextElementSibling)];
          w = (V = z.find((D) => lce(E, D))) !== null && V !== void 0 ? V : null;
        } else {
          var H, X = [...B($ == null ? void 0 : $.previousElementSibling), ...B($)];
          w = (H = X.findLast((D) => jM(E, D))) !== null && H !== void 0 ? H : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), S = w, i === "forward" ? c = 0 : (c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((D) => {
          c -= D.textContent.length;
        })));
      }
      S && c === S.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Hv && S.getAttribute("data-slate-zero-width") === "z" && (p = S.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Qp && (d = S.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Hv && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && zt.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = zt.toSlateNode(e, J), {
          path: ee,
          offset: L
        } = yn.start(e, zt.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (L = s), {
          path: ee,
          offset: L
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var T = zt.toSlateNode(e, u), W = zt.findPath(e, T);
    return {
      path: W,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = MM(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (MM(t)) {
        if (Qp && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = g.startContainer, h = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        que && sce(s) || Qp ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Qp && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = zt.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var S = jM(s, u) || s === u && c < l, x = p ? w : zt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: S ? "forward" : "backward"
    });
    if (!x)
      return null;
    var y = {
      anchor: w,
      focus: x
    };
    return kt.isExpanded(y) && kt.isForward(y) && ei(u) && yn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = yn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, pce = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, dce = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, fce = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Kn = (e) => {
  var t = pce[e], n = dce[e], r = fce[e], o = t && Uv(t), i = n && Uv(n), a = r && Uv(r);
  return (s) => !!(o && o(s) || PM && i && i(s) || !PM && a && a(s));
};
Kn("bold"), Kn("compose"), Kn("moveBackward"), Kn("moveForward"), Kn("deleteBackward"), Kn("deleteForward"), Kn("deleteLineBackward"), Kn("deleteLineForward"), Kn("deleteWordBackward"), Kn("deleteWordForward"), Kn("extendBackward"), Kn("extendForward"), Kn("extendLineBackward"), Kn("extendLineForward"), Kn("italic"), Kn("moveLineBackward"), Kn("moveLineForward"), Kn("moveWordBackward"), Kn("moveWordForward"), Kn("redo"), Kn("insertSoftBreak"), Kn("splitBlock"), Kn("transposeCharacter"), Kn("undo");
var hce = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Yz(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, gce = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class mce extends uc {
  constructor() {
    super(...arguments), vu(this, "context", null), vu(this, "manager", null), vu(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, gce);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = hce(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
vu(mce, "contextType", Gue);
qe({});
qe({});
qe({});
var vr = {}, YC = {}, Mc = {}, Tc = {}, Jz = "Expected a function", AM = NaN, vce = "[object Symbol]", yce = /^\s+|\s+$/g, bce = /^[-+]0x[0-9a-f]+$/i, wce = /^0b[01]+$/i, Cce = /^0o[0-7]+$/i, xce = parseInt, Ece = typeof En == "object" && En && En.Object === Object && En, Oce = typeof self == "object" && self && self.Object === Object && self, kce = Ece || Oce || Function("return this")(), _ce = Object.prototype, Lce = _ce.toString, Pce = Math.max, Sce = Math.min, Gv = function() {
  return kce.Date.now();
};
function Dce(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Jz);
  t = BM(t) || 0, Gf(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Pce(BM(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, _ = t - P;
    return p ? Sce(_, i - F) : _;
  }
  function h(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = Gv();
    if (h(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function S() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(Gv());
  }
  function y() {
    var C = Gv(), P = h(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = S, y.flush = x, y;
}
function Mce(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Jz);
  return Gf(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Dce(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Gf(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Tce(e) {
  return !!e && typeof e == "object";
}
function jce(e) {
  return typeof e == "symbol" || Tce(e) && Lce.call(e) == vce;
}
function BM(e) {
  if (typeof e == "number")
    return e;
  if (jce(e))
    return AM;
  if (Gf(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Gf(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(yce, "");
  var n = wce.test(e);
  return n || Cce.test(e) ? xce(e.slice(2), n ? 2 : 8) : bce.test(e) ? AM : +e;
}
var Ace = Mce, jc = {};
Object.defineProperty(jc, "__esModule", {
  value: !0
});
jc.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Md.has(t) || Md.set(t, /* @__PURE__ */ new Set());
  var o = Md.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
jc.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Md.get(t).delete(n.name || t);
};
var Md = /* @__PURE__ */ new Map();
Object.defineProperty(Tc, "__esModule", {
  value: !0
});
var Bce = Ace, Rce = Ice(Bce), RM = jc;
function Ice(e) {
  return e && e.__esModule ? e : { default: e };
}
var Nce = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Rce.default)(e, t);
}, rr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = Nce(function(r) {
        rr.scrollHandler(e);
      }, t);
      return rr.scrollSpyContainers.push(e), (0, RM.addPassiveEventListener)(e, "scroll", n), function() {
        (0, RM.removePassiveEventListener)(e, "scroll", n), rr.scrollSpyContainers.splice(rr.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return rr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = rr.scrollSpyContainers[rr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(rr.currentPositionX(e), rr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    rr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = rr.scrollSpyContainers[rr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    rr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    rr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), rr.spySetState && rr.spySetState.length && rr.spySetState.indexOf(e) > -1 && rr.spySetState.splice(rr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", rr.scrollHandler);
  },
  update: function() {
    return rr.scrollSpyContainers.forEach(function(e) {
      return rr.scrollHandler(e);
    });
  }
};
Tc.default = rr;
var fl = {}, Ac = {};
Object.defineProperty(Ac, "__esModule", {
  value: !0
});
var Fce = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, zce = function() {
  return window.location.hash.replace(/^#/, "");
}, Uce = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, $ce = function(e) {
  return getComputedStyle(e).position !== "static";
}, qv = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, Wce = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if ($ce(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = qv(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return qv(t, s).offsetTop - qv(e, s).offsetTop;
};
Ac.default = {
  updateHash: Fce,
  getHash: zce,
  filterElementInContainer: Uce,
  scrollOffset: Wce
};
var Hg = {}, JC = {};
Object.defineProperty(JC, "__esModule", {
  value: !0
});
JC.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var QC = {};
Object.defineProperty(QC, "__esModule", {
  value: !0
});
var Vce = jc, Hce = ["mousedown", "wheel", "touchmove", "keydown"];
QC.default = {
  subscribe: function(e) {
    return typeof document < "u" && Hce.forEach(function(t) {
      return (0, Vce.addPassiveEventListener)(document, t, e);
    });
  }
};
var Bc = {};
Object.defineProperty(Bc, "__esModule", {
  value: !0
});
var e0 = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      e0.registered[e] = t;
    },
    remove: function(e) {
      e0.registered[e] = null;
    }
  }
};
Bc.default = e0;
Object.defineProperty(Hg, "__esModule", {
  value: !0
});
var Gce = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, qce = Ac;
Gg(qce);
var Zce = JC, IM = Gg(Zce), Kce = QC, Xce = Gg(Kce), Yce = Bc, Ko = Gg(Yce);
function Gg(e) {
  return e && e.__esModule ? e : { default: e };
}
var Qz = function(e) {
  return IM.default[e.smooth] || IM.default.defaultEasing;
}, Jce = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Qce = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, t0 = function() {
  return Qce() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), eU = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, tU = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, nU = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, epe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, tpe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, npe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Ko.default.registered.end && Ko.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    t0.call(window, i);
    return;
  }
  Ko.default.registered.end && Ko.default.registered.end(o.to, o.target, o.currentPosition);
}, ex = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Rc = function(e, t, n, r) {
  t.data = t.data || eU(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (Xce.default.subscribe(o), ex(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? tU(t) : nU(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Ko.default.registered.end && Ko.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = Jce(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Qz(t), a = npe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Ko.default.registered.begin && Ko.default.registered.begin(t.data.to, t.data.target), t0.call(window, a);
    }, t.delay);
    return;
  }
  Ko.default.registered.begin && Ko.default.registered.begin(t.data.to, t.data.target), t0.call(window, a);
}, qg = function(e) {
  return e = Gce({}, e), e.data = e.data || eU(), e.absolute = !0, e;
}, rpe = function(e) {
  Rc(0, qg(e));
}, ope = function(e, t) {
  Rc(e, qg(t));
}, ipe = function(e) {
  e = qg(e), ex(e), Rc(e.horizontal ? epe(e) : tpe(e), e);
}, spe = function(e, t) {
  t = qg(t), ex(t);
  var n = t.horizontal ? tU(t) : nU(t);
  Rc(e + n, t);
};
Hg.default = {
  animateTopScroll: Rc,
  getAnimationType: Qz,
  scrollToTop: rpe,
  scrollToBottom: ipe,
  scrollTo: ope,
  scrollMore: spe
};
Object.defineProperty(fl, "__esModule", {
  value: !0
});
var ape = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, lpe = Ac, upe = tx(lpe), cpe = Hg, ppe = tx(cpe), dpe = Bc, td = tx(dpe);
function tx(e) {
  return e && e.__esModule ? e : { default: e };
}
var nd = {}, NM = void 0;
fl.default = {
  unmount: function() {
    nd = {};
  },
  register: function(e, t) {
    nd[e] = t;
  },
  unregister: function(e) {
    delete nd[e];
  },
  get: function(e) {
    return nd[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return NM = e;
  },
  getActiveLink: function() {
    return NM;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = ape({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = upe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      td.default.registered.begin && td.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, td.default.registered.end && td.default.registered.end(e, n);
      return;
    }
    ppe.default.animateTopScroll(s, t, e, n);
  }
};
var n0 = { exports: {} }, Zv = { exports: {} }, un = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var FM;
function fpe() {
  if (FM) return un;
  FM = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function S(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(y) {
    return S(y) === u;
  }
  return un.AsyncMode = l, un.ConcurrentMode = u, un.ContextConsumer = s, un.ContextProvider = a, un.Element = t, un.ForwardRef = c, un.Fragment = r, un.Lazy = f, un.Memo = g, un.Portal = n, un.Profiler = i, un.StrictMode = o, un.Suspense = p, un.isAsyncMode = function(y) {
    return x(y) || S(y) === l;
  }, un.isConcurrentMode = x, un.isContextConsumer = function(y) {
    return S(y) === s;
  }, un.isContextProvider = function(y) {
    return S(y) === a;
  }, un.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, un.isForwardRef = function(y) {
    return S(y) === c;
  }, un.isFragment = function(y) {
    return S(y) === r;
  }, un.isLazy = function(y) {
    return S(y) === f;
  }, un.isMemo = function(y) {
    return S(y) === g;
  }, un.isPortal = function(y) {
    return S(y) === n;
  }, un.isProfiler = function(y) {
    return S(y) === i;
  }, un.isStrictMode = function(y) {
    return S(y) === o;
  }, un.isSuspense = function(y) {
    return S(y) === p;
  }, un.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === g || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === h || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, un.typeOf = S, un;
}
var vn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zM;
function hpe() {
  return zM || (zM = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function S(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === g || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === h || N.$$typeof === E || N.$$typeof === w || N.$$typeof === m);
    }
    function x(N) {
      if (typeof N == "object" && N !== null) {
        var le = N.$$typeof;
        switch (le) {
          case t:
            var ye = N.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var y = l, C = u, P = s, F = a, _ = t, I = c, B = r, $ = f, V = g, z = n, H = i, X = o, J = p, te = !1;
    function ee(N) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), L(N) || x(N) === l;
    }
    function L(N) {
      return x(N) === u;
    }
    function T(N) {
      return x(N) === s;
    }
    function W(N) {
      return x(N) === a;
    }
    function D(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function G(N) {
      return x(N) === c;
    }
    function O(N) {
      return x(N) === r;
    }
    function M(N) {
      return x(N) === f;
    }
    function U(N) {
      return x(N) === g;
    }
    function j(N) {
      return x(N) === n;
    }
    function Z(N) {
      return x(N) === i;
    }
    function A(N) {
      return x(N) === o;
    }
    function Q(N) {
      return x(N) === p;
    }
    vn.AsyncMode = y, vn.ConcurrentMode = C, vn.ContextConsumer = P, vn.ContextProvider = F, vn.Element = _, vn.ForwardRef = I, vn.Fragment = B, vn.Lazy = $, vn.Memo = V, vn.Portal = z, vn.Profiler = H, vn.StrictMode = X, vn.Suspense = J, vn.isAsyncMode = ee, vn.isConcurrentMode = L, vn.isContextConsumer = T, vn.isContextProvider = W, vn.isElement = D, vn.isForwardRef = G, vn.isFragment = O, vn.isLazy = M, vn.isMemo = U, vn.isPortal = j, vn.isProfiler = Z, vn.isStrictMode = A, vn.isSuspense = Q, vn.isValidElementType = S, vn.typeOf = x;
  }()), vn;
}
var UM;
function rU() {
  return UM || (UM = 1, process.env.NODE_ENV === "production" ? Zv.exports = fpe() : Zv.exports = hpe()), Zv.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Kv, $M;
function gpe() {
  if ($M) return Kv;
  $M = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Kv = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, Kv;
}
var Xv, WM;
function nx() {
  if (WM) return Xv;
  WM = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Xv = e, Xv;
}
var VM, HM;
function oU() {
  return HM || (HM = 1, VM = Function.call.bind(Object.prototype.hasOwnProperty)), VM;
}
var Yv, GM;
function mpe() {
  if (GM) return Yv;
  GM = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = nx(), n = {}, r = oU();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Yv = o, Yv;
}
var Jv, qM;
function vpe() {
  if (qM) return Jv;
  qM = 1;
  var e = rU(), t = gpe(), n = nx(), r = oU(), o = mpe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Jv = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(L) {
      var T = L && (u && L[u] || L[c]);
      if (typeof T == "function")
        return T;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: S,
      element: x(),
      elementType: y(),
      instanceOf: C,
      node: I(),
      objectOf: F,
      oneOf: P,
      oneOfType: _,
      shape: $,
      exact: V
    };
    function f(L, T) {
      return L === T ? L !== 0 || 1 / L === 1 / T : L !== L && T !== T;
    }
    function m(L, T) {
      this.message = L, this.data = T && typeof T == "object" ? T : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function h(L) {
      if (process.env.NODE_ENV !== "production")
        var T = {}, W = 0;
      function D(O, M, U, j, Z, A, Q) {
        if (j = j || d, A = A || U, Q !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + U;
            !T[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            W < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), T[le] = !0, W++);
          }
        }
        return M[U] == null ? O ? M[U] === null ? new m("The " + Z + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new m("The " + Z + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : L(M, U, j, Z, A);
      }
      var G = D.bind(null, !1);
      return G.isRequired = D.bind(null, !0), G;
    }
    function E(L) {
      function T(W, D, G, O, M, U) {
        var j = W[D], Z = X(j);
        if (Z !== L) {
          var A = J(j);
          return new m(
            "Invalid " + O + " `" + M + "` of type " + ("`" + A + "` supplied to `" + G + "`, expected ") + ("`" + L + "`."),
            { expectedType: L }
          );
        }
        return null;
      }
      return h(T);
    }
    function w() {
      return h(a);
    }
    function S(L) {
      function T(W, D, G, O, M) {
        if (typeof L != "function")
          return new m("Property `" + M + "` of component `" + G + "` has invalid PropType notation inside arrayOf.");
        var U = W[D];
        if (!Array.isArray(U)) {
          var j = X(U);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an array."));
        }
        for (var Z = 0; Z < U.length; Z++) {
          var A = L(U, Z, G, O, M + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return h(T);
    }
    function x() {
      function L(T, W, D, G, O) {
        var M = T[W];
        if (!s(M)) {
          var U = X(M);
          return new m("Invalid " + G + " `" + O + "` of type " + ("`" + U + "` supplied to `" + D + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(L);
    }
    function y() {
      function L(T, W, D, G, O) {
        var M = T[W];
        if (!e.isValidElementType(M)) {
          var U = X(M);
          return new m("Invalid " + G + " `" + O + "` of type " + ("`" + U + "` supplied to `" + D + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(L);
    }
    function C(L) {
      function T(W, D, G, O, M) {
        if (!(W[D] instanceof L)) {
          var U = L.name || d, j = ee(W[D]);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return h(T);
    }
    function P(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function T(W, D, G, O, M) {
        for (var U = W[D], j = 0; j < L.length; j++)
          if (f(U, L[j]))
            return null;
        var Z = JSON.stringify(L, function(A, Q) {
          var N = J(Q);
          return N === "symbol" ? String(Q) : Q;
        });
        return new m("Invalid " + O + " `" + M + "` of value `" + String(U) + "` " + ("supplied to `" + G + "`, expected one of " + Z + "."));
      }
      return h(T);
    }
    function F(L) {
      function T(W, D, G, O, M) {
        if (typeof L != "function")
          return new m("Property `" + M + "` of component `" + G + "` has invalid PropType notation inside objectOf.");
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an object."));
        for (var Z in U)
          if (r(U, Z)) {
            var A = L(U, Z, G, O, M + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return h(T);
    }
    function _(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var T = 0; T < L.length; T++) {
        var W = L[T];
        if (typeof W != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(W) + " at index " + T + "."
          ), a;
      }
      function D(G, O, M, U, j) {
        for (var Z = [], A = 0; A < L.length; A++) {
          var Q = L[A], N = Q(G, O, M, U, j, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && Z.push(N.data.expectedType);
        }
        var le = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + j + "` supplied to " + ("`" + M + "`" + le + "."));
      }
      return h(D);
    }
    function I() {
      function L(T, W, D, G, O) {
        return z(T[W]) ? null : new m("Invalid " + G + " `" + O + "` supplied to " + ("`" + D + "`, expected a ReactNode."));
      }
      return h(L);
    }
    function B(L, T, W, D, G) {
      return new m(
        (L || "React class") + ": " + T + " type `" + W + "." + D + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + G + "`."
      );
    }
    function $(L) {
      function T(W, D, G, O, M) {
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        for (var Z in L) {
          var A = L[Z];
          if (typeof A != "function")
            return B(G, O, M, Z, J(A));
          var Q = A(U, Z, G, O, M + "." + Z, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(T);
    }
    function V(L) {
      function T(W, D, G, O, M) {
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        var Z = t({}, W[D], L);
        for (var A in Z) {
          var Q = L[A];
          if (r(L, A) && typeof Q != "function")
            return B(G, O, M, A, J(Q));
          if (!Q)
            return new m(
              "Invalid " + O + " `" + M + "` key `" + A + "` supplied to `" + G + "`.\nBad object: " + JSON.stringify(W[D], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(L), null, "  ")
            );
          var N = Q(U, A, G, O, M + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return h(T);
    }
    function z(L) {
      switch (typeof L) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !L;
        case "object":
          if (Array.isArray(L))
            return L.every(z);
          if (L === null || s(L))
            return !0;
          var T = p(L);
          if (T) {
            var W = T.call(L), D;
            if (T !== L.entries) {
              for (; !(D = W.next()).done; )
                if (!z(D.value))
                  return !1;
            } else
              for (; !(D = W.next()).done; ) {
                var G = D.value;
                if (G && !z(G[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function H(L, T) {
      return L === "symbol" ? !0 : T ? T["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && T instanceof Symbol : !1;
    }
    function X(L) {
      var T = typeof L;
      return Array.isArray(L) ? "array" : L instanceof RegExp ? "object" : H(T, L) ? "symbol" : T;
    }
    function J(L) {
      if (typeof L > "u" || L === null)
        return "" + L;
      var T = X(L);
      if (T === "object") {
        if (L instanceof Date)
          return "date";
        if (L instanceof RegExp)
          return "regexp";
      }
      return T;
    }
    function te(L) {
      var T = J(L);
      switch (T) {
        case "array":
        case "object":
          return "an " + T;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + T;
        default:
          return T;
      }
    }
    function ee(L) {
      return !L.constructor || !L.constructor.name ? d : L.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, Jv;
}
var Qv, ZM;
function ype() {
  if (ZM) return Qv;
  ZM = 1;
  var e = nx();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Qv = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Qv;
}
if (process.env.NODE_ENV !== "production") {
  var bpe = rU(), wpe = !0;
  n0.exports = vpe()(bpe.isElement, wpe);
} else
  n0.exports = ype()();
var Zg = n0.exports, Kg = {};
Object.defineProperty(Kg, "__esModule", {
  value: !0
});
var Cpe = Ac, ey = xpe(Cpe);
function xpe(e) {
  return e && e.__esModule ? e : { default: e };
}
var Epe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return ey.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && ey.default.getHash() !== e && ey.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Kg.default = Epe;
Object.defineProperty(Mc, "__esModule", {
  value: !0
});
var rd = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Ope = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), kpe = Oe, KM = Ic(kpe), _pe = Tc, od = Ic(_pe), Lpe = fl, Ppe = Ic(Lpe), Spe = Zg, Xn = Ic(Spe), Dpe = Kg, Zi = Ic(Dpe);
function Ic(e) {
  return e && e.__esModule ? e : { default: e };
}
function Mpe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Tpe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function jpe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var XM = {
  to: Xn.default.string.isRequired,
  containerId: Xn.default.string,
  container: Xn.default.object,
  activeClass: Xn.default.string,
  activeStyle: Xn.default.object,
  spy: Xn.default.bool,
  horizontal: Xn.default.bool,
  smooth: Xn.default.oneOfType([Xn.default.bool, Xn.default.string]),
  offset: Xn.default.number,
  delay: Xn.default.number,
  isDynamic: Xn.default.bool,
  onClick: Xn.default.func,
  duration: Xn.default.oneOfType([Xn.default.number, Xn.default.func]),
  absolute: Xn.default.bool,
  onSetActive: Xn.default.func,
  onSetInactive: Xn.default.func,
  ignoreCancelEvents: Xn.default.bool,
  hashSpy: Xn.default.bool,
  saveHashHistory: Xn.default.bool,
  spyThrottle: Xn.default.number
};
Mc.default = function(e, t) {
  var n = t || Ppe.default, r = function(i) {
    jpe(a, i);
    function a(s) {
      Mpe(this, a);
      var l = Tpe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return Ope(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!od.default.isMounted(s)) {
            var l = od.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (Zi.default.isMounted() || Zi.default.mount(n), Zi.default.mapContainer(this.props.to, s)), od.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        od.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = rd({}, this.props.style, this.props.activeStyle) : l = rd({}, this.props.style);
        var u = rd({}, this.props);
        for (var c in XM)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, KM.default.createElement(e, u);
      }
    }]), a;
  }(KM.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, rd({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Zi.default.isMounted() && !Zi.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, h = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            h = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - h + a, m = f + w.width;
          }
          var S = a - i.props.offset;
          d = S >= Math.floor(f) && S < Math.floor(m), g = S < Math.floor(f) || S >= Math.floor(m);
        } else {
          var x = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, y = x + F.height;
          }
          var _ = s - i.props.offset;
          d = _ >= Math.floor(x) && _ < Math.floor(y), g = _ < Math.floor(x) || _ >= Math.floor(y);
        }
        var I = n.getActiveLink();
        if (g) {
          if (c === I && n.setActiveLink(void 0), i.props.hashSpy && Zi.default.getHash() === c) {
            var B = i.props.saveHashHistory, $ = B === void 0 ? !1 : B;
            Zi.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (I !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && Zi.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = XM, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(YC, "__esModule", {
  value: !0
});
var Ape = Oe, YM = iU(Ape), Bpe = Mc, Rpe = iU(Bpe);
function iU(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ipe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function JM(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Npe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Fpe = function(e) {
  Npe(t, e);
  function t() {
    var n, r, o, i;
    Ipe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = JM(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return YM.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), JM(o, i);
  }
  return t;
}(YM.default.Component);
YC.default = (0, Rpe.default)(Fpe);
var rx = {};
Object.defineProperty(rx, "__esModule", {
  value: !0
});
var zpe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Upe = Oe, QM = sU(Upe), $pe = Mc, Wpe = sU($pe);
function sU(e) {
  return e && e.__esModule ? e : { default: e };
}
function Vpe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Hpe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Gpe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var qpe = function(e) {
  Gpe(t, e);
  function t() {
    return Vpe(this, t), Hpe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return zpe(t, [{
    key: "render",
    value: function() {
      return QM.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(QM.default.Component);
rx.default = (0, Wpe.default)(qpe);
var ox = {}, Xg = {};
Object.defineProperty(Xg, "__esModule", {
  value: !0
});
var Zpe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Kpe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Xpe = Oe, eT = Yg(Xpe), Ype = tl;
Yg(Ype);
var Jpe = fl, tT = Yg(Jpe), Qpe = Zg, nT = Yg(Qpe);
function Yg(e) {
  return e && e.__esModule ? e : { default: e };
}
function ede(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function tde(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function nde(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Xg.default = function(e) {
  var t = function(n) {
    nde(r, n);
    function r(o) {
      ede(this, r);
      var i = tde(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Kpe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        tT.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        tT.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return eT.default.createElement(e, Zpe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(eT.default.Component);
  return t.propTypes = {
    name: nT.default.string,
    id: nT.default.string
  }, t;
};
Object.defineProperty(ox, "__esModule", {
  value: !0
});
var rT = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, rde = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ode = Oe, oT = ix(ode), ide = Xg, sde = ix(ide), ade = Zg, iT = ix(ade);
function ix(e) {
  return e && e.__esModule ? e : { default: e };
}
function lde(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ude(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function cde(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var aU = function(e) {
  cde(t, e);
  function t() {
    return lde(this, t), ude(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return rde(t, [{
    key: "render",
    value: function() {
      var n = this, r = rT({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, oT.default.createElement(
        "div",
        rT({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(oT.default.Component);
aU.propTypes = {
  name: iT.default.string,
  id: iT.default.string
};
ox.default = (0, sde.default)(aU);
var ty = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, sT = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function aT(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lT(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function uT(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var id = Oe, $s = Tc, ny = fl, lr = Zg, Ki = Kg, cT = {
  to: lr.string.isRequired,
  containerId: lr.string,
  container: lr.object,
  activeClass: lr.string,
  spy: lr.bool,
  smooth: lr.oneOfType([lr.bool, lr.string]),
  offset: lr.number,
  delay: lr.number,
  isDynamic: lr.bool,
  onClick: lr.func,
  duration: lr.oneOfType([lr.number, lr.func]),
  absolute: lr.bool,
  onSetActive: lr.func,
  onSetInactive: lr.func,
  ignoreCancelEvents: lr.bool,
  hashSpy: lr.bool,
  spyThrottle: lr.number
}, pde = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || ny, r = function(i) {
      uT(a, i);
      function a(s) {
        aT(this, a);
        var l = lT(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return sT(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            $s.isMounted(s) || $s.mount(s, this.props.spyThrottle), this.props.hashSpy && (Ki.isMounted() || Ki.mount(n), Ki.mapContainer(this.props.to, s)), this.props.spy && $s.addStateHandler(this.stateHandler), $s.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          $s.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = ty({}, this.props);
          for (var u in cT)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, id.createElement(e, l);
        }
      }]), a;
    }(id.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, ty({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Ki.isMounted() && !Ki.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, h = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Ki.getHash() === l && Ki.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), $s.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Ki.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), $s.updateStates();
        }
      };
    };
    return r.propTypes = cT, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      uT(r, n);
      function r(o) {
        aT(this, r);
        var i = lT(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return sT(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          ny.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          ny.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return id.createElement(e, ty({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(id.Component);
    return t.propTypes = {
      name: lr.string,
      id: lr.string
    }, t;
  }
}, dde = pde;
Object.defineProperty(vr, "__esModule", {
  value: !0
});
vr.Helpers = vr.ScrollElement = vr.ScrollLink = vr.animateScroll = vr.scrollSpy = vr.Events = vr.scroller = vr.Element = vr.Button = vr.Link = void 0;
var fde = YC, lU = li(fde), hde = rx, uU = li(hde), gde = ox, cU = li(gde), mde = fl, pU = li(mde), vde = Bc, dU = li(vde), yde = Tc, fU = li(yde), bde = Hg, hU = li(bde), wde = Mc, gU = li(wde), Cde = Xg, mU = li(Cde), xde = dde, vU = li(xde);
function li(e) {
  return e && e.__esModule ? e : { default: e };
}
vr.Link = lU.default;
vr.Button = uU.default;
vr.Element = cU.default;
vr.scroller = pU.default;
vr.Events = dU.default;
vr.scrollSpy = fU.default;
vr.animateScroll = hU.default;
vr.ScrollLink = gU.default;
vr.ScrollElement = mU.default;
vr.Helpers = vU.default;
vr.default = { Link: lU.default, Button: uU.default, Element: cU.default, scroller: pU.default, Events: dU.default, scrollSpy: fU.default, animateScroll: hU.default, ScrollLink: gU.default, ScrollElement: mU.default, Helpers: vU.default };
qe({});
qe({});
qe({});
function nc(e) {
  "@babel/helpers - typeof";
  return nc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, nc(e);
}
function Ede(e, t) {
  if (nc(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (nc(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Ode(e) {
  var t = Ede(e, "string");
  return nc(t) == "symbol" ? t : t + "";
}
function ve(e, t, n) {
  return (t = Ode(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function yU(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ry, pT;
function kde() {
  if (pT) return ry;
  pT = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return ry = t, ry;
}
var _de = kde(), kr = /* @__PURE__ */ yU(_de), yt = qe(null);
function Lde() {
  kr(!!Ee, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Ee(yt);
  return kr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Pde(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Sde(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Dde(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Sde(e, i), o;
}
function Mde(e, t, n) {
  var r = Pde(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function Tde(e) {
  google.maps.event.removeListener(e);
}
function Zt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(Tde);
}
function Vt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = Mde(o, i, n);
  return Dde(t, r, o, i), a;
}
function jde(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: h,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: S,
    onUnmount: x
  } = e, [y, C] = k(null), P = Qe(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null), [A, Q] = k(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), v(() => {
    y && l && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && m && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && g && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(y, "mouseout", g)));
  }, [g]), v(() => {
    y && f && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && h && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && E && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), v(() => {
    y && s && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(y, "click", s)));
  }, [s]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), v(() => {
    var N = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(N), N !== null && S && S(N), () => {
      N !== null && x && x(N);
    };
  }, []), on.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: on.jsx(yt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
ke(jde);
function dT(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function bU(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        dT(i, r, o, a, s, "next", l);
      }
      function s(l) {
        dT(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function wU(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return kr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var aa = typeof document < "u";
function CU(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return aa ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function fT(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function xU() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return fT(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return fT(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Il = !1;
function EU() {
  return on.jsx("div", {
    children: "Loading..."
  });
}
var r0 = {
  id: "script-loader",
  version: "weekly"
};
class Ade extends be {
  constructor() {
    super(...arguments), ve(this, "check", null), ve(this, "state", {
      loaded: !1
    }), ve(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ve(this, "isCleaningUp", /* @__PURE__ */ bU(function* () {
      function t(n) {
        if (!Il)
          n();
        else if (aa)
          var r = window.setInterval(function() {
            Il || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ve(this, "cleanup", () => {
      Il = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), ve(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && xU(), kr(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: wU(this.props)
      };
      CU(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), ve(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (aa) {
      if (window.google && window.google.maps && !Il) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), aa && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (aa) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Il = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return on.jsxs(on.Fragment, {
      children: [on.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || on.jsx(EU, {})]
    });
  }
}
ve(Ade, "defaultProps", r0);
function Bde(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function sx(e, t) {
  if (e == null) return {};
  var n, r, o = Bde(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var hT;
function Rde(e) {
  var {
    id: t = r0.id,
    version: n = r0.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = Qe(!1), [f, m] = k(!1), [h, E] = k(void 0);
  v(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), v(function() {
    aa && u && xU();
  }, [u]), v(function() {
    f && kr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = wU({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!aa)
      return;
    function x() {
      g.current && (m(!0), hT = w);
    }
    if (window.google && window.google.maps && hT === w) {
      x();
      return;
    }
    CU({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(y) {
      g.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var S = Qe(void 0);
  return v(function() {
    S.current && l !== S.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), S.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var Ide = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], Nde = on.jsx(EU, {});
function Fde(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = sx(e, Ide), {
    isLoaded: s,
    loadError: l
  } = Rde(a);
  return v(function() {
    s && typeof n == "function" && n();
  }, [s, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || Nde;
}
ke(Fde);
var gT;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(gT || (gT = {}));
function mT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mT(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vT = {}, yT = {
  options(e, t) {
    e.setOptions(t);
  }
};
function zde(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = Ee(yt), [i, a] = k(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var s = new google.maps.TrafficLayer(qf(qf({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ke(zde);
class Ude extends be {
  constructor() {
    super(...arguments), ve(this, "state", {
      trafficLayer: null
    }), ve(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ve(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(qf(qf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: yT,
      eventMap: vT,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: yT,
      eventMap: vT,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Zt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Ude, "contextType", yt);
function $de(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Ee(yt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ke($de);
class Wde extends be {
  constructor() {
    super(...arguments), ve(this, "state", {
      bicyclingLayer: null
    }), ve(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Wde, "contextType", yt);
function Vde(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Ee(yt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ke(Vde);
class Hde extends be {
  constructor() {
    super(...arguments), ve(this, "state", {
      transitLayer: null
    }), ve(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Hde, "contextType", yt);
function bT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bT(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wT = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, CT = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Gde(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = Ee(yt), [d, g] = k(null), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), v(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), v(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    kr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var I = new google.maps.drawing.DrawingManager(Zf(Zf({}, t), {}, {
      map: p
    }));
    return n && I.setDrawingMode(n), r && m(google.maps.event.addListener(I, "circlecomplete", r)), o && E(google.maps.event.addListener(I, "markercomplete", o)), i && S(google.maps.event.addListener(I, "overlaycomplete", i)), a && y(google.maps.event.addListener(I, "polygoncomplete", a)), s && P(google.maps.event.addListener(I, "polylinecomplete", s)), l && _(google.maps.event.addListener(I, "rectanglecomplete", l)), g(I), u && u(I), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ke(Gde);
class qde extends be {
  constructor(t) {
    super(t), ve(this, "registeredEvents", []), ve(this, "state", {
      drawingManager: null
    }), ve(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), kr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Zf(Zf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: CT,
      eventMap: wT,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: CT,
      eventMap: wT,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Zt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ve(qde, "contextType", yt);
function xT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wa(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xT(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ET = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, OT = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Kf = {};
function Zde(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: h,
    onClick: E,
    onDblClick: w,
    onDrag: S,
    onDragEnd: x,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: _,
    onRightClick: I,
    onClickableChanged: B,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: H,
    onIconChanged: X,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: L,
    onZindexChanged: T,
    onLoad: W,
    onUnmount: D
  } = e, G = Ee(yt), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, N] = k(null), [le, ye] = k(null), [oe, Be] = k(null), [Ue, $e] = k(null), [Ie, Je] = k(null), [Ze, Me] = k(null), [Ye, nt] = k(null), [De, je] = k(null), [Ke, We] = k(null), [Fe, et] = k(null), [Re, Rt] = k(null), [rt, ot] = k(null), [at, Kt] = k(null), [lt, ut] = k(null), [tt, Xe] = k(null), [Xt, Yt] = k(null), [bt, Rn] = k(null), [wt, In] = k(null), [Ct, fn] = k(null);
  v(() => {
    O !== null && O.setMap(G);
  }, [G]), v(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), v(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), v(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), v(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), v(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), v(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), v(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), v(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), v(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), v(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), v(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), v(() => {
    O && h !== void 0 && O.setZIndex(h);
  }, [O, h]), v(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), v(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), v(() => {
    O && y && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(O, "dragstart", y)));
  }, [y]), v(() => {
    O && _ && (le !== null && google.maps.event.removeListener(le), ye(google.maps.event.addListener(O, "mousedown", _)));
  }, [_]), v(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Be(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), v(() => {
    O && P && (Ue !== null && google.maps.event.removeListener(Ue), $e(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), v(() => {
    O && F && (Ie !== null && google.maps.event.removeListener(Ie), Je(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), v(() => {
    O && I && (Ze !== null && google.maps.event.removeListener(Ze), Me(google.maps.event.addListener(O, "rightclick", I)));
  }, [I]), v(() => {
    O && E && (Ye !== null && google.maps.event.removeListener(Ye), nt(google.maps.event.addListener(O, "click", E)));
  }, [E]), v(() => {
    O && S && (De !== null && google.maps.event.removeListener(De), je(google.maps.event.addListener(O, "drag", S)));
  }, [S]), v(() => {
    O && B && (Ke !== null && google.maps.event.removeListener(Ke), We(google.maps.event.addListener(O, "clickable_changed", B)));
  }, [B]), v(() => {
    O && $ && (Fe !== null && google.maps.event.removeListener(Fe), et(google.maps.event.addListener(O, "cursor_changed", $)));
  }, [$]), v(() => {
    O && V && (Re !== null && google.maps.event.removeListener(Re), Rt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), v(() => {
    O && z && (rt !== null && google.maps.event.removeListener(rt), ot(google.maps.event.addListener(O, "draggable_changed", z)));
  }, [z]), v(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), Kt(google.maps.event.addListener(O, "flat_changed", H)));
  }, [H]), v(() => {
    O && X && (lt !== null && google.maps.event.removeListener(lt), ut(google.maps.event.addListener(O, "icon_changed", X)));
  }, [X]), v(() => {
    O && J && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(O, "position_changed", J)));
  }, [J]), v(() => {
    O && te && (Xt !== null && google.maps.event.removeListener(Xt), Yt(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), v(() => {
    O && ee && (bt !== null && google.maps.event.removeListener(bt), Rn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), v(() => {
    O && L && (wt !== null && google.maps.event.removeListener(wt), In(google.maps.event.addListener(O, "visible_changed", L)));
  }, [L]), v(() => {
    O && T && (Ct !== null && google.maps.event.removeListener(Ct), fn(google.maps.event.addListener(O, "zindex_changed", T)));
  }, [T]), v(() => {
    var xt = Wa(Wa(Wa({}, n || Kf), r ? Kf : {
      map: G
    }), {}, {
      position: t
    }), re = new google.maps.Marker(xt);
    return r ? r.addMarker(re, !!o) : re.setMap(G), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof h == "number" && re.setZIndex(h), w && j(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), y && N(google.maps.event.addListener(re, "dragstart", y)), _ && ye(google.maps.event.addListener(re, "mousedown", _)), C && Be(google.maps.event.addListener(re, "mouseout", C)), P && $e(google.maps.event.addListener(re, "mouseover", P)), F && Je(google.maps.event.addListener(re, "mouseup", F)), I && Me(google.maps.event.addListener(re, "rightclick", I)), E && nt(google.maps.event.addListener(re, "click", E)), S && je(google.maps.event.addListener(re, "drag", S)), B && We(google.maps.event.addListener(re, "clickable_changed", B)), $ && et(google.maps.event.addListener(re, "cursor_changed", $)), V && Rt(google.maps.event.addListener(re, "animation_changed", V)), z && ot(google.maps.event.addListener(re, "draggable_changed", z)), H && Kt(google.maps.event.addListener(re, "flat_changed", H)), X && ut(google.maps.event.addListener(re, "icon_changed", X)), J && Xe(google.maps.event.addListener(re, "position_changed", J)), te && Yt(google.maps.event.addListener(re, "shape_changed", te)), ee && Rn(google.maps.event.addListener(re, "title_changed", ee)), L && In(google.maps.event.addListener(re, "visible_changed", L)), T && fn(google.maps.event.addListener(re, "zindex_changed", T)), M(re), W && W(re), () => {
      U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), Q !== null && google.maps.event.removeListener(Q), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), Ie !== null && google.maps.event.removeListener(Ie), Ze !== null && google.maps.event.removeListener(Ze), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Fe !== null && google.maps.event.removeListener(Fe), Re !== null && google.maps.event.removeListener(Re), rt !== null && google.maps.event.removeListener(rt), at !== null && google.maps.event.removeListener(at), lt !== null && google.maps.event.removeListener(lt), tt !== null && google.maps.event.removeListener(tt), bt !== null && google.maps.event.removeListener(bt), wt !== null && google.maps.event.removeListener(wt), Ct !== null && google.maps.event.removeListener(Ct), D && D(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var wr = Bn(() => i ? it.map(i, (xt) => {
    if (!ti(xt))
      return xt;
    var re = xt;
    return ni(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return on.jsx(on.Fragment, {
    children: wr
  }) || null;
}
ke(Zde);
class Kde extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return bU(function* () {
      var n = Wa(Wa(Wa({}, t.props.options || Kf), t.props.clusterer ? Kf : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Vt({
        updaterMap: OT,
        eventMap: ET,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: OT,
      eventMap: ET,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Zt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? it.map(this.props.children, (n) => {
      if (!ti(n))
        return n;
      var r = n;
      return ni(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ve(Kde, "contextType", yt);
var Xde = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), Yde = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Xde(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Jde(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Qde = 2e3, efe = 500, tfe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", nfe = "png", rfe = [53, 56, 66, 78, 90], ofe = "cluster", OU = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || tfe, this.imageExtension = r.imageExtension || nfe, this.imageSizes = r.imageSizes || rfe, this.calculator = r.calculator || Jde, this.batchSize = r.batchSize || Qde, this.batchSizeIE = r.batchSizeIE || efe, this.clusterClass = r.clusterClass || ofe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new Yde(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function kT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ife(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kT(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ao = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, nn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, sfe = {};
function afe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: h,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: S,
    onClusteringEnd: x,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [_, I] = k(null), B = Ee(yt), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null);
  return v(() => {
    _ && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(_, Ao.onMouseOut, C)));
  }, [C]), v(() => {
    _ && y && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(_, Ao.onMouseOver, y)));
  }, [y]), v(() => {
    _ && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(_, Ao.onClick, w)));
  }, [w]), v(() => {
    _ && S && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(_, Ao.onClusteringBegin, S)));
  }, [S]), v(() => {
    _ && x && (X !== null && google.maps.event.removeListener(X), H(google.maps.event.addListener(_, Ao.onClusteringEnd, x)));
  }, [x]), v(() => {
    typeof r < "u" && _ !== null && nn.averageCenter(_, r);
  }, [_, r]), v(() => {
    typeof o < "u" && _ !== null && nn.batchSizeIE(_, o);
  }, [_, o]), v(() => {
    typeof i < "u" && _ !== null && nn.calculator(_, i);
  }, [_, i]), v(() => {
    typeof a < "u" && _ !== null && nn.clusterClass(_, a);
  }, [_, a]), v(() => {
    typeof s < "u" && _ !== null && nn.enableRetinaIcons(_, s);
  }, [_, s]), v(() => {
    typeof l < "u" && _ !== null && nn.gridSize(_, l);
  }, [_, l]), v(() => {
    typeof u < "u" && _ !== null && nn.ignoreHidden(_, u);
  }, [_, u]), v(() => {
    typeof c < "u" && _ !== null && nn.imageExtension(_, c);
  }, [_, c]), v(() => {
    typeof p < "u" && _ !== null && nn.imagePath(_, p);
  }, [_, p]), v(() => {
    typeof d < "u" && _ !== null && nn.imageSizes(_, d);
  }, [_, d]), v(() => {
    typeof g < "u" && _ !== null && nn.maxZoom(_, g);
  }, [_, g]), v(() => {
    typeof f < "u" && _ !== null && nn.minimumClusterSize(_, f);
  }, [_, f]), v(() => {
    typeof m < "u" && _ !== null && nn.styles(_, m);
  }, [_, m]), v(() => {
    typeof h < "u" && _ !== null && nn.title(_, h);
  }, [_, h]), v(() => {
    typeof E < "u" && _ !== null && nn.zoomOnClick(_, E);
  }, [_, E]), v(() => {
    if (B) {
      var W = ife({}, n || sfe), D = new OU(B, [], W);
      return r && nn.averageCenter(D, r), o && nn.batchSizeIE(D, o), i && nn.calculator(D, i), a && nn.clusterClass(D, a), s && nn.enableRetinaIcons(D, s), l && nn.gridSize(D, l), u && nn.ignoreHidden(D, u), c && nn.imageExtension(D, c), p && nn.imagePath(D, p), d && nn.imageSizes(D, d), g && nn.maxZoom(D, g), f && nn.minimumClusterSize(D, f), m && nn.styles(D, m), h && nn.title(D, h), E && nn.zoomOnClick(D, E), C && ee(google.maps.event.addListener(D, Ao.onMouseOut, C)), y && T(google.maps.event.addListener(D, Ao.onMouseOver, y)), w && V(google.maps.event.addListener(D, Ao.onClick, w)), S && H(google.maps.event.addListener(D, Ao.onClusteringBegin, S)), x && J(google.maps.event.addListener(D, Ao.onClusteringEnd, x)), I(D), P && P(D), () => {
        te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), F && F(D);
      };
    }
  }, []), _ !== null && t(_) || null;
}
ke(afe);
class lfe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      markerClusterer: null
    }), ve(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new OU(this.context, [], this.props.options);
      this.registeredEvents = Vt({
        updaterMap: nn,
        eventMap: Ao,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: nn,
      eventMap: Ao,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Zt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ve(lfe, "contextType", yt);
function _T(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var kU = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || _T(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, _T));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), h = m.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + g ? r = h.x + u - g : h.x + p + u + g > s && (r = h.x + p + u + g - s), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), ufe = ["position"], cfe = ["position"];
function LT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LT(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PT = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, ST = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, pfe = {};
function dfe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = Ee(yt), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), I = Qe(null);
  return v(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (g) {
      var B = r || pfe, {
        position: $
      } = B, V = sx(B, ufe), z;
      $ && !($ instanceof google.maps.LatLng) && (z = new google.maps.LatLng($.lat, $.lng));
      var H = new kU(Xf(Xf({}, V), z ? {
        position: z
      } : {}));
      I.current = document.createElement("div"), m(H), a && E(google.maps.event.addListener(H, "closeclick", a)), s && S(google.maps.event.addListener(H, "domready", s)), l && y(google.maps.event.addListener(H, "content_changed", l)), u && P(google.maps.event.addListener(H, "position_changed", u)), c && _(google.maps.event.addListener(H, "zindex_changed", c)), H.setContent(I.current), n ? H.open(g, n) : H.getPosition() ? H.open(g) : kr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(H);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), I.current ? br(it.only(t), I.current) : null;
}
ke(dfe);
class ffe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "containerElement", null), ve(this, "state", {
      infoBox: null
    }), ve(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : kr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ve(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = sx(t, cfe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new kU(Xf(Xf({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Vt({
      updaterMap: ST,
      eventMap: PT,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: ST,
      eventMap: PT,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Zt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? br(it.only(this.props.children), this.containerElement) : null;
  }
}
ve(ffe, "contextType", yt);
var DT, MT;
function hfe() {
  return MT || (MT = 1, DT = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), DT;
}
var gfe = hfe(), TT = /* @__PURE__ */ yU(gfe), jT = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], oy = 1, Nl = 8;
class ax {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== oy)
      throw new Error("Got v".concat(o, " data when expected v").concat(oy, "."));
    var i = jT[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new ax(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = jT.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Nl, t), this.coords = new this.ArrayType(this.data, Nl + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Nl + a + s + l), this.ids = new this.IndexArrayType(this.data, Nl, t), this.coords = new this.ArrayType(this.data, Nl + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (oy << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return o0(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var h = d + p >> 1, E = a[2 * h], w = a[2 * h + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          AT(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], h = i[2 * f + 1];
      AT(m, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= h) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= h) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function o0(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    _U(e, t, a, r, o, i), o0(e, t, n, r, a - 1, 1 - i), o0(e, t, n, a + 1, o, 1 - i);
  }
}
function _U(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      _U(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (Fl(e, t, r, n), t[2 * o + i] > g && Fl(e, t, r, o); f < m; ) {
      for (Fl(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? Fl(e, t, r, m) : (m++, Fl(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function Fl(e, t, n, r) {
  iy(e, n, r), iy(t, 2 * n, 2 * r), iy(t, 2 * n + 1, 2 * r + 1);
}
function iy(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function AT(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var mfe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, BT = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Ws = 2, as = 3, sy = 4, ns = 5, LU = 6;
class vfe {
  constructor(t) {
    this.options = Object.assign(Object.create(mfe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = BT(sd(u)), d = BT(ad(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(sd(r), ad(a), sd(i), ad(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + ns] > 1 ? RT(p, f, this.clusterProps) : this.points[p[f + as]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + sy] === t && p.push(a[g + ns] > 1 ? RT(a, g, this.clusterProps) : this.points[a[g + as]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new ax(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + ns] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = PU(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + as]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = sd(f), d = ad(m);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + as] : E = this.points[n[l + as]].id, E !== void 0 && (h.id = E), a.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Ws] <= n)) {
        l[p + Ws] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + ns], h = m;
        for (var E of f) {
          var w = E * c;
          l[w + Ws] > n && (h += l[w + ns]);
        }
        if (h > m && h >= a) {
          var S = d * m, x = g * m, y = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var _ = F * c;
            if (!(l[_ + Ws] <= n)) {
              l[_ + Ws] = n;
              var I = l[_ + ns];
              S += l[_] * I, x += l[_ + 1] * I, l[_ + sy] = P, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, _)));
            }
          }
          l[p + sy] = P, u.push(S / h, x / h, 1 / 0, P, -1, h), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (h > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Ws] <= n)) {
                l[V + Ws] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ns] > 1) {
      var o = this.clusterProps[t[n + LU]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + as]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function RT(e, t, n) {
  return {
    type: "Feature",
    id: e[t + as],
    properties: PU(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [yfe(e[t]), bfe(e[t + 1])]
    }
  };
}
function PU(e, t, n) {
  var r = e[t + ns], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + LU], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + as],
    point_count: r,
    point_count_abbreviated: o
  });
}
function sd(e) {
  return e / 360 + 0.5;
}
function ad(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function yfe(e) {
  return (e - 0.5) * 360;
}
function bfe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function wfe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class bo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class i0 {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(bo.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => bo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (bo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Cfe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return xfe(n);
  }
}
var xfe = (e) => {
  var t = e.map((n) => new i0({
    position: bo.getPosition(n),
    markers: [n]
  }));
  return t;
};
class Efe extends Cfe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = wfe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new vfe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!TT(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = bo.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !TT(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new i0({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new i0({
      markers: [i],
      position: bo.getPosition(i)
    });
  }
}
class Ofe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class kfe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (bo.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function _fe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class lx {
  constructor() {
    _fe(lx, google.maps.OverlayView);
  }
}
var yu;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(yu || (yu = {}));
var Lfe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Pfe extends lx {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new Efe(o),
      renderer: a = new kfe(),
      onClusterClick: s = Lfe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (bo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, yu.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || bo.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => bo.setMap(l, null)));
      }
      google.maps.event.trigger(this, yu.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => bo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Ofe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => bo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, yu.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), bo.setMap(r.marker, n);
    });
  }
}
function IT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function NT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IT(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Sfe(e) {
  var t = Lde(), [n, r] = k(null);
  return v(() => {
    if (t && n === null) {
      var o = new Pfe(NT(NT({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Dfe(e) {
  var {
    children: t,
    options: n
  } = e, r = Sfe(n);
  return r !== null ? t(r) : null;
}
ke(Dfe);
var FT = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, zT = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Mfe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = Ee(yt), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), I = Qe(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var B = new google.maps.InfoWindow(r);
    return m(B), I.current = document.createElement("div"), a && E(google.maps.event.addListener(B, "closeclick", a)), s && S(google.maps.event.addListener(B, "domready", s)), l && y(google.maps.event.addListener(B, "content_changed", l)), u && P(google.maps.event.addListener(B, "position_changed", u)), c && _(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(I.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(g, n) : B.getPosition() ? B.open(g) : kr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(B), B.close();
    };
  }, []), I.current ? br(it.only(t), I.current) : null;
}
ke(Mfe);
class Tfe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "containerElement", null), ve(this, "state", {
      infoWindow: null
    }), ve(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : kr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ve(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Vt({
      updaterMap: zT,
      eventMap: FT,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: zT,
      eventMap: FT,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Zt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? br(it.only(this.props.children), this.containerElement) : null;
  }
}
ve(Tfe, "contextType", yt);
function UT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UT(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $T = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, WT = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, jfe = {};
function Afe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onLoad: E,
    onUnmount: w
  } = e, S = Ee(yt), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null);
  return v(() => {
    x !== null && x.setMap(S);
  }, [S]), v(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), v(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), v(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), v(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), v(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), v(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), v(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), v(() => {
    x && l && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), v(() => {
    x && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), v(() => {
    x && c && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), v(() => {
    x && p && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), v(() => {
    x && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), v(() => {
    x && g && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(x, "mouseup", g)));
  }, [g]), v(() => {
    x && f && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), v(() => {
    x && m && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), v(() => {
    x && h && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(x, "drag", h)));
  }, [h]), v(() => {
    var j = new google.maps.Polyline(Yf(Yf({}, t || jfe), {}, {
      map: S
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && P(google.maps.event.addListener(j, "dblclick", a)), s && _(google.maps.event.addListener(j, "dragend", s)), l && B(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && H(google.maps.event.addListener(j, "mousemove", c)), p && J(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), g && T(google.maps.event.addListener(j, "mouseup", g)), f && D(google.maps.event.addListener(j, "rightclick", f)), m && O(google.maps.event.addListener(j, "click", m)), h && U(google.maps.event.addListener(j, "drag", h)), y(j), E && E(j), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), w && w(j), j.setMap(null);
    };
  }, []), null;
}
ke(Afe);
class Bfe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      polyline: null
    }), ve(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Yf(Yf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: WT,
      eventMap: $T,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: WT,
      eventMap: $T,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Zt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Bfe, "contextType", yt);
function VT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function HT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VT(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GT = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, qT = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Rfe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: E,
    onLoad: w,
    onUnmount: S,
    onEdit: x
  } = e, y = Ee(yt), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), v(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), v(() => {
    C && typeof l == "function" && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof g == "function" && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), v(() => {
    C && typeof f == "function" && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof m == "function" && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(() => {
    C && typeof h == "function" && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(C, "click", h)));
  }, [h]), v(() => {
    C && typeof E == "function" && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), v(() => {
    var A = new google.maps.Polygon(HT(HT({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && _(google.maps.event.addListener(A, "dblclick", s)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && H(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), g && T(google.maps.event.addListener(A, "mouseover", g)), f && D(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), h && U(google.maps.event.addListener(A, "click", h)), E && Z(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), M !== null && google.maps.event.removeListener(M), S && S(A), A.setMap(null);
    };
  }, []), null;
}
ke(Rfe);
class Ife extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Vt({
      updaterMap: qT,
      eventMap: GT,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: qT,
      eventMap: GT,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Zt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Ife, "contextType", yt);
function ZT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZT(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var KT = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, XT = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Nfe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: S
  } = e, x = Ee(yt), [y, C] = k(null), [P, F] = k(null), [_, I] = k(null), [B, $] = k(null), [V, z] = k(null), [H, X] = k(null), [J, te] = k(null), [ee, L] = k(null), [T, W] = k(null), [D, G] = k(null), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null);
  return v(() => {
    y !== null && y.setMap(x);
  }, [x]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), v(() => {
    y && s && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), v(() => {
    y && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), L(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && g && (T !== null && google.maps.event.removeListener(T), W(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), v(() => {
    y && f && (D !== null && google.maps.event.removeListener(D), G(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(y, "click", m)));
  }, [m]), v(() => {
    y && h && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(y, "drag", h)));
  }, [h]), v(() => {
    y && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), v(() => {
    var Q = new google.maps.Rectangle(Jf(Jf({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), a && F(google.maps.event.addListener(Q, "dblclick", a)), s && I(google.maps.event.addListener(Q, "dragend", s)), l && $(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && X(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && L(google.maps.event.addListener(Q, "mouseover", d)), g && W(google.maps.event.addListener(Q, "mouseup", g)), f && G(google.maps.event.addListener(Q, "rightclick", f)), m && M(google.maps.event.addListener(Q, "click", m)), h && j(google.maps.event.addListener(Q, "drag", h)), E && A(google.maps.event.addListener(Q, "bounds_changed", E)), C(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), _ !== null && google.maps.event.removeListener(_), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), T !== null && google.maps.event.removeListener(T), D !== null && google.maps.event.removeListener(D), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), S && S(Q), Q.setMap(null);
    };
  }, []), null;
}
ke(Nfe);
class Ffe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      rectangle: null
    }), ve(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Jf(Jf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: XT,
      eventMap: KT,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: XT,
      eventMap: KT,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Zt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Ffe, "contextType", yt);
function YT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YT(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JT = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, QT = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, zfe = {};
function Ufe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: S,
    onLoad: x,
    onUnmount: y
  } = e, C = Ee(yt), [P, F] = k(null), [_, I] = k(null), [B, $] = k(null), [V, z] = k(null), [H, X] = k(null), [J, te] = k(null), [ee, L] = k(null), [T, W] = k(null), [D, G] = k(null), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, N] = k(null), [le, ye] = k(null);
  return v(() => {
    P !== null && P.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), v(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), v(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), v(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), v(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), v(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), v(() => {
    P && s && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), v(() => {
    P && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), v(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), v(() => {
    P && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), v(() => {
    P && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), v(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), L(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), v(() => {
    P && g && (T !== null && google.maps.event.removeListener(T), W(google.maps.event.addListener(P, "mouseover", g)));
  }, [g]), v(() => {
    P && f && (D !== null && google.maps.event.removeListener(D), G(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), v(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), v(() => {
    P && h && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(P, "click", h)));
  }, [h]), v(() => {
    P && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), v(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(P, "center_changed", w)));
  }, [h]), v(() => {
    P && S && (le !== null && google.maps.event.removeListener(le), ye(google.maps.event.addListener(P, "radius_changed", S)));
  }, [S]), v(() => {
    var oe = new google.maps.Circle(Qf(Qf({}, t || zfe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && I(google.maps.event.addListener(oe, "dblclick", s)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && L(google.maps.event.addListener(oe, "mouseout", d)), g && W(google.maps.event.addListener(oe, "mouseover", g)), f && G(google.maps.event.addListener(oe, "mouseup", f)), m && M(google.maps.event.addListener(oe, "rightclick", m)), h && j(google.maps.event.addListener(oe, "click", h)), E && A(google.maps.event.addListener(oe, "drag", E)), w && N(google.maps.event.addListener(oe, "center_changed", w)), S && ye(google.maps.event.addListener(oe, "radius_changed", S)), F(oe), x && x(oe), () => {
      _ !== null && google.maps.event.removeListener(_), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), T !== null && google.maps.event.removeListener(T), D !== null && google.maps.event.removeListener(D), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Q !== null && google.maps.event.removeListener(Q), le !== null && google.maps.event.removeListener(le), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
ke(Ufe);
class $fe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      circle: null
    }), ve(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Qf(Qf({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: QT,
      eventMap: JT,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: QT,
      eventMap: JT,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Zt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ve($fe, "contextType", yt);
function ej(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function eh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ej(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ej(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tj = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, nj = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Wfe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: h
  } = e, E = Ee(yt), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null);
  return v(() => {
    w !== null && w.setMap(E);
  }, [E]), v(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && a && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), v(() => {
    w && s && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && g && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), v(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (E !== null) {
      var A = new google.maps.Data(eh(eh({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && _(google.maps.event.addListener(A, "mousemove", i)), a && B(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && H(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && T(google.maps.event.addListener(A, "addfeature", c)), p && D(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && Z(google.maps.event.addListener(A, "setproperty", f)), S(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), M !== null && google.maps.event.removeListener(M), j !== null && google.maps.event.removeListener(j), h && h(w), w.setMap(null));
    };
  }, []), null;
}
ke(Wfe);
class Vfe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      data: null
    }), ve(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(eh(eh({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Vt({
        updaterMap: nj,
        eventMap: tj,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: nj,
      eventMap: tj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Zt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Vfe, "contextType", yt);
function rj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ij = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, sj = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class Hfe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      kmlLayer: null
    }), ve(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(oj(oj({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: sj,
      eventMap: ij,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: sj,
      eventMap: ij,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Zt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ve(Hfe, "contextType", yt);
function SU(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Gfe(e, t) {
  return new t(e.lat, e.lng);
}
function qfe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Zfe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Kfe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Xfe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Yfe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function DU(e, t, n, r) {
  return n !== void 0 ? Xfe(e, t, Kfe(n, google.maps.LatLngBounds, qfe)) : Yfe(e, t, Zfe(r, google.maps.LatLng, Gfe));
}
function Jfe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function aj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qfe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function ehe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Qfe({}, this.container ? SU(this.container, o) : {
        x: 0,
        y: 0
      }), u = DU(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function lj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function the(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function uj(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function cj(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function nhe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = Ee(yt), c = Bn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Bn(() => ehe(c, r, t, n, s), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), oi.createPortal(l, c);
}
ke(nhe);
class hl extends be {
  constructor(t) {
    super(t), ve(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ve(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      kr(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ve(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ve(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = the({
        x: 0,
        y: 0
      }, this.containerRef.current ? SU(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = DU(r, o, this.props.bounds, this.props.position);
      if (!Jfe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ve(this, "draw", () => {
      this.onPositionElement();
    }), ve(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Hr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = uj(t.position), r = uj(this.props.position), o = cj(t.bounds), i = cj(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? oi.createPortal(on.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: it.only(this.props.children)
    }), t) : null;
  }
}
ve(hl, "FLOAT_PANE", "floatPane");
ve(hl, "MAP_PANE", "mapPane");
ve(hl, "MARKER_LAYER", "markerLayer");
ve(hl, "OVERLAY_LAYER", "overlayLayer");
ve(hl, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ve(hl, "contextType", yt);
function rhe() {
}
function pj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fj = {
  onDblClick: "dblclick",
  onClick: "click"
}, hj = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function ohe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = Ee(yt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Bn(() => new google.maps.GroundOverlay(t, a, r), []);
  return v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), v(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ke(ohe);
class MU extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      groundOverlay: null
    }), ve(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    kr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, dj(dj({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: hj,
      eventMap: fj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: hj,
      eventMap: fj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ve(MU, "defaultProps", {
  onLoad: rhe
});
ve(MU, "contextType", yt);
function gj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function th(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gj(Object(n), !0).forEach(function(r) {
      ve(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mj = {}, vj = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function ihe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = Ee(yt), [a, s] = k(null);
  return v(() => {
    google.maps.visualization || kr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    kr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(th(th({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ke(ihe);
class she extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      heatmapLayer: null
    }), ve(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    kr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), kr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(th(th({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: vj,
      eventMap: mj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: vj,
      eventMap: mj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Zt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ve(she, "contextType", yt);
var yj = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, bj = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class ahe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      streetViewPanorama: null
    }), ve(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Vt({
      updaterMap: bj,
      eventMap: yj,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: bj,
      eventMap: yj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Zt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ve(ahe, "contextType", yt);
class lhe extends be {
  constructor() {
    super(...arguments), ve(this, "state", {
      streetViewService: null
    }), ve(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ve(lhe, "contextType", yt);
var wj = {
  onDirectionsChanged: "directions_changed"
}, Cj = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class uhe extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "state", {
      directionsRenderer: null
    }), ve(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Vt({
      updaterMap: Cj,
      eventMap: wj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: Cj,
      eventMap: wj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Zt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ve(uhe, "contextType", yt);
var xj = {
  onPlacesChanged: "places_changed"
}, Ej = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class che extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "containerElement", Hr()), ve(this, "state", {
      searchBox: null
    }), ve(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (kr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Vt({
          updaterMap: Ej,
          eventMap: xj,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: Ej,
      eventMap: xj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Zt(this.registeredEvents));
  }
  render() {
    return on.jsx("div", {
      ref: this.containerElement,
      children: it.only(this.props.children)
    });
  }
}
ve(che, "contextType", yt);
var Oj = {
  onPlaceChanged: "place_changed"
}, kj = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class TU extends be {
  constructor() {
    super(...arguments), ve(this, "registeredEvents", []), ve(this, "containerElement", Hr()), ve(this, "state", {
      autocomplete: null
    }), ve(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    kr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Vt({
        updaterMap: kj,
        eventMap: Oj,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Zt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: kj,
      eventMap: Oj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Zt(this.registeredEvents);
  }
  render() {
    return on.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: it.only(this.props.children)
    });
  }
}
ve(TU, "defaultProps", {
  className: ""
});
ve(TU, "contextType", yt);
let phe = { data: "" }, dhe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || phe, fhe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, hhe = /\/\*[^]*?\*\/|  +/g, _j = /\n+/g, hs = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? hs(a, i) : i + "{" + hs(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += hs(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += hs.p ? hs.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Oi = {}, jU = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + jU(e[n]);
    return t;
  }
  return e;
}, ghe = (e, t, n, r, o) => {
  let i = jU(e), a = Oi[i] || (Oi[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Oi[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = fhe.exec(u.replace(hhe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(_j, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(_j, " ").trim();
      return d[0];
    })(e);
    Oi[a] = hs(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Oi.g ? Oi.g : null;
  return n && (Oi.g = Oi[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Oi[a], t, r, s), a;
}, mhe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : hs(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Jg(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return ghe(n.unshift ? n.raw ? mhe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, dhe(t.target), t.g, t.o, t.k);
}
let AU, s0, a0;
Jg.bind({ g: 1 });
let Bi = Jg.bind({ k: 1 });
function vhe(e, t, n, r) {
  hs.p = t, AU = e, s0 = n, a0 = r;
}
function js(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: s0 && s0() }, s), n.o = / *go\d+/.test(l), s.className = Jg.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), a0 && u[0] && a0(s), AU(u, s);
    }
    return o;
  };
}
var yhe = (e) => typeof e == "function", bhe = (e, t) => yhe(e) ? e(t) : e, whe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Che = Bi`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, xhe = Bi`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Ehe = Bi`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Ohe = js("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Che} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${xhe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Ehe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, khe = Bi`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, _he = js("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${khe} 1s linear infinite;
`, Lhe = Bi`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Phe = Bi`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, She = js("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Lhe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Phe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Dhe = js("div")`
  position: absolute;
`, Mhe = js("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, The = Bi`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, jhe = js("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${The} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, Ahe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? ze.createElement(jhe, null, t) : t : n === "blank" ? null : ze.createElement(Mhe, null, ze.createElement(_he, { ...r }), n !== "loading" && ze.createElement(Dhe, null, n === "error" ? ze.createElement(Ohe, { ...r }) : ze.createElement(She, { ...r })));
}, Bhe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Rhe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, Ihe = "0%{opacity:0;} 100%{opacity:1;}", Nhe = "0%{opacity:1;} 100%{opacity:0;}", Fhe = js("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, zhe = js("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Uhe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = whe() ? [Ihe, Nhe] : [Bhe(n), Rhe(n)];
  return { animation: t ? `${Bi(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Bi(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
ze.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? Uhe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = ze.createElement(Ahe, { toast: e }), a = ze.createElement(zhe, { ...e.ariaProps }, bhe(e.message, e));
  return ze.createElement(Fhe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : ze.createElement(ze.Fragment, null, i, a));
});
vhe(ze.createElement);
Jg`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function $he(e) {
  const { error: t } = e, n = "arkynAudioUploadError";
  return t ? /* @__PURE__ */ q.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function Whe(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynAudioUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ q.jsx("strong", { className: o.trim(), children: t });
}
function Vhe(e) {
  const { onChange: t, value: n, disableDrag: r = !1, onDragging: o } = e, [i, a] = k(!1), s = Qe(null), l = () => {
    a(!0);
  }, u = () => {
    a(!1);
  }, c = (f) => {
    if (r || !i || !s.current) return;
    const m = s.current.getBoundingClientRect(), h = f.clientX - m.left, E = Math.min(Math.max(h / m.width * 100, 0), 100);
    t(E);
  }, p = (f) => {
    if (!s.current) return;
    const m = s.current.getBoundingClientRect(), h = f.clientX - m.left, E = Math.min(Math.max(h / m.width * 100, 0), 100);
    t(E);
  };
  v(() => (i ? (o && o(!0), document.addEventListener("mousemove", c), document.addEventListener("mouseup", u)) : (o && o(!1), document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u)), () => {
    document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
  }), [i]);
  const g = `arkynSliderTrack ${i ? "isDragging" : "isNotDragging"}`;
  return /* @__PURE__ */ q.jsxs(
    "div",
    {
      className: g,
      ref: s,
      onMouseDown: l,
      onClick: p,
      children: [
        /* @__PURE__ */ q.jsx("div", { className: "arkynSliderFill", style: { width: `${n}%` } }),
        /* @__PURE__ */ q.jsx("div", { className: "arkynSliderThumb", style: { left: `${n}%` } })
      ]
    }
  );
}
function Hhe(e) {
  var P, F, _, I;
  const {
    filePath: t,
    disabled: n,
    acceptAudio: r,
    handleSelectFile: o,
    isLoading: i,
    reSendAudio: a,
    changeAudioButtonText: s
  } = e, [l, u] = k(0), c = Qe(null), [p, d] = k(!1), [g, f] = k(!1);
  v(() => {
    const B = c.current;
    if (!B) return;
    const $ = () => {
      const V = B.duration, H = B.currentTime / V * 100;
      u(H);
    };
    return B.addEventListener("timeupdate", $), () => {
      B.removeEventListener("timeupdate", $);
    };
  }, []);
  function m(B) {
    const $ = c.current;
    if (!$) return;
    const V = $.duration, z = B / 100 * V;
    $.currentTime = z;
  }
  function h() {
    var B;
    (B = c.current) == null || B.play(), f(!0);
  }
  function E() {
    var B;
    (B = c.current) == null || B.pause(), f(!1);
  }
  function w() {
    g ? E() : h();
  }
  const S = (P = c.current) == null ? void 0 : P.currentTime, x = (F = c.current) == null ? void 0 : F.duration;
  function y(B) {
    if (!B) return "00:00";
    const $ = Math.floor(B / 60), V = Math.floor(B % 60), z = String($).padStart(2, "0"), H = String(V).padStart(2, "0");
    return `${z}:${H}`;
  }
  p || !g ? (_ = c.current) == null || _.pause() : g && ((I = c.current) == null || I.play());
  function C() {
    if (n) return;
    const B = document.createElement("input");
    B.type = "file", B.accept = r, B.onchange = ($) => {
      var z;
      const V = (z = $.target.files) == null ? void 0 : z[0];
      V && o(V);
    }, B.click();
  }
  return /* @__PURE__ */ q.jsxs("div", { className: "arkynAudioUploadHasFileContentContainer", children: [
    /* @__PURE__ */ q.jsx("audio", { ref: c, src: t, onEnded: E }),
    /* @__PURE__ */ q.jsxs("div", { className: "arkynAudioUploadAudioPlayer", children: [
      /* @__PURE__ */ q.jsxs("button", { type: "button", onClick: w, children: [
        g && /* @__PURE__ */ q.jsx(A$, {}),
        !g && /* @__PURE__ */ q.jsx(B$, {})
      ] }),
      /* @__PURE__ */ q.jsx("p", { children: y(S) }),
      /* @__PURE__ */ q.jsx(
        Vhe,
        {
          value: l,
          onChange: m,
          onDragging: d
        }
      ),
      /* @__PURE__ */ q.jsx("p", { children: y(x) })
    ] }),
    /* @__PURE__ */ q.jsx(O8, {}),
    /* @__PURE__ */ q.jsxs("div", { className: "arkynAudioUploadButtonsContainer", children: [
      !!a && /* @__PURE__ */ q.jsx(Oue, { orientation: "bottom", text: "Reenviar áudio", children: /* @__PURE__ */ q.jsx(
        Eue,
        {
          type: "button",
          "aria-label": "resend image",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: i,
          onClick: a,
          icon: _0,
          disabled: n
        }
      ) }),
      /* @__PURE__ */ q.jsx(
        qC,
        {
          isLoading: i,
          onClick: C,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: n,
          children: s
        }
      )
    ] })
  ] });
}
function Ghe(e) {
  const {
    dropAudioText: t,
    isLoading: n,
    acceptAudio: r,
    handleSelectFile: o,
    selectAudioButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ q.jsxs("div", { onDrop: s, className: "arkynAudioUploadNoFileContent", children: [
    /* @__PURE__ */ q.jsx(
      qC,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ q.jsx("p", { children: t })
  ] });
}
function mEe(e) {
  const {
    name: t,
    label: n,
    fileName: r = "file",
    method: o = "POST",
    onUpload: i,
    fileResponseName: a = "url",
    selectAudioButtonText: s = "Selecionar arquivo de áudio",
    dropAudioText: l = "Ou arraste e solte um arquivo de áudio aqui",
    changeAudioButtonText: u = "Trocar arquivo de áudio",
    acceptAudio: c = "audio/*",
    action: p,
    defaultValue: d = "",
    showAsterisk: g = !1,
    disabled: f = !1
  } = e, h = xue()[t], [E, w] = k(d), [S, x] = k(""), [y, C] = k(null), [P, F] = k(d), [_, I] = k(!1);
  async function B(J) {
    if (f) return;
    I(!0), C(J), x("");
    const te = new FormData();
    te.append(r, J), await fetch(p, { method: o, body: te }).then(async (ee) => await ee.json()).then((ee) => {
      ee != null && ee.error ? x(ee.error) : w(ee == null ? void 0 : ee[a]), i && i(ee == null ? void 0 : ee[a]);
    }).catch((ee) => {
      console.error(ee), x("Erro ao enviar audio");
    }).finally(() => I(!1));
  }
  function $(J) {
    if (!f) {
      if (console.log(J.type), J.type.indexOf("audio") === -1) {
        x("O arquivo selecionado não é um arquivo de áudio");
        return;
      }
      F(URL.createObjectURL(J)), B(J);
    }
  }
  const V = h || S, X = `arkynAudioUpload ${V ? "hasError" : "noHasError"} ${P ? "hasAudio" : "noHasAudio"}`;
  return /* @__PURE__ */ q.jsxs("div", { className: "arkynAudioUploadContainer", children: [
    n && /* @__PURE__ */ q.jsx(Whe, { label: n, showAsterisk: g }),
    /* @__PURE__ */ q.jsxs("div", { className: X, children: [
      /* @__PURE__ */ q.jsx("input", { type: "hidden", name: t, value: E || "" }),
      !P && /* @__PURE__ */ q.jsx(
        Ghe,
        {
          disabled: f,
          isLoading: _,
          acceptAudio: c,
          dropAudioText: l,
          handleSelectFile: $,
          selectAudioButtonText: s
        }
      ),
      P && /* @__PURE__ */ q.jsx(
        Hhe,
        {
          filePath: P,
          acceptAudio: c,
          changeAudioButtonText: u,
          disabled: f,
          handleSelectFile: $,
          isLoading: _,
          reSendAudio: V && y ? () => B(y) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ q.jsx($he, { error: V })
  ] });
}
function rc(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, g = { xs: 12, sm: 16, md: 20, lg: 24 }[i], h = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ q.jsxs("button", { className: h, disabled: l || t, ...p, children: [
    /* @__PURE__ */ q.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ q.jsx(ri, { size: g, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ q.jsxs("div", { className: "arkynButtonContent", children: [
      Nd(g, a),
      c,
      Nd(g, s)
    ] })
  ] });
}
function ux() {
  const e = S0(), t = vR(), n = D0(), [r, o] = k(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  v(() => {
    var c, p;
    let u = ((p = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : p.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), v(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const BU = qe({});
function Lj(e) {
  var p;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = ux(), a = Qe(null), s = ((p = a.current) == null ? void 0 : p.name) || "", l = (i == null ? void 0 : i[s]) || null, u = S$(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ q.jsx(BU.Provider, { value: { error: l, id: u, inputRef: a }, children: /* @__PURE__ */ q.jsx(
    "section",
    {
      id: r || s || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function Jr() {
  return Ee(BU);
}
function vEe(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: a = null,
    onCheck: s,
    value: l,
    ...u
  } = e, { id: c, inputRef: p, error: d } = Jr(), g = o || !!d, [f, m] = k(i || !1), h = typeof a == "boolean" ? a : f, S = `arkynCheckbox ${r} ${g ? "errorTrue" : "errorFalse"} ${h ? "checkedTrue" : "checkedFalse"} ${n}`;
  function x() {
    const y = f;
    m(!y), s && s(y ? "" : l || "checked");
  }
  return /* @__PURE__ */ q.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: S,
      onClick: x,
      ...u,
      children: [
        /* @__PURE__ */ q.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: p,
            value: h ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ q.jsx(hh, {})
      ]
    }
  );
}
function qhe(e) {
  const { error: t } = e, n = "arkynFileUploadError";
  return t ? /* @__PURE__ */ q.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function Zhe(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynFileUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ q.jsx("strong", { className: o.trim(), children: t });
}
function RU(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, p = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ q.jsxs(
    "button",
    {
      disabled: a || t,
      className: p.trim(),
      ...l,
      children: [
        /* @__PURE__ */ q.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ q.jsx(ri, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ q.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ q.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function IU(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ q.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ q.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function Khe(e) {
  const {
    disabled: t,
    file: n,
    isLoading: r,
    acceptFile: o,
    changeFileButtonText: i,
    handleSelectFile: a,
    reSendFile: s
  } = e;
  function l() {
    if (t) return;
    const c = document.createElement("input");
    c.type = "file", c.accept = o, c.onchange = (p) => {
      var g;
      const d = (g = p.target.files) == null ? void 0 : g[0];
      d && a(d);
    }, c.click();
  }
  function u() {
    return n.type.startsWith("image/") ? /* @__PURE__ */ q.jsx(R$, {}) : n.type.startsWith("audio/") ? /* @__PURE__ */ q.jsx(I$, {}) : n.type.startsWith("application/zip") ? /* @__PURE__ */ q.jsx(N$, {}) : /* @__PURE__ */ q.jsx(F$, {});
  }
  return /* @__PURE__ */ q.jsxs("div", { className: "arkynFileUploadHasFileContent", children: [
    /* @__PURE__ */ q.jsxs("section", { className: "arkynFileUploadFileContainer", children: [
      /* @__PURE__ */ q.jsx(u, {}),
      /* @__PURE__ */ q.jsx("p", { children: n.name })
    ] }),
    /* @__PURE__ */ q.jsx(eI, {}),
    /* @__PURE__ */ q.jsxs("div", { className: "arkynFileUploadButtonsContainer", children: [
      !!s && /* @__PURE__ */ q.jsx(IU, { orientation: "bottom", text: "Reenviar arquivo", children: /* @__PURE__ */ q.jsx(
        RU,
        {
          type: "button",
          "aria-label": "resend file",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: r,
          onClick: s,
          icon: _0,
          disabled: t
        }
      ) }),
      /* @__PURE__ */ q.jsx(
        rc,
        {
          isLoading: r,
          onClick: l,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: t,
          children: i
        }
      )
    ] })
  ] });
}
function Xhe(e) {
  const {
    dropFileText: t,
    isLoading: n,
    acceptFile: r,
    handleSelectFile: o,
    selectFileButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ q.jsxs("div", { onDrop: s, className: "arkynFileUploadNoFileContent", children: [
    /* @__PURE__ */ q.jsx(
      qC,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ q.jsx("p", { children: t })
  ] });
}
function yEe(e) {
  const {
    name: t,
    label: n,
    showAsterisk: r = !1,
    action: o,
    fileName: i = "file",
    method: a = "POST",
    acceptFile: s = "*",
    fileResponseName: l = "url",
    changeFileButtonText: u = "Alterar arquivo",
    selectFileButtonText: c = "Selecionar arquivo",
    dropFileText: p = "Ou arraste e solte o arquivo aqui",
    onUpload: d,
    disabled: g = !1
  } = e, m = ux()[t], [h, E] = k(""), [w, S] = k(""), [x, y] = k(null), [C, P] = k(!1);
  async function F(z) {
    if (g) return;
    P(!0), y(z), S("");
    const H = new FormData();
    H.append(i, z), await fetch(o, { method: a, body: H }).then(async (X) => await X.json()).then((X) => {
      X != null && X.error ? S(X.error) : E(X == null ? void 0 : X[l]), d && d(X == null ? void 0 : X[l]);
    }).catch((X) => {
      console.error(X), S("Erro ao enviar o arquivo");
    }).finally(() => P(!1));
  }
  function _(z) {
    g || F(z);
  }
  const I = m || w, V = `arkynFileUpload ${I ? "hasError" : "noHasError"} ${x ? "hasFile" : "noHasFile"}`;
  return /* @__PURE__ */ q.jsxs("div", { className: "arkynFileUploadContainer", children: [
    n && /* @__PURE__ */ q.jsx(Zhe, { label: n, showAsterisk: r }),
    /* @__PURE__ */ q.jsxs("div", { className: V, children: [
      /* @__PURE__ */ q.jsx("input", { type: "hidden", name: t, value: h || "" }),
      !x && /* @__PURE__ */ q.jsx(
        Xhe,
        {
          disabled: g,
          isLoading: C,
          acceptFile: s,
          dropFileText: p,
          handleSelectFile: _,
          selectFileButtonText: c
        }
      ),
      x && /* @__PURE__ */ q.jsx(
        Khe,
        {
          disabled: g,
          isLoading: C,
          acceptFile: s,
          file: x,
          handleSelectFile: _,
          changeFileButtonText: u,
          reSendFile: I && x ? () => F(x) : void 0
        }
      )
    ] }),
    I && /* @__PURE__ */ q.jsx(qhe, { error: I })
  ] });
}
function bEe(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = Jr();
  return t ? /* @__PURE__ */ q.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ q.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function Pj(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = Jr(), a = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ q.jsx("label", { className: a.trim(), htmlFor: o, ...r });
}
function Yhe(e) {
  const {
    disabled: t,
    filePath: n,
    isLoading: r,
    acceptImage: o,
    changeImageButtonText: i,
    handleSelectFile: a,
    reSendImage: s
  } = e;
  function l() {
    if (t) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = o, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && a(p);
    }, u.click();
  }
  return /* @__PURE__ */ q.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${n}")` },
      children: [
        s && /* @__PURE__ */ q.jsx(IU, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ q.jsx(
          RU,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: r,
            onClick: s,
            icon: _0,
            disabled: t
          }
        ) }),
        /* @__PURE__ */ q.jsx(
          rc,
          {
            isLoading: r,
            onClick: l,
            variant: "outline",
            size: "sm",
            type: "button",
            disabled: t,
            children: i
          }
        )
      ]
    }
  );
}
function Jhe(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ q.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function Qhe(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ q.jsx("strong", { className: o.trim(), children: t });
}
function ege(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ q.jsxs("div", { onDrop: s, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ q.jsx(
      rc,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ q.jsx("p", { children: t })
  ] });
}
function tge(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: a = "file",
    method: s = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: p = "Selecionar imagem",
    dropImageText: d = "Ou arraste e solte a imagem aqui",
    onUpload: g,
    disabled: f = !1
  } = e, h = ux()[t], [E, w] = k(n), [S, x] = k(""), [y, C] = k(null), [P, F] = k(n), [_, I] = k(!1);
  async function B(J) {
    if (f) return;
    I(!0), C(J), x("");
    const te = new FormData();
    te.append(a, J), await fetch(i, { method: s, body: te }).then(async (ee) => await ee.json()).then((ee) => {
      ee != null && ee.error ? x(ee.error) : w(ee == null ? void 0 : ee[u]), g && g(ee == null ? void 0 : ee[u]);
    }).catch((ee) => {
      console.error(ee), x("Erro ao enviar imagem");
    }).finally(() => I(!1));
  }
  function $(J) {
    f || (F(URL.createObjectURL(J)), B(J));
  }
  const V = h || S, X = `arkynImageUpload ${V ? "hasError" : "noHasError"} ${P ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ q.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ q.jsx(Qhe, { label: r, showAsterisk: o }),
    /* @__PURE__ */ q.jsxs("div", { className: X, children: [
      /* @__PURE__ */ q.jsx("input", { type: "hidden", name: t, value: E || "" }),
      !P && /* @__PURE__ */ q.jsx(
        ege,
        {
          disabled: f,
          isLoading: _,
          acceptImage: l,
          dropImageText: d,
          handleSelectFile: $,
          selectImageButtonText: p
        }
      ),
      P && /* @__PURE__ */ q.jsx(
        Yhe,
        {
          disabled: f,
          isLoading: _,
          acceptImage: l,
          filePath: P,
          handleSelectFile: $,
          changeImageButtonText: c,
          reSendImage: V && y ? () => B(y) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ q.jsx(Jhe, { error: V })
  ] });
}
function ys(e, t, n) {
  if (!e) return /* @__PURE__ */ q.jsx(q.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ q.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ q.jsx("p", { className: n, children: /* @__PURE__ */ q.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function cx(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function NU(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function FU(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const px = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, zU = cx(px.CNPJ).length;
function nge(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    defaultValue: d,
    readOnly: g,
    onFocus: f,
    onBlur: m,
    title: h,
    style: E,
    onChange: w,
    ...S
  } = e;
  function x(z) {
    let H = cx(z);
    const X = FU(H);
    if (!(H.length > zU))
      return H = NU(H, px[X]), H;
  }
  const y = c ? "right" : "left", B = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || g || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: B,
    prefix: ys(s, V, "prefix"),
    sufix: ys(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: x(d || ""),
    disabled: p,
    readOnly: g,
    onFocus: f,
    onBlur: m,
    title: h,
    style: E,
    onChange: w,
    loadingPosition: y,
    iconSize: V,
    Spinner: /* @__PURE__ */ q.jsx(ri, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...S
  };
}
function rge(e) {
  const [t, n] = k(!1), r = Qe(null), { inputRef: o, id: i, error: a } = Jr(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: f,
    iconSize: m,
    loadingPosition: h,
    isLoading: E,
    LeftIcon: w,
    readOnly: S,
    onFocus: x,
    onBlur: y,
    RightIcon: C,
    Spinner: P,
    onChange: F,
    value: _,
    defaultValue: I,
    ...B
  } = nge({ ...e, id: i, isError: l }, t), [$, V] = k(I), z = w && !E, H = C && !E, X = h === "left" && E, J = h === "right" && E;
  function te() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function ee(W) {
    let D = cx(W.target.value);
    const G = FU(D);
    D.length > zU || (D = NU(D, px[G]), W.target.value = D, V(D), F && F(W));
  }
  function L(W) {
    n(!0), x && x(W);
  }
  function T(W) {
    n(!1), y && y(W);
  }
  return /* @__PURE__ */ q.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: te,
      className: d,
      children: [
        g,
        X && P,
        z && /* @__PURE__ */ q.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ q.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: S,
            ref: s,
            value: _ || $,
            onFocus: L,
            onChange: ee,
            onBlur: T,
            ...B
          }
        ),
        H && /* @__PURE__ */ q.jsx(C, { size: m, strokeWidth: 2.5 }),
        J && P,
        f
      ]
    }
  );
}
const oge = 3, ige = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? oge : 0), ld = 2, Sj = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), l0 = (e) => {
  let t = e;
  return typeof e == "string" ? (t = Sj(e), t % 1 !== 0 && (t = t.toFixed(ld))) : t = Number.isInteger(e) ? Number(e) * 10 ** ld : e.toFixed(ld), Sj(t) / 10 ** ld;
}, Dj = (e, t, n) => {
  if (!t) return [0, ""];
  const r = l0(t), o = ige(e, r, n);
  return [r, o];
};
function sge(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: h,
    // showCents = false,
    max: E = 1e9,
    locale: w = "pt-BR",
    currency: S = "BRL",
    ...x
  } = e, y = c ? "right" : "left", B = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: B,
    prefix: ys(s, V, "prefix"),
    sufix: ys(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    locale: w,
    currency: S,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: h,
    max: E,
    // showCents,
    loadingPosition: y,
    iconSize: V,
    Spinner: /* @__PURE__ */ q.jsx(ri, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...x
  };
}
function age(e) {
  const [t, n] = k(!1), [r, o] = k("0"), i = Qe(null), { inputRef: a, id: s, error: l } = Jr(), u = a || i, c = e.isError || !!l, {
    disabled: p,
    title: d,
    style: g,
    className: f,
    prefix: m,
    sufix: h,
    iconSize: E,
    loadingPosition: w,
    isLoading: S,
    LeftIcon: x,
    readOnly: y,
    onFocus: C,
    onBlur: P,
    RightIcon: F,
    Spinner: _,
    value: I,
    max: B,
    onChangeValue: $,
    onKeyPress: V,
    currency: z,
    locale: H,
    name: X,
    defaultValue: J,
    ...te
  } = sge({ ...e, id: s, isError: c }, t), ee = x && !S, L = F && !S, T = w === "left" && S, W = w === "right" && S;
  function D() {
    p || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function G(Z) {
    n(!0), C && C(Z);
  }
  function O(Z) {
    n(!1), P && P(Z);
  }
  const M = (Z) => {
    const [A, Q] = Dj(
      H,
      Z,
      z
    );
    return !B || A <= B ? (o(Q), [A, Q]) : [l0(r), r];
  }, U = (Z) => {
    Z.preventDefault();
    const [A, Q] = M(Z.target.value);
    $ && $(Z, String(A), String(Q));
  }, j = (Z) => V && V(Z, Z.key, Z.key);
  return v(() => {
    const Z = I || +J || void 0, [, A] = Dj(H, Z, z);
    o(A);
  }, [z, J, I]), /* @__PURE__ */ q.jsxs(
    "section",
    {
      title: d,
      style: g,
      onClick: D,
      className: f,
      children: [
        m,
        T && _,
        ee && /* @__PURE__ */ q.jsx(x, { size: E, strokeWidth: 2.5 }),
        /* @__PURE__ */ q.jsx(
          "input",
          {
            value: r,
            onChange: U,
            onBlur: O,
            onFocus: G,
            onKeyUp: j,
            disabled: p || S,
            readOnly: y,
            ...te
          }
        ),
        /* @__PURE__ */ q.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: X,
            value: l0(r)
          }
        ),
        W && _,
        L && /* @__PURE__ */ q.jsx(F, { size: E, strokeWidth: 2.5 }),
        h
      ]
    }
  );
}
function lge(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: h,
    onChange: E,
    showMask: w = !1,
    type: S,
    ...x
  } = e, y = c ? "right" : "left", B = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: B,
    prefix: ys(s, V, "prefix"),
    sufix: ys(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: h,
    onChange: E,
    loadingPosition: y,
    iconSize: V,
    showMask: w,
    Spinner: /* @__PURE__ */ q.jsx(ri, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...x
  };
}
const uge = Ir((e, t) => /* @__PURE__ */ q.jsx("input", { ref: t, ...e }));
function cge(e) {
  const [t, n] = k(!1), r = Qe(null), { inputRef: o, id: i, error: a } = Jr(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: f,
    iconSize: m,
    loadingPosition: h,
    isLoading: E,
    LeftIcon: w,
    readOnly: S,
    onFocus: x,
    onBlur: y,
    RightIcon: C,
    Spinner: P,
    ...F
  } = lge({ ...e, id: i, isError: l }, t), _ = w && !E, I = C && !E, B = h === "left" && E, $ = h === "right" && E;
  function V() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function z(X) {
    n(!0), x && x(X);
  }
  function H(X) {
    n(!1), y && y(X);
  }
  return /* @__PURE__ */ q.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: V,
      className: d,
      children: [
        g,
        B && P,
        _ && /* @__PURE__ */ q.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ q.jsx(
          el,
          {
            component: uge,
            ref: s,
            onFocus: z,
            onBlur: H,
            disabled: u,
            ...F
          }
        ),
        I && /* @__PURE__ */ q.jsx(C, { size: m, strokeWidth: 2.5 }),
        $ && P,
        f
      ]
    }
  );
}
function pge(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: h,
    onChange: E,
    ...w
  } = e, S = c ? "right" : "left", _ = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, B = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: _,
    prefix: ys(s, B, "prefix"),
    sufix: ys(l, B, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: h,
    onChange: E,
    loadingPosition: S,
    iconSize: B,
    Spinner: /* @__PURE__ */ q.jsx(ri, { className: "spinner", size: B, strokeWidth: 2.5 }),
    ...w
  };
}
function dge(e) {
  const [t, n] = k(!1), r = Qe(null), { inputRef: o, id: i, error: a } = Jr(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: f,
    iconSize: m,
    loadingPosition: h,
    isLoading: E,
    LeftIcon: w,
    readOnly: S,
    onFocus: x,
    onBlur: y,
    RightIcon: C,
    type: P,
    Spinner: F,
    ..._
  } = pge({ ...e, id: i, isError: l }, t), I = w && !E, B = C && !E, $ = h === "left" && E, V = h === "right" && E;
  function z() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function H(J) {
    n(!0), x && x(J);
  }
  function X(J) {
    n(!1), y && y(J);
  }
  return P === "hidden" ? /* @__PURE__ */ q.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: s,
      ..._
    }
  ) : /* @__PURE__ */ q.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: z,
      className: d,
      children: [
        g,
        $ && F,
        I && /* @__PURE__ */ q.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ q.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: S,
            ref: s,
            onFocus: H,
            onBlur: X,
            type: P,
            ..._
          }
        ),
        B && /* @__PURE__ */ q.jsx(C, { size: m, strokeWidth: 2.5 }),
        V && F,
        f
      ]
    }
  );
}
function Qg(e) {
  return e.type === "currency" ? /* @__PURE__ */ q.jsx(age, { ...e }) : e.type === "masked" ? /* @__PURE__ */ q.jsx(cge, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ q.jsx(rge, { ...e }) : /* @__PURE__ */ q.jsx(dge, { ...e });
}
function fge(e) {
  const { iconSize: t, isLoading: n, disabled: r, readOnly: o, isFocused: i } = e, l = `arkynMultiSelectChevron ${r || o ? "notAnimate" : ""} ${i ? "focused" : ""}`;
  return n ? /* @__PURE__ */ q.jsx(q.Fragment, {}) : /* @__PURE__ */ q.jsx(L0, { className: l, size: t, strokeWidth: 2.5 });
}
function hge(e) {
  const {
    children: t,
    handleContainerFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s,
    readOnly: l,
    variant: u,
    size: c,
    id: p,
    prefixExists: d
  } = e, g = d ? "hasPrefix" : "", f = o ? "errored" : "", m = r || l || i ? "opacity" : "", h = a ? "focused" : "";
  return /* @__PURE__ */ q.jsx(
    "section",
    {
      id: p,
      className: `arkynMultiSelectContainer ${g} ${u} ${c} ${m} ${f} ${h} ${s}`,
      onClick: n,
      children: t
    }
  );
}
function gge(e) {
  const { children: t, size: n } = e, r = `arkynMultiSelectContent ${n}`;
  return /* @__PURE__ */ q.jsx("div", { className: r, children: t });
}
function mge(e) {
  const { label: t, value: n, handleChangeValue: r } = e;
  return /* @__PURE__ */ q.jsxs("div", { className: "arkynMultiSelectMark", children: [
    t,
    /* @__PURE__ */ q.jsx(
      "button",
      {
        type: "button",
        onClick: (o) => {
          o.stopPropagation(), r(n);
        },
        children: /* @__PURE__ */ q.jsx(P0, {})
      }
    )
  ] });
}
function vge(e) {
  const { label: t, optionHasSelected: n, handleChangeValue: r, value: o, size: i } = e, a = n(o) ? "active" : "", s = `arkynMultiSelectOption ${i} ${a}`;
  return /* @__PURE__ */ q.jsxs("div", { onClick: () => r(o), className: s, children: [
    t,
    " ",
    /* @__PURE__ */ q.jsx(hh, {})
  ] });
}
function yge(e) {
  const { children: t, isFocused: n, isSearchable: r, onSearch: o } = e;
  function i(a) {
    r && o(a.target.value);
  }
  return n ? /* @__PURE__ */ q.jsxs("div", { className: "arkynMultiSelectOptionsContainer", children: [
    r && /* @__PURE__ */ q.jsx(
      Qg,
      {
        type: "search",
        name: "search-select",
        variant: "underline",
        leftIcon: mR,
        onChange: i
      }
    ),
    t
  ] }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function bge(e) {
  const { isFocused: t, handleBlur: n } = e;
  return t ? /* @__PURE__ */ q.jsx("aside", { className: "arkynMultiSelectOverlay", onClick: n }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function wge(e) {
  const { iconSize: t, isLoading: n } = e;
  return n ? /* @__PURE__ */ q.jsx(
    ri,
    {
      className: "arkynMultiSelectSpinner",
      size: t,
      strokeWidth: 2.5
    }
  ) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function wEe(e) {
  const {
    name: t,
    options: n,
    className: r = "",
    placeholder: o = "Selecione...",
    closeOnSelect: i = !1,
    defaultValue: a = [],
    isError: s,
    isLoading: l = !1,
    readOnly: u = !1,
    isSearchable: c = !1,
    leftIcon: p,
    onSearch: d,
    onSelect: g,
    onBlur: f,
    notFoundText: m = "Sem opções disponíveis",
    onFocus: h,
    disabled: E = !1,
    prefix: w,
    size: S = "md",
    value: x,
    variant: y = "solid"
  } = e, C = Jr(), P = Qe(null), F = C.inputRef || P, _ = C.id, I = s || !!C.error, $ = { md: 20, lg: 20 }[S], V = QR(w, $, "prefix"), [z, H] = k(""), [X, J] = k(!1), [te, ee] = k(a), L = x || te;
  function T(j) {
    return L.includes(j);
  }
  function W(j) {
    const Z = n.find((A) => A.value === j);
    return (Z == null ? void 0 : Z.label) || "";
  }
  function D() {
    E || !(F != null && F.current) || X || (J(!0), F.current.focus(), h && h());
  }
  function G() {
    J(!1), f && F.current && F.current.blur();
  }
  function O(j) {
    H(j), d && d(j);
  }
  function M(j) {
    T(j) ? ee(te.filter((Z) => Z !== j)) : ee([...te, j]), g && g(te), i && G();
  }
  const U = n.filter((j) => !!(e.onSearch || !e.isSearchable || j.label.toLowerCase().includes(z.toLowerCase())));
  return /* @__PURE__ */ q.jsxs(
    hge,
    {
      handleContainerFocus: D,
      disabled: E,
      isError: I,
      isFocused: X,
      isLoading: l,
      readOnly: u,
      size: S,
      variant: y,
      className: r,
      prefixExists: !!w,
      id: _,
      children: [
        /* @__PURE__ */ q.jsx(
          "input",
          {
            ref: F,
            name: t,
            value: JSON.stringify(L),
            type: "hidden"
          }
        ),
        V,
        p && /* @__PURE__ */ q.jsx(p, { size: $, strokeWidth: 2.5 }),
        /* @__PURE__ */ q.jsxs(gge, { size: S, children: [
          L.map((j) => /* @__PURE__ */ q.jsx(
            mge,
            {
              label: W(j),
              value: j,
              handleChangeValue: M
            },
            j
          )),
          L.length <= 0 && /* @__PURE__ */ q.jsx("p", { children: o })
        ] }),
        /* @__PURE__ */ q.jsxs(
          yge,
          {
            isFocused: X,
            isSearchable: c,
            onSearch: O,
            children: [
              U.map(({ label: j, value: Z }) => /* @__PURE__ */ q.jsx(
                vge,
                {
                  label: j,
                  value: Z,
                  size: S,
                  handleChangeValue: M,
                  optionHasSelected: T
                },
                Z
              )),
              U.length <= 0 && /* @__PURE__ */ q.jsx("p", { children: m })
            ]
          }
        ),
        /* @__PURE__ */ q.jsx(
          fge,
          {
            disabled: E,
            isFocused: X,
            readOnly: u,
            iconSize: $,
            isLoading: l
          }
        ),
        /* @__PURE__ */ q.jsx(wge, { iconSize: $, isLoading: l }),
        /* @__PURE__ */ q.jsx(bge, { handleBlur: G, isFocused: X })
      ]
    }
  );
}
const Na = [
  {
    name: "Afghanistan",
    code: "+93",
    prefix: null,
    iso: "AF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/af.svg",
    mask: "__-___-____"
  },
  {
    name: "Aland Islands",
    code: "+358",
    prefix: null,
    iso: "AX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ax.svg",
    mask: "(___)___-__-__"
  },
  {
    name: "Albania",
    code: "+355",
    prefix: null,
    iso: "AL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/al.svg",
    mask: "(___)___-___"
  },
  {
    name: "Algeria",
    code: "+213",
    prefix: null,
    iso: "DZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dz.svg",
    mask: "__-___-____"
  },
  {
    name: "American Samoa",
    code: "+1",
    prefix: "684",
    iso: "AS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/as.svg",
    mask: "(684)___-____"
  },
  {
    name: "Andorra",
    code: "+376",
    prefix: null,
    iso: "AD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ad.svg",
    mask: "___-___"
  },
  {
    name: "Angola",
    code: "+244",
    prefix: null,
    iso: "AO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ao.svg",
    mask: "(___)___-___"
  },
  {
    name: "Anguilla",
    code: "+1",
    prefix: "264",
    iso: "AI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ai.svg",
    mask: "(264)___-____"
  },
  {
    name: "Antarctica",
    code: "+672",
    prefix: "1",
    iso: "AQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/aq.svg",
    mask: "1__-___"
  },
  {
    name: "Antigua and Barbuda",
    code: "+1",
    prefix: "268",
    iso: "AG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ag.svg",
    mask: "(268)___-____"
  },
  {
    name: "Argentina",
    code: "+54",
    prefix: null,
    iso: "AR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ar.svg",
    mask: "(___)___-____"
  },
  {
    name: "Armenia",
    code: "+374",
    prefix: null,
    iso: "AM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/am.svg",
    mask: "__-___-___"
  },
  {
    name: "Aruba",
    code: "+297",
    prefix: null,
    iso: "AW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/aw.svg",
    mask: "___-____"
  },
  {
    name: "Ascension Island",
    code: "+247",
    prefix: null,
    iso: "AC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sh.svg",
    mask: "____"
  },
  {
    name: "Australia",
    code: "+61",
    prefix: null,
    iso: "AU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/au.svg",
    mask: "_-____-____"
  },
  {
    name: "Austria",
    code: "+43",
    prefix: null,
    iso: "AT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/at.svg",
    mask: "(___)___-____"
  },
  {
    name: "Azerbaijan",
    code: "+994",
    prefix: null,
    iso: "AZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/az.svg",
    mask: "__-___-__-__"
  },
  {
    name: "Bahamas",
    code: "+1",
    prefix: "242",
    iso: "BS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bs.svg",
    mask: "(242)___-____"
  },
  {
    name: "Bahrain",
    code: "+973",
    prefix: null,
    iso: "BH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bh.svg",
    mask: "____-____"
  },
  {
    name: "Bangladesh",
    code: "+880",
    prefix: "1",
    iso: "BD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bd.svg",
    mask: "1___-______"
  },
  {
    name: "Barbados",
    code: "+1",
    prefix: "246",
    iso: "BB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bb.svg",
    mask: "(246)___-____"
  },
  {
    name: "Belarus",
    code: "+375",
    prefix: null,
    iso: "BY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/by.svg",
    mask: "(__)___-__-__"
  },
  {
    name: "Belgium",
    code: "+32",
    prefix: null,
    iso: "BE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/be.svg",
    mask: "(___)___-___"
  },
  {
    name: "Belize",
    code: "+501",
    prefix: null,
    iso: "BZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bz.svg",
    mask: "___-____"
  },
  {
    name: "Benin",
    code: "+229",
    prefix: null,
    iso: "BJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bj.svg",
    mask: "__-__-____"
  },
  {
    name: "Bermuda",
    code: "+1",
    prefix: "441",
    iso: "BM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bm.svg",
    mask: "(441)___-____"
  },
  {
    name: "Bhutan",
    code: "+975",
    prefix: null,
    iso: "BT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bt.svg",
    mask: "_-___-___"
  },
  {
    name: "Bolivia",
    code: "+591",
    prefix: null,
    iso: "BO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bo.svg",
    mask: "_-___-____"
  },
  {
    name: "Bosnia and Herzegovina",
    code: "+387",
    prefix: null,
    iso: "BA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ba.svg",
    mask: "__-_____"
  },
  {
    name: "Botswana",
    code: "+267",
    prefix: null,
    iso: "BW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bw.svg",
    mask: "__-___-___"
  },
  {
    name: "Brasil",
    code: "+55",
    prefix: null,
    iso: "BR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/br.svg",
    mask: "(__) _____-____"
  },
  {
    name: "British Indian Ocean Territory",
    code: "+246",
    prefix: null,
    iso: "IO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/io.svg",
    mask: "___-____"
  },
  {
    name: "Brunei Darussalam",
    code: "+673",
    prefix: null,
    iso: "BN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bn.svg",
    mask: "___-____"
  },
  {
    name: "Bulgaria",
    code: "+359",
    prefix: null,
    iso: "BG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bg.svg",
    mask: "(___)___-___"
  },
  {
    name: "Burkina Faso",
    code: "+226",
    prefix: null,
    iso: "BF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bf.svg",
    mask: "__-__-____"
  },
  {
    name: "Burundi",
    code: "+257",
    prefix: null,
    iso: "BI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bi.svg",
    mask: "__-__-____"
  },
  {
    name: "Cambodia",
    code: "+855",
    prefix: null,
    iso: "KH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kh.svg",
    mask: "__-___-___"
  },
  {
    name: "Cameroon",
    code: "+237",
    prefix: null,
    iso: "CM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cm.svg",
    mask: "____-____"
  },
  {
    name: "Canada",
    code: "+1",
    prefix: null,
    iso: "CA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ca.svg",
    mask: "(___)___-____"
  },
  {
    name: "Cape Verde",
    code: "+238",
    prefix: null,
    iso: "CV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cv.svg",
    mask: "(___)__-__"
  },
  {
    name: "Cayman Islands",
    code: "+1",
    prefix: "345",
    iso: "KY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ky.svg",
    mask: "(345)___-____"
  },
  {
    name: "Central African Republic",
    code: "+236",
    prefix: null,
    iso: "CF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cf.svg",
    mask: "__-__-____"
  },
  {
    name: "Chad",
    code: "+235",
    prefix: null,
    iso: "TD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/td.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Chile",
    code: "+56",
    prefix: null,
    iso: "CL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cl.svg",
    mask: "_-____-____"
  },
  {
    name: "China",
    code: "+86",
    prefix: null,
    iso: "CN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cn.svg",
    mask: "__-_____-_____"
  },
  {
    name: "Christmas Island",
    code: "+61",
    prefix: null,
    iso: "CX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cx.svg",
    mask: "_-____-____"
  },
  {
    name: "Cocos (Keeling) Islands",
    code: "+61",
    prefix: null,
    iso: "CC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cc.svg",
    mask: "_-____-____"
  },
  {
    name: "Colombia",
    code: "+57",
    prefix: null,
    iso: "CO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/co.svg",
    mask: "(___)___-____"
  },
  {
    name: "Comoros",
    code: "+269",
    prefix: null,
    iso: "KM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/km.svg",
    mask: "__-_____"
  },
  {
    name: "Congo",
    code: "+242",
    prefix: null,
    iso: "CG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cg.svg",
    mask: "__-_____"
  },
  {
    name: "Cook Islands",
    code: "+682",
    prefix: null,
    iso: "CK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ck.svg",
    mask: "__-___"
  },
  {
    name: "Costa Rica",
    code: "+506",
    prefix: null,
    iso: "CR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cr.svg",
    mask: "____-____"
  },
  {
    name: "Croatia",
    code: "+385",
    prefix: null,
    iso: "HR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hr.svg",
    mask: "__-___-___"
  },
  {
    name: "Cuba",
    code: "+53",
    prefix: null,
    iso: "CU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cu.svg",
    mask: "_-___-____"
  },
  {
    name: "Cyprus",
    code: "+357",
    prefix: null,
    iso: "CY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cy.svg",
    mask: "__-___-___"
  },
  {
    name: "Czech Republic",
    code: "+420",
    prefix: null,
    iso: "CZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cz.svg",
    mask: "(___)___-___"
  },
  {
    name: "Democratic Republic of the Congo",
    code: "+243",
    prefix: null,
    iso: "CD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cd.svg",
    mask: "(___)___-___"
  },
  {
    name: "Denmark",
    code: "+45",
    prefix: null,
    iso: "DK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dk.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Djibouti",
    code: "+253",
    prefix: null,
    iso: "DJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dj.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Dominica",
    code: "+1",
    prefix: "767",
    iso: "DM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dm.svg",
    mask: "(767)___-____"
  },
  {
    name: "Dominican Republic",
    code: "+1",
    prefix: "849",
    iso: "DO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/do.svg",
    mask: "(894)___-____"
  },
  {
    name: "Ecuador",
    code: "+593",
    prefix: null,
    iso: "EC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ec.svg",
    mask: "__-___-____"
  },
  {
    name: "Egypt",
    code: "+20",
    prefix: null,
    iso: "EG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/eg.svg",
    mask: "(___)___-____"
  },
  {
    name: "El Salvador",
    code: "+503",
    prefix: null,
    iso: "SV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sv.svg",
    mask: "__-__-____"
  },
  {
    name: "Equatorial Guinea",
    code: "+240",
    prefix: null,
    iso: "GQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gq.svg",
    mask: "__-___-____"
  },
  {
    name: "Eritrea",
    code: "+291",
    prefix: null,
    iso: "ER",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/er.svg",
    mask: "_-___-___"
  },
  {
    name: "Estonia",
    code: "+372",
    prefix: null,
    iso: "EE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ee.svg",
    mask: "____-____"
  },
  {
    name: "Eswatini",
    code: "+268",
    prefix: null,
    iso: "SZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sz.svg",
    mask: "__-__-____"
  },
  {
    name: "Ethiopia",
    code: "+251",
    prefix: null,
    iso: "ET",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/et.svg",
    mask: "__-___-____"
  },
  {
    name: "Falkland Islands (Malvinas)",
    code: "+500",
    prefix: null,
    iso: "FK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fk.svg",
    mask: "_____"
  },
  {
    name: "Faroe Islands",
    code: "+298",
    prefix: null,
    iso: "FO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fo.svg",
    mask: "__ __ __"
  },
  {
    name: "Fiji",
    code: "+679",
    prefix: null,
    iso: "FJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fj.svg",
    mask: "__-_____"
  },
  {
    name: "Finland",
    code: "+358",
    prefix: null,
    iso: "FI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fi.svg",
    mask: "__ ___ ____"
  },
  {
    name: "France",
    code: "+33",
    prefix: null,
    iso: "FR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fr.svg",
    mask: "_ __ __ __ __"
  },
  {
    name: "French Guiana",
    code: "+594",
    prefix: null,
    iso: "GF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gf.svg",
    mask: "___ __ __ __"
  },
  {
    name: "French Polynesia",
    code: "+689",
    prefix: null,
    iso: "PF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pf.svg",
    mask: "__ __ __ __"
  },
  {
    name: "Gabon",
    code: "+241",
    prefix: null,
    iso: "GA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ga.svg",
    mask: "_ __ __ __"
  },
  {
    name: "Gambia",
    code: "+220",
    prefix: null,
    iso: "GM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gm.svg",
    mask: "___ ____"
  },
  {
    name: "Georgia",
    code: "+995",
    prefix: null,
    iso: "GE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ge.svg",
    mask: "(___)___-___"
  },
  {
    name: "Germany",
    code: "+49",
    prefix: "3",
    iso: "DE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/de.svg",
    mask: "(3____) __-____"
  },
  {
    name: "Ghana",
    code: "+233",
    prefix: "03",
    iso: "GH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gh.svg",
    mask: "03_ ___ ____"
  },
  {
    name: "Gibraltar",
    code: "+350",
    prefix: null,
    iso: "GI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gi.svg",
    mask: "___-_____"
  },
  {
    name: "Greece",
    code: "+30",
    prefix: null,
    iso: "GR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gr.svg",
    mask: "(___)___-____"
  },
  {
    name: "Greenland",
    code: "+299",
    prefix: null,
    iso: "GL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gl.svg",
    mask: "__-__-__"
  },
  {
    name: "Grenada",
    code: "+1",
    prefix: "473",
    iso: "GD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gd.svg",
    mask: "(473)___-____"
  },
  {
    name: "Guadeloupe",
    code: "+590",
    prefix: null,
    iso: "GP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gp.svg",
    mask: "___ __ __ __"
  },
  {
    name: "Guam",
    code: "+1",
    prefix: "671",
    iso: "GU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gu.svg",
    mask: "671 ___ ____"
  },
  {
    name: "Guatemala",
    code: "+502",
    prefix: null,
    iso: "GT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gt.svg",
    mask: "_-___-____"
  },
  {
    name: "Guernsey",
    code: "+44",
    prefix: null,
    iso: "GG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gg.svg",
    mask: "(____)______"
  },
  {
    name: "Guinea",
    code: "+224",
    prefix: null,
    iso: "GN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gn.svg",
    mask: "__-___-___"
  },
  {
    name: "Guinea-Bissau",
    code: "+245",
    prefix: null,
    iso: "GW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gw.svg",
    mask: "_-______"
  },
  {
    name: "Guyana",
    code: "+592",
    prefix: null,
    iso: "GY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gy.svg",
    mask: "___-____"
  },
  {
    name: "Haiti",
    code: "+509",
    prefix: null,
    iso: "HT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ht.svg",
    mask: "__-__-____"
  },
  {
    name: "Holy See (Vatican City State)",
    code: "+39",
    prefix: "06698",
    iso: "VA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/va.svg",
    mask: "06 698_____"
  },
  {
    name: "Honduras",
    code: "+504",
    prefix: null,
    iso: "HN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hn.svg",
    mask: "____-____"
  },
  {
    name: "Hong Kong",
    code: "+852",
    prefix: null,
    iso: "HK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hk.svg",
    mask: "____-____"
  },
  {
    name: "Hungary",
    code: "+36",
    prefix: null,
    iso: "HU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hu.svg",
    mask: "__ ___ ____"
  },
  {
    name: "Iceland",
    code: "+354",
    prefix: null,
    iso: "IS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/is.svg",
    mask: "___-____"
  },
  {
    name: "India",
    code: "+91",
    prefix: null,
    iso: "IN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/in.svg",
    mask: "(____)___-___"
  },
  {
    name: "Indonesia",
    code: "+62",
    prefix: "8",
    iso: "ID",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/id.svg",
    mask: "(8__)___-__-___"
  },
  {
    name: "Iran",
    code: "+98",
    prefix: null,
    iso: "IR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ir.svg",
    mask: "(___)___-____"
  },
  {
    name: "Iraq",
    code: "+964",
    prefix: null,
    iso: "IQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/iq.svg",
    mask: "(___)___-____"
  },
  {
    name: "Ireland",
    code: "+353",
    prefix: null,
    iso: "IE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ie.svg",
    mask: "(___)___-___"
  },
  {
    name: "Isle of Man",
    code: "+44",
    prefix: null,
    iso: "IM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/im.svg",
    mask: "(____)______"
  },
  {
    name: "Israel",
    code: "+972",
    prefix: "5",
    iso: "IL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/il.svg",
    mask: "__-___-____"
  },
  {
    name: "Italy",
    code: "+39",
    prefix: null,
    iso: "IT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/it.svg",
    mask: "(___)____-___"
  },
  {
    name: "Ivory Coast / Cote d'Ivoire",
    code: "+225",
    prefix: null,
    iso: "CI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ci.svg",
    mask: "__-___-___"
  },
  {
    name: "Jamaica",
    code: "+1",
    prefix: "876",
    iso: "JM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jm.svg",
    mask: "(876)___-____"
  },
  {
    name: "Japan",
    code: "+81",
    prefix: null,
    iso: "JP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jp.svg",
    mask: "__-____-____"
  },
  {
    name: "Jersey",
    code: "+44",
    prefix: null,
    iso: "JE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/je.svg",
    mask: "(____)____-______"
  },
  {
    name: "Jordan",
    code: "+962",
    prefix: null,
    iso: "JO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jo.svg",
    mask: "_-____-____"
  },
  {
    name: "Kazakhstan",
    code: "+77",
    prefix: null,
    iso: "KZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kz.svg",
    mask: "(_____) _ __ __"
  },
  {
    name: "Kenya",
    code: "+254",
    prefix: null,
    iso: "KE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ke.svg",
    mask: "___-______"
  },
  {
    name: "Kiribati",
    code: "+686",
    prefix: null,
    iso: "KI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ki.svg",
    mask: "__-___"
  },
  {
    name: "Korea, Democratic People's Republic of Korea",
    code: "+850",
    prefix: null,
    iso: "KP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kp.svg",
    mask: "____-_____________"
  },
  {
    name: "Korea, Republic of South Korea",
    code: "+82",
    prefix: null,
    iso: "KR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kr.svg",
    mask: "__-___-____"
  },
  {
    name: "Kosovo",
    code: "+383",
    prefix: null,
    iso: "XK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/xk.svg",
    mask: "___-___-___"
  },
  {
    name: "Kuwait",
    code: "+965",
    prefix: null,
    iso: "KW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kw.svg",
    mask: "____-____"
  },
  {
    name: "Kyrgyzstan",
    code: "+996",
    prefix: null,
    iso: "KG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kg.svg",
    mask: "(___)___-___"
  },
  {
    name: "Laos",
    code: "+856",
    prefix: "20",
    iso: "LA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/la.svg",
    mask: "(20__)___-___"
  },
  {
    name: "Latvia",
    code: "+371",
    prefix: null,
    iso: "LV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lv.svg",
    mask: "__-___-___"
  },
  {
    name: "Lebanon",
    code: "+961",
    prefix: null,
    iso: "LB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lb.svg",
    mask: "__-___-___"
  },
  {
    name: "Lesotho",
    code: "+266",
    prefix: null,
    iso: "LS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ls.svg",
    mask: "_-___-____"
  },
  {
    name: "Liberia",
    code: "+231",
    prefix: null,
    iso: "LR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lr.svg",
    mask: "__-___-___"
  },
  {
    name: "Libya",
    code: "+218",
    prefix: "21",
    iso: "LY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ly.svg",
    mask: "21-___-____"
  },
  {
    name: "Liechtenstein",
    code: "+423",
    prefix: null,
    iso: "LI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/li.svg",
    mask: "(___)___-____"
  },
  {
    name: "Lithuania",
    code: "+370",
    prefix: null,
    iso: "LT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lt.svg",
    mask: "(___)__-___"
  },
  {
    name: "Luxembourg",
    code: "+352",
    prefix: null,
    iso: "LU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lu.svg",
    mask: "(___)___-___"
  },
  {
    name: "Macau",
    code: "+853",
    prefix: null,
    iso: "MO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mo.svg",
    mask: "____-____"
  },
  {
    name: "Madagascar",
    code: "+261",
    prefix: null,
    iso: "MG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mg.svg",
    mask: "__-__-_____"
  },
  {
    name: "Malawi",
    code: "+265",
    prefix: null,
    iso: "MW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mw.svg",
    mask: "_-____-____"
  },
  {
    name: "Malaysia",
    code: "+60",
    prefix: null,
    iso: "MY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/my.svg",
    mask: "__-___-____"
  },
  {
    name: "Maldives",
    code: "+960",
    prefix: null,
    iso: "MV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mv.svg",
    mask: "___-____"
  },
  {
    name: "Mali",
    code: "+223",
    prefix: null,
    iso: "ML",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ml.svg",
    mask: "__-__-____"
  },
  {
    name: "Malta",
    code: "+356",
    prefix: null,
    iso: "MT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mt.svg",
    mask: "____-____"
  },
  {
    name: "Marshall Islands",
    code: "+692",
    prefix: null,
    iso: "MH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mh.svg",
    mask: "___-____"
  },
  {
    name: "Martinique",
    code: "+596",
    prefix: null,
    iso: "MQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mq.svg",
    mask: "(___)__-__-__"
  },
  {
    name: "Mauritania",
    code: "+222",
    prefix: null,
    iso: "MR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mr.svg",
    mask: "__-__-____"
  },
  {
    name: "Mauritius",
    code: "+230",
    prefix: null,
    iso: "MU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mu.svg",
    mask: "___-____"
  },
  {
    name: "Mayotte",
    code: "+262",
    prefix: null,
    iso: "YT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/yt.svg",
    mask: "_____-____"
  },
  {
    name: "Mexico",
    code: "+52",
    prefix: null,
    iso: "MX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mx.svg",
    mask: "(___)___-____"
  },
  {
    name: "Micronesia, Federated States of Micronesia",
    code: "+691",
    prefix: null,
    iso: "FM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fm.svg",
    mask: "___-____"
  },
  {
    name: "Moldova",
    code: "+373",
    prefix: null,
    iso: "MD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/md.svg",
    mask: "____-____"
  },
  {
    name: "Monaco",
    code: "+377",
    prefix: null,
    iso: "MC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mc.svg",
    mask: "(___)___-___"
  },
  {
    name: "Mongolia",
    code: "+976",
    prefix: null,
    iso: "MN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mn.svg",
    mask: "__-__-____"
  },
  {
    name: "Montenegro",
    code: "+382",
    prefix: null,
    iso: "ME",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/me.svg",
    mask: "__-___-___"
  },
  {
    name: "Montserrat",
    code: "+1",
    prefix: "664",
    iso: "MS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ms.svg",
    mask: "(664)___-____"
  },
  {
    name: "Morocco",
    code: "+212",
    prefix: null,
    iso: "MA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ma.svg",
    mask: "__-____-___"
  },
  {
    name: "Mozambique",
    code: "+258",
    prefix: null,
    iso: "MZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mz.svg",
    mask: "__-___-___"
  },
  {
    name: "Myanmar",
    code: "+95",
    prefix: null,
    iso: "MM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mm.svg",
    mask: "__-___-___"
  },
  {
    name: "Namibia",
    code: "+264",
    prefix: null,
    iso: "NA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/na.svg",
    mask: "__-___-____"
  },
  {
    name: "Nauru",
    code: "+674",
    prefix: null,
    iso: "NR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nr.svg",
    mask: "___-____"
  },
  {
    name: "Nepal",
    code: "+977",
    prefix: null,
    iso: "NP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/np.svg",
    mask: "__-___-___"
  },
  {
    name: "Netherlands",
    code: "+31",
    prefix: null,
    iso: "NL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nl.svg",
    mask: "__-___-____"
  },
  {
    name: "New Caledonia",
    code: "+687",
    prefix: null,
    iso: "NC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nc.svg",
    mask: "__-____"
  },
  {
    name: "New Zealand",
    code: "+64",
    prefix: null,
    iso: "NZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nz.svg",
    mask: "(___)___-____"
  },
  {
    name: "Nicaragua",
    code: "+505",
    prefix: null,
    iso: "NI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ni.svg",
    mask: "____-____"
  },
  {
    name: "Niger",
    code: "+227",
    prefix: null,
    iso: "NE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ne.svg",
    mask: "__-__-____"
  },
  {
    name: "Nigeria",
    code: "+234",
    prefix: null,
    iso: "NG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ng.svg",
    mask: "(___)___-____"
  },
  {
    name: "Niue",
    code: "+683",
    prefix: null,
    iso: "NU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nu.svg",
    mask: "____"
  },
  {
    name: "Norfolk Island",
    code: "+672",
    prefix: "3",
    iso: "NF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nf.svg",
    mask: "3__-___"
  },
  {
    name: "North Macedonia",
    code: "+389",
    prefix: null,
    iso: "MK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mk.svg",
    mask: "__-___-___"
  },
  {
    name: "Northern Mariana Islands",
    code: "+1",
    prefix: "670",
    iso: "MP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mp.svg",
    mask: "(670)___-____"
  },
  {
    name: "Norway",
    code: "+47",
    prefix: null,
    iso: "NO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/no.svg",
    mask: "(___)__-___"
  },
  {
    name: "Oman",
    code: "+968",
    prefix: null,
    iso: "OM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/om.svg",
    mask: "__-___-___"
  },
  {
    name: "Pakistan",
    code: "+92",
    prefix: null,
    iso: "PK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pk.svg",
    mask: "(___)___-____"
  },
  {
    name: "Palau",
    code: "+680",
    prefix: null,
    iso: "PW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pw.svg",
    mask: "___-____"
  },
  {
    name: "Palestine",
    code: "+970",
    prefix: null,
    iso: "PS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ps.svg",
    mask: "__-___-____"
  },
  {
    name: "Panama",
    code: "+507",
    prefix: null,
    iso: "PA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pa.svg",
    mask: "___-____"
  },
  {
    name: "Papua New Guinea",
    code: "+675",
    prefix: null,
    iso: "PG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pg.svg",
    mask: "(___)__-___"
  },
  {
    name: "Paraguay",
    code: "+595",
    prefix: null,
    iso: "PY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/py.svg",
    mask: "(___)___-___"
  },
  {
    name: "Peru",
    code: "+51",
    prefix: null,
    iso: "PE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pe.svg",
    mask: "(___)___-___"
  },
  {
    name: "Philippines",
    code: "+63",
    prefix: null,
    iso: "PH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ph.svg",
    mask: "(___)___-____"
  },
  {
    name: "Pitcairn",
    code: "+870",
    prefix: null,
    iso: "PN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pn.svg",
    mask: "___-___-___"
  },
  {
    name: "Poland",
    code: "+48",
    prefix: null,
    iso: "PL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pl.svg",
    mask: "(___)___-___"
  },
  {
    name: "Portugal",
    code: "+351",
    prefix: null,
    iso: "PT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pt.svg",
    mask: "__-___-____"
  },
  {
    name: "Puerto Rico",
    code: "+1",
    prefix: null,
    iso: "PR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pr.svg",
    mask: "(___) ___ ____"
  },
  {
    name: "Qatar",
    code: "+974",
    prefix: null,
    iso: "QA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/qa.svg",
    mask: "____-____"
  },
  {
    name: "Reunion",
    code: "+262",
    prefix: null,
    iso: "RE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/re.svg",
    mask: "_____-____"
  },
  {
    name: "Romania",
    code: "+40",
    prefix: null,
    iso: "RO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ro.svg",
    mask: "__-___-____"
  },
  {
    name: "Russia",
    code: "+7",
    prefix: null,
    iso: "RU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ru.svg",
    mask: "(___)___-__-__"
  },
  {
    name: "Rwanda",
    code: "+250",
    prefix: null,
    iso: "RW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/rw.svg",
    mask: "(___)___-___"
  },
  {
    name: "Saint Barthelemy",
    code: "+590",
    prefix: null,
    iso: "BL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bl.svg",
    mask: "___-__-__-__"
  },
  {
    name: "Saint Helena, Ascension and Tristan Da Cunha",
    code: "+290",
    prefix: null,
    iso: "SH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sh.svg",
    mask: "____"
  },
  {
    name: "Saint Kitts and Nevis",
    code: "+1",
    prefix: null,
    iso: "KN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kn.svg",
    mask: "(869)___-____"
  },
  {
    name: "Saint Lucia",
    code: "+1",
    prefix: "758",
    iso: "LC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lc.svg",
    mask: "(758)___-____"
  },
  {
    name: "Saint Martin",
    code: "+590",
    prefix: null,
    iso: "MF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mf.svg",
    mask: "(___)___-___"
  },
  {
    name: "Saint Pierre and Miquelon",
    code: "+508",
    prefix: null,
    iso: "PM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pm.svg",
    mask: "__-____"
  },
  {
    name: "Saint Vincent and the Grenadines",
    code: "+1",
    prefix: "784",
    iso: "VC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vc.svg",
    mask: "(784)___-____"
  },
  {
    name: "Samoa",
    code: "+685",
    prefix: null,
    iso: "WS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ws.svg",
    mask: "__-____"
  },
  {
    name: "San Marino",
    code: "+378",
    prefix: null,
    iso: "SM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sm.svg",
    mask: "____-______"
  },
  {
    name: "Sao Tome and Principe",
    code: "+239",
    prefix: null,
    iso: "ST",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/st.svg",
    mask: "__-_____"
  },
  {
    name: "Saudi Arabia",
    code: "+966",
    prefix: null,
    iso: "SA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sa.svg",
    mask: "_-____-____"
  },
  {
    name: "Senegal",
    code: "+221",
    prefix: null,
    iso: "SN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sn.svg",
    mask: "__-___-____"
  },
  {
    name: "Serbia",
    code: "+381",
    prefix: null,
    iso: "RS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/rs.svg",
    mask: "__-___-____"
  },
  {
    name: "Seychelles",
    code: "+248",
    prefix: null,
    iso: "SC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sc.svg",
    mask: "_-___-___"
  },
  {
    name: "Sierra Leone",
    code: "+232",
    prefix: null,
    iso: "SL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sl.svg",
    mask: "__-______"
  },
  {
    name: "Singapore",
    code: "+65",
    prefix: null,
    iso: "SG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sg.svg",
    mask: "____-____"
  },
  {
    name: "Sint Maarten",
    code: "+1",
    prefix: "721",
    iso: "SX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sx.svg",
    mask: "(721)___-____"
  },
  {
    name: "Slovakia",
    code: "+421",
    prefix: null,
    iso: "SK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sk.svg",
    mask: "(___)___-___"
  },
  {
    name: "Slovenia",
    code: "+386",
    prefix: null,
    iso: "SI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/si.svg",
    mask: "__-___-___"
  },
  {
    name: "Solomon Islands",
    code: "+677",
    prefix: null,
    iso: "SB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sb.svg",
    mask: "___-____"
  },
  {
    name: "Somalia",
    code: "+252",
    prefix: null,
    iso: "SO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/so.svg",
    mask: "__-___-___"
  },
  {
    name: "South Africa",
    code: "+27",
    prefix: null,
    iso: "ZA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/za.svg",
    mask: "__-___-____"
  },
  {
    name: "South Georgia and the South Sandwich Islands",
    code: "+500",
    prefix: null,
    iso: "GS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gs.svg",
    mask: "_____"
  },
  {
    name: "South Sudan",
    code: "+211",
    prefix: null,
    iso: "SS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ss.svg",
    mask: "__-___-____"
  },
  {
    name: "Spain",
    code: "+34",
    prefix: null,
    iso: "ES",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/es.svg",
    mask: "(___)___-___"
  },
  {
    name: "Sri Lanka",
    code: "+94",
    prefix: null,
    iso: "LK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lk.svg",
    mask: "__-___-____"
  },
  {
    name: "Sudan",
    code: "+249",
    prefix: null,
    iso: "SD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sd.svg",
    mask: "__-___-____"
  },
  {
    name: "Suriname",
    code: "+597",
    prefix: null,
    iso: "SR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sr.svg",
    mask: "___-____"
  },
  {
    name: "Svalbard and Jan Mayen",
    code: "+47",
    prefix: null,
    iso: "SJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sj.svg",
    mask: "(___)__-___"
  },
  {
    name: "Sweden",
    code: "+46",
    prefix: null,
    iso: "SE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/se.svg",
    mask: "__-___-____"
  },
  {
    name: "Switzerland",
    code: "+41",
    prefix: null,
    iso: "CH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ch.svg",
    mask: "__-___-____"
  },
  {
    name: "Syrian Arab Republic",
    code: "+963",
    prefix: null,
    iso: "SY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sy.svg",
    mask: "__-____-___"
  },
  {
    name: "Taiwan",
    code: "+886",
    prefix: null,
    iso: "TW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tw.svg",
    mask: "_-____-____"
  },
  {
    name: "Tajikistan",
    code: "+992",
    prefix: null,
    iso: "TJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tj.svg",
    mask: "__-___-____"
  },
  {
    name: "United Republic of Tanzania",
    code: "+255",
    prefix: null,
    iso: "TZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tz.svg",
    mask: "__-___-____"
  },
  {
    name: "Thailand",
    code: "+66",
    prefix: null,
    iso: "TH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/th.svg",
    mask: "__-___-____"
  },
  {
    name: "Timor-Leste",
    code: "+670",
    prefix: null,
    iso: "TL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tl.svg",
    mask: "___-_____"
  },
  {
    name: "Togo",
    code: "+228",
    prefix: null,
    iso: "TG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tg.svg",
    mask: "__-___-___"
  },
  {
    name: "Tokelau",
    code: "+690",
    prefix: null,
    iso: "TK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tk.svg",
    mask: "____"
  },
  {
    name: "Tonga",
    code: "+676",
    prefix: null,
    iso: "TO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/to.svg",
    mask: "_____"
  },
  {
    name: "Trinidad and Tobago",
    code: "+1",
    prefix: "868",
    iso: "TT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tt.svg",
    mask: "(868)___-____"
  },
  {
    name: "Tunisia",
    code: "+216",
    prefix: null,
    iso: "TN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tn.svg",
    mask: "__-___-___"
  },
  {
    name: "Turkey",
    code: "+90",
    prefix: null,
    iso: "TR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tr.svg",
    mask: "(___)___-____"
  },
  {
    name: "Turkmenistan",
    code: "+993",
    prefix: null,
    iso: "TM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tm.svg",
    mask: "_-___-____"
  },
  {
    name: "Turks and Caicos Islands",
    code: "+1",
    prefix: "249",
    iso: "TC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tc.svg",
    mask: "(249)___-___"
  },
  {
    name: "Tuvalu",
    code: "+688",
    prefix: null,
    iso: "TV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tv.svg",
    mask: "______"
  },
  {
    name: "Uganda",
    code: "+256",
    prefix: null,
    iso: "UG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ug.svg",
    mask: "(___)___-___"
  },
  {
    name: "Ukraine",
    code: "+380",
    prefix: null,
    iso: "UA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ua.svg",
    mask: "(__)___-__-__"
  },
  {
    name: "United Arab Emirates",
    code: "+971",
    prefix: null,
    iso: "AE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ae.svg",
    mask: "_-___-____"
  },
  {
    name: "United Kingdom",
    code: "+44",
    prefix: null,
    iso: "GB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gb.svg",
    mask: "__-____-____"
  },
  {
    name: "United States",
    code: "+1",
    prefix: "408",
    iso: "US",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/us.svg",
    mask: "(408)___-____"
  },
  {
    name: "Uruguay",
    code: "+598",
    prefix: null,
    iso: "UY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/uy.svg",
    mask: "_-___-__-__"
  },
  {
    name: "Uzbekistan",
    code: "+998",
    prefix: null,
    iso: "UZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/uz.svg",
    mask: "__-___-____"
  },
  {
    name: "Vanuatu",
    code: "+678",
    prefix: null,
    iso: "VU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vu.svg",
    mask: "__-_____"
  },
  {
    name: "Venezuela, Bolivarian Republic of Venezuela",
    code: "+58",
    prefix: null,
    iso: "VE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ve.svg",
    mask: "(___)___-____"
  },
  {
    name: "Vietnam",
    code: "+84",
    prefix: null,
    iso: "VN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vn.svg",
    mask: "(___)____-___"
  },
  {
    name: "Virgin Islands, British",
    code: "+1",
    prefix: "284",
    iso: "VG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vg.svg",
    mask: "(284)___-____"
  },
  {
    name: "Virgin Islands, U.S.",
    code: "+1",
    prefix: "340",
    iso: "VI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vi.svg",
    mask: "(340)___-____"
  },
  {
    name: "Wallis and Futuna",
    code: "+681",
    prefix: null,
    iso: "WF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/wf.svg",
    mask: "__-____"
  },
  {
    name: "Yemen",
    code: "+967",
    prefix: null,
    iso: "YE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ye.svg",
    mask: "___-___-___"
  },
  {
    name: "Zambia",
    code: "+260",
    prefix: null,
    iso: "ZM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/zm.svg",
    mask: "__-___-____"
  },
  {
    name: "Zimbabwe",
    code: "+263",
    prefix: null,
    iso: "ZW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/zw.svg",
    mask: "_-______"
  }
];
function Cge(e) {
  const {
    children: t,
    onFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s = "",
    readOnly: l,
    variant: u,
    size: c,
    id: p
  } = e, m = `arkynPhoneInputContainer ${u} ${c} ${r || l || i ? "opacity" : ""} ${o ? "errored" : ""} ${a ? "focused" : ""} ${s}`;
  return /* @__PURE__ */ q.jsx("section", { id: p, className: m.trim(), onClick: n, children: t });
}
function xge(e) {
  const { isOpen: t, onClick: n } = e;
  return t ? /* @__PURE__ */ q.jsx("aside", { className: "arkynPhoneInputCountriesOverlay", onClick: n }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function Ege(e) {
  const { country: t, isActive: n, handleChangeValue: r, size: o } = e, a = `arkynPhoneInputCountryOption ${o} ${n ? "active" : ""}`;
  return /* @__PURE__ */ q.jsxs("div", { onClick: () => r(t), className: a, children: [
    /* @__PURE__ */ q.jsx("img", { src: t.flag, alt: t.name, className: "flag" }),
    t.name,
    " ",
    /* @__PURE__ */ q.jsx("span", { children: t.code }),
    /* @__PURE__ */ q.jsx(hh, { className: "check" })
  ] });
}
function Oge(e) {
  const { children: t, isOpen: n, onSearch: r, search: o, placeholder: i } = e;
  function a(s) {
    r(s.target.value);
  }
  return n ? /* @__PURE__ */ q.jsxs("div", { className: "arkynPhoneInputCountryOptionsContainer", children: [
    /* @__PURE__ */ q.jsx(
      "input",
      {
        type: "search",
        name: "search-select",
        className: "arkynPhoneInputCountryOptionsContainerSearchSelect",
        value: o,
        id: "input-search",
        placeholder: i,
        onChange: a
      }
    ),
    t
  ] }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function kge(e) {
  const { currentCountry: t, onClick: n } = e;
  return /* @__PURE__ */ q.jsxs("div", { className: "phoneInputSelectCountry", onClick: n, children: [
    /* @__PURE__ */ q.jsx(
      "img",
      {
        className: "flag",
        src: t.flag,
        alt: t.name
      }
    ),
    /* @__PURE__ */ q.jsx(L0, { className: "chevronDown", strokeWidth: 2.5 }),
    /* @__PURE__ */ q.jsx(eI, { orientation: "vertical" })
  ] });
}
function dx(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const fx = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function UU(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function $U(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const WU = dx(fx.NINE).length, _ge = Ir((e, t) => /* @__PURE__ */ q.jsx("input", { ref: t, ...e })), Lge = Ir(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    v(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = dx(g.target.value);
      const m = $U(f);
      f.length > WU || (f = UU(f, fx[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ q.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ q.jsx(
      el,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: _ge,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
function Mj(e, t) {
  if (t.code === "+55") {
    let o = dx(e);
    const i = $U(o);
    return o.length > WU ? void 0 : (o = UU(o, fx[i]), o);
  }
  let r = t.mask;
  if (t.prefix) {
    const o = /\$+/g;
    r = r.replace(o, t.prefix);
  }
  for (let o = 0, i = 0; o < r.length && i < e.length; o++)
    r[o] === "_" && (r = r.substring(0, o) + e[i] + r.substring(o + 1), i++);
  return r;
}
function Pge(e, t) {
  const n = Na.find(
    (r) => r.code === e && r.prefix === t
  );
  return n || null;
}
function Sge(e) {
  const t = Na.find((n) => n.code === e);
  return t || null;
}
function Dge(e) {
  const t = e.split(" ")[0].split("-")[0], n = e.split(" ")[0].split("-")[1], r = e.split(" ")[1];
  if (!t || !r)
    return { country: null, formattedNumber: "" };
  if (n) {
    const s = Pge(t, n);
    if (!s) return { country: null, formattedNumber: "" };
    const l = Mj(r, s);
    return { country: s, formattedNumber: l };
  }
  const o = Sge(t);
  if (!o) return { country: null, formattedNumber: "" };
  const i = Mj(r, o);
  return { country: o, formattedNumber: i };
}
function CEe(e) {
  const {
    defaultCountry: t,
    className: n = "",
    disabled: r = !1,
    isError: o = !1,
    isLoading: i = !1,
    readOnly: a = !1,
    size: s = "md",
    defaultValue: l = "",
    variant: u = "solid",
    name: c,
    onChange: p,
    searchCountryPlaceholder: d = "Pesquisar país",
    notFoundCountryText: g = "Nenhum país encontrado",
    ...f
  } = e, m = Dge(l), [h, E] = k(!1), [w, S] = k(""), [x, y] = k(!1), [C, P] = k(m.formattedNumber || ""), [F, _] = k(() => {
    if (m.country) return m.country;
    const D = Na.find((G) => G.iso === t);
    return D || Na[30];
  }), { id: I, inputRef: B, error: $ } = Jr(), V = o || !!$, z = Qe(null);
  function H() {
    h || x || (E(!0), z.current && z.current.focus());
  }
  function X() {
    y(!0), E(!0);
  }
  function J() {
    y(!1), E(!1);
  }
  function te() {
    E(!0);
  }
  function ee() {
    E(!1);
  }
  function L(D) {
    return D.name.toLowerCase().includes(w.toLowerCase());
  }
  function T(D) {
    return F.prefix ? D.replace(F.prefix, "").replaceAll(" ", "").replaceAll("-", "").replaceAll("(", "").replaceAll(")", "").trim() : D.replaceAll(" ", "").replaceAll("-", "").replaceAll("(", "").replaceAll(")", "").trim();
  }
  function W(D) {
    let G = F.code;
    return F.prefix && (G += `-${F.prefix}`), G += " ", G += T(D || C), G;
  }
  return /* @__PURE__ */ q.jsxs(
    Cge,
    {
      id: I,
      disabled: r,
      isError: V,
      isLoading: i,
      isFocused: h,
      readOnly: a,
      size: s,
      variant: u,
      className: n,
      onFocus: H,
      children: [
        /* @__PURE__ */ q.jsx(
          kge,
          {
            currentCountry: F,
            onClick: X,
            size: s
          }
        ),
        /* @__PURE__ */ q.jsxs(
          Oge,
          {
            isOpen: x,
            search: w,
            placeholder: d,
            onSearch: S,
            children: [
              Na.filter((D) => L(D)).map((D) => /* @__PURE__ */ q.jsx(
                Ege,
                {
                  country: D,
                  handleChangeValue: () => {
                    _(D), y(!1), P(D.mask);
                  },
                  isActive: D.iso === F.iso,
                  size: s
                },
                D.iso
              )),
              Na.filter((D) => L(D)).length === 0 && /* @__PURE__ */ q.jsx("p", { children: g })
            ]
          }
        ),
        /* @__PURE__ */ q.jsx(
          xge,
          {
            isOpen: x,
            onClick: J
          }
        ),
        /* @__PURE__ */ q.jsx(
          Lge,
          {
            ref: z,
            currentCountry: F,
            value: C,
            onChange: (D) => {
              P(D), p && p(W(D));
            },
            disabled: r,
            onBlur: ee,
            onFocus: te,
            size: s
          }
        ),
        /* @__PURE__ */ q.jsx("input", { ref: B, type: "hidden", name: c, value: W() })
      ]
    }
  );
}
const VU = qe({});
function Mge() {
  return Ee(VU);
}
function xEe(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: a = "",
    ...s
  } = e, [l, u] = k(t || ""), { inputRef: c, id: p } = Jr();
  function d(f) {
    u(f), o && o(f);
  }
  const g = `arkynRadioGroup ${i} ${a}`;
  return /* @__PURE__ */ q.jsxs(
    VU.Provider,
    {
      value: { onChange: d, value: r || l, size: i },
      children: [
        /* @__PURE__ */ q.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: p,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ q.jsx("div", { className: g.trim(), ...s })
      ]
    }
  );
}
function EEe(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...a
  } = e, { onChange: s, size: l, value: u } = Mge(), { error: c } = Jr(), m = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ q.jsxs("label", { className: m.trim(), children: [
    /* @__PURE__ */ q.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => s(t),
        onFocus: () => s(t),
        ...a
      }
    ),
    o
  ] });
}
var Ui = {};
Object.defineProperty(Ui, "__esModule", {
  value: !0
});
var Tge = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), ay = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, HU = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Tge ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, hx = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var ud = 1; ud < 20; ud++)
  hx["f" + ud] = 111 + ud;
function em(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return GU(a, t);
  }), o = function(s) {
    return r.some(function(l) {
      return qU(l, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function jge(e, t) {
  return em(e, t);
}
function Age(e, t) {
  return em(e, { byKey: !0 }, t);
}
function GU(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in ay)
    r[ay[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = gx(d), m = ay[f];
      if (d.length > 1 && !m && !HU[d] && !hx[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = ZU(d)), m && (r[m] = g ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function qU(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function ZU(e) {
  e = gx(e);
  var t = hx[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function gx(e) {
  return e = e.toLowerCase(), e = HU[e] || e, e;
}
var Bge = Ui.default = em, ly = Ui.isHotkey = em;
Ui.isCodeHotkey = jge;
Ui.isKeyHotkey = Age;
Ui.parseHotkey = GU;
Ui.compareHotkey = qU;
Ui.toKeyCode = ZU;
Ui.toKeyName = gx;
var Rge = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return Pr(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || ms.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || ms.isOperationList(e.undos[0].operations));
  }
}, uy = /* @__PURE__ */ new WeakMap(), zl = /* @__PURE__ */ new WeakMap(), la = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return Rge.isHistory(e.history) && K.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return zl.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return uy.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = la.isMerging(e);
    zl.set(e, !0), t(), zl.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = la.isMerging(e);
    zl.set(e, !1), t(), zl.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = la.isSaving(e);
    uy.set(e, !1), t(), uy.set(e, n);
  }
}, Ige = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && Ce.setSelection(t, i.selectionBefore), la.withoutSaving(t, () => {
        K.withoutNormalizing(t, () => {
          for (var a of i.operations)
            t.apply(a);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      la.withoutSaving(t, () => {
        K.withoutNormalizing(t, () => {
          var a = i.operations.map(ms.inverse).reverse();
          for (var s of a)
            t.apply(s);
          i.selectionBefore && Ce.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: a
    } = i, s = a[a.length - 1], l = s && s.operations[s.operations.length - 1], u = la.isSaving(t), c = la.isMerging(t);
    if (u == null && (u = Fge(r)), u) {
      if (c == null && (s == null ? c = !1 : o.length !== 0 ? c = !0 : c = Nge(r, l)), s && c)
        s.operations.push(r);
      else {
        var p = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", p);
      }
      for (; a.length > 100; )
        a.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, Nge = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && ie.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && ie.equals(e.path, t.path)), Fge = (e, t) => e.type !== "set_selection", zge = Wge, KU = "֑-߿יִ-﷽ﹰ-ﻼ", XU = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", Uge = new RegExp("^[^" + XU + "]*[" + KU + "]"), $ge = new RegExp("^[^" + KU + "]*[" + XU + "]");
function Wge(e) {
  return e = String(e || ""), Uge.test(e) ? "rtl" : $ge.test(e) ? "ltr" : "neutral";
}
const YU = /* @__PURE__ */ gh(zge);
function Vge(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var mx = Vge, Hge = typeof xn == "object" && xn && xn.Object === Object && xn, Gge = Hge, qge = Gge, Zge = typeof self == "object" && self && self.Object === Object && self, Kge = qge || Zge || Function("return this")(), JU = Kge, Xge = JU, Yge = function() {
  return Xge.Date.now();
}, Jge = Yge, Qge = /\s/;
function eme(e) {
  for (var t = e.length; t-- && Qge.test(e.charAt(t)); )
    ;
  return t;
}
var tme = eme, nme = tme, rme = /^\s+/;
function ome(e) {
  return e && e.slice(0, nme(e) + 1).replace(rme, "");
}
var ime = ome, sme = JU, ame = sme.Symbol, QU = ame, Tj = QU, e3 = Object.prototype, lme = e3.hasOwnProperty, ume = e3.toString, Ul = Tj ? Tj.toStringTag : void 0;
function cme(e) {
  var t = lme.call(e, Ul), n = e[Ul];
  try {
    e[Ul] = void 0;
    var r = !0;
  } catch {
  }
  var o = ume.call(e);
  return r && (t ? e[Ul] = n : delete e[Ul]), o;
}
var pme = cme, dme = Object.prototype, fme = dme.toString;
function hme(e) {
  return fme.call(e);
}
var gme = hme, jj = QU, mme = pme, vme = gme, yme = "[object Null]", bme = "[object Undefined]", Aj = jj ? jj.toStringTag : void 0;
function wme(e) {
  return e == null ? e === void 0 ? bme : yme : Aj && Aj in Object(e) ? mme(e) : vme(e);
}
var Cme = wme;
function xme(e) {
  return e != null && typeof e == "object";
}
var Eme = xme, Ome = Cme, kme = Eme, _me = "[object Symbol]";
function Lme(e) {
  return typeof e == "symbol" || kme(e) && Ome(e) == _me;
}
var Pme = Lme, Sme = ime, Bj = mx, Dme = Pme, Rj = NaN, Mme = /^[-+]0x[0-9a-f]+$/i, Tme = /^0b[01]+$/i, jme = /^0o[0-7]+$/i, Ame = parseInt;
function Bme(e) {
  if (typeof e == "number")
    return e;
  if (Dme(e))
    return Rj;
  if (Bj(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Bj(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = Sme(e);
  var n = Tme.test(e);
  return n || jme.test(e) ? Ame(e.slice(2), n ? 2 : 8) : Mme.test(e) ? Rj : +e;
}
var Rme = Bme, Ime = mx, cy = Jge, Ij = Rme, Nme = "Expected a function", Fme = Math.max, zme = Math.min;
function Ume(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Nme);
  t = Ij(t) || 0, Ime(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Fme(Ij(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, _ = t - P;
    return p ? zme(_, i - F) : _;
  }
  function h(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = cy();
    if (h(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function S() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(cy());
  }
  function y() {
    var C = cy(), P = h(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return clearTimeout(s), s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = S, y.flush = x, y;
}
var t3 = Ume;
const $me = /* @__PURE__ */ gh(t3);
var Wme = t3, Vme = mx, Hme = "Expected a function";
function Gme(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Hme);
  return Vme(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Wme(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var qme = Gme;
const Zme = /* @__PURE__ */ gh(qme), Nj = (e) => typeof e == "object" && e != null && e.nodeType === 1, Fj = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", cd = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return Fj(n.overflowY, t) || Fj(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, pd = (e, t, n, r, o, i, a, s) => i < e && a > t || i > e && a < t ? 0 : i <= e && s <= n || a >= t && s >= n ? i - e - r : a > t && s < n || i < e && s > n ? a - t + o : 0, Kme = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, zj = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: a, block: s, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, p = typeof u == "function" ? u : (X) => X !== u;
  if (!Nj(e)) throw new TypeError("Invalid target");
  const d = document.scrollingElement || document.documentElement, g = [];
  let f = e;
  for (; Nj(f) && p(f); ) {
    if (f = Kme(f), f === d) {
      g.push(f);
      break;
    }
    f != null && f === document.body && cd(f) && !cd(document.documentElement) || f != null && cd(f, c) && g.push(f);
  }
  const m = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, h = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: E, scrollY: w } = window, { height: S, width: x, top: y, right: C, bottom: P, left: F } = e.getBoundingClientRect(), { top: _, right: I, bottom: B, left: $ } = ((X) => {
    const J = window.getComputedStyle(X);
    return { top: parseFloat(J.scrollMarginTop) || 0, right: parseFloat(J.scrollMarginRight) || 0, bottom: parseFloat(J.scrollMarginBottom) || 0, left: parseFloat(J.scrollMarginLeft) || 0 };
  })(e);
  let V = s === "start" || s === "nearest" ? y - _ : s === "end" ? P + B : y + S / 2 - _ + B, z = l === "center" ? F + x / 2 - $ + I : l === "end" ? C + I : F - $;
  const H = [];
  for (let X = 0; X < g.length; X++) {
    const J = g[X], { height: te, width: ee, top: L, right: T, bottom: W, left: D } = J.getBoundingClientRect();
    if (a === "if-needed" && y >= 0 && F >= 0 && P <= h && C <= m && (J === d && !cd(J) || y >= L && P <= W && F >= D && C <= T)) return H;
    const G = getComputedStyle(J), O = parseInt(G.borderLeftWidth, 10), M = parseInt(G.borderTopWidth, 10), U = parseInt(G.borderRightWidth, 10), j = parseInt(G.borderBottomWidth, 10);
    let Z = 0, A = 0;
    const Q = "offsetWidth" in J ? J.offsetWidth - J.clientWidth - O - U : 0, N = "offsetHeight" in J ? J.offsetHeight - J.clientHeight - M - j : 0, le = "offsetWidth" in J ? J.offsetWidth === 0 ? 0 : ee / J.offsetWidth : 0, ye = "offsetHeight" in J ? J.offsetHeight === 0 ? 0 : te / J.offsetHeight : 0;
    if (d === J) Z = s === "start" ? V : s === "end" ? V - h : s === "nearest" ? pd(w, w + h, h, M, j, w + V, w + V + S, S) : V - h / 2, A = l === "start" ? z : l === "center" ? z - m / 2 : l === "end" ? z - m : pd(E, E + m, m, O, U, E + z, E + z + x, x), Z = Math.max(0, Z + w), A = Math.max(0, A + E);
    else {
      Z = s === "start" ? V - L - M : s === "end" ? V - W + j + N : s === "nearest" ? pd(L, W, te, M, j + N, V, V + S, S) : V - (L + te / 2) + N / 2, A = l === "start" ? z - D - O : l === "center" ? z - (D + ee / 2) + Q / 2 : l === "end" ? z - T + U + Q : pd(D, T, ee, O, U + Q, z, z + x, x);
      const { scrollLeft: oe, scrollTop: Be } = J;
      Z = ye === 0 ? 0 : Math.max(0, Math.min(Be + Z / ye, J.scrollHeight - te / ye + N)), A = le === 0 ? 0 : Math.max(0, Math.min(oe + A / le, J.scrollWidth - ee / le + Q)), V += Be - Z, z += oe - A;
    }
    H.push({ el: J, top: Z, left: A });
  }
  return H;
}, Xme = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function Yme(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(zj(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: a } of zj(e, Xme(t))) {
    const s = i - n.top + n.bottom, l = a - n.left + n.right;
    o.scroll({ top: s, left: l, behavior: r });
  }
}
var da = [], Jme = function() {
  return da.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Qme = function() {
  return da.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, Uj = "ResizeObserver loop completed with undelivered notifications.", eve = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: Uj
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = Uj), window.dispatchEvent(e);
}, oc;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(oc || (oc = {}));
var fa = function(e) {
  return Object.freeze(e);
}, tve = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, fa(this);
  }
  return e;
}(), n3 = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, fa(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), vx = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, r3 = function(e) {
  if (vx(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, a = o.offsetHeight;
  return !(i || a || e.getClientRects().length);
}, $j = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, nve = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, bu = typeof window < "u" ? window : {}, dd = /* @__PURE__ */ new WeakMap(), Wj = /auto|scroll/, rve = /^tb|vertical/, ove = /msie|trident/i.test(bu.navigator && bu.navigator.userAgent), Vo = function(e) {
  return parseFloat(e || "0");
}, Va = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new tve((n ? t : e) || 0, (n ? e : t) || 0);
}, Vj = fa({
  devicePixelContentBoxSize: Va(),
  borderBoxSize: Va(),
  contentBoxSize: Va(),
  contentRect: new n3(0, 0, 0, 0)
}), o3 = function(e, t) {
  if (t === void 0 && (t = !1), dd.has(e) && !t)
    return dd.get(e);
  if (r3(e))
    return dd.set(e, Vj), Vj;
  var n = getComputedStyle(e), r = vx(e) && e.ownerSVGElement && e.getBBox(), o = !ove && n.boxSizing === "border-box", i = rve.test(n.writingMode || ""), a = !r && Wj.test(n.overflowY || ""), s = !r && Wj.test(n.overflowX || ""), l = r ? 0 : Vo(n.paddingTop), u = r ? 0 : Vo(n.paddingRight), c = r ? 0 : Vo(n.paddingBottom), p = r ? 0 : Vo(n.paddingLeft), d = r ? 0 : Vo(n.borderTopWidth), g = r ? 0 : Vo(n.borderRightWidth), f = r ? 0 : Vo(n.borderBottomWidth), m = r ? 0 : Vo(n.borderLeftWidth), h = p + u, E = l + c, w = m + g, S = d + f, x = s ? e.offsetHeight - S - e.clientHeight : 0, y = a ? e.offsetWidth - w - e.clientWidth : 0, C = o ? h + w : 0, P = o ? E + S : 0, F = r ? r.width : Vo(n.width) - C - y, _ = r ? r.height : Vo(n.height) - P - x, I = F + h + y + w, B = _ + E + x + S, $ = fa({
    devicePixelContentBoxSize: Va(Math.round(F * devicePixelRatio), Math.round(_ * devicePixelRatio), i),
    borderBoxSize: Va(I, B, i),
    contentBoxSize: Va(F, _, i),
    contentRect: new n3(p, l, F, _)
  });
  return dd.set(e, $), $;
}, i3 = function(e, t, n) {
  var r = o3(e, n), o = r.borderBoxSize, i = r.contentBoxSize, a = r.devicePixelContentBoxSize;
  switch (t) {
    case oc.DEVICE_PIXEL_CONTENT_BOX:
      return a;
    case oc.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, ive = /* @__PURE__ */ function() {
  function e(t) {
    var n = o3(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = fa([n.borderBoxSize]), this.contentBoxSize = fa([n.contentBoxSize]), this.devicePixelContentBoxSize = fa([n.devicePixelContentBoxSize]);
  }
  return e;
}(), s3 = function(e) {
  if (r3(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, sve = function() {
  var e = 1 / 0, t = [];
  da.forEach(function(a) {
    if (a.activeTargets.length !== 0) {
      var s = [];
      a.activeTargets.forEach(function(u) {
        var c = new ive(u.target), p = s3(u.target);
        s.push(c), u.lastReportedSize = i3(u.target, u.observedBox), p < e && (e = p);
      }), t.push(function() {
        a.callback.call(a.observer, s, a.observer);
      }), a.activeTargets.splice(0, a.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, Hj = function(e) {
  da.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (s3(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, ave = function() {
  var e = 0;
  for (Hj(e); Jme(); )
    e = sve(), Hj(e);
  return Qme() && eve(), e > 0;
}, py, a3 = [], lve = function() {
  return a3.splice(0).forEach(function(e) {
    return e();
  });
}, uve = function(e) {
  if (!py) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return lve();
    }).observe(n, r), py = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  a3.push(e), py();
}, cve = function(e) {
  uve(function() {
    requestAnimationFrame(e);
  });
}, Td = 0, pve = function() {
  return !!Td;
}, dve = 250, fve = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, Gj = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], qj = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, dy = !1, hve = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = dve), !dy) {
      dy = !0;
      var r = qj(t);
      cve(function() {
        var o = !1;
        try {
          o = ave();
        } finally {
          if (dy = !1, t = r - qj(), !pve())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, fve);
    };
    document.body ? n() : bu.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), Gj.forEach(function(n) {
      return bu.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), Gj.forEach(function(n) {
      return bu.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), u0 = new hve(), Zj = function(e) {
  !Td && e > 0 && u0.start(), Td += e, !Td && u0.stop();
}, gve = function(e) {
  return !vx(e) && !nve(e) && getComputedStyle(e).display === "inline";
}, mve = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || oc.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = i3(this.target, this.observedBox, !0);
    return gve(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), vve = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), fd = /* @__PURE__ */ new WeakMap(), Kj = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, hd = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new vve(t, n);
    fd.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = fd.get(t), i = o.observationTargets.length === 0;
    Kj(o.observationTargets, n) < 0 && (i && da.push(o), o.observationTargets.push(new mve(n, r && r.box)), Zj(1), u0.schedule());
  }, e.unobserve = function(t, n) {
    var r = fd.get(t), o = Kj(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && da.splice(da.indexOf(r), 1), r.observationTargets.splice(o, 1), Zj(-1));
  }, e.disconnect = function(t) {
    var n = this, r = fd.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), yve = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    hd.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!$j(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    hd.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!$j(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    hd.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    hd.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function bve(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Ja(e, t) {
  if (e == null) return {};
  var n = bve(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function ic(e) {
  "@babel/helpers - typeof";
  return ic = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ic(e);
}
function wve(e, t) {
  if (ic(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (ic(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Cve(e) {
  var t = wve(e, "string");
  return ic(t) === "symbol" ? t : String(t);
}
function Io(e, t, n) {
  return t = Cve(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var yx = /* @__PURE__ */ qe(null), As = () => {
  var e = Ee(yx);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, fy, hy, l3 = parseInt(Oe.version.split(".")[0], 10), u3 = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, Xj = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Vr = typeof navigator < "u" && /Android/.test(navigator.userAgent), Fa = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Js = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), xve = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), c3 = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), Eve = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), Ove = Vr && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), kve = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), _ve = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), Lve = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), jd = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((fy = navigator.userAgent.match(/Version\/(\d+)/)) !== null && fy !== void 0 && fy[1] && parseInt((hy = navigator.userAgent.match(/Version\/(\d+)/)) === null || hy === void 0 ? void 0 : hy[1], 10) < 17);
var Xi = (!Eve || !Ove) && !xve && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", Ha = /* @__PURE__ */ new WeakMap(), bx = /* @__PURE__ */ new WeakMap(), wx = /* @__PURE__ */ new WeakMap(), p3 = /* @__PURE__ */ new WeakMap(), Ad = /* @__PURE__ */ new WeakMap(), c0 = /* @__PURE__ */ new WeakMap(), sc = /* @__PURE__ */ new WeakMap(), ha = /* @__PURE__ */ new WeakMap(), nh = /* @__PURE__ */ new WeakMap(), tm = /* @__PURE__ */ new WeakMap(), p0 = /* @__PURE__ */ new WeakMap(), vs = /* @__PURE__ */ new WeakMap(), ua = /* @__PURE__ */ new WeakMap(), wu = /* @__PURE__ */ new WeakMap(), d0 = /* @__PURE__ */ new WeakMap(), Cx = /* @__PURE__ */ new WeakMap(), No = /* @__PURE__ */ new WeakMap(), Di = /* @__PURE__ */ new WeakMap(), eo = /* @__PURE__ */ new WeakMap(), ls = /* @__PURE__ */ new WeakMap(), us = /* @__PURE__ */ new WeakMap(), d3 = /* @__PURE__ */ new WeakMap(), Qa = Symbol("placeholder"), f3 = Symbol("mark-placeholder"), h3 = globalThis.Node, Pve = globalThis.Text, xx = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Sve = (e) => bs(e) && e.nodeType === 8, Ro = (e) => bs(e) && e.nodeType === 1, bs = (e) => {
  var t = xx(e);
  return !!t && e instanceof t.Node;
}, f0 = (e) => {
  var t = e && e.anchorNode && xx(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, g3 = (e) => bs(e) && e.nodeType === 3, Dve = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, Mve = (e) => {
  var [t, n] = e;
  if (Ro(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = m3(t, o, r ? "backward" : "forward"), r = o < n; Ro(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = jve(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, Tve = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, m3 = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (Sve(o) || Ro(o) && o.childNodes.length === 0 || Ro(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, jve = (e, t, n) => {
  var [r] = m3(e, t, n);
  return r;
}, v3 = (e) => {
  var t = "";
  if (g3(e) && e.nodeValue)
    return e.nodeValue;
  if (Ro(e)) {
    for (var n of Array.from(e.childNodes))
      t += v3(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, Ave = /data-slate-fragment="(.+?)"/m, Bve = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(Ave) || [];
  return n;
}, Cu = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Ex = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ro(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = fe.getWindow(e);
  if (o.contains(r))
    return fe.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Ex(e, i, n);
}, Rve = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, Yj = (e, t) => !!(e.compareDocumentPosition(t) & h3.DOCUMENT_POSITION_PRECEDING), Ive = (e, t) => !!(e.compareDocumentPosition(t) & h3.DOCUMENT_POSITION_FOLLOWING), Nve = 0;
class Fve {
  constructor() {
    Io(this, "id", void 0), this.id = "".concat(Nve++);
  }
}
var fe = {
  androidPendingDiffs: (e) => eo.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = Cx.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = fe.toDOMNode(e, e), n = fe.findDocumentOrShadowRoot(e);
    vs.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = fe.findDocumentOrShadowRoot(e), r = Cu(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Ce.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = fe.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = fe.toSlateNode(e, t.target), a = fe.findPath(e, i);
    if (Ve.isElement(i) && K.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = K.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? K.before(e, u) : K.after(e, u);
      if (c) {
        var p = K.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = fe.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = fe.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = nh.get(t);
    return n || (n = new Fve(), nh.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = wx.get(r);
      if (o == null) {
        if (K.isEditor(r))
          return n;
        break;
      }
      var i = bx.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Lr.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!vs.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          fe.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = fe.toDOMNode(t, t), o = fe.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = Cu(o), a = fe.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(a);
        }
        t.selection || Ce.select(t, K.start(t, [])), vs.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = p3.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = fe.toDOMNode(t, t), a;
    try {
      a = Ro(n) ? n : n.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return a ? a.closest("[data-slate-editor]") === i && (!o || a.isContentEditable ? !0 : typeof a.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    a.closest('[contenteditable="false"]') === i || !!a.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => bs(t) && fe.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return K.hasPath(e, n.path) && K.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => fe.hasEditableTarget(e, t) || fe.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => bs(t) && fe.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!ua.get(e),
  isFocused: (e) => !!vs.get(e),
  isReadOnly: (e) => !!p0.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (p0.get(e)) return !1;
    var n = fe.hasTarget(e, t) && fe.toSlateNode(e, t);
    return Ve.isElement(n) && K.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = tm.get(e), r = K.isEditor(t) ? Ad.get(e) : n == null ? void 0 : n.get(fe.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Lr.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = K.node(e, t.path), r = fe.toDOMNode(e, n), o;
    K.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var h, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof Pve ? E : m,
            (h = m.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Lr.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = pe.isBackward(t), i = fe.toDOMPoint(e, n), a = pe.isCollapsed(t) ? i : fe.toDOMPoint(e, r), s = fe.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Ro(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = Ro(p) ? p : p.parentElement, h = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ro(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? sc.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : Mve(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = fe.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), E = h && g.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), S = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = fe.getWindow(e), y = x.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((D) => {
            if (Vr && !r && D.hasAttribute("data-slate-zero-width") && D.textContent.length > 0 && D.textContext !== "\uFEFF") {
              D.textContent.startsWith("\uFEFF") && (D.textContent = D.textContent.slice(1));
              return;
            }
            D.parentNode.removeChild(D);
          }), c = C.textContent.length, S = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), _ = 0; _ < F.length; _++) {
          var I = F[_];
          if (fe.hasDOMNode(e, I)) {
            w = I;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), S = w, c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((D) => {
          c -= D.textContent.length;
        })) : c = 1;
      } else if (E) {
        var B = (D) => D ? D.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...B($), ...B($ == null ? void 0 : $.nextElementSibling)];
          w = (V = z.find((D) => Ive(E, D))) !== null && V !== void 0 ? V : null;
        } else {
          var H, X = [...B($ == null ? void 0 : $.previousElementSibling), ...B($)];
          w = (H = X.findLast((D) => Yj(E, D))) !== null && H !== void 0 ? H : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), S = w, i === "forward" ? c = 0 : (c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((D) => {
          c -= D.textContent.length;
        })));
      }
      S && c === S.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Vr && S.getAttribute("data-slate-zero-width") === "z" && (p = S.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Fa && (d = S.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Vr && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && fe.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = fe.toSlateNode(e, J), {
          path: ee,
          offset: L
        } = K.start(e, fe.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (L = s), {
          path: ee,
          offset: L
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var T = fe.toSlateNode(e, u), W = fe.findPath(e, T);
    return {
      path: W,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = f0(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (f0(t)) {
        if (Fa && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = g.startContainer, h = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        c3 && Tve(s) || Fa ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Fa && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = fe.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var S = Yj(s, u) || s === u && c < l, x = p ? w : fe.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: S ? "forward" : "backward"
    });
    if (!x)
      return null;
    var y = {
      anchor: w,
      focus: x
    };
    return pe.isExpanded(y) && pe.isForward(y) && Ro(u) && K.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = K.unhangRange(e, y, {
      voids: !0
    })), y;
  }
};
function zve(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!K.hasPath(e, n))
    return !1;
  var o = Te.get(e, n);
  if (!He.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = ie.next(n);
  if (!K.hasPath(e, i))
    return !1;
  var a = Te.get(e, i);
  return He.isText(a) && a.text.startsWith(r.text);
}
function y3(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function Uve(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function $ve(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function b3(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), a = Uve(i, o), s = Math.min(i.length - a, o.length - a), l = $ve(i, o, s), u = {
    start: n + a,
    end: r - l,
    text: o.slice(a, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function Wve(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = y3(e, t, n), a = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), s = i.slice(r, a), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return b3(e, {
    start: r,
    end: l,
    text: s
  });
}
function Vve(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function h0(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!K.hasPath(e, n))
    return null;
  var o = Te.get(e, n);
  if (!He.isText(o))
    return null;
  var i = K.above(e, {
    match: (s) => Ve.isElement(s) && K.isBlock(e, s),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var a = K.next(e, {
      at: n,
      match: He.isText
    });
    if (!a || !ie.isDescendant(a[1], i[1]))
      return null;
    r -= o.text.length, o = a[0], n = a[1];
  }
  return {
    path: n,
    offset: r
  };
}
function Jj(e, t) {
  var n = h0(e, t.anchor);
  if (!n)
    return null;
  if (pe.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = h0(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function g0(e, t, n) {
  var r = eo.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: p
    } = c;
    return ie.equals(p, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return Ot.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var a = {
      path: t.path,
      offset: i.start
    }, s = Ot.transform(a, n, {
      affinity: "backward"
    });
    return s ? {
      path: s.path,
      offset: s.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = Ot.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && ie.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function Qj(e, t, n) {
  var r = g0(e, t.anchor, n);
  if (!r)
    return null;
  if (pe.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = g0(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function Hve(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !ie.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !ie.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !ie.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: ie.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: ie.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return ie.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: ie.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: ie.transform(n, t)
      };
  }
  var i = ie.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function eA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eA(Object(n), !0).forEach(function(r) {
      Io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Gve = 25, qve = 200, Zve = function() {
}, Kve = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function Xve(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, a = null, s = null, l = 0, u = !1, c = () => {
    var $ = us.get(t);
    if (us.delete(t), $) {
      var {
        selection: V
      } = t, z = Jj(t, $);
      z && (!V || !pe.equals(z, V)) && Ce.select(t, z);
    }
  }, p = () => {
    var $ = ls.get(t);
    if (ls.delete(t), !!$) {
      if ($.at) {
        var V = Ot.isPoint($.at) ? h0(t, $.at) : Jj(t, $.at);
        if (!V)
          return;
        var z = K.range(t, V);
        (!t.selection || !pe.equals(t.selection, z)) && Ce.select(t, V);
      }
      $.run();
    }
  }, d = () => {
    if (a && (clearTimeout(a), a = null), s && (clearTimeout(s), s = null), !x() && !S()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), S() && (o = "action");
    var $ = t.selection && K.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    Di.set(t, t.marks), Zve("flush", ls.get(t), eo.get(t));
    for (var V = x(), z; z = (H = eo.get(t)) === null || H === void 0 ? void 0 : H[0]; ) {
      var H, X, J = No.get(t);
      J !== void 0 && (No.delete(t), t.marks = J), J && u === !1 && (u = null);
      var te = Vve(z);
      (!t.selection || !pe.equals(t.selection, te)) && Ce.select(t, te), z.diff.text ? K.insertText(t, z.diff.text) : K.deleteFragment(t), eo.set(t, (X = eo.get(t)) === null || X === void 0 ? void 0 : X.filter((T) => {
        var {
          id: W
        } = T;
        return W !== z.id;
      })), zve(t, z) || (V = !1, ls.delete(t), Di.delete(t), o = "action", us.delete(t), n.cancel(), r.cancel(), $ == null || $.unref());
    }
    var ee = $ == null ? void 0 : $.unref();
    if (ee && !us.get(t) && (!t.selection || !pe.equals(ee, t.selection)) && Ce.select(t, ee), S()) {
      p();
      return;
    }
    V && n(), n.flush(), r.flush(), c();
    var L = Di.get(t);
    Di.delete(t), L !== void 0 && (t.marks = L, t.onChange());
  }, g = ($) => {
    i && clearTimeout(i), i = setTimeout(() => {
      ua.set(t, !1), d();
    }, Gve);
  }, f = ($) => {
    ua.set(t, !0), i && (clearTimeout(i), i = null);
  }, m = function() {
    var V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, z = c0.get(t);
    if (z) {
      if (x() || V) {
        z.style.display = "none";
        return;
      }
      z.style.removeProperty("display");
    }
  }, h = ($, V) => {
    var z, H = (z = eo.get(t)) !== null && z !== void 0 ? z : [];
    eo.set(t, H);
    var X = Te.leaf(t, $), J = H.findIndex((L) => ie.equals(L.path, $));
    if (J < 0) {
      var te = b3(X.text, V);
      te && H.push({
        path: $,
        diff: V,
        id: l++
      }), m();
      return;
    }
    var ee = Wve(X.text, H[J].diff, V);
    if (!ee) {
      H.splice(J, 1), m();
      return;
    }
    H[J] = gd(gd({}, H[J]), {}, {
      diff: ee
    });
  }, E = function(V) {
    var {
      at: z
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, us.delete(t), n.cancel(), r.cancel(), S() && d(), ls.set(t, {
      at: z,
      run: V
    }), s = setTimeout(d);
  }, w = ($) => {
    var V;
    if (a && (clearTimeout(a), a = null), !Ha.get(t)) {
      var {
        inputType: z
      } = $, H = null, X = $.dataTransfer || $.data || void 0;
      u !== !1 && z !== "insertText" && z !== "insertCompositionText" && (u = !1);
      var [J] = $.getTargetRanges();
      J && (H = fe.toSlateRange(t, J, {
        exactMatch: !1,
        suppressThrow: !0
      }));
      var te = fe.getWindow(t), ee = te.getSelection();
      if (!H && ee && (J = ee, H = fe.toSlateRange(t, ee, {
        exactMatch: !1,
        suppressThrow: !0
      })), H = (V = H) !== null && V !== void 0 ? V : t.selection, !!H) {
        var L = !0;
        if (z.startsWith("delete")) {
          if (pe.isExpanded(H)) {
            var [T, W] = pe.edges(H), D = Te.leaf(t, T.path);
            if (D.text.length === T.offset && W.offset === 0) {
              var G = K.next(t, {
                at: T.path,
                match: He.isText
              });
              G && ie.equals(G[1], W.path) && (H = {
                anchor: W,
                focus: W
              });
            }
          }
          var O = z.endsWith("Backward") ? "backward" : "forward", [M, U] = pe.edges(H), [j, Z] = K.leaf(t, M.path), A = {
            text: "",
            start: M.offset,
            end: U.offset
          }, Q = eo.get(t), N = Q == null ? void 0 : Q.find((We) => ie.equals(We.path, Z)), le = N ? [N.diff, A] : [A], ye = y3(j.text, ...le);
          if (ye.length === 0 && (L = !1), pe.isExpanded(H)) {
            if (L && ie.equals(H.anchor.path, H.focus.path)) {
              var oe = {
                path: H.anchor.path,
                offset: M.offset
              }, Be = K.range(t, oe, oe);
              return P(Be), h(H.anchor.path, {
                text: "",
                end: U.offset,
                start: M.offset
              });
            }
            return E(() => K.deleteFragment(t, {
              direction: O
            }), {
              at: H
            });
          }
        }
        switch (z) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            return E(() => K.deleteFragment(t), {
              at: H
            });
          case "deleteContent":
          case "deleteContentForward": {
            var {
              anchor: Ue
            } = H;
            if (L && pe.isCollapsed(H)) {
              var $e = Te.leaf(t, Ue.path);
              if (Ue.offset < $e.text.length)
                return h(Ue.path, {
                  text: "",
                  start: Ue.offset,
                  end: Ue.offset + 1
                });
            }
            return E(() => K.deleteForward(t), {
              at: H
            });
          }
          case "deleteContentBackward": {
            var Ie, {
              anchor: Je
            } = H, Ze = f0(J) ? J.isCollapsed : !!((Ie = J) !== null && Ie !== void 0 && Ie.collapsed);
            return L && Ze && pe.isCollapsed(H) && Je.offset > 0 ? h(Je.path, {
              text: "",
              start: Je.offset - 1,
              end: Je.offset
            }) : E(() => K.deleteBackward(t), {
              at: H
            });
          }
          case "deleteEntireSoftLine":
            return E(() => {
              K.deleteBackward(t, {
                unit: "line"
              }), K.deleteForward(t, {
                unit: "line"
              });
            }, {
              at: H
            });
          case "deleteHardLineBackward":
            return E(() => K.deleteBackward(t, {
              unit: "block"
            }), {
              at: H
            });
          case "deleteSoftLineBackward":
            return E(() => K.deleteBackward(t, {
              unit: "line"
            }), {
              at: H
            });
          case "deleteHardLineForward":
            return E(() => K.deleteForward(t, {
              unit: "block"
            }), {
              at: H
            });
          case "deleteSoftLineForward":
            return E(() => K.deleteForward(t, {
              unit: "line"
            }), {
              at: H
            });
          case "deleteWordBackward":
            return E(() => K.deleteBackward(t, {
              unit: "word"
            }), {
              at: H
            });
          case "deleteWordForward":
            return E(() => K.deleteForward(t, {
              unit: "word"
            }), {
              at: H
            });
          case "insertLineBreak":
            return E(() => K.insertSoftBreak(t), {
              at: H
            });
          case "insertParagraph":
            return E(() => K.insertBreak(t), {
              at: H
            });
          case "insertCompositionText":
          case "deleteCompositionText":
          case "insertFromComposition":
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText": {
            if (Kve(X))
              return E(() => fe.insertData(t, X), {
                at: H
              });
            var Me = X ?? "";
            if (No.get(t) && (Me = Me.replace("\uFEFF", "")), z === "insertText" && /.*\n.*\n$/.test(Me) && (Me = Me.slice(0, -1)), Me.includes(`
`))
              return E(() => {
                var We = Me.split(`
`);
                We.forEach((Fe, et) => {
                  Fe && K.insertText(t, Fe), et !== We.length - 1 && K.insertSoftBreak(t);
                });
              }, {
                at: H
              });
            if (ie.equals(H.anchor.path, H.focus.path)) {
              var [Ye, nt] = pe.edges(H), De = {
                start: Ye.offset,
                end: nt.offset,
                text: Me
              };
              if (Me && u && z === "insertCompositionText") {
                var je = u.start + u.text.search(/\S|$/), Ke = De.start + De.text.search(/\S|$/);
                Ke === je + 1 && De.end === u.start + u.text.length ? (De.start -= 1, u = null, I()) : u = !1;
              } else z === "insertText" ? u === null ? u = De : u && pe.isCollapsed(H) && u.end + u.text.length === Ye.offset ? u = gd(gd({}, u), {}, {
                text: u.text + Me
              }) : u = !1 : u = !1;
              if (L) {
                h(Ye.path, De);
                return;
              }
            }
            return E(() => K.insertText(t, Me), {
              at: H
            });
          }
        }
      }
    }
  }, S = () => !!ls.get(t), x = () => {
    var $;
    return !!(($ = eo.get(t)) !== null && $ !== void 0 && $.length);
  }, y = () => S() || x(), C = () => o, P = ($) => {
    us.set(t, $), a && (clearTimeout(a), a = null);
    var {
      selection: V
    } = t;
    if ($) {
      var z = !V || !ie.equals(V.anchor.path, $.anchor.path), H = !V || !ie.equals(V.anchor.path.slice(0, -1), $.anchor.path.slice(0, -1));
      (z && u || H) && (u = !1), (z || x()) && (a = setTimeout(d, qve));
    }
  }, F = () => {
    (S() || !x()) && d();
  }, _ = ($) => {
    x() || (m(!0), setTimeout(m));
  }, I = () => {
    S() || (s = setTimeout(d));
  }, B = ($) => {
    if (!(x() || S()) && $.some((z) => Ex(t, z, $))) {
      var V;
      (V = d3.get(t)) === null || V === void 0 || V();
    }
  };
  return {
    flush: d,
    scheduleFlush: I,
    hasPendingDiffs: x,
    hasPendingAction: S,
    hasPendingChanges: y,
    isFlushing: C,
    handleUserSelect: P,
    handleCompositionEnd: g,
    handleCompositionStart: f,
    handleDOMBeforeInput: w,
    handleKeyDown: _,
    handleDomMutations: B,
    handleInput: F
  };
}
function Yve() {
  var e = Qe(!1);
  return v(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var ac = jd ? D$ : v;
function Jve(e, t, n) {
  var [r] = k(() => new MutationObserver(t));
  ac(() => {
    r.takeRecords();
  }), v(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var Qve = ["node"];
function tA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function eye(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tA(Object(n), !0).forEach(function(r) {
      Io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tye = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, nye = Vr ? (e) => {
  var {
    node: t
  } = e, n = Ja(e, Qve);
  if (!Vr)
    return null;
  var r = As(), o = Yve(), [i] = k(() => Xve(eye({
    editor: r
  }, n)));
  return Jve(t, i.handleDomMutations, tye), Cx.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, rye = ["anchor", "focus"], oye = ["anchor", "focus"], iye = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), w3 = (e, t) => {
  var n = Ja(e, rye), r = Ja(t, oye);
  return e[Qa] === t[Qa] && iye(n, r);
}, sye = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!pe.equals(r, o) || !w3(r, o))
      return !1;
  }
  return !0;
}, aye = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !w3(r, o))
      return !1;
  }
  return !0;
};
function nA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lye(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nA(Object(n), !0).forEach(function(r) {
      Io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uye = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = As(), a = fe.findPath(i, o), s = ie.parent(a), l = !!n[f3];
  return i.isVoid(r) ? /* @__PURE__ */ Oe.createElement(gy, {
    length: Te.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && K.string(i, s) === "" ? /* @__PURE__ */ Oe.createElement(gy, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ Oe.createElement(gy, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ Oe.createElement(rA, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ Oe.createElement(rA, {
    text: n.text
  });
}, rA = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = Qe(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = k(o);
  return ac(() => {
    var a = o();
    r.current && r.current.textContent !== a && (r.current.textContent = a);
  }), /* @__PURE__ */ Oe.createElement(cye, {
    ref: r
  }, i);
}, cye = /* @__PURE__ */ ke(/* @__PURE__ */ Ir((e, t) => /* @__PURE__ */ Oe.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), gy = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ Oe.createElement("span", lye({}, o), !(Vr || u3) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ Oe.createElement("br", null) : null);
};
function oA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function C3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oA(Object(n), !0).forEach(function(r) {
      Io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pye = Vr ? 300 : 0;
function dye(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function iA(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var fye = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: a = (w) => /* @__PURE__ */ Oe.createElement(gye, C3({}, w))
  } = e, s = As(), l = Qe(null), u = Qe(null), [c, p] = k(!1), d = Qe(null), g = dn((w) => {
    if (dye(l, w == null), w == null) {
      var S;
      c0.delete(s), (S = t.onPlaceholderResize) === null || S === void 0 || S.call(t, null);
    } else {
      if (c0.set(s, w), !l.current) {
        var x = window.ResizeObserver || yve;
        l.current = new x(() => {
          var y;
          (y = t.onPlaceholderResize) === null || y === void 0 || y.call(t, w);
        });
      }
      l.current.observe(w), u.current = w;
    }
  }, [u, t, s]), f = /* @__PURE__ */ Oe.createElement(uye, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), m = !!t[Qa];
  if (v(() => (m ? d.current || (d.current = setTimeout(() => {
    p(!0), d.current = null;
  }, pye)) : (iA(d), p(!1)), () => iA(d)), [m, p]), m && c) {
    var h = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: Js ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: g
      }
    };
    f = /* @__PURE__ */ Oe.createElement(Oe.Fragment, null, i(h), f);
  }
  var E = {
    "data-slate-leaf": !0
  };
  return a({
    attributes: E,
    children: f,
    leaf: t,
    text: r
  });
}, hye = /* @__PURE__ */ Oe.memo(fye, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && He.equals(t.leaf, e.leaf) && t.leaf[Qa] === e.leaf[Qa]), gye = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ Oe.createElement("span", C3({}, t), n);
}, mye = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: a
  } = e, s = As(), l = Qe(null), u = He.decorations(a, t), c = fe.findKey(s, a), p = [], d = 0; d < u.length; d++) {
    var g = u[d];
    p.push(/* @__PURE__ */ Oe.createElement(hye, {
      isLast: n && d === u.length - 1,
      key: "".concat(c.id, "-").concat(d),
      renderPlaceholder: o,
      leaf: g,
      text: a,
      parent: r,
      renderLeaf: i
    }));
  }
  var f = dn((m) => {
    var h = tm.get(s);
    m ? (h == null || h.set(c, m), ha.set(a, m), sc.set(m, a)) : (h == null || h.delete(c), ha.delete(a), l.current && sc.delete(l.current)), l.current = m;
  }, [l, s, c, a]);
  return /* @__PURE__ */ Oe.createElement("span", {
    "data-slate-node": "text",
    ref: f
  }, p);
}, x3 = /* @__PURE__ */ Oe.memo(mye, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && aye(t.decorations, e.decorations));
function sA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function m0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sA(Object(n), !0).forEach(function(r) {
      Io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vye = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (w) => /* @__PURE__ */ Oe.createElement(bye, m0({}, w)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = As(), l = xye(), u = s.isInline(n), c = fe.findKey(s, n), p = dn((w) => {
    var S = tm.get(s);
    w ? (S == null || S.set(c, w), ha.set(n, w), sc.set(w, n)) : (S == null || S.delete(c), ha.delete(n));
  }, [s, c, n]), d = O3({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  }), g = {
    "data-slate-node": "element",
    ref: p
  };
  if (u && (g["data-slate-inline"] = !0), !u && K.hasInlines(s, n)) {
    var f = Te.string(n), m = YU(f);
    m === "rtl" && (g.dir = m);
  }
  if (K.isVoid(s, n)) {
    g["data-slate-void"] = !0, !l && u && (g.contentEditable = !1);
    var h = u ? "span" : "div", [[E]] = Te.texts(n);
    d = /* @__PURE__ */ Oe.createElement(h, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ Oe.createElement(x3, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: E
    })), bx.set(E, 0), wx.set(E, n);
  }
  return r({
    attributes: g,
    children: d,
    element: n
  });
}, yye = /* @__PURE__ */ Oe.memo(vye, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && sye(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && pe.equals(e.selection, t.selection))), bye = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = As(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ Oe.createElement(i, m0(m0({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, E3 = /* @__PURE__ */ qe(() => []), wye = () => Ee(E3), Cye = /* @__PURE__ */ qe(!1), O3 = (e) => {
  var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = wye(), l = As();
  Ha.set(l, !1);
  for (var u = fe.findPath(l, n), c = [], p = Ve.isElement(n) && !l.isInline(n) && K.hasInlines(l, n), d = 0; d < n.children.length; d++) {
    var g = u.concat(d), f = n.children[d], m = fe.findKey(l, f), h = K.range(l, g), E = a && pe.intersection(h, a), w = s([f, g]);
    for (var S of t) {
      var x = pe.intersection(S, h);
      x && w.push(x);
    }
    Ve.isElement(f) ? c.push(/* @__PURE__ */ Oe.createElement(Cye.Provider, {
      key: "provider-".concat(m.id),
      value: !!E
    }, /* @__PURE__ */ Oe.createElement(yye, {
      decorations: w,
      element: f,
      key: m.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: E
    }))) : c.push(/* @__PURE__ */ Oe.createElement(x3, {
      decorations: w,
      key: m.id,
      isLast: p && d === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: f
    })), bx.set(f, d), wx.set(f, n);
  }
  return c;
}, k3 = /* @__PURE__ */ qe(!1), xye = () => Ee(k3), _3 = /* @__PURE__ */ qe(null), nm = () => {
  var e = Ee(_3);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function Eye() {
  var e = As(), t = Qe(!1), n = Qe(0), r = dn(() => {
    if (!t.current) {
      t.current = !0;
      var o = fe.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return v(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var Oye = 3, kye = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, _ye = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Lye = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Yn = (e) => {
  var t = kye[e], n = _ye[e], r = Lye[e], o = t && ly(t), i = n && ly(n), a = r && ly(r);
  return (s) => !!(o && o(s) || Xj && i && i(s) || !Xj && a && a(s));
}, Qn = {
  isBold: Yn("bold"),
  isCompose: Yn("compose"),
  isMoveBackward: Yn("moveBackward"),
  isMoveForward: Yn("moveForward"),
  isDeleteBackward: Yn("deleteBackward"),
  isDeleteForward: Yn("deleteForward"),
  isDeleteLineBackward: Yn("deleteLineBackward"),
  isDeleteLineForward: Yn("deleteLineForward"),
  isDeleteWordBackward: Yn("deleteWordBackward"),
  isDeleteWordForward: Yn("deleteWordForward"),
  isExtendBackward: Yn("extendBackward"),
  isExtendForward: Yn("extendForward"),
  isExtendLineBackward: Yn("extendLineBackward"),
  isExtendLineForward: Yn("extendLineForward"),
  isItalic: Yn("italic"),
  isMoveLineBackward: Yn("moveLineBackward"),
  isMoveLineForward: Yn("moveLineForward"),
  isMoveWordBackward: Yn("moveWordBackward"),
  isMoveWordForward: Yn("moveWordForward"),
  isRedo: Yn("redo"),
  isSoftBreak: Yn("insertSoftBreak"),
  isSplitBlock: Yn("splitBlock"),
  isTransposeCharacter: Yn("transposeCharacter"),
  isUndo: Yn("undo")
}, Pye = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Ex(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, Sye = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class L3 extends uc {
  constructor() {
    super(...arguments), Io(this, "context", null), Io(this, "manager", null), Io(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, Sye);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = Pye(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Io(L3, "contextType", yx);
var Dye = Vr ? L3 : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ Oe.createElement(Oe.Fragment, null, t);
}, Mye = /* @__PURE__ */ qe(!1), Tye = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], jye = ["text"];
function aA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ho(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aA(Object(n), !0).forEach(function(r) {
      Io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Aye = (e) => /* @__PURE__ */ Oe.createElement(Oe.Fragment, null, O3(e)), Bye = /* @__PURE__ */ Ir((e, t) => {
  var n = dn((M) => /* @__PURE__ */ Oe.createElement(Rye, Ho({}, M)), []), {
    autoFocus: r,
    decorate: o = Iye,
    onDOMBeforeInput: i,
    placeholder: a,
    readOnly: s = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: p = Nye,
    style: d = {},
    as: g = "div",
    disableDefaultStyles: f = !1
  } = e, m = Ja(e, Tye), h = nm(), [E, w] = k(!1), S = Qe(null), x = Qe([]), [y, C] = k(), P = Qe(!1), {
    onUserInput: F,
    receivedUserInput: _
  } = Eye(), [, I] = M$((M) => M + 1, 0);
  d3.set(h, I), p0.set(h, s);
  var B = Bn(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  v(() => {
    S.current && r && S.current.focus();
  }, [r]);
  var $ = Qe(), V = Bn(() => Zme(() => {
    if (Ha.get(h)) {
      V();
      return;
    }
    var M = fe.toDOMNode(h, h), U = M.getRootNode();
    if (!P.current && Js && U instanceof ShadowRoot) {
      P.current = !0;
      var j = Rve();
      j ? document.execCommand("indent") : Ce.deselect(h), P.current = !1;
      return;
    }
    var Z = $.current;
    if ((Vr || !fe.isComposing(h)) && (!B.isUpdatingSelection || Z != null && Z.isFlushing()) && !B.isDraggingInternally) {
      var A = fe.findDocumentOrShadowRoot(h), {
        activeElement: Q
      } = A, N = fe.toDOMNode(h, h), le = Cu(A);
      if (Q === N ? (B.latestElement = Q, vs.set(h, !0)) : vs.delete(h), !le)
        return Ce.deselect(h);
      var {
        anchorNode: ye,
        focusNode: oe
      } = le, Be = fe.hasEditableTarget(h, ye) || fe.isTargetInsideNonReadonlyVoid(h, ye), Ue = fe.hasTarget(h, oe);
      if (Be && Ue) {
        var $e = fe.toSlateRange(h, le, {
          exactMatch: !1,
          suppressThrow: !0
        });
        $e && (!fe.isComposing(h) && !(Z != null && Z.hasPendingChanges()) && !(Z != null && Z.isFlushing()) ? Ce.select(h, $e) : Z == null || Z.handleUserSelect($e));
      }
      s && (!Be || !Ue) && Ce.deselect(h);
    }
  }, 100), [h, s, B]), z = Bn(() => $me(V, 0), [V]);
  $.current = nye({
    node: S,
    onDOMSelectionChange: V,
    scheduleOnDOMSelectionChange: z
  }), ac(() => {
    var M, U, j;
    S.current && (j = xx(S.current)) ? (p3.set(h, j), Ad.set(h, S.current), ha.set(h, S.current), sc.set(S.current, h)) : ha.delete(h);
    var {
      selection: Z
    } = h, A = fe.findDocumentOrShadowRoot(h), Q = Cu(A);
    if (!(!Q || !fe.isFocused(h) || (M = $.current) !== null && M !== void 0 && M.hasPendingAction())) {
      var N = (Be) => {
        var Ue = Q.type !== "None";
        if (!(!Z && !Ue)) {
          var $e = Q.focusNode, Ie;
          if (Fa && Q.rangeCount > 1) {
            var Je = Q.getRangeAt(0), Ze = Q.getRangeAt(Q.rangeCount - 1);
            Je.startContainer === $e ? Ie = Ze.endContainer : Ie = Je.startContainer;
          } else
            Ie = Q.anchorNode;
          var Me = Ad.get(h), Ye = !1;
          if (Me.contains(Ie) && Me.contains($e) && (Ye = !0), Ue && Ye && Z && !Be) {
            var nt = fe.toSlateRange(h, Q, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (nt && pe.equals(nt, Z)) {
              var De;
              if (!B.hasMarkPlaceholder || (De = Ie) !== null && De !== void 0 && (De = De.parentElement) !== null && De !== void 0 && De.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (Z && !fe.hasRange(h, Z)) {
            h.selection = fe.toSlateRange(h, Q, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          B.isUpdatingSelection = !0;
          var je = Z && fe.toDOMRange(h, Z);
          return je ? (fe.isComposing(h) && !Vr ? Q.collapseToEnd() : pe.isBackward(Z) ? Q.setBaseAndExtent(je.endContainer, je.endOffset, je.startContainer, je.startOffset) : Q.setBaseAndExtent(je.startContainer, je.startOffset, je.endContainer, je.endOffset), p(h, je)) : Q.removeAllRanges(), je;
        }
      };
      Q.rangeCount <= 1 && N();
      var le = ((U = $.current) === null || U === void 0 ? void 0 : U.isFlushing()) === "action";
      if (!Vr || !le) {
        setTimeout(() => {
          B.isUpdatingSelection = !1;
        });
        return;
      }
      var ye = null, oe = requestAnimationFrame(() => {
        if (le) {
          var Be = (Ue) => {
            try {
              var $e = fe.toDOMNode(h, h);
              $e.focus(), N(Ue);
            } catch {
            }
          };
          Be(), ye = setTimeout(() => {
            Be(!0), B.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(oe), ye && clearTimeout(ye);
      };
    }
  });
  var H = dn((M) => {
    var U = fe.toDOMNode(h, h), j = U.getRootNode();
    if (P != null && P.current && Js && j instanceof ShadowRoot) {
      var Z = M.getTargetRanges(), A = Z[0], Q = new window.Range();
      Q.setStart(A.startContainer, A.startOffset), Q.setEnd(A.endContainer, A.endOffset);
      var N = fe.toSlateRange(h, Q, {
        exactMatch: !1,
        suppressThrow: !1
      });
      Ce.select(h, N), M.preventDefault(), M.stopImmediatePropagation();
      return;
    }
    if (F(), !s && fe.hasEditableTarget(h, M.target) && !Fye(M, i)) {
      var le;
      if ($.current)
        return $.current.handleDOMBeforeInput(M);
      z.flush(), V.flush();
      var {
        selection: ye
      } = h, {
        inputType: oe
      } = M, Be = M.dataTransfer || M.data || void 0, Ue = oe === "insertCompositionText" || oe === "deleteCompositionText";
      if (Ue && fe.isComposing(h))
        return;
      var $e = !1;
      if (oe === "insertText" && ye && pe.isCollapsed(ye) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      M.data && M.data.length === 1 && /[a-z ]/i.test(M.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      ye.anchor.offset !== 0 && ($e = !0, h.marks && ($e = !1), !Ha.get(h))) {
        var Ie, Je, {
          anchor: Ze
        } = ye, [Me, Ye] = fe.toDOMPoint(h, Ze), nt = (Ie = Me.parentElement) === null || Ie === void 0 ? void 0 : Ie.closest("a"), De = fe.getWindow(h);
        if ($e && nt && fe.hasDOMNode(h, nt)) {
          var je, Ke = De == null ? void 0 : De.document.createTreeWalker(nt, NodeFilter.SHOW_TEXT).lastChild();
          Ke === Me && ((je = Ke.textContent) === null || je === void 0 ? void 0 : je.length) === Ye && ($e = !1);
        }
        if ($e && Me.parentElement && (De == null || (Je = De.getComputedStyle(Me.parentElement)) === null || Je === void 0 ? void 0 : Je.whiteSpace) === "pre") {
          var We = K.above(h, {
            at: Ze.path,
            match: (ot) => Ve.isElement(ot) && K.isBlock(h, ot)
          });
          We && Te.string(We[0]).includes("	") && ($e = !1);
        }
      }
      if ((!oe.startsWith("delete") || oe.startsWith("deleteBy")) && !Ha.get(h)) {
        var [Fe] = M.getTargetRanges();
        if (Fe) {
          var et = fe.toSlateRange(h, Fe, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!ye || !pe.equals(ye, et)) {
            $e = !1;
            var Re = !Ue && h.selection && K.rangeRef(h, h.selection);
            Ce.select(h, et), Re && wu.set(h, Re);
          }
        }
      }
      if (Ue)
        return;
      if ($e || M.preventDefault(), ye && pe.isExpanded(ye) && oe.startsWith("delete")) {
        var Rt = oe.endsWith("Backward") ? "backward" : "forward";
        K.deleteFragment(h, {
          direction: Rt
        });
        return;
      }
      switch (oe) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          K.deleteFragment(h);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          K.deleteForward(h);
          break;
        }
        case "deleteContentBackward": {
          K.deleteBackward(h);
          break;
        }
        case "deleteEntireSoftLine": {
          K.deleteBackward(h, {
            unit: "line"
          }), K.deleteForward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          K.deleteBackward(h, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          K.deleteBackward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          K.deleteForward(h, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          K.deleteForward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          K.deleteBackward(h, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          K.deleteForward(h, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          K.insertSoftBreak(h);
          break;
        case "insertParagraph": {
          K.insertBreak(h);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          oe === "insertFromComposition" && fe.isComposing(h) && (w(!1), ua.set(h, !1)), (Be == null ? void 0 : Be.constructor.name) === "DataTransfer" ? fe.insertData(h, Be) : typeof Be == "string" && ($e ? x.current.push(() => K.insertText(h, Be)) : K.insertText(h, Be));
          break;
        }
      }
      var rt = (le = wu.get(h)) === null || le === void 0 ? void 0 : le.unref();
      wu.delete(h), rt && (!h.selection || !pe.equals(h.selection, rt)) && Ce.select(h, rt);
    }
  }, [h, V, F, i, s, z]), X = dn((M) => {
    M == null ? (V.cancel(), z.cancel(), Ad.delete(h), ha.delete(h), S.current && Xi && S.current.removeEventListener("beforeinput", H)) : Xi && M.addEventListener("beforeinput", H), S.current = M, typeof t == "function" ? t(M) : t && (t.current = M);
  }, [V, z, h, H, t]);
  ac(() => {
    var M = fe.getWindow(h);
    M.document.addEventListener("selectionchange", z);
    var U = () => {
      B.isDraggingInternally = !1;
    };
    return M.document.addEventListener("dragend", U), M.document.addEventListener("drop", U), () => {
      M.document.removeEventListener("selectionchange", z), M.document.removeEventListener("dragend", U), M.document.removeEventListener("drop", U);
    };
  }, [z, B]);
  var J = o([h, []]), te = a && h.children.length === 1 && Array.from(Te.texts(h)).length === 1 && Te.string(h) === "" && !E, ee = dn((M) => {
    if (M && te) {
      var U;
      C((U = M.getBoundingClientRect()) === null || U === void 0 ? void 0 : U.height);
    } else
      C(void 0);
  }, [te]);
  if (te) {
    var L = K.start(h, []);
    J.push({
      [Qa]: !0,
      placeholder: a,
      onPlaceholderResize: ee,
      anchor: L,
      focus: L
    });
  }
  var {
    marks: T
  } = h;
  if (B.hasMarkPlaceholder = !1, h.selection && pe.isCollapsed(h.selection) && T) {
    var {
      anchor: W
    } = h.selection, D = Te.leaf(h, W.path), G = Ja(D, jye);
    if (!He.equals(D, T, {
      loose: !0
    })) {
      B.hasMarkPlaceholder = !0;
      var O = Object.fromEntries(Object.keys(G).map((M) => [M, null]));
      J.push(Ho(Ho(Ho({
        [f3]: !0
      }, O), T), {}, {
        anchor: W,
        focus: W
      }));
    }
  }
  return v(() => {
    setTimeout(() => {
      var {
        selection: M
      } = h;
      if (M) {
        var {
          anchor: U
        } = M, j = Te.leaf(h, U.path);
        if (T && !He.equals(j, T, {
          loose: !0
        })) {
          No.set(h, T);
          return;
        }
      }
      No.delete(h);
    });
  }), /* @__PURE__ */ Oe.createElement(k3.Provider, {
    value: s
  }, /* @__PURE__ */ Oe.createElement(Mye.Provider, {
    value: E
  }, /* @__PURE__ */ Oe.createElement(E3.Provider, {
    value: o
  }, /* @__PURE__ */ Oe.createElement(Dye, {
    node: S,
    receivedUserInput: _
  }, /* @__PURE__ */ Oe.createElement(g, Ho(Ho({
    role: s ? void 0 : "textbox",
    "aria-multiline": s ? void 0 : !0
  }, m), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: Xi || !jd ? m.spellCheck : !1,
    autoCorrect: Xi || !jd ? m.autoCorrect : "false",
    autoCapitalize: Xi || !jd ? m.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !s,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: X,
    style: Ho(Ho({}, f ? {} : Ho({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, y ? {
      minHeight: y
    } : {})), d),
    onBeforeInput: dn((M) => {
      if (!Xi && !s && !$r(M, m.onBeforeInput) && fe.hasSelectableTarget(h, M.target) && (M.preventDefault(), !fe.isComposing(h))) {
        var U = M.data;
        K.insertText(h, U);
      }
    }, [m.onBeforeInput, h, s]),
    onInput: dn((M) => {
      if (!$r(M, m.onInput)) {
        if ($.current) {
          $.current.handleInput();
          return;
        }
        for (var U of x.current)
          U();
        if (x.current = [], !fe.isFocused(h)) {
          var j = M.nativeEvent, Z = h;
          if (j.inputType === "historyUndo" && typeof Z.undo == "function") {
            Z.undo();
            return;
          }
          if (j.inputType === "historyRedo" && typeof Z.redo == "function") {
            Z.redo();
            return;
          }
        }
      }
    }, [m.onInput, h]),
    onBlur: dn((M) => {
      if (!(s || B.isUpdatingSelection || !fe.hasSelectableTarget(h, M.target) || $r(M, m.onBlur))) {
        var U = fe.findDocumentOrShadowRoot(h);
        if (B.latestElement !== U.activeElement) {
          var {
            relatedTarget: j
          } = M, Z = fe.toDOMNode(h, h);
          if (j !== Z && !(Ro(j) && j.hasAttribute("data-slate-spacer"))) {
            if (j != null && bs(j) && fe.hasDOMNode(h, j)) {
              var A = fe.toSlateNode(h, j);
              if (Ve.isElement(A) && !h.isVoid(A))
                return;
            }
            if (Js) {
              var Q = Cu(U);
              Q == null || Q.removeAllRanges();
            }
            vs.delete(h);
          }
        }
      }
    }, [s, B.isUpdatingSelection, B.latestElement, h, m.onBlur]),
    onClick: dn((M) => {
      if (fe.hasTarget(h, M.target) && !$r(M, m.onClick) && bs(M.target)) {
        var U = fe.toSlateNode(h, M.target), j = fe.findPath(h, U);
        if (!K.hasPath(h, j) || Te.get(h, j) !== U)
          return;
        if (M.detail === Oye && j.length >= 1) {
          var Z = j;
          if (!(Ve.isElement(U) && K.isBlock(h, U))) {
            var A, Q = K.above(h, {
              match: ($e) => Ve.isElement($e) && K.isBlock(h, $e),
              at: j
            });
            Z = (A = Q == null ? void 0 : Q[1]) !== null && A !== void 0 ? A : j.slice(0, 1);
          }
          var N = K.range(h, Z);
          Ce.select(h, N);
          return;
        }
        if (s)
          return;
        var le = K.start(h, j), ye = K.end(h, j), oe = K.void(h, {
          at: le
        }), Be = K.void(h, {
          at: ye
        });
        if (oe && Be && ie.equals(oe[1], Be[1])) {
          var Ue = K.range(h, le);
          Ce.select(h, Ue);
        }
      }
    }, [h, m.onClick, s]),
    onCompositionEnd: dn((M) => {
      if (fe.hasSelectableTarget(h, M.target)) {
        var U;
        if (fe.isComposing(h) && Promise.resolve().then(() => {
          w(!1), ua.set(h, !1);
        }), (U = $.current) === null || U === void 0 || U.handleCompositionEnd(M), $r(M, m.onCompositionEnd) || Vr)
          return;
        if (!Js && !kve && !u3 && !Lve && !_ve && M.data) {
          var j = No.get(h);
          No.delete(h), j !== void 0 && (Di.set(h, h.marks), h.marks = j), K.insertText(h, M.data);
          var Z = Di.get(h);
          Di.delete(h), Z !== void 0 && (h.marks = Z);
        }
      }
    }, [m.onCompositionEnd, h]),
    onCompositionUpdate: dn((M) => {
      fe.hasSelectableTarget(h, M.target) && !$r(M, m.onCompositionUpdate) && (fe.isComposing(h) || (w(!0), ua.set(h, !0)));
    }, [m.onCompositionUpdate, h]),
    onCompositionStart: dn((M) => {
      if (fe.hasSelectableTarget(h, M.target)) {
        var U;
        if ((U = $.current) === null || U === void 0 || U.handleCompositionStart(M), $r(M, m.onCompositionStart) || Vr)
          return;
        w(!0);
        var {
          selection: j
        } = h;
        if (j && pe.isExpanded(j)) {
          K.deleteFragment(h);
          return;
        }
      }
    }, [m.onCompositionStart, h]),
    onCopy: dn((M) => {
      fe.hasSelectableTarget(h, M.target) && !$r(M, m.onCopy) && !lA(M) && (M.preventDefault(), fe.setFragmentData(h, M.clipboardData, "copy"));
    }, [m.onCopy, h]),
    onCut: dn((M) => {
      if (!s && fe.hasSelectableTarget(h, M.target) && !$r(M, m.onCut) && !lA(M)) {
        M.preventDefault(), fe.setFragmentData(h, M.clipboardData, "cut");
        var {
          selection: U
        } = h;
        if (U)
          if (pe.isExpanded(U))
            K.deleteFragment(h);
          else {
            var j = Te.parent(h, U.anchor.path);
            K.isVoid(h, j) && Ce.delete(h);
          }
      }
    }, [s, h, m.onCut]),
    onDragOver: dn((M) => {
      if (fe.hasTarget(h, M.target) && !$r(M, m.onDragOver)) {
        var U = fe.toSlateNode(h, M.target);
        Ve.isElement(U) && K.isVoid(h, U) && M.preventDefault();
      }
    }, [m.onDragOver, h]),
    onDragStart: dn((M) => {
      if (!s && fe.hasTarget(h, M.target) && !$r(M, m.onDragStart)) {
        var U = fe.toSlateNode(h, M.target), j = fe.findPath(h, U), Z = Ve.isElement(U) && K.isVoid(h, U) || K.void(h, {
          at: j,
          voids: !0
        });
        if (Z) {
          var A = K.range(h, j);
          Ce.select(h, A);
        }
        B.isDraggingInternally = !0, fe.setFragmentData(h, M.dataTransfer, "drag");
      }
    }, [s, h, m.onDragStart, B]),
    onDrop: dn((M) => {
      if (!s && fe.hasTarget(h, M.target) && !$r(M, m.onDrop)) {
        M.preventDefault();
        var U = h.selection, j = fe.findEventRange(h, M), Z = M.dataTransfer;
        Ce.select(h, j), B.isDraggingInternally && U && !pe.equals(U, j) && !K.void(h, {
          at: j,
          voids: !0
        }) && Ce.delete(h, {
          at: U
        }), fe.insertData(h, Z), fe.isFocused(h) || fe.focus(h);
      }
    }, [s, h, m.onDrop, B]),
    onDragEnd: dn((M) => {
      !s && B.isDraggingInternally && m.onDragEnd && fe.hasTarget(h, M.target) && m.onDragEnd(M);
    }, [s, B, m, h]),
    onFocus: dn((M) => {
      if (!s && !B.isUpdatingSelection && fe.hasEditableTarget(h, M.target) && !$r(M, m.onFocus)) {
        var U = fe.toDOMNode(h, h), j = fe.findDocumentOrShadowRoot(h);
        if (B.latestElement = j.activeElement, Fa && M.target !== U) {
          U.focus();
          return;
        }
        vs.set(h, !0);
      }
    }, [s, B, h, m.onFocus]),
    onKeyDown: dn((M) => {
      if (!s && fe.hasEditableTarget(h, M.target)) {
        var U;
        (U = $.current) === null || U === void 0 || U.handleKeyDown(M);
        var {
          nativeEvent: j
        } = M;
        if (fe.isComposing(h) && j.isComposing === !1 && (ua.set(h, !1), w(!1)), $r(M, m.onKeyDown) || fe.isComposing(h))
          return;
        var {
          selection: Z
        } = h, A = h.children[Z !== null ? Z.focus.path[0] : 0], Q = YU(Te.string(A)) === "rtl";
        if (Qn.isRedo(j)) {
          M.preventDefault();
          var N = h;
          typeof N.redo == "function" && N.redo();
          return;
        }
        if (Qn.isUndo(j)) {
          M.preventDefault();
          var le = h;
          typeof le.undo == "function" && le.undo();
          return;
        }
        if (Qn.isMoveLineBackward(j)) {
          M.preventDefault(), Ce.move(h, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (Qn.isMoveLineForward(j)) {
          M.preventDefault(), Ce.move(h, {
            unit: "line"
          });
          return;
        }
        if (Qn.isExtendLineBackward(j)) {
          M.preventDefault(), Ce.move(h, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (Qn.isExtendLineForward(j)) {
          M.preventDefault(), Ce.move(h, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (Qn.isMoveBackward(j)) {
          M.preventDefault(), Z && pe.isCollapsed(Z) ? Ce.move(h, {
            reverse: !Q
          }) : Ce.collapse(h, {
            edge: Q ? "end" : "start"
          });
          return;
        }
        if (Qn.isMoveForward(j)) {
          M.preventDefault(), Z && pe.isCollapsed(Z) ? Ce.move(h, {
            reverse: Q
          }) : Ce.collapse(h, {
            edge: Q ? "start" : "end"
          });
          return;
        }
        if (Qn.isMoveWordBackward(j)) {
          M.preventDefault(), Z && pe.isExpanded(Z) && Ce.collapse(h, {
            edge: "focus"
          }), Ce.move(h, {
            unit: "word",
            reverse: !Q
          });
          return;
        }
        if (Qn.isMoveWordForward(j)) {
          M.preventDefault(), Z && pe.isExpanded(Z) && Ce.collapse(h, {
            edge: "focus"
          }), Ce.move(h, {
            unit: "word",
            reverse: Q
          });
          return;
        }
        if (Xi) {
          if ((c3 || Js) && Z && (Qn.isDeleteBackward(j) || Qn.isDeleteForward(j)) && pe.isCollapsed(Z)) {
            var ye = Te.parent(h, Z.anchor.path);
            if (Ve.isElement(ye) && K.isVoid(h, ye) && (K.isInline(h, ye) || K.isBlock(h, ye))) {
              M.preventDefault(), K.deleteBackward(h, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (Qn.isBold(j) || Qn.isItalic(j) || Qn.isTransposeCharacter(j)) {
            M.preventDefault();
            return;
          }
          if (Qn.isSoftBreak(j)) {
            M.preventDefault(), K.insertSoftBreak(h);
            return;
          }
          if (Qn.isSplitBlock(j)) {
            M.preventDefault(), K.insertBreak(h);
            return;
          }
          if (Qn.isDeleteBackward(j)) {
            M.preventDefault(), Z && pe.isExpanded(Z) ? K.deleteFragment(h, {
              direction: "backward"
            }) : K.deleteBackward(h);
            return;
          }
          if (Qn.isDeleteForward(j)) {
            M.preventDefault(), Z && pe.isExpanded(Z) ? K.deleteFragment(h, {
              direction: "forward"
            }) : K.deleteForward(h);
            return;
          }
          if (Qn.isDeleteLineBackward(j)) {
            M.preventDefault(), Z && pe.isExpanded(Z) ? K.deleteFragment(h, {
              direction: "backward"
            }) : K.deleteBackward(h, {
              unit: "line"
            });
            return;
          }
          if (Qn.isDeleteLineForward(j)) {
            M.preventDefault(), Z && pe.isExpanded(Z) ? K.deleteFragment(h, {
              direction: "forward"
            }) : K.deleteForward(h, {
              unit: "line"
            });
            return;
          }
          if (Qn.isDeleteWordBackward(j)) {
            M.preventDefault(), Z && pe.isExpanded(Z) ? K.deleteFragment(h, {
              direction: "backward"
            }) : K.deleteBackward(h, {
              unit: "word"
            });
            return;
          }
          if (Qn.isDeleteWordForward(j)) {
            M.preventDefault(), Z && pe.isExpanded(Z) ? K.deleteFragment(h, {
              direction: "forward"
            }) : K.deleteForward(h, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [s, h, m.onKeyDown]),
    onPaste: dn((M) => {
      !s && fe.hasEditableTarget(h, M.target) && !$r(M, m.onPaste) && (!Xi || Dve(M.nativeEvent) || Js) && (M.preventDefault(), fe.insertData(h, M.clipboardData));
    }, [s, h, m.onPaste])
  }), /* @__PURE__ */ Oe.createElement(Aye, {
    decorations: J,
    node: h,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: h.selection
  }))))));
}), Rye = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ Oe.createElement("span", Ho({}, t), n, Vr && /* @__PURE__ */ Oe.createElement("br", null))
  );
}, Iye = () => [], Nye = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && pe.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), Yme(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, $r = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, lA = (e) => bs(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), Fye = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, zye = /* @__PURE__ */ qe(!1), Uye = /* @__PURE__ */ qe({});
function $ye(e) {
  var t = Qe([]).current, n = Qe({
    editor: e
  }).current, r = dn((i) => {
    n.editor = i, t.forEach((a) => a(i));
  }, [t, n]), o = Bn(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var Wye = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], Vye = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: a
  } = e, s = Ja(e, Wye), [l, u] = Oe.useState(() => {
    if (!Te.isNodeList(a))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(Lr.stringify(a)));
    if (!K.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(Lr.stringify(t)));
    return t.children = a, Object.assign(t, s), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: p
  } = $ye(t), d = dn((m) => {
    var h;
    switch (r && r(t.children), m == null || (h = m.operation) === null || h === void 0 ? void 0 : h.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((E) => ({
      v: E.v + 1,
      editor: t
    })), p(t);
  }, [t, p, r, o, i]);
  v(() => (d0.set(t, d), () => {
    d0.set(t, () => {
    });
  }), [t, d]);
  var [g, f] = k(fe.isFocused(t));
  return v(() => {
    f(fe.isFocused(t));
  }, [t]), ac(() => {
    var m = () => f(fe.isFocused(t));
    return l3 >= 17 ? (document.addEventListener("focusin", m), document.addEventListener("focusout", m), () => {
      document.removeEventListener("focusin", m), document.removeEventListener("focusout", m);
    }) : (document.addEventListener("focus", m, !0), document.addEventListener("blur", m, !0), () => {
      document.removeEventListener("focus", m, !0), document.removeEventListener("blur", m, !0);
    });
  }, []), /* @__PURE__ */ Oe.createElement(Uye.Provider, {
    value: c
  }, /* @__PURE__ */ Oe.createElement(_3.Provider, {
    value: l
  }, /* @__PURE__ */ Oe.createElement(yx.Provider, {
    value: l.editor
  }, /* @__PURE__ */ Oe.createElement(zye.Provider, {
    value: g
  }, n))));
}, uA = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, cA = (e, t, n) => {
  var r = fe.toDOMRange(e, t).getBoundingClientRect(), o = fe.toDOMRange(e, n).getBoundingClientRect();
  return uA(r, o) && uA(o, r);
}, Hye = (e, t) => {
  var n = K.range(e, pe.end(t)), r = Array.from(K.positions(e, {
    at: t
  })), o = 0, i = r.length, a = Math.floor(i / 2);
  if (cA(e, K.range(e, r[o]), n))
    return K.range(e, r[o], n);
  if (r.length < 2)
    return K.range(e, r[r.length - 1], n);
  for (; a !== r.length && a !== o; )
    cA(e, K.range(e, r[a]), n) ? i = a : o = a, a = Math.floor((o + i) / 2);
  return K.range(e, r[i], n);
};
function pA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pA(Object(n), !0).forEach(function(r) {
      Io(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Gye = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: a,
    addMark: s,
    removeMark: l
  } = r;
  return tm.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var p, d;
    (p = Cx.get(r)) === null || p === void 0 || p(), !No.get(r) && (d = eo.get(r)) !== null && d !== void 0 && d.length && No.set(r, null), Di.delete(r), s(u, c);
  }, r.removeMark = (u) => {
    var c;
    !No.get(r) && (c = eo.get(r)) !== null && c !== void 0 && c.length && No.set(r, null), Di.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return a(u);
    if (r.selection && pe.isCollapsed(r.selection)) {
      var c = K.above(r, {
        match: (f) => Ve.isElement(f) && K.isBlock(r, f),
        at: r.selection
      });
      if (c) {
        var [, p] = c, d = K.range(r, p, r.selection.anchor), g = Hye(r, d);
        pe.isCollapsed(g) || Ce.delete(r, {
          at: g
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], p = [], d = eo.get(r);
    if (d != null && d.length) {
      var g = d.map((z) => Hve(z, u)).filter(Boolean);
      eo.set(r, g);
    }
    var f = us.get(r);
    f && us.set(r, Qj(r, f, u));
    var m = ls.get(r);
    if (m != null && m.at) {
      var h = Ot.isPoint(m == null ? void 0 : m.at) ? g0(r, m.at, u) : Qj(r, m.at, u);
      ls.set(r, h ? dA(dA({}, m), {}, {
        at: h
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...Ra(r, u.path));
        break;
      }
      case "set_selection": {
        var E;
        (E = wu.get(r)) === null || E === void 0 || E.unref(), wu.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...Ra(r, ie.parent(u.path)));
        break;
      }
      case "merge_node": {
        var w = ie.previous(u.path);
        c.push(...Ra(r, w));
        break;
      }
      case "move_node": {
        var S = ie.common(ie.parent(u.path), ie.parent(u.newPath));
        c.push(...Ra(r, S));
        var x;
        ie.isBefore(u.path, u.newPath) ? (c.push(...Ra(r, ie.parent(u.path))), x = u.newPath) : (c.push(...Ra(r, ie.parent(u.newPath))), x = u.path);
        var y = Te.get(t, ie.parent(x)), C = fe.findKey(r, y), P = K.pathRef(r, ie.parent(x));
        p.push([P, C]);
        break;
      }
    }
    switch (o(u), u.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node":
        Ha.set(r, !0);
    }
    for (var [F, _] of c) {
      var [I] = K.node(r, F);
      nh.set(I, _);
    }
    for (var [B, $] of p) {
      if (B.current) {
        var [V] = K.node(r, B.current);
        nh.set(V, $);
      }
      B.unref();
    }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [p, d] = pe.edges(c), g = K.void(r, {
        at: p.path
      }), f = K.void(r, {
        at: d.path
      });
      if (!(pe.isCollapsed(c) && !g)) {
        var m = fe.toDOMRange(r, c), h = m.cloneContents(), E = h.childNodes[0];
        if (h.childNodes.forEach((I) => {
          I.textContent && I.textContent.trim() !== "" && (E = I);
        }), f) {
          var [w] = f, S = m.cloneRange(), x = fe.toDOMNode(r, w);
          S.setEndAfter(x), h = S.cloneContents();
        }
        if (g && (E = h.querySelector("[data-slate-spacer]")), Array.from(h.querySelectorAll("[data-slate-zero-width]")).forEach((I) => {
          var B = I.getAttribute("data-slate-zero-width") === "n";
          I.textContent = B ? `
` : "";
        }), g3(E)) {
          var y = E.ownerDocument.createElement("span");
          y.style.whiteSpace = "pre", y.appendChild(E), h.appendChild(y), E = y;
        }
        var C = r.getFragment(), P = JSON.stringify(C), F = window.btoa(encodeURIComponent(P));
        E.setAttribute("data-slate-fragment", F), u.setData("application/".concat(n), F);
        var _ = h.ownerDocument.createElement("div");
        return _.appendChild(h), _.setAttribute("hidden", "true"), h.ownerDocument.body.appendChild(_), u.setData("text/html", _.innerHTML), u.setData("text/plain", v3(_)), h.ownerDocument.body.removeChild(_), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || Bve(u);
    if (c) {
      var p = decodeURIComponent(window.atob(c)), d = JSON.parse(p);
      return r.insertFragment(d), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var p = c.split(/\r\n|\r|\n/), d = !1;
      for (var g of p)
        d && Ce.splitNodes(r, {
          always: !0
        }), r.insertText(g), d = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = l3 < 18 ? tl.unstable_batchedUpdates : (p) => p();
    c(() => {
      var p = d0.get(r);
      p && p(u), i(u);
    });
  }, r;
}, Ra = (e, t) => {
  var n = [];
  for (var [r, o] of K.levels(e, {
    at: t
  })) {
    var i = fe.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function P3(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    K.nodes(e, {
      at: K.unhangRange(e, r),
      match: (i) => !K.isEditor(i) && Ve.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const fA = ["listItem", "numberedList"], Bd = ["left", "center", "right", "justify"];
function qye(e, t) {
  const n = Bd.includes(t) ? "align" : "type", r = P3(e, t, n), o = fA.includes(t);
  Ce.unwrapNodes(e, {
    match: (a) => !K.isEditor(a) && Ve.isElement(a) && fA.includes(a.type) && !Bd.includes(t),
    split: !0
  });
  let i;
  if (Bd.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, Ce.setNodes(e, i), !r && o) {
    const a = { type: t, children: [] };
    Ce.wrapNodes(e, a);
  }
}
function Vs({ format: e, icon: t }) {
  const n = nm(), r = Bd.includes(e) ? "align" : "type", i = P3(n, e, r) ? "activeTrue" : "activeFalse";
  function a(s) {
    s.preventDefault(), qye(n, e);
  }
  return /* @__PURE__ */ q.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: a,
      children: /* @__PURE__ */ q.jsx(t, {})
    }
  );
}
function Zye({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ q.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ q.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ q.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ q.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ q.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ q.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    case "image":
      return /* @__PURE__ */ q.jsxs("div", { style: r, ...e, children: [
        /* @__PURE__ */ q.jsx(
          "img",
          {
            className: "arkynElementImage",
            alt: "arkynElementImage",
            src: (n == null ? void 0 : n.src) || ""
          }
        ),
        t
      ] });
    default:
      return /* @__PURE__ */ q.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
const S3 = qe({});
function Kye(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, s = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ q.jsx(S3.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ q.jsx(bR, { children: t && /* @__PURE__ */ q.jsxs("aside", { className: s.trim(), ...i, children: [
    /* @__PURE__ */ q.jsx(
      Ou.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ q.jsx(
      Ou.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function Xye(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ q.jsx("footer", { className: o.trim(), ...r });
}
function Yye(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = Ee(S3), a = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ q.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ q.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ q.jsx(P0, { size: 24 })
      }
    )
  ] });
}
const v0 = qe({});
function Jye() {
  if (!v0)
    throw new Error("useTabContext must be used within a TabProvider");
  return Ee(v0);
}
function Qye(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [a, s] = k(r || ""), [l, u] = k(!0), c = Qe(null), p = `arkynTabContainer ${o || ""}`, [d, g] = k({
    width: "0px",
    left: "0px",
    transition: "none"
  }), f = (h, E) => {
    const w = h.getBoundingClientRect(), S = c.current.getBoundingClientRect(), x = E ? void 0 : "none";
    u(!1), g({
      transition: x,
      width: `${w.width}px`,
      left: `${w.left - S.left}px`
    });
  };
  v(() => {
    const h = c.current;
    if (!h) return;
    let E = null;
    E = h.querySelector("button.activeTrue"), E && f(E);
  }, []);
  const m = (h) => {
    const E = h.target;
    E && (s(E.value), E.classList.add("activeTrue"), f(E, !0), n && n(E.value));
  };
  return /* @__PURE__ */ q.jsxs("nav", { ref: c, className: p.trim(), ...i, children: [
    /* @__PURE__ */ q.jsx(v0.Provider, { value: { handleTabClick: m, showInitialTab: l, value: a }, children: t }),
    /* @__PURE__ */ q.jsx("div", { className: "activeLine", style: d })
  ] });
}
function hA(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: a, handleTabClick: s } = Jye(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && a ? "showBorderBottom" : ""} ${l} ${n}`;
  function p(d) {
    s(d), r && r(d);
  }
  return /* @__PURE__ */ q.jsx(
    "button",
    {
      onClick: p,
      className: c.trim(),
      ...o,
      type: "button",
      children: t
    }
  );
}
function ebe(e) {
  const {
    action: t,
    tabLabels: n = ["Adicionar URL", "Upload de arquivo"],
    modalCancelButton: r = "Cancelar",
    modalConfirmButton: o = "Confirmar",
    modalInputImageLabel: i = "Imagem:",
    modalInputUrlLabel: a = "URL da imagem:",
    modalTitle: s = "Inserir imagem"
  } = e, l = nm(), [u, c] = k(!1), [p, d] = k(""), [g, f] = k("url");
  function m(h) {
    h.preventDefault(), !(!p || p === "") && (l.insertNodes([
      { type: "paragraph", children: [{ text: "" }] },
      { type: "image", src: p, children: [{ text: "" }] },
      { type: "paragraph", children: [{ text: "" }] }
    ]), c(!1));
  }
  return /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
    /* @__PURE__ */ q.jsx(
      "button",
      {
        type: "button",
        className: "arkynRichTextInsertImage",
        onMouseDown: () => c(!0),
        children: /* @__PURE__ */ q.jsx(z$, {})
      }
    ),
    /* @__PURE__ */ q.jsxs(
      Kye,
      {
        isVisibled: u,
        makeInvisible: () => c(!1),
        children: [
          /* @__PURE__ */ q.jsx(Yye, { children: s }),
          /* @__PURE__ */ q.jsxs("div", { className: "arkynRichTextInsertImageModalContent", children: [
            /* @__PURE__ */ q.jsxs(Qye, { defaultActive: g, onClick: f, children: [
              /* @__PURE__ */ q.jsx(hA, { value: "url", children: n[0] }),
              /* @__PURE__ */ q.jsx(hA, { value: "file", children: n[1] })
            ] }),
            g === "url" && /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
              /* @__PURE__ */ q.jsxs(Lj, { children: [
                /* @__PURE__ */ q.jsx(Pj, { children: a }),
                /* @__PURE__ */ q.jsx(
                  Qg,
                  {
                    type: "text",
                    name: "richTextimageURL",
                    defaultValue: p,
                    onChange: (h) => d(h.target.value)
                  }
                )
              ] }),
              p && /* @__PURE__ */ q.jsx(
                "img",
                {
                  className: "arkynRichTextInsertImageModalPreviewImage",
                  src: p,
                  alt: "preview"
                }
              )
            ] }),
            g === "file" && /* @__PURE__ */ q.jsxs(Lj, { children: [
              /* @__PURE__ */ q.jsx(Pj, { children: i }),
              /* @__PURE__ */ q.jsx(
                tge,
                {
                  name: "richTextimageURL",
                  action: t,
                  defaultValue: p,
                  onUpload: (h) => d(h || "")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ q.jsxs(Xye, { children: [
            /* @__PURE__ */ q.jsx(
              rc,
              {
                type: "button",
                scheme: "danger",
                variant: "outline",
                onClick: () => c(!1),
                children: r
              }
            ),
            /* @__PURE__ */ q.jsx(rc, { type: "button", onClick: m, children: o })
          ] })
        ]
      }
    )
  ] });
}
function tbe({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ q.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ q.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ q.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ q.jsx("u", { children: t })), /* @__PURE__ */ q.jsx("span", { ...e, children: t });
}
function D3(e, t) {
  const n = K.marks(e);
  return n ? n[t] === !0 : !1;
}
function M3(e, t) {
  D3(e, t) ? K.removeMark(e, t) : K.addMark(e, t, !0);
}
function md({ format: e, icon: t }) {
  const n = nm(), o = D3(n, e) ? "activeTrue" : "activeFalse";
  function i(a) {
    a.preventDefault(), M3(n, e);
  }
  return /* @__PURE__ */ q.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ q.jsx(t, {})
    }
  );
}
function nbe({ children: e }) {
  return /* @__PURE__ */ q.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
function gA(e) {
  return e.map((t) => Te.string(t)).join("");
}
const mA = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, vd = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
function OEe(e) {
  const {
    name: t,
    hiddenButtons: n,
    imageConfig: r,
    defaultValue: o = "[]",
    enforceCharacterLimit: i = !1,
    onChangeCharactersCount: a,
    maxLimit: s = 2e3,
    onChange: l,
    isError: u
  } = e, c = Bn(() => Ige(Gye(RV())), []), { id: p, inputRef: d, error: g } = Jr(), f = Qe(null);
  function m() {
    try {
      const J = JSON.parse(o);
      return !Array.isArray(J) || J.length <= 0 ? vd : J.every(
        (ee) => typeof ee == "object" && ee !== null && "type" in ee && "children" in ee
      ) ? J : vd;
    } catch {
      return vd;
    }
  }
  const h = gA(m()), [E, w] = k(h.length), [S, x] = k(
    JSON.stringify(m()) || "[]"
  ), [y, C] = k(!1), P = d || f, F = u || !!g, _ = dn(tbe, []), I = dn(Zye, []);
  function B(J) {
    const te = gA(J);
    w(te.length), a && a(te.length), !(i && te.length >= s) && (x(JSON.stringify(J)), l && l(J), c.children = J, Ce.setNodes(c, { children: J }));
  }
  const $ = y ? "focusTrue" : "focusFalse", z = `arkynRichText ${F || s < E ? "errorTrue" : "errorFalse"} ${$}`, H = s - E;
  function X(J) {
    return !(n != null && n.includes(J));
  }
  return /* @__PURE__ */ q.jsxs(
    Vye,
    {
      editor: c,
      initialValue: m(),
      onChange: B,
      onValueChange: B,
      children: [
        /* @__PURE__ */ q.jsxs("div", { className: z, children: [
          /* @__PURE__ */ q.jsxs(nbe, { children: [
            X("headingOne") && /* @__PURE__ */ q.jsx(Vs, { format: "headingOne", icon: U$ }),
            X("headingTwo") && /* @__PURE__ */ q.jsx(Vs, { format: "headingTwo", icon: $$ }),
            X("blockQuote") && /* @__PURE__ */ q.jsx(Vs, { format: "blockQuote", icon: W$ }),
            X("bold") && /* @__PURE__ */ q.jsx(md, { format: "bold", icon: V$ }),
            X("italic") && /* @__PURE__ */ q.jsx(md, { format: "italic", icon: H$ }),
            X("underline") && /* @__PURE__ */ q.jsx(md, { format: "underline", icon: G$ }),
            X("code") && /* @__PURE__ */ q.jsx(md, { format: "code", icon: q$ }),
            X("left") && /* @__PURE__ */ q.jsx(Vs, { format: "left", icon: Z$ }),
            X("right") && /* @__PURE__ */ q.jsx(Vs, { format: "right", icon: K$ }),
            X("center") && /* @__PURE__ */ q.jsx(Vs, { format: "center", icon: X$ }),
            X("justify") && /* @__PURE__ */ q.jsx(Vs, { format: "justify", icon: Y$ }),
            r && X("image") && /* @__PURE__ */ q.jsx(ebe, { ...r })
          ] }),
          /* @__PURE__ */ q.jsx(
            Bye,
            {
              className: "editorContainer",
              renderElement: I,
              renderLeaf: _,
              spellCheck: !0,
              id: p,
              onFocus: () => C(!0),
              onBlur: () => C(!1),
              onKeyDown: (J) => {
                for (const te in mA)
                  if (Bge(te, J)) {
                    J.preventDefault();
                    const ee = mA[te];
                    M3(c, ee);
                  }
              }
            }
          ),
          H < 0 && /* @__PURE__ */ q.jsx("div", { className: "restatesCharacters", children: H })
        ] }),
        /* @__PURE__ */ q.jsx("input", { type: "hidden", ref: P, name: t, value: S }),
        /* @__PURE__ */ q.jsx("input", { type: "hidden", name: `${t}Count`, value: E })
      ]
    }
  );
}
function rbe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: p,
    onBlur: d,
    title: g,
    style: f,
    closeOnSelect: m = !0,
    ...h
  } = e, y = `arkyn_select ${s ? "hasPrefix" : ""} ${a} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, P = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: y,
    prefix: QR(s, P, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: p,
    onBlur: d,
    title: g,
    closeOnSelect: m,
    style: f,
    iconSize: P,
    Spinner: /* @__PURE__ */ q.jsx(ri, { className: "spinner", size: P, strokeWidth: 2.5 }),
    ...h
  };
}
function kEe(e) {
  var U;
  const [t, n] = k(""), [r, o] = k(!1), { inputRef: i, id: a, error: s } = Jr(), l = Qe(null), u = i || l, c = e.isError || !!s, {
    disabled: p,
    title: d,
    style: g,
    className: f,
    prefix: m,
    iconSize: h,
    isLoading: E,
    LeftIcon: w,
    value: S = null,
    defaultValue: x = "",
    onFocus: y,
    onBlur: C,
    Spinner: P,
    name: F,
    placeholder: _,
    onSelect: I,
    options: B,
    optionMaxHeight: $,
    closeOnSelect: V,
    isSearchable: z,
    onSearch: H,
    ...X
  } = rbe({ ...e, id: a, isError: c }, r), [J, te] = k(x);
  function ee() {
    p || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function L(j) {
    H && (n(""), H(j.target.value)), H || n(j.target.value);
  }
  function T(j) {
    r || (o(!0), y && y(j));
  }
  function W() {
    o(!1), C && u.current && u.current.blur();
  }
  function D(j) {
    const { label: Z, value: A } = j;
    te(J !== A ? A : ""), I && I({ label: Z, value: A }), V && W();
  }
  const G = typeof S == "string" ? S : J, O = ((U = B.find((j) => j.value === G)) == null ? void 0 : U.label) || "", M = () => {
    if (!r && O) return !0;
    if (!r && !O) return !1;
    if (r && O) return !0;
    if (r && !O) return !1;
  };
  return /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
    /* @__PURE__ */ q.jsxs(
      "section",
      {
        title: d,
        style: g,
        onClick: ee,
        className: `${f} placeholder_dark_${M()}`,
        children: [
          m,
          w && /* @__PURE__ */ q.jsx(w, { size: h, strokeWidth: 2.5 }),
          /* @__PURE__ */ q.jsx(
            "input",
            {
              disabled: p,
              readOnly: !0,
              placeholder: O || _,
              onFocus: T,
              ...X
            }
          ),
          /* @__PURE__ */ q.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: F,
              value: G || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ q.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: $ },
              children: [
                z && /* @__PURE__ */ q.jsx(
                  Qg,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: mR,
                    onChange: L
                  }
                ),
                B.filter((j) => !!(e.onSearch || !e.isSearchable || j.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: j, value: Z }) => /* @__PURE__ */ q.jsxs(
                  "div",
                  {
                    onClick: () => D({ label: j, value: Z }),
                    className: G === Z ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      j,
                      " ",
                      /* @__PURE__ */ q.jsx(hh, {})
                    ]
                  },
                  Z
                )),
                B.length <= 0 && /* @__PURE__ */ q.jsx("p", { children: "Sem opções disponíveis" })
              ]
            }
          ),
          !E && /* @__PURE__ */ q.jsx(
            L0,
            {
              className: "arkyn_select_arrow",
              size: h,
              strokeWidth: 2.5
            }
          ),
          E && P
        ]
      }
    ),
    r && /* @__PURE__ */ q.jsx("aside", { className: "arkyn_select_overlay", onClick: W })
  ] });
}
function _Ee(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: a,
    className: s = "",
    onCheck: l,
    ...u
  } = e, [c, p] = k(n), { id: d, inputRef: g } = Jr(), f = typeof r == "boolean" ? r : c;
  function m() {
    p(!c), l && l(f ? i : o || "checked");
  }
  const E = `arkynSwitch ${f ? "checkedTrue" : "checkedFalse"} ${t} ${s}`;
  return /* @__PURE__ */ q.jsx("button", { type: "button", onClick: m, className: E, ...u, children: /* @__PURE__ */ q.jsx(
    "input",
    {
      id: d,
      type: "hidden",
      name: a,
      ref: g,
      onClick: m,
      value: f ? o || "checked" : i
    }
  ) });
}
function LEe(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: a,
    onBlur: s,
    title: l,
    style: u,
    ...c
  } = e, [p, d] = k(!1), { inputRef: g, id: f, error: m } = Jr(), h = Qe(null), E = g || h, S = e.isError || !!m ? "errorTrue" : "errorFalse", C = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${S} ${p ? "focusedTrue" : "focusedFalse"} ${r}`;
  function P() {
    o || !(E != null && E.current) || (d(!0), E.current.focus());
  }
  function F(I) {
    d(!0), a && a(I);
  }
  function _(I) {
    d(!1), s && s(I);
  }
  return /* @__PURE__ */ q.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: P,
      className: C,
      children: /* @__PURE__ */ q.jsx(
        "textarea",
        {
          id: f,
          disabled: o,
          readOnly: i,
          ref: E,
          onFocus: F,
          onBlur: _,
          ...c
        }
      )
    }
  );
}
function PEe(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ q.jsx("nav", { className: r, ...n });
}
function SEe(e) {
  const { pathname: t } = M0(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...a
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ q.jsxs("p", { className: l, children: [
    /* @__PURE__ */ q.jsx(Ty, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ q.jsxs(eW, { to: i, className: l, ...a, children: [
    /* @__PURE__ */ q.jsx(Ty, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function T3(e = "") {
  const t = M0(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([a, s]) => {
      s === void 0 ? n.delete(`${r}${a}`) : n.set(`${r}${a}`, String(s));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let a = n.toString();
      return a && (a = "?" + a), a;
    }
  };
}
function vA(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function DEe(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    currentPage: a = 1,
    registerPerPage: s = 20,
    ...l
  } = e, u = yR(), { getParam: c, getScopedSearch: p } = T3(t), d = Number(c("page")) || a, g = Number(c("per_page")) || s, f = Math.ceil(n / g), m = d > 1 ? vA(d - 1 - i, d - 1) : [], h = d < f ? vA(
    d,
    Math.min(d + i, f)
  ) : [];
  function E(w) {
    u(p({ page: w }));
  }
  return /* @__PURE__ */ q.jsxs("div", { className: "arkynPagination", ...l, children: [
    /* @__PURE__ */ q.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d <= 1,
        onClick: () => E(d - 1),
        children: /* @__PURE__ */ q.jsx(J$, {})
      }
    ),
    d > 1 + i && /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
      /* @__PURE__ */ q.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => E(1),
          children: "1"
        }
      ),
      d > 2 + i && /* @__PURE__ */ q.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ q.jsx(Ix, {}) })
    ] }),
    m.length > 0 && m.map((w, S) => /* @__PURE__ */ q.jsx(
      "button",
      {
        onClick: () => E(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      S
    )),
    /* @__PURE__ */ q.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: d }),
    h.length > 0 && h.map((w, S) => /* @__PURE__ */ q.jsx(
      "button",
      {
        onClick: () => E(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      S
    )),
    d + i < f && /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
      d + 1 + i < f && /* @__PURE__ */ q.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ q.jsx(Ix, {}) }),
      /* @__PURE__ */ q.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => E(f),
          children: f
        }
      )
    ] }),
    /* @__PURE__ */ q.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d >= f,
        onClick: () => E(d + 1),
        children: /* @__PURE__ */ q.jsx(Ty, {})
      }
    )
  ] });
}
const j3 = qe({});
function MEe(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...a
  } = e, s = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ q.jsx(j3.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ q.jsx(bR, { children: t && /* @__PURE__ */ q.jsxs("aside", { className: u.trim(), ...a, children: [
    /* @__PURE__ */ q.jsx(
      Ou.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ q.jsx(
      Ou.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${s})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${s})` },
        children: o
      }
    )
  ] }) }) });
}
function TEe(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = Ee(j3), a = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ q.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ q.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ q.jsx(P0, { size: 24 })
      }
    )
  ] });
}
function jEe(e) {
  const {
    children: t,
    button: n,
    closeOnClick: r,
    className: o = "",
    orientation: i = "bottomLeft"
  } = e, [a, s] = k(!1), u = `arkynPopover ${i} ${a ? "visibleTrue" : "visibleFalse"} ${o}`;
  function c() {
    a || s(!0);
  }
  return /* @__PURE__ */ q.jsxs("div", { className: u, onClick: c, children: [
    n,
    /* @__PURE__ */ q.jsx(
      Ou.div,
      {
        style: { visibility: a ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: a ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && s(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    a && /* @__PURE__ */ q.jsx("div", { onClick: () => s(!1), className: "arkynPopoverOverlay" })
  ] });
}
function AEe(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ q.jsx(gR, {});
      case "danger":
        return /* @__PURE__ */ q.jsx(hR, {});
      default:
        return /* @__PURE__ */ q.jsx(fR, {});
    }
  }
  return /* @__PURE__ */ q.jsxs("div", { className: r, children: [
    /* @__PURE__ */ q.jsxs("div", { children: [
      /* @__PURE__ */ q.jsx("div", { className: "bg" }),
      /* @__PURE__ */ q.jsx(o, {})
    ] }),
    /* @__PURE__ */ q.jsx("p", { children: /* @__PURE__ */ q.jsx("span", { children: t }) })
  ] });
}
var yr = {}, Ox = {}, Nc = {}, Fc = {}, A3 = "Expected a function", yA = NaN, obe = "[object Symbol]", ibe = /^\s+|\s+$/g, sbe = /^[-+]0x[0-9a-f]+$/i, abe = /^0b[01]+$/i, lbe = /^0o[0-7]+$/i, ube = parseInt, cbe = typeof xn == "object" && xn && xn.Object === Object && xn, pbe = typeof self == "object" && self && self.Object === Object && self, dbe = cbe || pbe || Function("return this")(), fbe = Object.prototype, hbe = fbe.toString, gbe = Math.max, mbe = Math.min, my = function() {
  return dbe.Date.now();
};
function vbe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(A3);
  t = bA(t) || 0, rh(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? gbe(bA(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, _ = t - P;
    return p ? mbe(_, i - F) : _;
  }
  function h(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = my();
    if (h(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function S() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(my());
  }
  function y() {
    var C = my(), P = h(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = S, y.flush = x, y;
}
function ybe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(A3);
  return rh(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), vbe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function rh(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function bbe(e) {
  return !!e && typeof e == "object";
}
function wbe(e) {
  return typeof e == "symbol" || bbe(e) && hbe.call(e) == obe;
}
function bA(e) {
  if (typeof e == "number")
    return e;
  if (wbe(e))
    return yA;
  if (rh(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = rh(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(ibe, "");
  var n = abe.test(e);
  return n || lbe.test(e) ? ube(e.slice(2), n ? 2 : 8) : sbe.test(e) ? yA : +e;
}
var Cbe = ybe, zc = {};
Object.defineProperty(zc, "__esModule", {
  value: !0
});
zc.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), Rd.has(n) || Rd.set(n, /* @__PURE__ */ new Set());
  var i = Rd.get(n);
  if (!i.has(o)) {
    var a = function() {
      var s = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return s;
    }();
    t.addEventListener(n, r, a ? { passive: !0 } : !1), i.add(o);
  }
};
zc.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), Rd.get(n).delete(r.name || n);
};
var Rd = /* @__PURE__ */ new Map();
Object.defineProperty(Fc, "__esModule", {
  value: !0
});
var xbe = Cbe, Ebe = Obe(xbe), wA = zc;
function Obe(e) {
  return e && e.__esModule ? e : { default: e };
}
var kbe = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Ebe.default)(t, n);
}, or = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = kbe(function(o) {
        or.scrollHandler(t);
      }, n);
      return or.scrollSpyContainers.push(t), (0, wA.addPassiveEventListener)(t, "scroll", r), function() {
        (0, wA.removePassiveEventListener)(t, "scroll", r), or.scrollSpyContainers.splice(or.scrollSpyContainers.indexOf(t), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(t) {
    return or.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.scrollY !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.scrollX : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.scrollX !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.scrollY : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = or.scrollSpyContainers[or.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(or.currentPositionX(t), or.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    or.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = or.scrollSpyContainers[or.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t);
  },
  updateStates: function() {
    or.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    or.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), or.spySetState && or.spySetState.length && or.spySetState.indexOf(t) > -1 && or.spySetState.splice(or.spySetState.indexOf(t), 1), document.removeEventListener("scroll", or.scrollHandler);
  },
  update: function() {
    return or.scrollSpyContainers.forEach(function(t) {
      return or.scrollHandler(t);
    });
  }
};
Fc.default = or;
var gl = {}, Uc = {};
Object.defineProperty(Uc, "__esModule", {
  value: !0
});
var _be = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, a = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", a) : history.replaceState(history.state, "", a);
}, Lbe = function() {
  return window.location.hash.replace(/^#/, "");
}, Pbe = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, Sbe = function(t) {
  return getComputedStyle(t).position !== "static";
}, vy = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, Dbe = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Sbe(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = vy(n, o), a = i.offsetTop, s = i.offsetParent;
      if (s !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return a;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return vy(n, l).offsetTop - vy(t, l).offsetTop;
};
Uc.default = {
  updateHash: _be,
  getHash: Lbe,
  filterElementInContainer: Pbe,
  scrollOffset: Dbe
};
var rm = {}, kx = {};
Object.defineProperty(kx, "__esModule", {
  value: !0
});
kx.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var _x = {};
Object.defineProperty(_x, "__esModule", {
  value: !0
});
var Mbe = zc, Tbe = ["mousedown", "wheel", "touchmove", "keydown"];
_x.default = {
  subscribe: function(t) {
    return typeof document < "u" && Tbe.forEach(function(n) {
      return (0, Mbe.addPassiveEventListener)(document, n, t);
    });
  }
};
var $c = {};
Object.defineProperty($c, "__esModule", {
  value: !0
});
var y0 = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      y0.registered[t] = n;
    },
    remove: function(t) {
      y0.registered[t] = null;
    }
  }
};
$c.default = y0;
Object.defineProperty(rm, "__esModule", {
  value: !0
});
var jbe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Abe = Uc;
om(Abe);
var Bbe = kx, CA = om(Bbe), Rbe = _x, Ibe = om(Rbe), Nbe = $c, Xo = om(Nbe);
function om(e) {
  return e && e.__esModule ? e : { default: e };
}
var B3 = function(t) {
  return CA.default[t.smooth] || CA.default.defaultEasing;
}, Fbe = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, zbe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, b0 = function() {
  return zbe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), R3 = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, I3 = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, N3 = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, Ube = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, $be = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, Wbe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Xo.default.registered.end && Xo.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    b0.call(window, i);
    return;
  }
  Xo.default.registered.end && Xo.default.registered.end(o.to, o.target, o.currentPosition);
}, Lx = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, Wc = function(t, n, r, o) {
  n.data = n.data || R3(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (Ibe.default.subscribe(i), Lx(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? I3(n) : N3(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    Xo.default.registered.end && Xo.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = Fbe(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var a = B3(n), s = Wbe.bind(null, a, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      Xo.default.registered.begin && Xo.default.registered.begin(n.data.to, n.data.target), b0.call(window, s);
    }, n.delay);
    return;
  }
  Xo.default.registered.begin && Xo.default.registered.begin(n.data.to, n.data.target), b0.call(window, s);
}, im = function(t) {
  return t = jbe({}, t), t.data = t.data || R3(), t.absolute = !0, t;
}, Vbe = function(t) {
  Wc(0, im(t));
}, Hbe = function(t, n) {
  Wc(t, im(n));
}, Gbe = function(t) {
  t = im(t), Lx(t), Wc(t.horizontal ? Ube(t) : $be(t), t);
}, qbe = function(t, n) {
  n = im(n), Lx(n);
  var r = n.horizontal ? I3(n) : N3(n);
  Wc(t + r, n);
};
rm.default = {
  animateTopScroll: Wc,
  getAnimationType: B3,
  scrollToTop: Vbe,
  scrollToBottom: Gbe,
  scrollTo: Hbe,
  scrollMore: qbe
};
Object.defineProperty(gl, "__esModule", {
  value: !0
});
var Zbe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Kbe = Uc, Xbe = Px(Kbe), Ybe = rm, Jbe = Px(Ybe), Qbe = $c, yd = Px(Qbe);
function Px(e) {
  return e && e.__esModule ? e : { default: e };
}
var bd = {}, xA = void 0;
gl.default = {
  unmount: function() {
    bd = {};
  },
  register: function(t, n) {
    bd[t] = n;
  },
  unregister: function(t) {
    delete bd[t];
  },
  get: function(t) {
    return bd[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return xA = t;
  },
  getActiveLink: function() {
    return xA;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = Zbe({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, a = void 0;
    o ? a = document.getElementById(o) : i && i.nodeType ? a = i : a = document, n.absolute = !0;
    var s = n.horizontal, l = Xbe.default.scrollOffset(a, r, s) + (n.offset || 0);
    if (!n.smooth) {
      yd.default.registered.begin && yd.default.registered.begin(t, r), a === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : a.scrollTop = l, yd.default.registered.end && yd.default.registered.end(t, r);
      return;
    }
    Jbe.default.animateTopScroll(l, n, t, r);
  }
};
var w0 = { exports: {} }, wd = { exports: {} }, cn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var EA;
function e0e() {
  if (EA) return cn;
  EA = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function S(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(y) {
    return S(y) === u;
  }
  return cn.AsyncMode = l, cn.ConcurrentMode = u, cn.ContextConsumer = s, cn.ContextProvider = a, cn.Element = t, cn.ForwardRef = c, cn.Fragment = r, cn.Lazy = f, cn.Memo = g, cn.Portal = n, cn.Profiler = i, cn.StrictMode = o, cn.Suspense = p, cn.isAsyncMode = function(y) {
    return x(y) || S(y) === l;
  }, cn.isConcurrentMode = x, cn.isContextConsumer = function(y) {
    return S(y) === s;
  }, cn.isContextProvider = function(y) {
    return S(y) === a;
  }, cn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, cn.isForwardRef = function(y) {
    return S(y) === c;
  }, cn.isFragment = function(y) {
    return S(y) === r;
  }, cn.isLazy = function(y) {
    return S(y) === f;
  }, cn.isMemo = function(y) {
    return S(y) === g;
  }, cn.isPortal = function(y) {
    return S(y) === n;
  }, cn.isProfiler = function(y) {
    return S(y) === i;
  }, cn.isStrictMode = function(y) {
    return S(y) === o;
  }, cn.isSuspense = function(y) {
    return S(y) === p;
  }, cn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === g || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === h || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, cn.typeOf = S, cn;
}
var pn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OA;
function t0e() {
  return OA || (OA = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function S(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === g || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === h || N.$$typeof === E || N.$$typeof === w || N.$$typeof === m);
    }
    function x(N) {
      if (typeof N == "object" && N !== null) {
        var le = N.$$typeof;
        switch (le) {
          case t:
            var ye = N.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var y = l, C = u, P = s, F = a, _ = t, I = c, B = r, $ = f, V = g, z = n, H = i, X = o, J = p, te = !1;
    function ee(N) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), L(N) || x(N) === l;
    }
    function L(N) {
      return x(N) === u;
    }
    function T(N) {
      return x(N) === s;
    }
    function W(N) {
      return x(N) === a;
    }
    function D(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function G(N) {
      return x(N) === c;
    }
    function O(N) {
      return x(N) === r;
    }
    function M(N) {
      return x(N) === f;
    }
    function U(N) {
      return x(N) === g;
    }
    function j(N) {
      return x(N) === n;
    }
    function Z(N) {
      return x(N) === i;
    }
    function A(N) {
      return x(N) === o;
    }
    function Q(N) {
      return x(N) === p;
    }
    pn.AsyncMode = y, pn.ConcurrentMode = C, pn.ContextConsumer = P, pn.ContextProvider = F, pn.Element = _, pn.ForwardRef = I, pn.Fragment = B, pn.Lazy = $, pn.Memo = V, pn.Portal = z, pn.Profiler = H, pn.StrictMode = X, pn.Suspense = J, pn.isAsyncMode = ee, pn.isConcurrentMode = L, pn.isContextConsumer = T, pn.isContextProvider = W, pn.isElement = D, pn.isForwardRef = G, pn.isFragment = O, pn.isLazy = M, pn.isMemo = U, pn.isPortal = j, pn.isProfiler = Z, pn.isStrictMode = A, pn.isSuspense = Q, pn.isValidElementType = S, pn.typeOf = x;
  }()), pn;
}
var kA;
function F3() {
  return kA || (kA = 1, process.env.NODE_ENV === "production" ? wd.exports = e0e() : wd.exports = t0e()), wd.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var yy, _A;
function n0e() {
  if (_A) return yy;
  _A = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return yy = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, yy;
}
var by, LA;
function Sx() {
  if (LA) return by;
  LA = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return by = e, by;
}
var wy, PA;
function z3() {
  return PA || (PA = 1, wy = Function.call.bind(Object.prototype.hasOwnProperty)), wy;
}
var Cy, SA;
function r0e() {
  if (SA) return Cy;
  SA = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Sx(), n = {}, r = z3();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Cy = o, Cy;
}
var xy, DA;
function o0e() {
  if (DA) return xy;
  DA = 1;
  var e = F3(), t = n0e(), n = Sx(), r = z3(), o = r0e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return xy = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(L) {
      var T = L && (u && L[u] || L[c]);
      if (typeof T == "function")
        return T;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: S,
      element: x(),
      elementType: y(),
      instanceOf: C,
      node: I(),
      objectOf: F,
      oneOf: P,
      oneOfType: _,
      shape: $,
      exact: V
    };
    function f(L, T) {
      return L === T ? L !== 0 || 1 / L === 1 / T : L !== L && T !== T;
    }
    function m(L, T) {
      this.message = L, this.data = T && typeof T == "object" ? T : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function h(L) {
      if (process.env.NODE_ENV !== "production")
        var T = {}, W = 0;
      function D(O, M, U, j, Z, A, Q) {
        if (j = j || d, A = A || U, Q !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = j + ":" + U;
            !T[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            W < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), T[le] = !0, W++);
          }
        }
        return M[U] == null ? O ? M[U] === null ? new m("The " + Z + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new m("The " + Z + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : L(M, U, j, Z, A);
      }
      var G = D.bind(null, !1);
      return G.isRequired = D.bind(null, !0), G;
    }
    function E(L) {
      function T(W, D, G, O, M, U) {
        var j = W[D], Z = X(j);
        if (Z !== L) {
          var A = J(j);
          return new m(
            "Invalid " + O + " `" + M + "` of type " + ("`" + A + "` supplied to `" + G + "`, expected ") + ("`" + L + "`."),
            { expectedType: L }
          );
        }
        return null;
      }
      return h(T);
    }
    function w() {
      return h(a);
    }
    function S(L) {
      function T(W, D, G, O, M) {
        if (typeof L != "function")
          return new m("Property `" + M + "` of component `" + G + "` has invalid PropType notation inside arrayOf.");
        var U = W[D];
        if (!Array.isArray(U)) {
          var j = X(U);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an array."));
        }
        for (var Z = 0; Z < U.length; Z++) {
          var A = L(U, Z, G, O, M + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return h(T);
    }
    function x() {
      function L(T, W, D, G, O) {
        var M = T[W];
        if (!s(M)) {
          var U = X(M);
          return new m("Invalid " + G + " `" + O + "` of type " + ("`" + U + "` supplied to `" + D + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(L);
    }
    function y() {
      function L(T, W, D, G, O) {
        var M = T[W];
        if (!e.isValidElementType(M)) {
          var U = X(M);
          return new m("Invalid " + G + " `" + O + "` of type " + ("`" + U + "` supplied to `" + D + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(L);
    }
    function C(L) {
      function T(W, D, G, O, M) {
        if (!(W[D] instanceof L)) {
          var U = L.name || d, j = ee(W[D]);
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return h(T);
    }
    function P(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function T(W, D, G, O, M) {
        for (var U = W[D], j = 0; j < L.length; j++)
          if (f(U, L[j]))
            return null;
        var Z = JSON.stringify(L, function(Q, N) {
          var le = J(N);
          return le === "symbol" ? String(N) : N;
        });
        return new m("Invalid " + O + " `" + M + "` of value `" + String(U) + "` " + ("supplied to `" + G + "`, expected one of " + Z + "."));
      }
      return h(T);
    }
    function F(L) {
      function T(W, D, G, O, M) {
        if (typeof L != "function")
          return new m("Property `" + M + "` of component `" + G + "` has invalid PropType notation inside objectOf.");
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an object."));
        for (var Z in U)
          if (r(U, Z)) {
            var A = L(U, Z, G, O, M + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return h(T);
    }
    function _(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var T = 0; T < L.length; T++) {
        var W = L[T];
        if (typeof W != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(W) + " at index " + T + "."
          ), a;
      }
      function D(G, O, M, U, j) {
        for (var Z = [], A = 0; A < L.length; A++) {
          var Q = L[A], N = Q(G, O, M, U, j, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && Z.push(N.data.expectedType);
        }
        var le = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + j + "` supplied to " + ("`" + M + "`" + le + "."));
      }
      return h(D);
    }
    function I() {
      function L(T, W, D, G, O) {
        return z(T[W]) ? null : new m("Invalid " + G + " `" + O + "` supplied to " + ("`" + D + "`, expected a ReactNode."));
      }
      return h(L);
    }
    function B(L, T, W, D, G) {
      return new m(
        (L || "React class") + ": " + T + " type `" + W + "." + D + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + G + "`."
      );
    }
    function $(L) {
      function T(W, D, G, O, M) {
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        for (var Z in L) {
          var A = L[Z];
          if (typeof A != "function")
            return B(G, O, M, Z, J(A));
          var Q = A(U, Z, G, O, M + "." + Z, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(T);
    }
    function V(L) {
      function T(W, D, G, O, M) {
        var U = W[D], j = X(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + M + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        var Z = t({}, W[D], L);
        for (var A in Z) {
          var Q = L[A];
          if (r(L, A) && typeof Q != "function")
            return B(G, O, M, A, J(Q));
          if (!Q)
            return new m(
              "Invalid " + O + " `" + M + "` key `" + A + "` supplied to `" + G + "`.\nBad object: " + JSON.stringify(W[D], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(L), null, "  ")
            );
          var N = Q(U, A, G, O, M + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return h(T);
    }
    function z(L) {
      switch (typeof L) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !L;
        case "object":
          if (Array.isArray(L))
            return L.every(z);
          if (L === null || s(L))
            return !0;
          var T = p(L);
          if (T) {
            var W = T.call(L), D;
            if (T !== L.entries) {
              for (; !(D = W.next()).done; )
                if (!z(D.value))
                  return !1;
            } else
              for (; !(D = W.next()).done; ) {
                var G = D.value;
                if (G && !z(G[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function H(L, T) {
      return L === "symbol" ? !0 : T ? T["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && T instanceof Symbol : !1;
    }
    function X(L) {
      var T = typeof L;
      return Array.isArray(L) ? "array" : L instanceof RegExp ? "object" : H(T, L) ? "symbol" : T;
    }
    function J(L) {
      if (typeof L > "u" || L === null)
        return "" + L;
      var T = X(L);
      if (T === "object") {
        if (L instanceof Date)
          return "date";
        if (L instanceof RegExp)
          return "regexp";
      }
      return T;
    }
    function te(L) {
      var T = J(L);
      switch (T) {
        case "array":
        case "object":
          return "an " + T;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + T;
        default:
          return T;
      }
    }
    function ee(L) {
      return !L.constructor || !L.constructor.name ? d : L.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, xy;
}
var Ey, MA;
function i0e() {
  if (MA) return Ey;
  MA = 1;
  var e = Sx();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Ey = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Ey;
}
if (process.env.NODE_ENV !== "production") {
  var s0e = F3(), a0e = !0;
  w0.exports = o0e()(s0e.isElement, a0e);
} else
  w0.exports = i0e()();
var sm = w0.exports, am = {};
Object.defineProperty(am, "__esModule", {
  value: !0
});
var l0e = Uc, Oy = u0e(l0e);
function u0e(e) {
  return e && e.__esModule ? e : { default: e };
}
var c0e = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return Oy.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && Oy.default.getHash() !== t && Oy.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
am.default = c0e;
Object.defineProperty(Nc, "__esModule", {
  value: !0
});
var Cd = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, p0e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), d0e = Oe, TA = Vc(d0e), f0e = Fc, xd = Vc(f0e), h0e = gl, g0e = Vc(h0e), m0e = sm, Jn = Vc(m0e), v0e = am, Yi = Vc(v0e);
function Vc(e) {
  return e && e.__esModule ? e : { default: e };
}
function y0e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function b0e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function w0e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var jA = {
  to: Jn.default.string.isRequired,
  containerId: Jn.default.string,
  container: Jn.default.object,
  activeClass: Jn.default.string,
  activeStyle: Jn.default.object,
  spy: Jn.default.bool,
  horizontal: Jn.default.bool,
  smooth: Jn.default.oneOfType([Jn.default.bool, Jn.default.string]),
  offset: Jn.default.number,
  delay: Jn.default.number,
  isDynamic: Jn.default.bool,
  onClick: Jn.default.func,
  duration: Jn.default.oneOfType([Jn.default.number, Jn.default.func]),
  absolute: Jn.default.bool,
  onSetActive: Jn.default.func,
  onSetInactive: Jn.default.func,
  ignoreCancelEvents: Jn.default.bool,
  hashSpy: Jn.default.bool,
  saveHashHistory: Jn.default.bool,
  spyThrottle: Jn.default.number
};
Nc.default = function(e, t) {
  var n = t || g0e.default, r = function(i) {
    w0e(a, i);
    function a(s) {
      y0e(this, a);
      var l = b0e(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return p0e(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          if (!xd.default.isMounted(l)) {
            var u = xd.default.mount(l, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(u);
          }
          this.props.hashSpy && (Yi.default.isMounted() || Yi.default.mount(n), Yi.default.mapContainer(this.props.to, l)), xd.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        xd.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(l) {
          return l();
        });
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = Cd({}, this.props.style, this.props.activeStyle) : u = Cd({}, this.props.style);
        var c = Cd({}, this.props);
        for (var p in jA)
          c.hasOwnProperty(p) && delete c[p];
        return c.className = l, c.style = u, c.onClick = this.handleClick, TA.default.createElement(e, c);
      }
    }]), a;
  }(TA.default.PureComponent), o = function() {
    var a = this;
    this.scrollTo = function(s, l) {
      n.scrollTo(s, Cd({}, a.state, l));
    }, this.handleClick = function(s) {
      a.props.onClick && a.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), a.scrollTo(a.props.to, a.props);
    }, this.spyHandler = function(s, l) {
      var u = a.getScrollSpyContainer();
      if (!(Yi.default.isMounted() && !Yi.default.isInitialized())) {
        var c = a.props.horizontal, p = a.props.to, d = null, g = void 0, f = void 0;
        if (c) {
          var m = 0, h = 0, E = 0;
          if (u.getBoundingClientRect) {
            var w = u.getBoundingClientRect();
            E = w.left;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var S = d.getBoundingClientRect();
            m = S.left - E + s, h = m + S.width;
          }
          var x = s - a.props.offset;
          g = x >= Math.floor(m) && x < Math.floor(h), f = x < Math.floor(m) || x >= Math.floor(h);
        } else {
          var y = 0, C = 0, P = 0;
          if (u.getBoundingClientRect) {
            var F = u.getBoundingClientRect();
            P = F.top;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var _ = d.getBoundingClientRect();
            y = _.top - P + l, C = y + _.height;
          }
          var I = l - a.props.offset;
          g = I >= Math.floor(y) && I < Math.floor(C), f = I < Math.floor(y) || I >= Math.floor(C);
        }
        var B = n.getActiveLink();
        if (f) {
          if (p === B && n.setActiveLink(void 0), a.props.hashSpy && Yi.default.getHash() === p) {
            var $ = a.props.saveHashHistory, V = $ === void 0 ? !1 : $;
            Yi.default.changeHash("", V);
          }
          a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive(p, d));
        }
        if (g && (B !== p || a.state.active === !1)) {
          n.setActiveLink(p);
          var z = a.props.saveHashHistory, H = z === void 0 ? !1 : z;
          a.props.hashSpy && Yi.default.changeHash(p, H), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(p, d));
        }
      }
    };
  };
  return r.propTypes = jA, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Ox, "__esModule", {
  value: !0
});
var C0e = Oe, AA = U3(C0e), x0e = Nc, E0e = U3(x0e);
function U3(e) {
  return e && e.__esModule ? e : { default: e };
}
function O0e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function BA(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function k0e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var _0e = function(e) {
  k0e(t, e);
  function t() {
    var n, r, o, i;
    O0e(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = BA(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return AA.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), BA(o, i);
  }
  return t;
}(AA.default.Component);
Ox.default = (0, E0e.default)(_0e);
var Dx = {};
Object.defineProperty(Dx, "__esModule", {
  value: !0
});
var L0e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), P0e = Oe, RA = $3(P0e), S0e = Nc, D0e = $3(S0e);
function $3(e) {
  return e && e.__esModule ? e : { default: e };
}
function M0e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function T0e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function j0e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var A0e = function(e) {
  j0e(t, e);
  function t() {
    return M0e(this, t), T0e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return L0e(t, [{
    key: "render",
    value: function() {
      return RA.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(RA.default.Component);
Dx.default = (0, D0e.default)(A0e);
var Mx = {}, lm = {};
Object.defineProperty(lm, "__esModule", {
  value: !0
});
var B0e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, R0e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), I0e = Oe, IA = um(I0e), N0e = tl;
um(N0e);
var F0e = gl, NA = um(F0e), z0e = sm, FA = um(z0e);
function um(e) {
  return e && e.__esModule ? e : { default: e };
}
function U0e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function $0e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function W0e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
lm.default = function(e) {
  var t = function(n) {
    W0e(r, n);
    function r(o) {
      U0e(this, r);
      var i = $0e(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return R0e(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        NA.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        NA.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return IA.default.createElement(e, B0e({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(IA.default.Component);
  return t.propTypes = {
    name: FA.default.string,
    id: FA.default.string
  }, t;
};
Object.defineProperty(Mx, "__esModule", {
  value: !0
});
var zA = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, V0e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), H0e = Oe, UA = Tx(H0e), G0e = lm, q0e = Tx(G0e), Z0e = sm, $A = Tx(Z0e);
function Tx(e) {
  return e && e.__esModule ? e : { default: e };
}
function K0e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function X0e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Y0e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var W3 = function(e) {
  Y0e(t, e);
  function t() {
    return K0e(this, t), X0e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return V0e(t, [{
    key: "render",
    value: function() {
      var r = this, o = zA({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, UA.default.createElement(
        "div",
        zA({}, o, { ref: function(a) {
          r.props.parentBindings.domNode = a;
        } }),
        this.props.children
      );
    }
  }]), t;
}(UA.default.Component);
W3.propTypes = {
  name: $A.default.string,
  id: $A.default.string
};
Mx.default = (0, q0e.default)(W3);
var ky = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, WA = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function VA(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function HA(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function GA(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Ed = Oe, Hs = Fc, _y = gl, ur = sm, Ji = am, qA = {
  to: ur.string.isRequired,
  containerId: ur.string,
  container: ur.object,
  activeClass: ur.string,
  spy: ur.bool,
  smooth: ur.oneOfType([ur.bool, ur.string]),
  offset: ur.number,
  delay: ur.number,
  isDynamic: ur.bool,
  onClick: ur.func,
  duration: ur.oneOfType([ur.number, ur.func]),
  absolute: ur.bool,
  onSetActive: ur.func,
  onSetInactive: ur.func,
  ignoreCancelEvents: ur.bool,
  hashSpy: ur.bool,
  spyThrottle: ur.number
}, J0e = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || _y, o = function(a) {
      GA(s, a);
      function s(l) {
        VA(this, s);
        var u = HA(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return WA(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            Hs.isMounted(u) || Hs.mount(u, this.props.spyThrottle), this.props.hashSpy && (Ji.isMounted() || Ji.mount(r), Ji.mapContainer(this.props.to, u)), this.props.spy && Hs.addStateHandler(this.stateHandler), Hs.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Hs.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = ky({}, this.props);
          for (var p in qA)
            c.hasOwnProperty(p) && delete c[p];
          return c.className = u, c.onClick = this.handleClick, Ed.createElement(t, c);
        }
      }]), s;
    }(Ed.Component), i = function() {
      var s = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, ky({}, s.state, u));
      }, this.handleClick = function(l) {
        s.props.onClick && s.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), s.scrollTo(s.props.to, s.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== s.props.to && (s.state !== null && s.state.active && s.props.onSetInactive && s.props.onSetInactive(), s.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = s.getScrollSpyContainer();
        if (!(Ji.isMounted() && !Ji.isInitialized())) {
          var c = s.props.to, p = null, d = 0, g = 0, f = 0;
          if (u.getBoundingClientRect) {
            var m = u.getBoundingClientRect();
            f = m.top;
          }
          if (!p || s.props.isDynamic) {
            if (p = r.get(c), !p)
              return;
            var h = p.getBoundingClientRect();
            d = h.top - f + l, g = d + h.height;
          }
          var E = l - s.props.offset, w = E >= Math.floor(d) && E < Math.floor(g), S = E < Math.floor(d) || E >= Math.floor(g), x = r.getActiveLink();
          if (S)
            return c === x && r.setActiveLink(void 0), s.props.hashSpy && Ji.getHash() === c && Ji.changeHash(), s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive()), Hs.updateStates();
          if (w && x !== c)
            return r.setActiveLink(c), s.props.hashSpy && Ji.changeHash(c), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(c)), Hs.updateStates();
        }
      };
    };
    return o.propTypes = qA, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      GA(o, r);
      function o(i) {
        VA(this, o);
        var a = HA(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return a.childBindings = {
          domNode: null
        }, a;
      }
      return WA(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(a) {
          this.props.name !== a.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          _y.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(a) {
          _y.register(a, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Ed.createElement(t, ky({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(Ed.Component);
    return n.propTypes = {
      name: ur.string,
      id: ur.string
    }, n;
  }
}, Q0e = J0e;
Object.defineProperty(yr, "__esModule", {
  value: !0
});
yr.Helpers = yr.ScrollElement = yr.ScrollLink = e$ = yr.animateScroll = yr.scrollSpy = yr.Events = yr.scroller = yr.Element = yr.Button = yr.Link = void 0;
var ewe = Ox, V3 = ui(ewe), twe = Dx, H3 = ui(twe), nwe = Mx, G3 = ui(nwe), rwe = gl, q3 = ui(rwe), owe = $c, Z3 = ui(owe), iwe = Fc, K3 = ui(iwe), swe = rm, X3 = ui(swe), awe = Nc, Y3 = ui(awe), lwe = lm, J3 = ui(lwe), uwe = Q0e, Q3 = ui(uwe);
function ui(e) {
  return e && e.__esModule ? e : { default: e };
}
yr.Link = V3.default;
yr.Button = H3.default;
yr.Element = G3.default;
yr.scroller = q3.default;
yr.Events = Z3.default;
yr.scrollSpy = K3.default;
var e$ = yr.animateScroll = X3.default;
yr.ScrollLink = Y3.default;
yr.ScrollElement = J3.default;
yr.Helpers = Q3.default;
yr.default = { Link: V3.default, Button: H3.default, Element: G3.default, scroller: q3.default, Events: Z3.default, scrollSpy: K3.default, animateScroll: X3.default, ScrollLink: Y3.default, ScrollElement: J3.default, Helpers: Q3.default };
const jx = qe({}), t$ = qe({});
function cwe() {
  const e = Ee(t$);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function ZA(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function BEe() {
  const e = S0(), { closeModal: t, closeAll: n, modalIsOpen: r } = Ee(jx), { showToast: o } = cwe(), { getParam: i } = T3(), { pathname: a } = M0(), s = yR(), l = i("closeAllModals"), u = D0();
  v(() => {
    var d, g;
    const c = ((g = (d = u[0]) == null ? void 0 : d.data) == null ? void 0 : g.closeModalKey) || "", p = r(c);
    c && p && t(c);
  }, [u]), v(() => {
    l === "true" && (n(), s(a));
  }, [l]), v(() => {
    const c = e == null ? void 0 : e.closeModalKey;
    c && t(c);
  }, [e]), v(() => {
    const c = e == null ? void 0 : e.closeAllModals;
    typeof c == "boolean" && c && n();
  }, [e]), v(() => {
    const c = e == null ? void 0 : e.toast, p = e == null ? void 0 : e.message;
    ZA(c) && o(c), !ZA(c) && p && o({ message: p, type: "danger" });
  }, [e]), v(() => {
    var c, p;
    if (typeof ((c = e == null ? void 0 : e.data) == null ? void 0 : c.scrollTo) == "string") {
      const d = document.getElementById((p = e == null ? void 0 : e.data) == null ? void 0 : p.scrollTo);
      d && e$.scrollTo(d.offsetTop - 200);
    }
  }, [e]);
}
const n$ = qe({});
function REe(e) {
  const t = Ee(n$);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, a = r(e), s = n(e);
    return { drawerIsOpen: a, drawerData: s, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function pwe() {
  return () => {
  };
}
function dwe() {
  return T$(
    pwe,
    () => !0,
    () => !1
  );
}
function IEe(e) {
  const t = Ee(jx);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, a = r(e), s = n(e);
    return { modalIsOpen: a, modalData: s, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function NEe(e) {
  const { children: t = !1 } = e, [n, r] = k([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function a(l, u) {
    const c = o(l);
    r(c ? (p) => [...p.filter((g) => g.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function s(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ q.jsx(
    n$.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: a, closeDrawer: s },
      children: t
    }
  );
}
function lc(e) {
  "@babel/helpers - typeof";
  return lc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, lc(e);
}
function fwe(e, t) {
  if (lc(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (lc(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function hwe(e) {
  var t = fwe(e, "string");
  return lc(t) == "symbol" ? t : t + "";
}
function de(e, t, n) {
  return (t = hwe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function r$(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ly, KA;
function gwe() {
  if (KA) return Ly;
  KA = 1;
  var e = process.env.NODE_ENV, t = function(r, o, i, a, s, l, u, c) {
    if (e !== "production" && o === void 0)
      throw new Error("invariant requires an error message argument");
    if (!r) {
      var p;
      if (o === void 0)
        p = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [i, a, s, l, u, c], g = 0;
        p = new Error(o.replace(/%s/g, function() {
          return d[g++];
        })), p.name = "Invariant Violation";
      }
      throw p.framesToPop = 1, p;
    }
  };
  return Ly = t, Ly;
}
var mwe = gwe(), _r = /* @__PURE__ */ r$(mwe), ht = qe(null);
function vwe() {
  _r(!!Ee, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Ee(ht);
  return _r(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function ywe(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function bwe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function wwe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return bwe(e, i), o;
}
function Cwe(e, t, n) {
  var r = ywe(n, function(i, a, s) {
    return typeof e[s] == "function" && i.push(google.maps.event.addListener(t, a, e[s])), i;
  }, []);
  return r;
}
function xwe(e) {
  google.maps.event.removeListener(e);
}
function Bt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(xwe);
}
function St(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = Cwe(o, i, n);
  return wwe(t, r, o, i), a;
}
var XA = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, YA = {
  extraMapTypes(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center(e, t) {
    e.setCenter(t);
  },
  clickableIcons(e, t) {
    e.setClickableIcons(t);
  },
  heading(e, t) {
    e.setHeading(t);
  },
  mapTypeId(e, t) {
    e.setMapTypeId(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  streetView(e, t) {
    e.setStreetView(t);
  },
  tilt(e, t) {
    e.setTilt(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
function Ewe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: h,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: S,
    onUnmount: x
  } = e, [y, C] = k(null), P = Qe(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null), [A, Q] = k(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), v(() => {
    y && l && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && m && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && g && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(y, "mouseout", g)));
  }, [g]), v(() => {
    y && f && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && h && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && E && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), v(() => {
    y && s && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(y, "click", s)));
  }, [s]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), v(() => {
    var N = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(N), N !== null && S && S(N), () => {
      N !== null && x && x(N);
    };
  }, []), q.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: q.jsx(ht.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
ke(Ewe);
let Owe = class extends be {
  constructor() {
    super(...arguments), de(this, "state", {
      map: null
    }), de(this, "registeredEvents", []), de(this, "mapRef", null), de(this, "getInstance", () => this.mapRef === null ? null : new google.maps.Map(this.mapRef, this.props.options)), de(this, "panTo", (t) => {
      var n = this.getInstance();
      n && n.panTo(t);
    }), de(this, "setMapCallback", () => {
      this.state.map !== null && this.props.onLoad && this.props.onLoad(this.state.map);
    }), de(this, "getRef", (t) => {
      this.mapRef = t;
    });
  }
  componentDidMount() {
    var t = this.getInstance();
    this.registeredEvents = St({
      updaterMap: YA,
      eventMap: XA,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        map: t
      };
    }, this.setMapCallback);
  }
  componentDidUpdate(t) {
    this.state.map !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: YA,
      eventMap: XA,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.map
    }));
  }
  componentWillUnmount() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), Bt(this.registeredEvents));
  }
  render() {
    return q.jsx("div", {
      id: this.props.id,
      ref: this.getRef,
      style: this.props.mapContainerStyle,
      className: this.props.mapContainerClassName,
      children: q.jsx(ht.Provider, {
        value: this.state.map,
        children: this.state.map !== null ? this.props.children : null
      })
    });
  }
};
function JA(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function o$(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        JA(i, r, o, a, s, "next", l);
      }
      function s(l) {
        JA(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function i$(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return _r(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var ca = typeof document < "u";
function s$(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return ca ? new Promise(function(i, a) {
    var s = document.getElementById(n), l = window;
    if (s) {
      var u = s.getAttribute("data-state");
      if (s.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, p = s.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, s.onerror = function(g) {
          p && p(g), a(g);
        };
        return;
      } else
        s.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(f) {
      d.setAttribute("data-state", "error"), a(f);
    }, l.initMap = function() {
      d.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function QA(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function a$() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return QA(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return QA(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
var $l = !1;
function l$() {
  return q.jsx("div", {
    children: "Loading..."
  });
}
var C0 = {
  id: "script-loader",
  version: "weekly"
};
class u$ extends be {
  constructor() {
    super(...arguments), de(this, "check", null), de(this, "state", {
      loaded: !1
    }), de(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), de(this, "isCleaningUp", /* @__PURE__ */ o$(function* () {
      function t(n) {
        if (!$l)
          n();
        else if (ca)
          var r = window.setInterval(function() {
            $l || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), de(this, "cleanup", () => {
      $l = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(r) {
        return typeof r.src == "string" && r.src.includes("maps.googleapis");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(r) {
        return r.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(r) {
        return r.innerText !== void 0 && r.innerText.length > 0 && r.innerText.includes(".gm-");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    }), de(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && a$(), _r(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: i$(this.props)
      };
      s$(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), de(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (ca) {
      if (window.google && window.google.maps && !$l) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), ca && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (ca) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, $l = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return q.jsxs(q.Fragment, {
      children: [q.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || q.jsx(l$, {})]
    });
  }
}
de(u$, "defaultProps", C0);
function kwe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function Ax(e, t) {
  if (e == null) return {};
  var n, r, o = kwe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var eB;
function _we(e) {
  var {
    id: t = C0.id,
    version: n = C0.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = Qe(!1), [f, m] = k(!1), [h, E] = k(void 0);
  v(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), v(function() {
    ca && u && a$();
  }, [u]), v(function() {
    f && _r(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = i$({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!ca)
      return;
    function y() {
      g.current && (m(!0), eB = w);
    }
    if (window.google && window.google.maps && eB === w) {
      y();
      return;
    }
    s$({
      id: t,
      url: w,
      nonce: r
    }).then(y).catch(function(P) {
      g.current && E(P), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(P);
    });
  }, [t, w, r]);
  var S = Qe(void 0);
  return v(function() {
    S.current && l !== S.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), S.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var Lwe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], Pwe = q.jsx(l$, {});
function Swe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = Ax(e, Lwe), {
    isLoaded: s,
    loadError: l
  } = _we(a);
  return v(function() {
    s && typeof n == "function" && n();
  }, [s, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || Pwe;
}
ke(Swe);
var tB;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(tB || (tB = {}));
function nB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rB = {}, oB = {
  options(e, t) {
    e.setOptions(t);
  }
};
function Dwe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = Ee(ht), [i, a] = k(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var s = new google.maps.TrafficLayer(oh(oh({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ke(Dwe);
class Mwe extends be {
  constructor() {
    super(...arguments), de(this, "state", {
      trafficLayer: null
    }), de(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), de(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(oh(oh({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = St({
      updaterMap: oB,
      eventMap: rB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: oB,
      eventMap: rB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Bt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
de(Mwe, "contextType", ht);
function Twe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Ee(ht), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ke(Twe);
class jwe extends be {
  constructor() {
    super(...arguments), de(this, "state", {
      bicyclingLayer: null
    }), de(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
de(jwe, "contextType", ht);
function Awe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Ee(ht), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ke(Awe);
class Bwe extends be {
  constructor() {
    super(...arguments), de(this, "state", {
      transitLayer: null
    }), de(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
de(Bwe, "contextType", ht);
function iB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ih(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sB = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, aB = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Rwe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = Ee(ht), [d, g] = k(null), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), v(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), v(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    _r(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var I = new google.maps.drawing.DrawingManager(ih(ih({}, t), {}, {
      map: p
    }));
    return n && I.setDrawingMode(n), r && m(google.maps.event.addListener(I, "circlecomplete", r)), o && E(google.maps.event.addListener(I, "markercomplete", o)), i && S(google.maps.event.addListener(I, "overlaycomplete", i)), a && y(google.maps.event.addListener(I, "polygoncomplete", a)), s && P(google.maps.event.addListener(I, "polylinecomplete", s)), l && _(google.maps.event.addListener(I, "rectanglecomplete", l)), g(I), u && u(I), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ke(Rwe);
class Iwe extends be {
  constructor(t) {
    super(t), de(this, "registeredEvents", []), de(this, "state", {
      drawingManager: null
    }), de(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), _r(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(ih(ih({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = St({
      updaterMap: aB,
      eventMap: sB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: aB,
      eventMap: sB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Bt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
de(Iwe, "contextType", ht);
function lB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ga(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uB = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, cB = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, sh = {};
function Nwe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: h,
    onClick: E,
    onDblClick: w,
    onDrag: S,
    onDragEnd: x,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: _,
    onRightClick: I,
    onClickableChanged: B,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: H,
    onIconChanged: X,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: L,
    onZindexChanged: T,
    onLoad: W,
    onUnmount: D
  } = e, G = Ee(ht), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, N] = k(null), [le, ye] = k(null), [oe, Be] = k(null), [Ue, $e] = k(null), [Ie, Je] = k(null), [Ze, Me] = k(null), [Ye, nt] = k(null), [De, je] = k(null), [Ke, We] = k(null), [Fe, et] = k(null), [Re, Rt] = k(null), [rt, ot] = k(null), [at, Kt] = k(null), [lt, ut] = k(null), [tt, Xe] = k(null), [Xt, Yt] = k(null), [bt, Rn] = k(null), [wt, In] = k(null), [Ct, fn] = k(null);
  v(() => {
    O !== null && O.setMap(G);
  }, [G]), v(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), v(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), v(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), v(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), v(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), v(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), v(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), v(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), v(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), v(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), v(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), v(() => {
    O && h !== void 0 && O.setZIndex(h);
  }, [O, h]), v(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), v(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), v(() => {
    O && y && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(O, "dragstart", y)));
  }, [y]), v(() => {
    O && _ && (le !== null && google.maps.event.removeListener(le), ye(google.maps.event.addListener(O, "mousedown", _)));
  }, [_]), v(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Be(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), v(() => {
    O && P && (Ue !== null && google.maps.event.removeListener(Ue), $e(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), v(() => {
    O && F && (Ie !== null && google.maps.event.removeListener(Ie), Je(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), v(() => {
    O && I && (Ze !== null && google.maps.event.removeListener(Ze), Me(google.maps.event.addListener(O, "rightclick", I)));
  }, [I]), v(() => {
    O && E && (Ye !== null && google.maps.event.removeListener(Ye), nt(google.maps.event.addListener(O, "click", E)));
  }, [E]), v(() => {
    O && S && (De !== null && google.maps.event.removeListener(De), je(google.maps.event.addListener(O, "drag", S)));
  }, [S]), v(() => {
    O && B && (Ke !== null && google.maps.event.removeListener(Ke), We(google.maps.event.addListener(O, "clickable_changed", B)));
  }, [B]), v(() => {
    O && $ && (Fe !== null && google.maps.event.removeListener(Fe), et(google.maps.event.addListener(O, "cursor_changed", $)));
  }, [$]), v(() => {
    O && V && (Re !== null && google.maps.event.removeListener(Re), Rt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), v(() => {
    O && z && (rt !== null && google.maps.event.removeListener(rt), ot(google.maps.event.addListener(O, "draggable_changed", z)));
  }, [z]), v(() => {
    O && H && (at !== null && google.maps.event.removeListener(at), Kt(google.maps.event.addListener(O, "flat_changed", H)));
  }, [H]), v(() => {
    O && X && (lt !== null && google.maps.event.removeListener(lt), ut(google.maps.event.addListener(O, "icon_changed", X)));
  }, [X]), v(() => {
    O && J && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(O, "position_changed", J)));
  }, [J]), v(() => {
    O && te && (Xt !== null && google.maps.event.removeListener(Xt), Yt(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), v(() => {
    O && ee && (bt !== null && google.maps.event.removeListener(bt), Rn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), v(() => {
    O && L && (wt !== null && google.maps.event.removeListener(wt), In(google.maps.event.addListener(O, "visible_changed", L)));
  }, [L]), v(() => {
    O && T && (Ct !== null && google.maps.event.removeListener(Ct), fn(google.maps.event.addListener(O, "zindex_changed", T)));
  }, [T]), v(() => {
    var xt = Ga(Ga(Ga({}, n || sh), r ? sh : {
      map: G
    }), {}, {
      position: t
    }), re = new google.maps.Marker(xt);
    return r ? r.addMarker(re, !!o) : re.setMap(G), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof h == "number" && re.setZIndex(h), w && j(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), y && N(google.maps.event.addListener(re, "dragstart", y)), _ && ye(google.maps.event.addListener(re, "mousedown", _)), C && Be(google.maps.event.addListener(re, "mouseout", C)), P && $e(google.maps.event.addListener(re, "mouseover", P)), F && Je(google.maps.event.addListener(re, "mouseup", F)), I && Me(google.maps.event.addListener(re, "rightclick", I)), E && nt(google.maps.event.addListener(re, "click", E)), S && je(google.maps.event.addListener(re, "drag", S)), B && We(google.maps.event.addListener(re, "clickable_changed", B)), $ && et(google.maps.event.addListener(re, "cursor_changed", $)), V && Rt(google.maps.event.addListener(re, "animation_changed", V)), z && ot(google.maps.event.addListener(re, "draggable_changed", z)), H && Kt(google.maps.event.addListener(re, "flat_changed", H)), X && ut(google.maps.event.addListener(re, "icon_changed", X)), J && Xe(google.maps.event.addListener(re, "position_changed", J)), te && Yt(google.maps.event.addListener(re, "shape_changed", te)), ee && Rn(google.maps.event.addListener(re, "title_changed", ee)), L && In(google.maps.event.addListener(re, "visible_changed", L)), T && fn(google.maps.event.addListener(re, "zindex_changed", T)), M(re), W && W(re), () => {
      U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), Q !== null && google.maps.event.removeListener(Q), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), Ie !== null && google.maps.event.removeListener(Ie), Ze !== null && google.maps.event.removeListener(Ze), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Fe !== null && google.maps.event.removeListener(Fe), Re !== null && google.maps.event.removeListener(Re), rt !== null && google.maps.event.removeListener(rt), at !== null && google.maps.event.removeListener(at), lt !== null && google.maps.event.removeListener(lt), tt !== null && google.maps.event.removeListener(tt), bt !== null && google.maps.event.removeListener(bt), wt !== null && google.maps.event.removeListener(wt), Ct !== null && google.maps.event.removeListener(Ct), D && D(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var wr = Bn(() => i ? it.map(i, (xt) => {
    if (!ti(xt))
      return xt;
    var re = xt;
    return ni(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return q.jsx(q.Fragment, {
    children: wr
  }) || null;
}
ke(Nwe);
class c$ extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return o$(function* () {
      var n = Ga(Ga(Ga({}, t.props.options || sh), t.props.clusterer ? sh : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = St({
        updaterMap: cB,
        eventMap: uB,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: cB,
      eventMap: uB,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Bt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? it.map(this.props.children, (n) => {
      if (!ti(n))
        return n;
      var r = n;
      return ni(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
de(c$, "contextType", ht);
var Fwe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), zwe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Fwe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Uwe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var $we = 2e3, Wwe = 500, Vwe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Hwe = "png", Gwe = [53, 56, 66, 78, 90], qwe = "cluster", p$ = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Vwe, this.imageExtension = r.imageExtension || Hwe, this.imageSizes = r.imageSizes || Gwe, this.calculator = r.calculator || Uwe, this.batchSize = r.batchSize || $we, this.batchSizeIE = r.batchSizeIE || Wwe, this.clusterClass = r.clusterClass || qwe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new zwe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var a = i;
          this.prototype[a] = o.prototype[a];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function pB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zwe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bo = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, rn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Kwe = {};
function Xwe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: h,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: S,
    onClusteringEnd: x,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [_, I] = k(null), B = Ee(ht), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null);
  return v(() => {
    _ && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(_, Bo.onMouseOut, C)));
  }, [C]), v(() => {
    _ && y && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(_, Bo.onMouseOver, y)));
  }, [y]), v(() => {
    _ && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(_, Bo.onClick, w)));
  }, [w]), v(() => {
    _ && S && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(_, Bo.onClusteringBegin, S)));
  }, [S]), v(() => {
    _ && x && (X !== null && google.maps.event.removeListener(X), H(google.maps.event.addListener(_, Bo.onClusteringEnd, x)));
  }, [x]), v(() => {
    typeof r < "u" && _ !== null && rn.averageCenter(_, r);
  }, [_, r]), v(() => {
    typeof o < "u" && _ !== null && rn.batchSizeIE(_, o);
  }, [_, o]), v(() => {
    typeof i < "u" && _ !== null && rn.calculator(_, i);
  }, [_, i]), v(() => {
    typeof a < "u" && _ !== null && rn.clusterClass(_, a);
  }, [_, a]), v(() => {
    typeof s < "u" && _ !== null && rn.enableRetinaIcons(_, s);
  }, [_, s]), v(() => {
    typeof l < "u" && _ !== null && rn.gridSize(_, l);
  }, [_, l]), v(() => {
    typeof u < "u" && _ !== null && rn.ignoreHidden(_, u);
  }, [_, u]), v(() => {
    typeof c < "u" && _ !== null && rn.imageExtension(_, c);
  }, [_, c]), v(() => {
    typeof p < "u" && _ !== null && rn.imagePath(_, p);
  }, [_, p]), v(() => {
    typeof d < "u" && _ !== null && rn.imageSizes(_, d);
  }, [_, d]), v(() => {
    typeof g < "u" && _ !== null && rn.maxZoom(_, g);
  }, [_, g]), v(() => {
    typeof f < "u" && _ !== null && rn.minimumClusterSize(_, f);
  }, [_, f]), v(() => {
    typeof m < "u" && _ !== null && rn.styles(_, m);
  }, [_, m]), v(() => {
    typeof h < "u" && _ !== null && rn.title(_, h);
  }, [_, h]), v(() => {
    typeof E < "u" && _ !== null && rn.zoomOnClick(_, E);
  }, [_, E]), v(() => {
    if (B) {
      var W = Zwe({}, n || Kwe), D = new p$(B, [], W);
      return r && rn.averageCenter(D, r), o && rn.batchSizeIE(D, o), i && rn.calculator(D, i), a && rn.clusterClass(D, a), s && rn.enableRetinaIcons(D, s), l && rn.gridSize(D, l), u && rn.ignoreHidden(D, u), c && rn.imageExtension(D, c), p && rn.imagePath(D, p), d && rn.imageSizes(D, d), g && rn.maxZoom(D, g), f && rn.minimumClusterSize(D, f), m && rn.styles(D, m), h && rn.title(D, h), E && rn.zoomOnClick(D, E), C && ee(google.maps.event.addListener(D, Bo.onMouseOut, C)), y && T(google.maps.event.addListener(D, Bo.onMouseOver, y)), w && V(google.maps.event.addListener(D, Bo.onClick, w)), S && H(google.maps.event.addListener(D, Bo.onClusteringBegin, S)), x && J(google.maps.event.addListener(D, Bo.onClusteringEnd, x)), I(D), P && P(D), () => {
        te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), F && F(D);
      };
    }
  }, []), _ !== null && t(_) || null;
}
ke(Xwe);
class Ywe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      markerClusterer: null
    }), de(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new p$(this.context, [], this.props.options);
      this.registeredEvents = St({
        updaterMap: rn,
        eventMap: Bo,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: rn,
      eventMap: Bo,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Bt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
de(Ywe, "contextType", ht);
function dB(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var d$ = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(c) {
        c.returnValue = !1, c.preventDefault && c.preventDefault(), t.enableEventPropagation || dB(c);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, dB));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), h = m.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + g ? r = h.x + u - g : h.x + p + u + g > s && (r = h.x + p + u + g - s), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Jwe = ["position"], Qwe = ["position"];
function fB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ah(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hB = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, gB = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, eCe = {};
function tCe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = Ee(ht), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), I = Qe(null);
  return v(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (g) {
      var B = r || eCe, {
        position: $
      } = B, V = Ax(B, Jwe), z;
      $ && !($ instanceof google.maps.LatLng) && (z = new google.maps.LatLng($.lat, $.lng));
      var H = new d$(ah(ah({}, V), z ? {
        position: z
      } : {}));
      I.current = document.createElement("div"), m(H), a && E(google.maps.event.addListener(H, "closeclick", a)), s && S(google.maps.event.addListener(H, "domready", s)), l && y(google.maps.event.addListener(H, "content_changed", l)), u && P(google.maps.event.addListener(H, "position_changed", u)), c && _(google.maps.event.addListener(H, "zindex_changed", c)), H.setContent(I.current), n ? H.open(g, n) : H.getPosition() ? H.open(g) : _r(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(H);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), I.current ? br(it.only(t), I.current) : null;
}
ke(tCe);
class nCe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "containerElement", null), de(this, "state", {
      infoBox: null
    }), de(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : _r(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), de(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = Ax(t, Qwe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new d$(ah(ah({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = St({
      updaterMap: gB,
      eventMap: hB,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: gB,
      eventMap: hB,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Bt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? br(it.only(this.props.children), this.containerElement) : null;
  }
}
de(nCe, "contextType", ht);
var Py, mB;
function rCe() {
  return mB || (mB = 1, Py = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), Py;
}
var oCe = rCe(), vB = /* @__PURE__ */ r$(oCe), yB = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Sy = 1, Wl = 8;
class Bx {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Sy)
      throw new Error("Got v".concat(o, " data when expected v").concat(Sy, "."));
    var i = yB[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new Bx(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = yB.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Wl, t), this.coords = new this.ArrayType(this.data, Wl + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Wl + a + s + l), this.ids = new this.IndexArrayType(this.data, Wl, t), this.coords = new this.ArrayType(this.data, Wl + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Sy << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return x0(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var h = d + p >> 1, E = a[2 * h], w = a[2 * h + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          bB(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], h = i[2 * f + 1];
      bB(m, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= h) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= h) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function x0(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    f$(e, t, a, r, o, i), x0(e, t, n, r, a - 1, 1 - i), x0(e, t, n, a + 1, o, 1 - i);
  }
}
function f$(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      f$(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (Vl(e, t, r, n), t[2 * o + i] > g && Vl(e, t, r, o); f < m; ) {
      for (Vl(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? Vl(e, t, r, m) : (m++, Vl(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function Vl(e, t, n, r) {
  Dy(e, n, r), Dy(t, 2 * n, 2 * r), Dy(t, 2 * n + 1, 2 * r + 1);
}
function Dy(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function bB(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var iCe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, wB = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Gs = 2, cs = 3, My = 4, rs = 5, h$ = 6;
class sCe {
  constructor(t) {
    this.options = Object.assign(Object.create(iCe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = wB(Od(u)), d = wB(kd(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Od(r), kd(a), Od(i), kd(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + rs] > 1 ? CB(p, f, this.clusterProps) : this.points[p[f + cs]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + My] === t && p.push(a[g + rs] > 1 ? CB(a, g, this.clusterProps) : this.points[a[g + cs]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Bx(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + rs] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = g$(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + cs]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = Od(f), d = kd(m);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + cs] : E = this.points[n[l + cs]].id, E !== void 0 && (h.id = E), a.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Gs] <= n)) {
        l[p + Gs] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + rs], h = m;
        for (var E of f) {
          var w = E * c;
          l[w + Gs] > n && (h += l[w + rs]);
        }
        if (h > m && h >= a) {
          var S = d * m, x = g * m, y = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var _ = F * c;
            if (!(l[_ + Gs] <= n)) {
              l[_ + Gs] = n;
              var I = l[_ + rs];
              S += l[_] * I, x += l[_ + 1] * I, l[_ + My] = P, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, _)));
            }
          }
          l[p + My] = P, u.push(S / h, x / h, 1 / 0, P, -1, h), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (h > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Gs] <= n)) {
                l[V + Gs] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + rs] > 1) {
      var o = this.clusterProps[t[n + h$]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + cs]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function CB(e, t, n) {
  return {
    type: "Feature",
    id: e[t + cs],
    properties: g$(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [aCe(e[t]), lCe(e[t + 1])]
    }
  };
}
function g$(e, t, n) {
  var r = e[t + rs], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + h$], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + cs],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Od(e) {
  return e / 360 + 0.5;
}
function kd(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function aCe(e) {
  return (e - 0.5) * 360;
}
function lCe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function uCe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class wo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class E0 {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(wo.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => wo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (wo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class cCe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return pCe(n);
  }
}
var pCe = (e) => {
  var t = e.map((n) => new E0({
    position: wo.getPosition(n),
    markers: [n]
  }));
  return t;
};
class dCe extends cCe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = uCe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new sCe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!vB(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = wo.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !vB(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new E0({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new E0({
      markers: [i],
      position: wo.getPosition(i)
    });
  }
}
class fCe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class hCe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (wo.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function gCe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Rx {
  constructor() {
    gCe(Rx, google.maps.OverlayView);
  }
}
var xu;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(xu || (xu = {}));
var mCe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class vCe extends Rx {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new dCe(o),
      renderer: a = new hCe(),
      onClusterClick: s = mCe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (wo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, xu.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || wo.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => wo.setMap(l, null)));
      }
      google.maps.event.trigger(this, xu.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => wo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new fCe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => wo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, xu.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), wo.setMap(r.marker, n);
    });
  }
}
function xB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function EB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function yCe(e) {
  var t = vwe(), [n, r] = k(null);
  return v(() => {
    if (t && n === null) {
      var o = new vCe(EB(EB({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function bCe(e) {
  var {
    children: t,
    options: n
  } = e, r = yCe(n);
  return r !== null ? t(r) : null;
}
ke(bCe);
var OB = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, kB = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function wCe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = Ee(ht), [f, m] = k(null), [h, E] = k(null), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), I = Qe(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var B = new google.maps.InfoWindow(r);
    return m(B), I.current = document.createElement("div"), a && E(google.maps.event.addListener(B, "closeclick", a)), s && S(google.maps.event.addListener(B, "domready", s)), l && y(google.maps.event.addListener(B, "content_changed", l)), u && P(google.maps.event.addListener(B, "position_changed", u)), c && _(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(I.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(g, n) : B.getPosition() ? B.open(g) : _r(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(B), B.close();
    };
  }, []), I.current ? br(it.only(t), I.current) : null;
}
ke(wCe);
class CCe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "containerElement", null), de(this, "state", {
      infoWindow: null
    }), de(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : _r(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), de(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = St({
      updaterMap: kB,
      eventMap: OB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: kB,
      eventMap: OB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Bt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? br(it.only(this.props.children), this.containerElement) : null;
  }
}
de(CCe, "contextType", ht);
function _B(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _B(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _B(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var LB = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, PB = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, xCe = {};
function ECe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onLoad: E,
    onUnmount: w
  } = e, S = Ee(ht), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null);
  return v(() => {
    x !== null && x.setMap(S);
  }, [S]), v(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), v(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), v(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), v(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), v(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), v(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), v(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), v(() => {
    x && l && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), v(() => {
    x && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), v(() => {
    x && c && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), v(() => {
    x && p && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), v(() => {
    x && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), v(() => {
    x && g && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(x, "mouseup", g)));
  }, [g]), v(() => {
    x && f && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), v(() => {
    x && m && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), v(() => {
    x && h && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(x, "drag", h)));
  }, [h]), v(() => {
    var j = new google.maps.Polyline(lh(lh({}, t || xCe), {}, {
      map: S
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && P(google.maps.event.addListener(j, "dblclick", a)), s && _(google.maps.event.addListener(j, "dragend", s)), l && B(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && H(google.maps.event.addListener(j, "mousemove", c)), p && J(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), g && T(google.maps.event.addListener(j, "mouseup", g)), f && D(google.maps.event.addListener(j, "rightclick", f)), m && O(google.maps.event.addListener(j, "click", m)), h && U(google.maps.event.addListener(j, "drag", h)), y(j), E && E(j), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), w && w(j), j.setMap(null);
    };
  }, []), null;
}
ke(ECe);
class OCe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      polyline: null
    }), de(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(lh(lh({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = St({
      updaterMap: PB,
      eventMap: LB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: PB,
      eventMap: LB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Bt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
de(OCe, "contextType", ht);
function SB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function DB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var MB = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, TB = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function kCe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: E,
    onLoad: w,
    onUnmount: S,
    onEdit: x
  } = e, y = Ee(ht), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), v(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), v(() => {
    C && typeof l == "function" && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof g == "function" && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), v(() => {
    C && typeof f == "function" && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof m == "function" && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(() => {
    C && typeof h == "function" && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(C, "click", h)));
  }, [h]), v(() => {
    C && typeof E == "function" && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), v(() => {
    var A = new google.maps.Polygon(DB(DB({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && _(google.maps.event.addListener(A, "dblclick", s)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && H(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), g && T(google.maps.event.addListener(A, "mouseover", g)), f && D(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), h && U(google.maps.event.addListener(A, "click", h)), E && Z(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), M !== null && google.maps.event.removeListener(M), S && S(A), A.setMap(null);
    };
  }, []), null;
}
ke(kCe);
class _Ce extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = St({
      updaterMap: TB,
      eventMap: MB,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: TB,
      eventMap: MB,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Bt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
de(_Ce, "contextType", ht);
function jB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var AB = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, BB = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function LCe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: h,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: S
  } = e, x = Ee(ht), [y, C] = k(null), [P, F] = k(null), [_, I] = k(null), [B, $] = k(null), [V, z] = k(null), [H, X] = k(null), [J, te] = k(null), [ee, L] = k(null), [T, W] = k(null), [D, G] = k(null), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null);
  return v(() => {
    y !== null && y.setMap(x);
  }, [x]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), v(() => {
    y && s && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), v(() => {
    y && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), L(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && g && (T !== null && google.maps.event.removeListener(T), W(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), v(() => {
    y && f && (D !== null && google.maps.event.removeListener(D), G(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(y, "click", m)));
  }, [m]), v(() => {
    y && h && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(y, "drag", h)));
  }, [h]), v(() => {
    y && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), v(() => {
    var Q = new google.maps.Rectangle(uh(uh({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), a && F(google.maps.event.addListener(Q, "dblclick", a)), s && I(google.maps.event.addListener(Q, "dragend", s)), l && $(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && X(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && L(google.maps.event.addListener(Q, "mouseover", d)), g && W(google.maps.event.addListener(Q, "mouseup", g)), f && G(google.maps.event.addListener(Q, "rightclick", f)), m && M(google.maps.event.addListener(Q, "click", m)), h && j(google.maps.event.addListener(Q, "drag", h)), E && A(google.maps.event.addListener(Q, "bounds_changed", E)), C(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), _ !== null && google.maps.event.removeListener(_), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), T !== null && google.maps.event.removeListener(T), D !== null && google.maps.event.removeListener(D), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), S && S(Q), Q.setMap(null);
    };
  }, []), null;
}
ke(LCe);
class PCe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      rectangle: null
    }), de(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(uh(uh({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = St({
      updaterMap: BB,
      eventMap: AB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: BB,
      eventMap: AB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Bt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
de(PCe, "contextType", ht);
function RB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ch(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var IB = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, NB = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, SCe = {};
function DCe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: h,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: S,
    onLoad: x,
    onUnmount: y
  } = e, C = Ee(ht), [P, F] = k(null), [_, I] = k(null), [B, $] = k(null), [V, z] = k(null), [H, X] = k(null), [J, te] = k(null), [ee, L] = k(null), [T, W] = k(null), [D, G] = k(null), [O, M] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, N] = k(null), [le, ye] = k(null);
  return v(() => {
    P !== null && P.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), v(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), v(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), v(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), v(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), v(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), v(() => {
    P && s && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), v(() => {
    P && l && (B !== null && google.maps.event.removeListener(B), $(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), v(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), v(() => {
    P && c && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), v(() => {
    P && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), v(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), L(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), v(() => {
    P && g && (T !== null && google.maps.event.removeListener(T), W(google.maps.event.addListener(P, "mouseover", g)));
  }, [g]), v(() => {
    P && f && (D !== null && google.maps.event.removeListener(D), G(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), v(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), M(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), v(() => {
    P && h && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(P, "click", h)));
  }, [h]), v(() => {
    P && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), v(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), N(google.maps.event.addListener(P, "center_changed", w)));
  }, [h]), v(() => {
    P && S && (le !== null && google.maps.event.removeListener(le), ye(google.maps.event.addListener(P, "radius_changed", S)));
  }, [S]), v(() => {
    var oe = new google.maps.Circle(ch(ch({}, t || SCe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && I(google.maps.event.addListener(oe, "dblclick", s)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && L(google.maps.event.addListener(oe, "mouseout", d)), g && W(google.maps.event.addListener(oe, "mouseover", g)), f && G(google.maps.event.addListener(oe, "mouseup", f)), m && M(google.maps.event.addListener(oe, "rightclick", m)), h && j(google.maps.event.addListener(oe, "click", h)), E && A(google.maps.event.addListener(oe, "drag", E)), w && N(google.maps.event.addListener(oe, "center_changed", w)), S && ye(google.maps.event.addListener(oe, "radius_changed", S)), F(oe), x && x(oe), () => {
      _ !== null && google.maps.event.removeListener(_), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), T !== null && google.maps.event.removeListener(T), D !== null && google.maps.event.removeListener(D), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Q !== null && google.maps.event.removeListener(Q), le !== null && google.maps.event.removeListener(le), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
ke(DCe);
class MCe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      circle: null
    }), de(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(ch(ch({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = St({
      updaterMap: NB,
      eventMap: IB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: NB,
      eventMap: IB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Bt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
de(MCe, "contextType", ht);
function FB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ph(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zB = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, UB = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function TCe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: h
  } = e, E = Ee(ht), [w, S] = k(null), [x, y] = k(null), [C, P] = k(null), [F, _] = k(null), [I, B] = k(null), [$, V] = k(null), [z, H] = k(null), [X, J] = k(null), [te, ee] = k(null), [L, T] = k(null), [W, D] = k(null), [G, O] = k(null), [M, U] = k(null), [j, Z] = k(null);
  return v(() => {
    w !== null && w.setMap(E);
  }, [E]), v(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), _(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && a && (I !== null && google.maps.event.removeListener(I), B(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), v(() => {
    w && s && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), H(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (L !== null && google.maps.event.removeListener(L), T(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (G !== null && google.maps.event.removeListener(G), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && g && (M !== null && google.maps.event.removeListener(M), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), v(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (E !== null) {
      var A = new google.maps.Data(ph(ph({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && _(google.maps.event.addListener(A, "mousemove", i)), a && B(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && H(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && T(google.maps.event.addListener(A, "addfeature", c)), p && D(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && Z(google.maps.event.addListener(A, "setproperty", f)), S(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), I !== null && google.maps.event.removeListener(I), $ !== null && google.maps.event.removeListener($), z !== null && google.maps.event.removeListener(z), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), L !== null && google.maps.event.removeListener(L), W !== null && google.maps.event.removeListener(W), G !== null && google.maps.event.removeListener(G), M !== null && google.maps.event.removeListener(M), j !== null && google.maps.event.removeListener(j), h && h(w), w.setMap(null));
    };
  }, []), null;
}
ke(TCe);
class jCe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      data: null
    }), de(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(ph(ph({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = St({
        updaterMap: UB,
        eventMap: zB,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: UB,
      eventMap: zB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Bt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
de(jCe, "contextType", ht);
function $B(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function WB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $B(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $B(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var VB = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, HB = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class ACe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      kmlLayer: null
    }), de(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(WB(WB({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = St({
      updaterMap: HB,
      eventMap: VB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: HB,
      eventMap: VB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Bt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
de(ACe, "contextType", ht);
function m$(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function BCe(e, t) {
  return new t(e.lat, e.lng);
}
function RCe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function ICe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function NCe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function FCe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function zCe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function v$(e, t, n, r) {
  return n !== void 0 ? FCe(e, t, NCe(n, google.maps.LatLngBounds, RCe)) : zCe(e, t, ICe(r, google.maps.LatLng, BCe));
}
function UCe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function GB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $Ce(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function WCe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = $Ce({}, this.container ? m$(this.container, o) : {
        x: 0,
        y: 0
      }), u = v$(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function qB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function VCe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function ZB(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function KB(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function HCe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = Ee(ht), c = Bn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Bn(() => WCe(c, r, t, n, s), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), oi.createPortal(l, c);
}
ke(HCe);
class ml extends be {
  constructor(t) {
    super(t), de(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), de(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      _r(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), de(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), de(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = VCe({
        x: 0,
        y: 0
      }, this.containerRef.current ? m$(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = v$(r, o, this.props.bounds, this.props.position);
      if (!UCe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), de(this, "draw", () => {
      this.onPositionElement();
    }), de(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Hr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = ZB(t.position), r = ZB(this.props.position), o = KB(t.bounds), i = KB(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? oi.createPortal(q.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: it.only(this.props.children)
    }), t) : null;
  }
}
de(ml, "FLOAT_PANE", "floatPane");
de(ml, "MAP_PANE", "mapPane");
de(ml, "MARKER_LAYER", "markerLayer");
de(ml, "OVERLAY_LAYER", "overlayLayer");
de(ml, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
de(ml, "contextType", ht);
function GCe() {
}
function XB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function YB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XB(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JB = {
  onDblClick: "dblclick",
  onClick: "click"
}, QB = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function qCe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = Ee(ht), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Bn(() => new google.maps.GroundOverlay(t, a, r), []);
  return v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), v(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ke(qCe);
class y$ extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      groundOverlay: null
    }), de(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    _r(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, YB(YB({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = St({
      updaterMap: QB,
      eventMap: JB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: QB,
      eventMap: JB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
de(y$, "defaultProps", {
  onLoad: GCe
});
de(y$, "contextType", ht);
function eR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eR(Object(n), !0).forEach(function(r) {
      de(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tR = {}, nR = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function ZCe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = Ee(ht), [a, s] = k(null);
  return v(() => {
    google.maps.visualization || _r(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    _r(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(dh(dh({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ke(ZCe);
class KCe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      heatmapLayer: null
    }), de(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    _r(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), _r(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(dh(dh({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = St({
      updaterMap: nR,
      eventMap: tR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: nR,
      eventMap: tR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Bt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
de(KCe, "contextType", ht);
var rR = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, oR = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class XCe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      streetViewPanorama: null
    }), de(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = St({
      updaterMap: oR,
      eventMap: rR,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: oR,
      eventMap: rR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Bt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
de(XCe, "contextType", ht);
class YCe extends be {
  constructor() {
    super(...arguments), de(this, "state", {
      streetViewService: null
    }), de(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
de(YCe, "contextType", ht);
var iR = {
  onDirectionsChanged: "directions_changed"
}, sR = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class JCe extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "state", {
      directionsRenderer: null
    }), de(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = St({
      updaterMap: sR,
      eventMap: iR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: sR,
      eventMap: iR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Bt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
de(JCe, "contextType", ht);
var aR = {
  onPlacesChanged: "places_changed"
}, lR = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class b$ extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "containerElement", Hr()), de(this, "state", {
      searchBox: null
    }), de(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (_r(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = St({
          updaterMap: lR,
          eventMap: aR,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: lR,
      eventMap: aR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Bt(this.registeredEvents));
  }
  render() {
    return q.jsx("div", {
      ref: this.containerElement,
      children: it.only(this.props.children)
    });
  }
}
de(b$, "contextType", ht);
var uR = {
  onPlaceChanged: "place_changed"
}, cR = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class w$ extends be {
  constructor() {
    super(...arguments), de(this, "registeredEvents", []), de(this, "containerElement", Hr()), de(this, "state", {
      autocomplete: null
    }), de(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    _r(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = St({
        updaterMap: cR,
        eventMap: uR,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Bt(this.registeredEvents), this.registeredEvents = St({
      updaterMap: cR,
      eventMap: uR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Bt(this.registeredEvents);
  }
  render() {
    return q.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: it.only(this.props.children)
    });
  }
}
de(w$, "defaultProps", {
  className: ""
});
de(w$, "contextType", ht);
function zEe({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ q.jsx(
    u$,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function UEe(e) {
  const { children: t = !1 } = e, [n, r] = k([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((p) => p.key === u)) == null ? void 0 : c.data;
  }
  function a(u, c) {
    const p = o(u);
    r(p ? (d) => [...d.filter((f) => f.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function s(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ q.jsx(
    jx.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: a, closeModal: s, closeAll: l },
      children: t
    }
  );
}
let QCe = { data: "" }, exe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || QCe, txe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, nxe = /\/\*[^]*?\*\/|  +/g, pR = /\n+/g, gs = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? gs(a, i) : i + "{" + gs(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += gs(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += gs.p ? gs.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, ki = {}, C$ = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + C$(e[n]);
    return t;
  }
  return e;
}, rxe = (e, t, n, r, o) => {
  let i = C$(e), a = ki[i] || (ki[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!ki[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = txe.exec(u.replace(nxe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(pR, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(pR, " ").trim();
      return d[0];
    })(e);
    ki[a] = gs(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && ki.g ? ki.g : null;
  return n && (ki.g = ki[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(ki[a], t, r, s), a;
}, oxe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : gs(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function cm(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return rxe(n.unshift ? n.raw ? oxe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, exe(t.target), t.g, t.o, t.k);
}
let x$, O0, k0;
cm.bind({ g: 1 });
let Ri = cm.bind({ k: 1 });
function ixe(e, t, n, r) {
  gs.p = t, x$ = e, O0 = n, k0 = r;
}
function Bs(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: O0 && O0() }, s), n.o = / *go\d+/.test(l), s.className = cm.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), k0 && u[0] && k0(s), x$(u, s);
    }
    return o;
  };
}
var sxe = (e) => typeof e == "function", fh = (e, t) => sxe(e) ? e(t) : e, axe = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), E$ = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), lxe = 20, O$ = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, lxe) };
    case 1:
      return { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return O$(e, { type: e.toasts.find((i) => i.id === n.id) ? 1 : 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, dismissed: !0, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, Id = [], pa = { toasts: [], pausedAt: void 0 }, Ba = (e) => {
  pa = O$(pa, e), Id.forEach((t) => {
    t(pa);
  });
}, uxe = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, cxe = (e = {}) => {
  let [t, n] = k(pa), r = Qe(pa);
  v(() => (r.current !== pa && n(pa), Id.push(n), () => {
    let i = Id.indexOf(n);
    i > -1 && Id.splice(i, 1);
  }), []);
  let o = t.toasts.map((i) => {
    var a, s, l;
    return { ...e, ...e[i.type], ...i, removeDelay: i.removeDelay || ((a = e[i.type]) == null ? void 0 : a.removeDelay) || (e == null ? void 0 : e.removeDelay), duration: i.duration || ((s = e[i.type]) == null ? void 0 : s.duration) || (e == null ? void 0 : e.duration) || uxe[i.type], style: { ...e.style, ...(l = e[i.type]) == null ? void 0 : l.style, ...i.style } };
  });
  return { ...t, toasts: o };
}, pxe = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, dismissed: !1, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || axe() }), Hc = (e) => (t, n) => {
  let r = pxe(t, e, n);
  return Ba({ type: 2, toast: r }), r.id;
}, Wr = (e, t) => Hc("blank")(e, t);
Wr.error = Hc("error");
Wr.success = Hc("success");
Wr.loading = Hc("loading");
Wr.custom = Hc("custom");
Wr.dismiss = (e) => {
  Ba({ type: 3, toastId: e });
};
Wr.remove = (e) => Ba({ type: 4, toastId: e });
Wr.promise = (e, t, n) => {
  let r = Wr.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return typeof e == "function" && (e = e()), e.then((o) => {
    let i = t.success ? fh(t.success, o) : void 0;
    return i ? Wr.success(i, { id: r, ...n, ...n == null ? void 0 : n.success }) : Wr.dismiss(r), o;
  }).catch((o) => {
    let i = t.error ? fh(t.error, o) : void 0;
    i ? Wr.error(i, { id: r, ...n, ...n == null ? void 0 : n.error }) : Wr.dismiss(r);
  }), e;
};
var dxe = (e, t) => {
  Ba({ type: 1, toast: { id: e, height: t } });
}, fxe = () => {
  Ba({ type: 5, time: Date.now() });
}, Eu = /* @__PURE__ */ new Map(), hxe = 1e3, gxe = (e, t = hxe) => {
  if (Eu.has(e)) return;
  let n = setTimeout(() => {
    Eu.delete(e), Ba({ type: 4, toastId: e });
  }, t);
  Eu.set(e, n);
}, mxe = (e) => {
  let { toasts: t, pausedAt: n } = cxe(e);
  v(() => {
    if (n) return;
    let i = Date.now(), a = t.map((s) => {
      if (s.duration === 1 / 0) return;
      let l = (s.duration || 0) + s.pauseDuration - (i - s.createdAt);
      if (l < 0) {
        s.visible && Wr.dismiss(s.id);
        return;
      }
      return setTimeout(() => Wr.dismiss(s.id), l);
    });
    return () => {
      a.forEach((s) => s && clearTimeout(s));
    };
  }, [t, n]);
  let r = dn(() => {
    n && Ba({ type: 6, time: Date.now() });
  }, [n]), o = dn((i, a) => {
    let { reverseOrder: s = !1, gutter: l = 8, defaultPosition: u } = a || {}, c = t.filter((g) => (g.position || u) === (i.position || u) && g.height), p = c.findIndex((g) => g.id === i.id), d = c.filter((g, f) => f < p && g.visible).length;
    return c.filter((g) => g.visible).slice(...s ? [d + 1] : [0, d]).reduce((g, f) => g + (f.height || 0) + l, 0);
  }, [t]);
  return v(() => {
    t.forEach((i) => {
      if (i.dismissed) gxe(i.id, i.removeDelay);
      else {
        let a = Eu.get(i.id);
        a && (clearTimeout(a), Eu.delete(i.id));
      }
    });
  }, [t]), { toasts: t, handlers: { updateHeight: dxe, startPause: fxe, endPause: r, calculateOffset: o } };
}, vxe = Ri`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, yxe = Ri`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, bxe = Ri`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, wxe = Bs("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${vxe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${yxe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${bxe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Cxe = Ri`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, xxe = Bs("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Cxe} 1s linear infinite;
`, Exe = Ri`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Oxe = Ri`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, kxe = Bs("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Exe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Oxe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, _xe = Bs("div")`
  position: absolute;
`, Lxe = Bs("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Pxe = Ri`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Sxe = Bs("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Pxe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, Dxe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? ze.createElement(Sxe, null, t) : t : n === "blank" ? null : ze.createElement(Lxe, null, ze.createElement(xxe, { ...r }), n !== "loading" && ze.createElement(_xe, null, n === "error" ? ze.createElement(wxe, { ...r }) : ze.createElement(kxe, { ...r })));
}, Mxe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Txe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, jxe = "0%{opacity:0;} 100%{opacity:1;}", Axe = "0%{opacity:1;} 100%{opacity:0;}", Bxe = Bs("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Rxe = Bs("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Ixe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = E$() ? [jxe, Axe] : [Mxe(n), Txe(n)];
  return { animation: t ? `${Ri(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ri(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, Nxe = ze.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? Ixe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = ze.createElement(Dxe, { toast: e }), a = ze.createElement(Rxe, { ...e.ariaProps }, fh(e.message, e));
  return ze.createElement(Bxe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : ze.createElement(ze.Fragment, null, i, a));
});
ixe(ze.createElement);
var Fxe = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = ze.useCallback((a) => {
    if (a) {
      let s = () => {
        let l = a.getBoundingClientRect().height;
        r(e, l);
      };
      s(), new MutationObserver(s).observe(a, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return ze.createElement("div", { ref: i, className: t, style: n }, o);
}, zxe = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: E$() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, Uxe = cm`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, _d = 16, $xe = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: a }) => {
  let { toasts: s, handlers: l } = mxe(n);
  return ze.createElement("div", { id: "_rht_toaster", style: { position: "fixed", zIndex: 9999, top: _d, left: _d, right: _d, bottom: _d, pointerEvents: "none", ...i }, className: a, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, s.map((u) => {
    let c = u.position || t, p = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), d = zxe(c, p);
    return ze.createElement(Fxe, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? Uxe : "", style: d }, u.type === "custom" ? fh(u.message, u) : o ? o(u) : ze.createElement(Nxe, { toast: u, position: c }));
  }));
}, dR = Wr;
function $Ee({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return dR.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return dR.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ q.jsxs(t$.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ q.jsx(
      $xe,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
function k$({ children: e, fallback: t = null }) {
  return dwe() ? /* @__PURE__ */ q.jsx(q.Fragment, { children: e() }) : /* @__PURE__ */ q.jsx(q.Fragment, { children: t });
}
let Wxe = class {
  constructor(t, n) {
    Gc(this, "pixelId");
    Gc(this, "autoConfig");
    Gc(this, "initialized");
    this.pixelId = t, this.autoConfig = (n == null ? void 0 : n.autoConfig) || !0, this.initialized = !1;
  }
  loadFacebookPixel() {
    if (window.fbq) return;
    const t = function(...o) {
      t.callMethod ? t.callMethod.apply(t, o) : t.queue.push(o);
    };
    window._fbq || (window._fbq = t), t.push = t, t.loaded = !0, t.version = "2.0", t.queue = [];
    const n = document.createElement("script");
    n.async = !0, n.src = "https://connect.facebook.net/en_US/fbevents.js";
    const r = document.getElementsByTagName("script")[0];
    if (!r.parentNode)
      throw new Error("No script tag found in the document");
    r.parentNode.insertBefore(n, r), window.fbq = t;
  }
  init(t = {}) {
    if (this.initialized = typeof window < "u" && !!window.fbq, this.loadFacebookPixel(), !window.fbq)
      throw new Error("window.fbq is not defined");
    this.autoConfig === !1 ? window.fbq("set", "autoConfig", !1, this.pixelId) : window.fbq("init", this.pixelId, t), this.initialized = !0;
  }
  pageView() {
    this.initialized && window.fbq && window.fbq("track", "PageView");
  }
  track(t, n) {
    this.initialized && window.fbq && window.fbq("track", t, n);
  }
  trackSingle(t, n, r) {
    this.initialized && window.fbq && window.fbq("trackSingle", t, n, r);
  }
  trackCustom(t, n) {
    this.initialized && window.fbq && window.fbq("trackCustom", t, n);
  }
  trackSingleCustom(t, n, r) {
    this.initialized && window.fbq && window.fbq("trackSingle", t, n, r);
  }
  grantConsent() {
    this.initialized && window.fbq && window.fbq("consent", "grant");
  }
  revokeConsent() {
    this.initialized && window.fbq && window.fbq("consent", "revoke");
  }
};
function Vxe(e) {
  const {
    pixelId: t,
    options: n,
    pageView: r,
    track: o,
    trackCustom: i,
    trackSingle: a,
    trackSingleCustom: s,
    grantConsent: l,
    revokeConsent: u
  } = e, c = new Wxe(t, n);
  return c.init(), r && c.pageView(), l && c.grantConsent(), u && c.revokeConsent(), o && c.track(...o), i && c.trackCustom(...i), a && c.trackSingle(t, ...a), s && c.trackSingleCustom(t, ...s), /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function VEe(e) {
  return process.env.NODE_ENV !== "production" && !e.showInDevMode ? /* @__PURE__ */ q.jsx(q.Fragment, {}) : /* @__PURE__ */ q.jsx(k$, { children: () => /* @__PURE__ */ q.jsx(Vxe, { ...e }) });
}
function HEe({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ q.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ q.jsx(
    Owe,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ q.jsx(c$, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ q.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ q.jsx(Q$, {}) });
}
function GEe({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = k(null), a = (l) => i(l), s = () => {
    var g, f, m, h;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function p(E) {
      const w = c.find((S) => S.types[0] === E);
      return w ? w.long_name : "";
    }
    function d(E) {
      const w = c.find((S) => S.types[0] === E);
      return w ? w.short_name : "";
    }
    if (u) {
      const E = p("route"), w = p("street_number"), S = p("sublocality_level_1"), x = p("administrative_area_level_2"), y = p("administrative_area_level_1"), C = d("administrative_area_level_1"), P = p("postal_code"), F = (f = (g = u.geometry) == null ? void 0 : g.location) == null ? void 0 : f.lat(), _ = (h = (m = u.geometry) == null ? void 0 : m.location) == null ? void 0 : h.lng();
      t && t({
        street: E,
        city: x,
        state: y,
        district: S,
        cep: P,
        streetNumber: w,
        stateShortName: C,
        coordinates: { lat: F, lng: _ }
      });
    }
  };
  return /* @__PURE__ */ q.jsx(
    b$,
    {
      onLoad: a,
      onPlacesChanged: s,
      options: n,
      children: /* @__PURE__ */ q.jsx(Qg, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function _$(e) {
  const { dataLayer: t, dataLayerName: n } = e;
  return `
  window.${n} = window.${n} || [];
  window.${n}.push(${JSON.stringify(t)})`;
}
function Hxe(e) {
  const { id: t, events: n, dataLayer: r, dataLayerName: o, preview: i, auth: a } = e, s = `&gtm_auth=${a}`, l = `&gtm_preview=${i}`;
  t || console.warn("GTM Id is required");
  const u = `
    <iframe src="https://www.googletagmanager.com/ns.html?id=${t}${s}${l}&gtm_cookies_win=x"
      height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>`, c = `
    (function(w,d,s,l,i){w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', ${JSON.stringify(
    n
  ).slice(1, -1)}});
      var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'${s}${l}&gtm_cookies_win=x';
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','${o}','${t}');`, p = _$({ dataLayer: r, dataLayerName: o });
  return {
    iframe: u,
    script: c,
    dataLayerVar: p
  };
}
let Gxe = class {
  initializeDataScript(t) {
    const n = document.createElement("script");
    return n.innerHTML = t, n;
  }
  initializeGTMElements(t) {
    const n = Hxe(t), r = () => {
      const a = document.createElement("noscript");
      return a.innerHTML = n.iframe, a;
    }, o = () => {
      const a = document.createElement("script");
      return a.innerHTML = n.script, a;
    }, i = this.initializeDataScript(n.dataLayerVar);
    return {
      noScript: r,
      script: o,
      dataScript: i
    };
  }
  initializeDataLayer(t) {
    const { dataLayer: n, dataLayerName: r } = t;
    if (window[r]) return window[r].push(n);
    const o = _$({ dataLayer: n, dataLayerName: r }), i = this.initializeDataScript(o);
    document.head.insertBefore(i, document.head.childNodes[0]);
  }
  initialize(t) {
    const {
      events: n,
      gtmId: r,
      dataLayer: o,
      auth: i = "",
      preview: a = "",
      dataLayerName: s = "dataLayer"
    } = t, l = this.initializeGTMElements({
      id: r,
      events: n,
      dataLayer: o || void 0,
      dataLayerName: s,
      auth: i,
      preview: a
    });
    o && document.head.appendChild(l.dataScript), document.head.insertBefore(l.script(), document.head.childNodes[0]), document.body.insertBefore(l.noScript(), document.body.childNodes[0]);
  }
};
function qxe(e) {
  return new Gxe().initialize(e), /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function ZEe(e) {
  const {
    gtmId: t,
    auth: n = "",
    preview: r = "",
    dataLayerName: o = "dataLayer",
    events: i = {},
    dataLayer: a = {},
    showInDevMode: s = !1
  } = e;
  return process.env.NODE_ENV !== "production" && !s ? /* @__PURE__ */ q.jsx(q.Fragment, {}) : /* @__PURE__ */ q.jsx(k$, { children: () => /* @__PURE__ */ q.jsx(
    qxe,
    {
      auth: n,
      dataLayer: a,
      dataLayerName: o,
      events: i,
      gtmId: t,
      preview: r
    }
  ) });
}
export {
  tEe as AlertContainer,
  nEe as AlertContent,
  rEe as AlertDescription,
  oEe as AlertIcon,
  rW as AlertTitle,
  mEe as AudioUpload,
  lEe as Badge,
  PEe as BreadcrumbContainer,
  SEe as BreadcrumbLink,
  rc as Button,
  uEe as Card,
  vEe as Checkbox,
  k$ as ClientOnly,
  eI as Divider,
  MEe as DrawerContainer,
  TEe as DrawerHeader,
  NEe as DrawerProvider,
  VEe as FacebookPixel,
  yEe as FileUpload,
  Lj as FormController,
  bEe as FormError,
  Pj as FormLabel,
  HEe as GoogleMap,
  zEe as GoogleProvider,
  GEe as GoogleSearchPlaces,
  ZEe as GoogleTagManager,
  RU as IconButton,
  tge as ImageUpload,
  Qg as Input,
  Kye as ModalContainer,
  Xye as ModalFooter,
  Yye as ModalHeader,
  UEe as ModalProvider,
  wEe as MultiSelect,
  DEe as Pagination,
  CEe as PhoneInput,
  jEe as Popover,
  EEe as RadioBox,
  xEe as RadioGroup,
  OEe as RichText,
  kEe as Select,
  cEe as Skeleton,
  Vhe as Slider,
  _Ee as Switch,
  hA as TabButton,
  Qye as TabContainer,
  pEe as TableBody,
  dEe as TableCaption,
  fEe as TableContainer,
  hEe as TableFooter,
  gEe as TableHeader,
  LEe as Textarea,
  AEe as Toast,
  $Ee as ToastProvider,
  IU as Tooltip,
  iEe as getHtmlFromRichTextValue,
  sEe as getRichTextValueFromHtml,
  aEe as isHtml,
  QR as morpheme,
  BEe as useAutomation,
  REe as useDrawer,
  ux as useFieldErrors,
  Jr as useFormController,
  dwe as useHydrated,
  IEe as useModal,
  T3 as useScopedParams,
  cwe as useToast
};
