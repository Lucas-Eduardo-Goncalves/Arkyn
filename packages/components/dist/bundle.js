import * as ut from "react";
import Se, { createContext as ht, useContext as Ae, memo as Ze, Children as Vt, isValidElement as Ia, cloneElement as Ra, useState as P, useRef as rt, useEffect as y, PureComponent as Te, createRef as Mr, useMemo as Ln, useId as pb, forwardRef as _a, Component as Mv, useCallback as dt, useReducer as hb, useLayoutEffect as gb } from "react";
import { Info as Pv, AlertTriangle as vb, XCircle as Bv, CheckCircle2 as Tv, MapPinned as mb, Loader2 as lr, Check as Av, RefreshCw as yb, Heading1 as bb, Heading2 as Cb, Quote as wb, Bold as Eb, Italic as Db, Underline as xb, Code as Lb, AlignLeft as Ob, AlignRight as Sb, AlignCenter as kb, AlignJustify as Mb, ChevronDown as Pb, ChevronRight as Mu, ChevronLeft as Bb, Ellipsis as Kc, X as Fv } from "lucide-react";
import * as ja from "react-dom";
import Ol, { createPortal as Pr } from "react-dom";
import { useActionData as Sl, useNavigation as Iv, useFetchers as Rv, useLocation as kl, Link as Tb, useNavigate as _v } from "@remix-run/react";
import { InputMask as Ab } from "@react-input/mask";
import { AnimatePresence as jv, motion as Go } from "framer-motion";
var vt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Na(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Pu = { exports: {} }, wo = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Yc;
function Fb() {
  if (Yc) return wo;
  Yc = 1;
  var e = Se, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, u, l) {
    var c, f = {}, p = null, g = null;
    l !== void 0 && (p = "" + l), u.key !== void 0 && (p = "" + u.key), u.ref !== void 0 && (g = u.ref);
    for (c in u) r.call(u, c) && !i.hasOwnProperty(c) && (f[c] = u[c]);
    if (s && s.defaultProps) for (c in u = s.defaultProps, u) f[c] === void 0 && (f[c] = u[c]);
    return { $$typeof: t, type: s, key: p, ref: g, props: f, _owner: o.current };
  }
  return wo.Fragment = n, wo.jsx = a, wo.jsxs = a, wo;
}
var Eo = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xc;
function Ib() {
  return Xc || (Xc = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Se, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), v = Symbol.iterator, h = "@@iterator";
    function d(C) {
      if (C === null || typeof C != "object")
        return null;
      var Z = v && C[v] || C[h];
      return typeof Z == "function" ? Z : null;
    }
    var w = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function L(C) {
      {
        for (var Z = arguments.length, Q = new Array(Z > 1 ? Z - 1 : 0), fe = 1; fe < Z; fe++)
          Q[fe - 1] = arguments[fe];
        D("error", C, Q);
      }
    }
    function D(C, Z, Q) {
      {
        var fe = w.ReactDebugCurrentFrame, De = fe.getStackAddendum();
        De !== "" && (Z += "%s", Q = Q.concat([De]));
        var ke = Q.map(function(Ee) {
          return String(Ee);
        });
        ke.unshift("Warning: " + Z), Function.prototype.apply.call(console[C], console, ke);
      }
    }
    var B = !1, b = !1, E = !1, O = !1, S = !1, V;
    V = Symbol.for("react.module.reference");
    function M(C) {
      return !!(typeof C == "string" || typeof C == "function" || C === r || C === i || S || C === o || C === l || C === c || O || C === g || B || b || E || typeof C == "object" && C !== null && (C.$$typeof === p || C.$$typeof === f || C.$$typeof === a || C.$$typeof === s || C.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      C.$$typeof === V || C.getModuleId !== void 0));
    }
    function q(C, Z, Q) {
      var fe = C.displayName;
      if (fe)
        return fe;
      var De = Z.displayName || Z.name || "";
      return De !== "" ? Q + "(" + De + ")" : Q;
    }
    function _(C) {
      return C.displayName || "Context";
    }
    function j(C) {
      if (C == null)
        return null;
      if (typeof C.tag == "number" && L("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof C == "function")
        return C.displayName || C.name || null;
      if (typeof C == "string")
        return C;
      switch (C) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case l:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof C == "object")
        switch (C.$$typeof) {
          case s:
            var Z = C;
            return _(Z) + ".Consumer";
          case a:
            var Q = C;
            return _(Q._context) + ".Provider";
          case u:
            return q(C, C.render, "ForwardRef");
          case f:
            var fe = C.displayName || null;
            return fe !== null ? fe : j(C.type) || "Memo";
          case p: {
            var De = C, ke = De._payload, Ee = De._init;
            try {
              return j(Ee(ke));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var I = Object.assign, z = 0, X, R, ee, re, k, A, G;
    function U() {
    }
    U.__reactDisabledLog = !0;
    function Y() {
      {
        if (z === 0) {
          X = console.log, R = console.info, ee = console.warn, re = console.error, k = console.group, A = console.groupCollapsed, G = console.groupEnd;
          var C = {
            configurable: !0,
            enumerable: !0,
            value: U,
            writable: !0
          };
          Object.defineProperties(console, {
            info: C,
            log: C,
            warn: C,
            error: C,
            group: C,
            groupCollapsed: C,
            groupEnd: C
          });
        }
        z++;
      }
    }
    function K() {
      {
        if (z--, z === 0) {
          var C = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: I({}, C, {
              value: X
            }),
            info: I({}, C, {
              value: R
            }),
            warn: I({}, C, {
              value: ee
            }),
            error: I({}, C, {
              value: re
            }),
            group: I({}, C, {
              value: k
            }),
            groupCollapsed: I({}, C, {
              value: A
            }),
            groupEnd: I({}, C, {
              value: G
            })
          });
        }
        z < 0 && L("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var m = w.ReactCurrentDispatcher, $;
    function W(C, Z, Q) {
      {
        if ($ === void 0)
          try {
            throw Error();
          } catch (De) {
            var fe = De.stack.trim().match(/\n( *(at )?)/);
            $ = fe && fe[1] || "";
          }
        return `
` + $ + C;
      }
    }
    var T = !1, J;
    {
      var te = typeof WeakMap == "function" ? WeakMap : Map;
      J = new te();
    }
    function N(C, Z) {
      if (!C || T)
        return "";
      {
        var Q = J.get(C);
        if (Q !== void 0)
          return Q;
      }
      var fe;
      T = !0;
      var De = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ke;
      ke = m.current, m.current = null, Y();
      try {
        if (Z) {
          var Ee = function() {
            throw Error();
          };
          if (Object.defineProperty(Ee.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ee, []);
            } catch (Ue) {
              fe = Ue;
            }
            Reflect.construct(C, [], Ee);
          } else {
            try {
              Ee.call();
            } catch (Ue) {
              fe = Ue;
            }
            C.call(Ee.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ue) {
            fe = Ue;
          }
          C();
        }
      } catch (Ue) {
        if (Ue && fe && typeof Ue.stack == "string") {
          for (var be = Ue.stack.split(`
`), $e = fe.stack.split(`
`), Ie = be.length - 1, _e = $e.length - 1; Ie >= 1 && _e >= 0 && be[Ie] !== $e[_e]; )
            _e--;
          for (; Ie >= 1 && _e >= 0; Ie--, _e--)
            if (be[Ie] !== $e[_e]) {
              if (Ie !== 1 || _e !== 1)
                do
                  if (Ie--, _e--, _e < 0 || be[Ie] !== $e[_e]) {
                    var nt = `
` + be[Ie].replace(" at new ", " at ");
                    return C.displayName && nt.includes("<anonymous>") && (nt = nt.replace("<anonymous>", C.displayName)), typeof C == "function" && J.set(C, nt), nt;
                  }
                while (Ie >= 1 && _e >= 0);
              break;
            }
        }
      } finally {
        T = !1, m.current = ke, K(), Error.prepareStackTrace = De;
      }
      var Wt = C ? C.displayName || C.name : "", Ht = Wt ? W(Wt) : "";
      return typeof C == "function" && J.set(C, Ht), Ht;
    }
    function se(C, Z, Q) {
      return N(C, !1);
    }
    function ue(C) {
      var Z = C.prototype;
      return !!(Z && Z.isReactComponent);
    }
    function de(C, Z, Q) {
      if (C == null)
        return "";
      if (typeof C == "function")
        return N(C, ue(C));
      if (typeof C == "string")
        return W(C);
      switch (C) {
        case l:
          return W("Suspense");
        case c:
          return W("SuspenseList");
      }
      if (typeof C == "object")
        switch (C.$$typeof) {
          case u:
            return se(C.render);
          case f:
            return de(C.type, Z, Q);
          case p: {
            var fe = C, De = fe._payload, ke = fe._init;
            try {
              return de(ke(De), Z, Q);
            } catch {
            }
          }
        }
      return "";
    }
    var ge = Object.prototype.hasOwnProperty, Ce = {}, me = w.ReactDebugCurrentFrame;
    function ye(C) {
      if (C) {
        var Z = C._owner, Q = de(C.type, C._source, Z ? Z.type : null);
        me.setExtraStackFrame(Q);
      } else
        me.setExtraStackFrame(null);
    }
    function ce(C, Z, Q, fe, De) {
      {
        var ke = Function.call.bind(ge);
        for (var Ee in C)
          if (ke(C, Ee)) {
            var be = void 0;
            try {
              if (typeof C[Ee] != "function") {
                var $e = Error((fe || "React class") + ": " + Q + " type `" + Ee + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof C[Ee] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw $e.name = "Invariant Violation", $e;
              }
              be = C[Ee](Z, Ee, fe, Q, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ie) {
              be = Ie;
            }
            be && !(be instanceof Error) && (ye(De), L("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", fe || "React class", Q, Ee, typeof be), ye(null)), be instanceof Error && !(be.message in Ce) && (Ce[be.message] = !0, ye(De), L("Failed %s type: %s", Q, be.message), ye(null));
          }
      }
    }
    var Me = Array.isArray;
    function ie(C) {
      return Me(C);
    }
    function Re(C) {
      {
        var Z = typeof Symbol == "function" && Symbol.toStringTag, Q = Z && C[Symbol.toStringTag] || C.constructor.name || "Object";
        return Q;
      }
    }
    function ae(C) {
      try {
        return Le(C), !1;
      } catch {
        return !0;
      }
    }
    function Le(C) {
      return "" + C;
    }
    function Fe(C) {
      if (ae(C))
        return L("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Re(C)), Le(C);
    }
    var ze = w.ReactCurrentOwner, Ye = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, we, Ct, ot;
    ot = {};
    function Jt(C) {
      if (ge.call(C, "ref")) {
        var Z = Object.getOwnPropertyDescriptor(C, "ref").get;
        if (Z && Z.isReactWarning)
          return !1;
      }
      return C.ref !== void 0;
    }
    function _t(C) {
      if (ge.call(C, "key")) {
        var Z = Object.getOwnPropertyDescriptor(C, "key").get;
        if (Z && Z.isReactWarning)
          return !1;
      }
      return C.key !== void 0;
    }
    function $t(C, Z) {
      if (typeof C.ref == "string" && ze.current && Z && ze.current.stateNode !== Z) {
        var Q = j(ze.current.type);
        ot[Q] || (L('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', j(ze.current.type), C.ref), ot[Q] = !0);
      }
    }
    function dn(C, Z) {
      {
        var Q = function() {
          we || (we = !0, L("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Z));
        };
        Q.isReactWarning = !0, Object.defineProperty(C, "key", {
          get: Q,
          configurable: !0
        });
      }
    }
    function pn(C, Z) {
      {
        var Q = function() {
          Ct || (Ct = !0, L("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Z));
        };
        Q.isReactWarning = !0, Object.defineProperty(C, "ref", {
          get: Q,
          configurable: !0
        });
      }
    }
    var hn = function(C, Z, Q, fe, De, ke, Ee) {
      var be = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: C,
        key: Z,
        ref: Q,
        props: Ee,
        // Record the component responsible for creating this element.
        _owner: ke
      };
      return be._store = {}, Object.defineProperty(be._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(be, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: fe
      }), Object.defineProperty(be, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: De
      }), Object.freeze && (Object.freeze(be.props), Object.freeze(be)), be;
    };
    function gn(C, Z, Q, fe, De) {
      {
        var ke, Ee = {}, be = null, $e = null;
        Q !== void 0 && (Fe(Q), be = "" + Q), _t(Z) && (Fe(Z.key), be = "" + Z.key), Jt(Z) && ($e = Z.ref, $t(Z, De));
        for (ke in Z)
          ge.call(Z, ke) && !Ye.hasOwnProperty(ke) && (Ee[ke] = Z[ke]);
        if (C && C.defaultProps) {
          var Ie = C.defaultProps;
          for (ke in Ie)
            Ee[ke] === void 0 && (Ee[ke] = Ie[ke]);
        }
        if (be || $e) {
          var _e = typeof C == "function" ? C.displayName || C.name || "Unknown" : C;
          be && dn(Ee, _e), $e && pn(Ee, _e);
        }
        return hn(C, be, $e, De, fe, ze.current, Ee);
      }
    }
    var jt = w.ReactCurrentOwner, Qt = w.ReactDebugCurrentFrame;
    function Ut(C) {
      if (C) {
        var Z = C._owner, Q = de(C.type, C._source, Z ? Z.type : null);
        Qt.setExtraStackFrame(Q);
      } else
        Qt.setExtraStackFrame(null);
    }
    var Zt;
    Zt = !1;
    function vn(C) {
      return typeof C == "object" && C !== null && C.$$typeof === t;
    }
    function In() {
      {
        if (jt.current) {
          var C = j(jt.current.type);
          if (C)
            return `

Check the render method of \`` + C + "`.";
        }
        return "";
      }
    }
    function mn(C) {
      {
        if (C !== void 0) {
          var Z = C.fileName.replace(/^.*[\\\/]/, ""), Q = C.lineNumber;
          return `

Check your code at ` + Z + ":" + Q + ".";
        }
        return "";
      }
    }
    var Rn = {};
    function Yn(C) {
      {
        var Z = In();
        if (!Z) {
          var Q = typeof C == "string" ? C : C.displayName || C.name;
          Q && (Z = `

Check the top-level render call using <` + Q + ">.");
        }
        return Z;
      }
    }
    function en(C, Z) {
      {
        if (!C._store || C._store.validated || C.key != null)
          return;
        C._store.validated = !0;
        var Q = Yn(Z);
        if (Rn[Q])
          return;
        Rn[Q] = !0;
        var fe = "";
        C && C._owner && C._owner !== jt.current && (fe = " It was passed a child from " + j(C._owner.type) + "."), Ut(C), L('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Q, fe), Ut(null);
      }
    }
    function _n(C, Z) {
      {
        if (typeof C != "object")
          return;
        if (ie(C))
          for (var Q = 0; Q < C.length; Q++) {
            var fe = C[Q];
            vn(fe) && en(fe, Z);
          }
        else if (vn(C))
          C._store && (C._store.validated = !0);
        else if (C) {
          var De = d(C);
          if (typeof De == "function" && De !== C.entries)
            for (var ke = De.call(C), Ee; !(Ee = ke.next()).done; )
              vn(Ee.value) && en(Ee.value, Z);
        }
      }
    }
    function Xn(C) {
      {
        var Z = C.type;
        if (Z == null || typeof Z == "string")
          return;
        var Q;
        if (typeof Z == "function")
          Q = Z.propTypes;
        else if (typeof Z == "object" && (Z.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Z.$$typeof === f))
          Q = Z.propTypes;
        else
          return;
        if (Q) {
          var fe = j(Z);
          ce(Q, C.props, "prop", fe, C);
        } else if (Z.PropTypes !== void 0 && !Zt) {
          Zt = !0;
          var De = j(Z);
          L("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", De || "Unknown");
        }
        typeof Z.getDefaultProps == "function" && !Z.getDefaultProps.isReactClassApproved && L("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yn(C) {
      {
        for (var Z = Object.keys(C.props), Q = 0; Q < Z.length; Q++) {
          var fe = Z[Q];
          if (fe !== "children" && fe !== "key") {
            Ut(C), L("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", fe), Ut(null);
            break;
          }
        }
        C.ref !== null && (Ut(C), L("Invalid attribute `ref` supplied to `React.Fragment`."), Ut(null));
      }
    }
    var jn = {};
    function Nn(C, Z, Q, fe, De, ke) {
      {
        var Ee = M(C);
        if (!Ee) {
          var be = "";
          (C === void 0 || typeof C == "object" && C !== null && Object.keys(C).length === 0) && (be += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var $e = mn(De);
          $e ? be += $e : be += In();
          var Ie;
          C === null ? Ie = "null" : ie(C) ? Ie = "array" : C !== void 0 && C.$$typeof === t ? (Ie = "<" + (j(C.type) || "Unknown") + " />", be = " Did you accidentally export a JSX literal instead of a component?") : Ie = typeof C, L("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ie, be);
        }
        var _e = gn(C, Z, Q, De, ke);
        if (_e == null)
          return _e;
        if (Ee) {
          var nt = Z.children;
          if (nt !== void 0)
            if (fe)
              if (ie(nt)) {
                for (var Wt = 0; Wt < nt.length; Wt++)
                  _n(nt[Wt], C);
                Object.freeze && Object.freeze(nt);
              } else
                L("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              _n(nt, C);
        }
        if (ge.call(Z, "key")) {
          var Ht = j(C), Ue = Object.keys(Z).filter(function(Ps) {
            return Ps !== "key";
          }), he = Ue.length > 0 ? "{key: someKey, " + Ue.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!jn[Ht + he]) {
            var Ms = Ue.length > 0 ? "{" + Ue.join(": ..., ") + ": ...}" : "{}";
            L(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, he, Ht, Ms, Ht), jn[Ht + he] = !0;
          }
        }
        return C === r ? yn(_e) : Xn(_e), _e;
      }
    }
    function bn(C, Z, Q) {
      return Nn(C, Z, Q, !0);
    }
    function Jn(C, Z, Q) {
      return Nn(C, Z, Q, !1);
    }
    var Qn = Jn, Cn = bn;
    Eo.Fragment = r, Eo.jsx = Qn, Eo.jsxs = Cn;
  }()), Eo;
}
process.env.NODE_ENV === "production" ? Pu.exports = Fb() : Pu.exports = Ib();
var F = Pu.exports;
function Rb(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ F.jsx("div", { className: r.trim(), ...n });
}
const Nv = ht({});
function _b() {
  return Ae(Nv);
}
function i_(e) {
  const { schema: t, children: n, className: r, ...o } = e, s = !((l) => {
    let c = !1;
    const f = (p) => {
      Array.isArray(p) ? p.forEach(f) : p && typeof p == "object" && "type" in p && (p.type === Rb ? c = !0 : p.props && p.props.children && f(p.props.children));
    };
    return f(l), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", u = `arkynAlertContainer ${t} ${s} ${r}`;
  return /* @__PURE__ */ F.jsx(Nv.Provider, { value: e, children: /* @__PURE__ */ F.jsx("div", { className: u.trim(), ...o, children: n }) });
}
function a_(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ F.jsx("div", { className: r.trim(), ...n });
}
function s_(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ F.jsx("div", { className: r.trim(), ...n });
}
function u_(e) {
  const { className: t, ...n } = e, { schema: r } = _b(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ F.jsx(Tv, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ F.jsx(Bv, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ F.jsx(vb, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ F.jsx(Pv, { className: o, ...n });
  }
}
function va(e, t) {
  return t ? /* @__PURE__ */ F.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ F.jsx(F.Fragment, {});
}
function zv(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function jb(e, t, n) {
  return e >= n ? [] : zv(e, e + t);
}
function Nb(e, t) {
  return e <= 1 ? [] : zv(e - 1 - t, e - 1);
}
function zb(e, t, n) {
  if (!e) return /* @__PURE__ */ F.jsx(F.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ F.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ F.jsx("p", { className: n, children: /* @__PURE__ */ F.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function l_(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: a = "",
    children: s,
    ...u
  } = e, c = { md: 12, lg: 14 }[r], f = `arkynBadge ${t} ${n} ${r} ${a}`;
  return /* @__PURE__ */ F.jsxs("div", { className: f.trim(), ...u, children: [
    va(c, o),
    s,
    va(c, o)
  ] });
}
function c_(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ F.jsx("div", { className: r.trim(), ...n });
}
function f_(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ F.jsx("div", { className: o.trim(), ...r });
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Bu = function(e, t) {
  return Bu = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
  }, Bu(e, t);
};
function yt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Bu(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Pe = function() {
  return Pe = Object.assign || function(t) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, Pe.apply(this, arguments);
};
function Ml(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function $b(e, t, n, r) {
  function o(i) {
    return i instanceof n ? i : new n(function(a) {
      a(i);
    });
  }
  return new (n || (n = Promise))(function(i, a) {
    function s(c) {
      try {
        l(r.next(c));
      } catch (f) {
        a(f);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (f) {
        a(f);
      }
    }
    function l(c) {
      c.done ? i(c.value) : o(c.value).then(s, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
}
function Ub(e, t) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, o, i, a;
  return a = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function s(l) {
    return function(c) {
      return u([l, c]);
    };
  }
  function u(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, o && (i = l[0] & 2 ? o.return : l[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, l[1])).done) return i;
      switch (o = 0, i && (l = [l[0] & 2, i.value]), l[0]) {
        case 0:
        case 1:
          i = l;
          break;
        case 4:
          return n.label++, { value: l[1], done: !1 };
        case 5:
          n.label++, o = l[1], l = [0];
          continue;
        case 7:
          l = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            n = 0;
            continue;
          }
          if (l[0] === 3 && (!i || l[1] > i[0] && l[1] < i[3])) {
            n.label = l[1];
            break;
          }
          if (l[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = l;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(l);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      l = t.call(e, n);
    } catch (c) {
      l = [6, c], o = 0;
    } finally {
      r = i = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function $v(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Wb = process.env.NODE_ENV, Hb = function(e, t, n, r, o, i, a, s) {
  if (Wb !== "production" && t === void 0)
    throw new Error("invariant requires an error message argument");
  if (!e) {
    var u;
    if (t === void 0)
      u = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var l = [n, r, o, i, a, s], c = 0;
      u = new Error(
        t.replace(/%s/g, function() {
          return l[c++];
        })
      ), u.name = "Invariant Violation";
    }
    throw u.framesToPop = 1, u;
  }
}, Vb = Hb, Nt = /* @__PURE__ */ $v(Vb), We = ht(null);
function qb() {
  Nt(!!Ae, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Ae(We);
  return Nt(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Zb(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function Gb(e, t) {
  Object.keys(e).forEach(function(n) {
    return t(e[n], n);
  });
}
function Kb(e, t, n, r) {
  var o = {}, i = function(a, s) {
    var u = n[s];
    u !== t[s] && (o[s] = u, a(r, u));
  };
  return Gb(e, i), o;
}
function Yb(e, t, n) {
  var r = Zb(n, function(i, a, s) {
    return typeof e[s] == "function" && i.push(google.maps.event.addListener(t, a, e[s])), i;
  }, []);
  return r;
}
function Xb(e) {
  google.maps.event.removeListener(e);
}
function Qe(e) {
  e === void 0 && (e = []), e.forEach(Xb);
}
function Ge(e) {
  var t = e.updaterMap, n = e.eventMap, r = e.prevProps, o = e.nextProps, i = e.instance, a = Yb(o, i, n);
  return Kb(t, r, o, i), a;
}
var Jc = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, Qc = {
  extraMapTypes: function(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center: function(e, t) {
    e.setCenter(t);
  },
  clickableIcons: function(e, t) {
    e.setClickableIcons(t);
  },
  heading: function(e, t) {
    e.setHeading(t);
  },
  mapTypeId: function(e, t) {
    e.setMapTypeId(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  streetView: function(e, t) {
    e.setStreetView(t);
  },
  tilt: function(e, t) {
    e.setTilt(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
function Jb(e) {
  var t = e.children, n = e.options, r = e.id, o = e.mapContainerStyle, i = e.mapContainerClassName, a = e.center, s = e.onClick, u = e.onDblClick, l = e.onDrag, c = e.onDragEnd, f = e.onDragStart, p = e.onMouseMove, g = e.onMouseOut, v = e.onMouseOver, h = e.onMouseDown, d = e.onMouseUp, w = e.onRightClick, L = e.onCenterChanged, D = e.onLoad, B = e.onUnmount, b = P(null), E = b[0], O = b[1], S = rt(null), V = P(null), M = V[0], q = V[1], _ = P(null), j = _[0], I = _[1], z = P(null), X = z[0], R = z[1], ee = P(null), re = ee[0], k = ee[1], A = P(null), G = A[0], U = A[1], Y = P(null), K = Y[0], m = Y[1], $ = P(null), W = $[0], T = $[1], J = P(null), te = J[0], N = J[1], se = P(null), ue = se[0], de = se[1], ge = P(null), Ce = ge[0], me = ge[1], ye = P(null), ce = ye[0], Me = ye[1], ie = P(null), Re = ie[0], ae = ie[1];
  return y(function() {
    n && E !== null && E.setOptions(n);
  }, [E, n]), y(function() {
    E !== null && typeof a < "u" && E.setCenter(a);
  }, [E, a]), y(function() {
    E && u && (j !== null && google.maps.event.removeListener(j), I(google.maps.event.addListener(E, "dblclick", u)));
  }, [u]), y(function() {
    E && c && (X !== null && google.maps.event.removeListener(X), R(google.maps.event.addListener(E, "dragend", c)));
  }, [c]), y(function() {
    E && f && (re !== null && google.maps.event.removeListener(re), k(google.maps.event.addListener(E, "dragstart", f)));
  }, [f]), y(function() {
    E && h && (G !== null && google.maps.event.removeListener(G), U(google.maps.event.addListener(E, "mousedown", h)));
  }, [h]), y(function() {
    E && p && (K !== null && google.maps.event.removeListener(K), m(google.maps.event.addListener(E, "mousemove", p)));
  }, [p]), y(function() {
    E && g && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(E, "mouseout", g)));
  }, [g]), y(function() {
    E && v && (te !== null && google.maps.event.removeListener(te), N(google.maps.event.addListener(E, "mouseover", v)));
  }, [v]), y(function() {
    E && d && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(E, "mouseup", d)));
  }, [d]), y(function() {
    E && w && (Ce !== null && google.maps.event.removeListener(Ce), me(google.maps.event.addListener(E, "rightclick", w)));
  }, [w]), y(function() {
    E && s && (ce !== null && google.maps.event.removeListener(ce), Me(google.maps.event.addListener(E, "click", s)));
  }, [s]), y(function() {
    E && l && (Re !== null && google.maps.event.removeListener(Re), ae(google.maps.event.addListener(E, "drag", l)));
  }, [l]), y(function() {
    E && L && (M !== null && google.maps.event.removeListener(M), q(google.maps.event.addListener(E, "center_changed", L)));
  }, [s]), y(function() {
    var Le = S.current === null ? null : new google.maps.Map(S.current, n);
    return O(Le), Le !== null && D && D(Le), function() {
      Le !== null && B && B(Le);
    };
  }, []), F.jsx("div", { id: r, ref: S, style: o, className: i, children: F.jsx(We.Provider, { value: E, children: E !== null ? t : null }) });
}
Ze(Jb);
var Qb = (
  /** @class */
  function(e) {
    yt(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.state = {
        map: null
      }, n.registeredEvents = [], n.mapRef = null, n.getInstance = function() {
        return n.mapRef === null ? null : new google.maps.Map(n.mapRef, n.props.options);
      }, n.panTo = function(r) {
        var o = n.getInstance();
        o && o.panTo(r);
      }, n.setMapCallback = function() {
        n.state.map !== null && n.props.onLoad && n.props.onLoad(n.state.map);
      }, n.getRef = function(r) {
        n.mapRef = r;
      }, n;
    }
    return t.prototype.componentDidMount = function() {
      var n = this.getInstance();
      this.registeredEvents = Ge({
        updaterMap: Qc,
        eventMap: Jc,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          map: n
        };
      }, this.setMapCallback);
    }, t.prototype.componentDidUpdate = function(n) {
      this.state.map !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
        updaterMap: Qc,
        eventMap: Jc,
        prevProps: n,
        nextProps: this.props,
        instance: this.state.map
      }));
    }, t.prototype.componentWillUnmount = function() {
      this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), Qe(this.registeredEvents));
    }, t.prototype.render = function() {
      return F.jsx("div", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName, children: F.jsx(We.Provider, { value: this.state.map, children: this.state.map !== null ? this.props.children : null }) });
    }, t;
  }(Te)
), Gr = typeof document < "u";
function Uv(e) {
  var t = e.url, n = e.id, r = e.nonce;
  return Gr ? new Promise(function(i, a) {
    var s = document.getElementById(n), u = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return i(n);
        var c = u.initMap, f = s.onerror;
        u.initMap = function() {
          c && c(), i(n);
        }, s.onerror = function(g) {
          f && f(g), a(g);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(v) {
      p.setAttribute("data-state", "error"), a(v);
    }, u.initMap = function() {
      p.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(p);
  }).catch(function(o) {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function ef(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Wv() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return ef(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return ef(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
function Hv(e) {
  var t = e.googleMapsApiKey, n = e.googleMapsClientId, r = e.version, o = r === void 0 ? "weekly" : r, i = e.language, a = e.region, s = e.libraries, u = e.channel, l = e.mapIds, c = e.authReferrerPolicy, f = [];
  return Nt(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? f.push("key=".concat(t)) : n && f.push("client=".concat(n)), o && f.push("v=".concat(o)), i && f.push("language=".concat(i)), a && f.push("region=".concat(a)), s && s.length && f.push("libraries=".concat(s.sort().join(","))), u && f.push("channel=".concat(u)), l && l.length && f.push("map_ids=".concat(l.join(","))), c && f.push("auth_referrer_policy=".concat(c)), f.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(f.join("&"));
}
var Do = !1;
function Vv() {
  return F.jsx("div", { children: "Loading..." });
}
var Tu = {
  id: "script-loader",
  version: "weekly"
}, eC = (
  /** @class */
  function(e) {
    yt(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.check = Mr(), n.state = {
        loaded: !1
      }, n.cleanupCallback = function() {
        delete window.google.maps, n.injectScript();
      }, n.isCleaningUp = function() {
        return $b(n, void 0, void 0, function() {
          function r(o) {
            if (!Do)
              o();
            else if (Gr)
              var i = window.setInterval(function() {
                Do || (window.clearInterval(i), o());
              }, 1);
          }
          return Ub(this, function(o) {
            return [2, new Promise(r)];
          });
        });
      }, n.cleanup = function() {
        Do = !0;
        var r = document.getElementById(n.props.id);
        r && r.parentNode && r.parentNode.removeChild(r), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(i) {
          return typeof i.src == "string" && i.src.includes("maps.googleapis");
        }).forEach(function(i) {
          i.parentNode && i.parentNode.removeChild(i);
        }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(i) {
          return i.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
        }).forEach(function(i) {
          i.parentNode && i.parentNode.removeChild(i);
        }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(i) {
          return i.innerText !== void 0 && i.innerText.length > 0 && i.innerText.includes(".gm-");
        }).forEach(function(i) {
          i.parentNode && i.parentNode.removeChild(i);
        });
      }, n.injectScript = function() {
        n.props.preventGoogleFontsLoading && Wv(), Nt(!!n.props.id, 'LoadScript requires "id" prop to be a string: %s', n.props.id);
        var r = {
          id: n.props.id,
          nonce: n.props.nonce,
          url: Hv(n.props)
        };
        Uv(r).then(function() {
          n.props.onLoad && n.props.onLoad(), n.setState(function() {
            return {
              loaded: !0
            };
          });
        }).catch(function(o) {
          n.props.onError && n.props.onError(o), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(n.props.googleMapsApiKey || "-", ") or Client ID (").concat(n.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
        });
      }, n;
    }
    return t.prototype.componentDidMount = function() {
      if (Gr) {
        if (window.google && window.google.maps && !Do) {
          console.error("google api is already presented");
          return;
        }
        this.isCleaningUp().then(this.injectScript).catch(function(r) {
          console.error("Error at injecting script after cleaning up: ", r);
        });
      }
    }, t.prototype.componentDidUpdate = function(n) {
      this.props.libraries !== n.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), Gr && n.language !== this.props.language && (this.cleanup(), this.setState(function() {
        return {
          loaded: !1
        };
      }, this.cleanupCallback));
    }, t.prototype.componentWillUnmount = function() {
      var n = this;
      if (Gr) {
        this.cleanup();
        var r = function() {
          n.check.current || (delete window.google, Do = !1);
        };
        window.setTimeout(r, 1), this.props.onUnmount && this.props.onUnmount();
      }
    }, t.prototype.render = function() {
      return F.jsxs(F.Fragment, { children: [F.jsx("div", { ref: this.check }), this.state.loaded ? this.props.children : this.props.loadingElement || F.jsx(Vv, {})] });
    }, t.defaultProps = Tu, t;
  }(Te)
), tf;
function tC(e) {
  var t = e.id, n = t === void 0 ? Tu.id : t, r = e.version, o = r === void 0 ? Tu.version : r, i = e.nonce, a = e.googleMapsApiKey, s = e.googleMapsClientId, u = e.language, l = e.region, c = e.libraries, f = e.preventGoogleFontsLoading, p = e.channel, g = e.mapIds, v = e.authReferrerPolicy, h = rt(!1), d = P(!1), w = d[0], L = d[1], D = P(void 0), B = D[0], b = D[1];
  y(function() {
    return h.current = !0, function() {
      h.current = !1;
    };
  }, []), y(function() {
    Gr && f && Wv();
  }, [f]), y(function() {
    w && Nt(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [w]);
  var E = Hv({
    version: o,
    googleMapsApiKey: a,
    googleMapsClientId: s,
    language: u,
    region: l,
    libraries: c,
    channel: p,
    mapIds: g,
    authReferrerPolicy: v
  });
  y(function() {
    if (!Gr)
      return;
    function V() {
      h.current && (L(!0), tf = E);
    }
    if (window.google && window.google.maps && tf === E) {
      V();
      return;
    }
    Uv({ id: n, url: E, nonce: i }).then(V).catch(function(q) {
      h.current && b(q), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(a || "-", ") or Client ID (").concat(s || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(q);
    });
  }, [n, E, i]);
  var O = rt();
  return y(function() {
    O.current && c !== O.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), O.current = c;
  }, [c]), { isLoaded: w, loadError: B, url: E };
}
var nC = F.jsx(Vv, {});
function rC(e) {
  var t = e.loadingElement, n = e.onLoad, r = e.onError, o = e.onUnmount, i = e.children, a = Ml(e, ["loadingElement", "onLoad", "onError", "onUnmount", "children"]), s = tC(a), u = s.isLoaded, l = s.loadError;
  return y(function() {
    u && typeof n == "function" && n();
  }, [u, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return function() {
      o && o();
    };
  }, [o]), u ? i : t || nC;
}
Ze(rC);
var nf;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(nf || (nf = {}));
var rf = {}, of = {
  options: function(e, t) {
    e.setOptions(t);
  }
};
function oC(e) {
  var t = e.options, n = e.onLoad, r = e.onUnmount, o = Ae(We), i = P(null), a = i[0], s = i[1];
  return y(function() {
    a !== null && a.setMap(o);
  }, [o]), y(function() {
    t && a !== null && a.setOptions(t);
  }, [a, t]), y(function() {
    var u = new google.maps.TrafficLayer(Pe(Pe({}, t || {}), { map: o }));
    return s(u), n && n(u), function() {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Ze(oC);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      trafficLayer: null
    }, n.setTrafficLayerCallback = function() {
      n.state.trafficLayer !== null && n.props.onLoad && n.props.onLoad(n.state.trafficLayer);
    }, n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TrafficLayer(Pe(Pe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ge({
      updaterMap: of,
      eventMap: rf,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        trafficLayer: n
      };
    }, this.setTrafficLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.trafficLayer !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: of,
      eventMap: rf,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Qe(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = We, t;
})(Te);
function iC(e) {
  var t = e.onLoad, n = e.onUnmount, r = Ae(We), o = P(null), i = o[0], a = o[1];
  return y(function() {
    i !== null && i.setMap(r);
  }, [r]), y(function() {
    var s = new google.maps.BicyclingLayer();
    return a(s), s.setMap(r), t && t(s), function() {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
Ze(iC);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      bicyclingLayer: null
    }, n.setBicyclingLayerCallback = function() {
      n.state.bicyclingLayer !== null && (n.state.bicyclingLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.bicyclingLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.BicyclingLayer();
    this.setState(function() {
      return {
        bicyclingLayer: n
      };
    }, this.setBicyclingLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = We, t;
})(Te);
function aC(e) {
  var t = e.onLoad, n = e.onUnmount, r = Ae(We), o = P(null), i = o[0], a = o[1];
  return y(function() {
    i !== null && i.setMap(r);
  }, [r]), y(function() {
    var s = new google.maps.TransitLayer();
    return a(s), s.setMap(r), t && t(s), function() {
      i !== null && (n && n(i), i.setMap(null));
    };
  }, []), null;
}
Ze(aC);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      transitLayer: null
    }, n.setTransitLayerCallback = function() {
      n.state.transitLayer !== null && (n.state.transitLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.transitLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: n
      };
    }, this.setTransitLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = We, t;
})(Te);
var af = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, sf = {
  drawingMode: function(e, t) {
    e.setDrawingMode(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function sC(e) {
  var t = e.options, n = e.drawingMode, r = e.onCircleComplete, o = e.onMarkerComplete, i = e.onOverlayComplete, a = e.onPolygonComplete, s = e.onPolylineComplete, u = e.onRectangleComplete, l = e.onLoad, c = e.onUnmount, f = Ae(We), p = P(null), g = p[0], v = p[1], h = P(null), d = h[0], w = h[1], L = P(null), D = L[0], B = L[1], b = P(null), E = b[0], O = b[1], S = P(null), V = S[0], M = S[1], q = P(null), _ = q[0], j = q[1], I = P(null), z = I[0], X = I[1];
  return y(function() {
    g !== null && g.setMap(f);
  }, [f]), y(function() {
    t && g !== null && g.setOptions(t);
  }, [g, t]), y(function() {
    g !== null && g.setDrawingMode(n ?? null);
  }, [g, n]), y(function() {
    g && r && (d !== null && google.maps.event.removeListener(d), w(google.maps.event.addListener(g, "circlecomplete", r)));
  }, [g, r]), y(function() {
    g && o && (D !== null && google.maps.event.removeListener(D), B(google.maps.event.addListener(g, "markercomplete", o)));
  }, [g, o]), y(function() {
    g && i && (E !== null && google.maps.event.removeListener(E), O(google.maps.event.addListener(g, "overlaycomplete", i)));
  }, [g, i]), y(function() {
    g && a && (V !== null && google.maps.event.removeListener(V), M(google.maps.event.addListener(g, "polygoncomplete", a)));
  }, [g, a]), y(function() {
    g && s && (_ !== null && google.maps.event.removeListener(_), j(google.maps.event.addListener(g, "polylinecomplete", s)));
  }, [g, s]), y(function() {
    g && u && (z !== null && google.maps.event.removeListener(z), X(google.maps.event.addListener(g, "rectanglecomplete", u)));
  }, [g, u]), y(function() {
    Nt(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(Pe(Pe({}, t || {}), { map: f }));
    return n && R.setDrawingMode(n), r && w(google.maps.event.addListener(R, "circlecomplete", r)), o && B(google.maps.event.addListener(R, "markercomplete", o)), i && O(google.maps.event.addListener(R, "overlaycomplete", i)), a && M(google.maps.event.addListener(R, "polygoncomplete", a)), s && j(google.maps.event.addListener(R, "polylinecomplete", s)), u && X(google.maps.event.addListener(R, "rectanglecomplete", u)), v(R), l && l(R), function() {
      g !== null && (d && google.maps.event.removeListener(d), D && google.maps.event.removeListener(D), E && google.maps.event.removeListener(E), V && google.maps.event.removeListener(V), _ && google.maps.event.removeListener(_), z && google.maps.event.removeListener(z), c && c(g), g.setMap(null));
    };
  }, []), null;
}
Ze(sC);
(function(e) {
  yt(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    return r.registeredEvents = [], r.state = {
      drawingManager: null
    }, r.setDrawingManagerCallback = function() {
      r.state.drawingManager !== null && r.props.onLoad && r.props.onLoad(r.state.drawingManager);
    }, Nt(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing), r;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.drawing.DrawingManager(Pe(Pe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ge({
      updaterMap: sf,
      eventMap: af,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        drawingManager: n
      };
    }, this.setDrawingManagerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.drawingManager !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: sf,
      eventMap: af,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Qe(this.registeredEvents), this.state.drawingManager.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = We, t;
})(Te);
var uf = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, lf = {
  animation: function(e, t) {
    e.setAnimation(t);
  },
  clickable: function(e, t) {
    e.setClickable(t);
  },
  cursor: function(e, t) {
    e.setCursor(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  icon: function(e, t) {
    e.setIcon(t);
  },
  label: function(e, t) {
    e.setLabel(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  opacity: function(e, t) {
    e.setOpacity(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  shape: function(e, t) {
    e.setShape(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, ma = {};
function uC(e) {
  var t = e.position, n = e.options, r = e.clusterer, o = e.noClustererRedraw, i = e.children, a = e.draggable, s = e.visible, u = e.animation, l = e.clickable, c = e.cursor, f = e.icon, p = e.label, g = e.opacity, v = e.shape, h = e.title, d = e.zIndex, w = e.onClick, L = e.onDblClick, D = e.onDrag, B = e.onDragEnd, b = e.onDragStart, E = e.onMouseOut, O = e.onMouseOver, S = e.onMouseUp, V = e.onMouseDown, M = e.onRightClick, q = e.onClickableChanged, _ = e.onCursorChanged, j = e.onAnimationChanged, I = e.onDraggableChanged, z = e.onFlatChanged, X = e.onIconChanged, R = e.onPositionChanged, ee = e.onShapeChanged, re = e.onTitleChanged, k = e.onVisibleChanged, A = e.onZindexChanged, G = e.onLoad, U = e.onUnmount, Y = Ae(We), K = P(null), m = K[0], $ = K[1], W = P(null), T = W[0], J = W[1], te = P(null), N = te[0], se = te[1], ue = P(null), de = ue[0], ge = ue[1], Ce = P(null), me = Ce[0], ye = Ce[1], ce = P(null), Me = ce[0], ie = ce[1], Re = P(null), ae = Re[0], Le = Re[1], Fe = P(null), ze = Fe[0], Ye = Fe[1], we = P(null), Ct = we[0], ot = we[1], Jt = P(null), _t = Jt[0], $t = Jt[1], dn = P(null), pn = dn[0], hn = dn[1], gn = P(null), jt = gn[0], Qt = gn[1], Ut = P(null), Zt = Ut[0], vn = Ut[1], In = P(null), mn = In[0], Rn = In[1], Yn = P(null), en = Yn[0], _n = Yn[1], Xn = P(null), yn = Xn[0], jn = Xn[1], Nn = P(null), bn = Nn[0], Jn = Nn[1], Qn = P(null), Cn = Qn[0], C = Qn[1], Z = P(null), Q = Z[0], fe = Z[1], De = P(null), ke = De[0], Ee = De[1], be = P(null), $e = be[0], Ie = be[1], _e = P(null), nt = _e[0], Wt = _e[1];
  y(function() {
    m !== null && m.setMap(Y);
  }, [Y]), y(function() {
    typeof n < "u" && m !== null && m.setOptions(n);
  }, [m, n]), y(function() {
    typeof a < "u" && m !== null && m.setDraggable(a);
  }, [m, a]), y(function() {
    t && m !== null && m.setPosition(t);
  }, [m, t]), y(function() {
    typeof s < "u" && m !== null && m.setVisible(s);
  }, [m, s]), y(function() {
    m == null || m.setAnimation(u);
  }, [m, u]), y(function() {
    m && l !== void 0 && m.setClickable(l);
  }, [m, l]), y(function() {
    m && c !== void 0 && m.setCursor(c);
  }, [m, c]), y(function() {
    m && f !== void 0 && m.setIcon(f);
  }, [m, f]), y(function() {
    m && p !== void 0 && m.setLabel(p);
  }, [m, p]), y(function() {
    m && g !== void 0 && m.setOpacity(g);
  }, [m, g]), y(function() {
    m && v !== void 0 && m.setShape(v);
  }, [m, v]), y(function() {
    m && h !== void 0 && m.setTitle(h);
  }, [m, h]), y(function() {
    m && d !== void 0 && m.setZIndex(d);
  }, [m, d]), y(function() {
    m && L && (T !== null && google.maps.event.removeListener(T), J(google.maps.event.addListener(m, "dblclick", L)));
  }, [L]), y(function() {
    m && B && (N !== null && google.maps.event.removeListener(N), se(google.maps.event.addListener(m, "dragend", B)));
  }, [B]), y(function() {
    m && b && (de !== null && google.maps.event.removeListener(de), ge(google.maps.event.addListener(m, "dragstart", b)));
  }, [b]), y(function() {
    m && V && (me !== null && google.maps.event.removeListener(me), ye(google.maps.event.addListener(m, "mousedown", V)));
  }, [V]), y(function() {
    m && E && (Me !== null && google.maps.event.removeListener(Me), ie(google.maps.event.addListener(m, "mouseout", E)));
  }, [E]), y(function() {
    m && O && (ae !== null && google.maps.event.removeListener(ae), Le(google.maps.event.addListener(m, "mouseover", O)));
  }, [O]), y(function() {
    m && S && (ze !== null && google.maps.event.removeListener(ze), Ye(google.maps.event.addListener(m, "mouseup", S)));
  }, [S]), y(function() {
    m && M && (Ct !== null && google.maps.event.removeListener(Ct), ot(google.maps.event.addListener(m, "rightclick", M)));
  }, [M]), y(function() {
    m && w && (_t !== null && google.maps.event.removeListener(_t), $t(google.maps.event.addListener(m, "click", w)));
  }, [w]), y(function() {
    m && D && (pn !== null && google.maps.event.removeListener(pn), hn(google.maps.event.addListener(m, "drag", D)));
  }, [D]), y(function() {
    m && q && (jt !== null && google.maps.event.removeListener(jt), Qt(google.maps.event.addListener(m, "clickable_changed", q)));
  }, [q]), y(function() {
    m && _ && (Zt !== null && google.maps.event.removeListener(Zt), vn(google.maps.event.addListener(m, "cursor_changed", _)));
  }, [_]), y(function() {
    m && j && (mn !== null && google.maps.event.removeListener(mn), Rn(google.maps.event.addListener(m, "animation_changed", j)));
  }, [j]), y(function() {
    m && I && (en !== null && google.maps.event.removeListener(en), _n(google.maps.event.addListener(m, "draggable_changed", I)));
  }, [I]), y(function() {
    m && z && (yn !== null && google.maps.event.removeListener(yn), jn(google.maps.event.addListener(m, "flat_changed", z)));
  }, [z]), y(function() {
    m && X && (bn !== null && google.maps.event.removeListener(bn), Jn(google.maps.event.addListener(m, "icon_changed", X)));
  }, [X]), y(function() {
    m && R && (Cn !== null && google.maps.event.removeListener(Cn), C(google.maps.event.addListener(m, "position_changed", R)));
  }, [R]), y(function() {
    m && ee && (Q !== null && google.maps.event.removeListener(Q), fe(google.maps.event.addListener(m, "shape_changed", ee)));
  }, [ee]), y(function() {
    m && re && (ke !== null && google.maps.event.removeListener(ke), Ee(google.maps.event.addListener(m, "title_changed", re)));
  }, [re]), y(function() {
    m && k && ($e !== null && google.maps.event.removeListener($e), Ie(google.maps.event.addListener(m, "visible_changed", k)));
  }, [k]), y(function() {
    m && A && (nt !== null && google.maps.event.removeListener(nt), Wt(google.maps.event.addListener(m, "zindex_changed", A)));
  }, [A]), y(function() {
    var Ue = Pe(Pe(Pe({}, n || ma), r ? ma : { map: Y }), { position: t }), he = new google.maps.Marker(Ue);
    return r ? r.addMarker(he, !!o) : he.setMap(Y), t && he.setPosition(t), typeof s < "u" && he.setVisible(s), typeof a < "u" && he.setDraggable(a), typeof l < "u" && he.setClickable(l), typeof c == "string" && he.setCursor(c), f && he.setIcon(f), typeof p < "u" && he.setLabel(p), typeof g < "u" && he.setOpacity(g), v && he.setShape(v), typeof h == "string" && he.setTitle(h), typeof d == "number" && he.setZIndex(d), L && J(google.maps.event.addListener(he, "dblclick", L)), B && se(google.maps.event.addListener(he, "dragend", B)), b && ge(google.maps.event.addListener(he, "dragstart", b)), V && ye(google.maps.event.addListener(he, "mousedown", V)), E && ie(google.maps.event.addListener(he, "mouseout", E)), O && Le(google.maps.event.addListener(he, "mouseover", O)), S && Ye(google.maps.event.addListener(he, "mouseup", S)), M && ot(google.maps.event.addListener(he, "rightclick", M)), w && $t(google.maps.event.addListener(he, "click", w)), D && hn(google.maps.event.addListener(he, "drag", D)), q && Qt(google.maps.event.addListener(he, "clickable_changed", q)), _ && vn(google.maps.event.addListener(he, "cursor_changed", _)), j && Rn(google.maps.event.addListener(he, "animation_changed", j)), I && _n(google.maps.event.addListener(he, "draggable_changed", I)), z && jn(google.maps.event.addListener(he, "flat_changed", z)), X && Jn(google.maps.event.addListener(he, "icon_changed", X)), R && C(google.maps.event.addListener(he, "position_changed", R)), ee && fe(google.maps.event.addListener(he, "shape_changed", ee)), re && Ee(google.maps.event.addListener(he, "title_changed", re)), k && Ie(google.maps.event.addListener(he, "visible_changed", k)), A && Wt(google.maps.event.addListener(he, "zindex_changed", A)), $(he), G && G(he), function() {
      T !== null && google.maps.event.removeListener(T), N !== null && google.maps.event.removeListener(N), de !== null && google.maps.event.removeListener(de), me !== null && google.maps.event.removeListener(me), Me !== null && google.maps.event.removeListener(Me), ae !== null && google.maps.event.removeListener(ae), ze !== null && google.maps.event.removeListener(ze), Ct !== null && google.maps.event.removeListener(Ct), _t !== null && google.maps.event.removeListener(_t), jt !== null && google.maps.event.removeListener(jt), Zt !== null && google.maps.event.removeListener(Zt), mn !== null && google.maps.event.removeListener(mn), en !== null && google.maps.event.removeListener(en), yn !== null && google.maps.event.removeListener(yn), bn !== null && google.maps.event.removeListener(bn), Cn !== null && google.maps.event.removeListener(Cn), ke !== null && google.maps.event.removeListener(ke), $e !== null && google.maps.event.removeListener($e), nt !== null && google.maps.event.removeListener(nt), U && U(he), r ? r.removeMarker(he, !!o) : he && he.setMap(null);
    };
  }, []);
  var Ht = Ln(function() {
    return i ? Vt.map(i, function(Ue) {
      if (!Ia(Ue))
        return Ue;
      var he = Ue;
      return Ra(he, { anchor: m });
    }) : null;
  }, [i, m]);
  return F.jsx(F.Fragment, { children: Ht }) || null;
}
Ze(uC);
var lC = (
  /** @class */
  function(e) {
    yt(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.registeredEvents = [], n;
    }
    return t.prototype.componentDidMount = function() {
      var n = Pe(Pe(Pe({}, this.props.options || ma), this.props.clusterer ? ma : { map: this.context }), { position: this.props.position });
      this.marker = new google.maps.Marker(n), this.props.clusterer ? this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw) : this.marker.setMap(this.context), this.registeredEvents = Ge({
        updaterMap: lf,
        eventMap: uf,
        prevProps: {},
        nextProps: this.props,
        instance: this.marker
      }), this.props.onLoad && this.props.onLoad(this.marker);
    }, t.prototype.componentDidUpdate = function(n) {
      this.marker && (Qe(this.registeredEvents), this.registeredEvents = Ge({
        updaterMap: lf,
        eventMap: uf,
        prevProps: n,
        nextProps: this.props,
        instance: this.marker
      }));
    }, t.prototype.componentWillUnmount = function() {
      this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Qe(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
    }, t.prototype.render = function() {
      var n = this, r = null;
      return this.props.children && (r = Vt.map(this.props.children, function(o) {
        if (!Ia(o))
          return o;
        var i = o;
        return Ra(i, { anchor: n.marker });
      })), r || null;
    }, t.contextType = We, t;
  }(Te)
), cC = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, u = this.backgroundPosition.split(" "), l = parseInt(((t = u[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = u[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), f = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(f !== null ? "".concat(f.y, "px") : "0", "; left: ").concat(f !== null ? "".concat(f.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var p = document.createElement("img");
        p.alt = s, p.src = this.url, p.width = this.width, p.height = this.height, p.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(l, "px")), this.cluster.getClusterer().enableRetinaIcons || (p.style.clip = "rect(-".concat(c, "px, -").concat(l + this.width, "px, -").concat(c + this.height, ", -").concat(l, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(p), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), fC = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new cC(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var u = 0, l = this.markers; u < l.length; u++) {
          var c = l[u];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function dC(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var pC = 2e3, hC = 500, gC = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", vC = "png", mC = [53, 56, 66, 78, 90], yC = "cluster", qv = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || gC, this.imageExtension = r.imageExtension || vC, this.imageSizes = r.imageSizes || mC, this.calculator = r.calculator || dC, this.batchSize = r.batchSize || pC, this.batchSizeIE = r.batchSizeIE || hC, this.clusterClass = r.clusterClass || yC, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [
        google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged),
        google.maps.event.addListener(t, "idle", this.onIdle)
      ]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, u = this.listeners; s < u.length; s++) {
        var l = u[s];
        google.maps.event.removeListener(l);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var u = n.getCenter(), l = t.getPosition();
        if (u && l) {
          var c = this.distanceBetweenPoints(u, l);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new fC(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), u = Math.min(t + this.batchSize, this.markers.length), l = t; l < u; l++) {
          var c = this.markers[l];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (u < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(u);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var f = 0, p = this.clusters; f < p.length; f++) {
            var g = p[f];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var a = i;
          this.prototype[a] = o.prototype[a];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Bn = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, it = {
  averageCenter: function(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE: function(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator: function(e, t) {
    e.setCalculator(t);
  },
  clusterClass: function(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons: function(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize: function(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden: function(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension: function(e, t) {
    e.setImageExtension(t);
  },
  imagePath: function(e, t) {
    e.setImagePath(t);
  },
  imageSizes: function(e, t) {
    e.setImageSizes(t);
  },
  maxZoom: function(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize: function(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles: function(e, t) {
    e.setStyles(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  zoomOnClick: function(e, t) {
    e.setZoomOnClick(t);
  }
}, bC = {};
function CC(e) {
  var t = e.children, n = e.options, r = e.averageCenter, o = e.batchSizeIE, i = e.calculator, a = e.clusterClass, s = e.enableRetinaIcons, u = e.gridSize, l = e.ignoreHidden, c = e.imageExtension, f = e.imagePath, p = e.imageSizes, g = e.maxZoom, v = e.minimumClusterSize, h = e.styles, d = e.title, w = e.zoomOnClick, L = e.onClick, D = e.onClusteringBegin, B = e.onClusteringEnd, b = e.onMouseOver, E = e.onMouseOut, O = e.onLoad, S = e.onUnmount, V = P(null), M = V[0], q = V[1], _ = Ae(We), j = P(null), I = j[0], z = j[1], X = P(null), R = X[0], ee = X[1], re = P(null), k = re[0], A = re[1], G = P(null), U = G[0], Y = G[1], K = P(null), m = K[0], $ = K[1];
  return y(function() {
    M && E && (U !== null && google.maps.event.removeListener(U), Y(google.maps.event.addListener(M, Bn.onMouseOut, E)));
  }, [E]), y(function() {
    M && b && (m !== null && google.maps.event.removeListener(m), $(google.maps.event.addListener(M, Bn.onMouseOver, b)));
  }, [b]), y(function() {
    M && L && (I !== null && google.maps.event.removeListener(I), z(google.maps.event.addListener(M, Bn.onClick, L)));
  }, [L]), y(function() {
    M && D && (R !== null && google.maps.event.removeListener(R), ee(google.maps.event.addListener(M, Bn.onClusteringBegin, D)));
  }, [D]), y(function() {
    M && B && (k !== null && google.maps.event.removeListener(k), ee(google.maps.event.addListener(M, Bn.onClusteringEnd, B)));
  }, [B]), y(function() {
    typeof r < "u" && M !== null && it.averageCenter(M, r);
  }, [M, r]), y(function() {
    typeof o < "u" && M !== null && it.batchSizeIE(M, o);
  }, [M, o]), y(function() {
    typeof i < "u" && M !== null && it.calculator(M, i);
  }, [M, i]), y(function() {
    typeof a < "u" && M !== null && it.clusterClass(M, a);
  }, [M, a]), y(function() {
    typeof s < "u" && M !== null && it.enableRetinaIcons(M, s);
  }, [M, s]), y(function() {
    typeof u < "u" && M !== null && it.gridSize(M, u);
  }, [M, u]), y(function() {
    typeof l < "u" && M !== null && it.ignoreHidden(M, l);
  }, [M, l]), y(function() {
    typeof c < "u" && M !== null && it.imageExtension(M, c);
  }, [M, c]), y(function() {
    typeof f < "u" && M !== null && it.imagePath(M, f);
  }, [M, f]), y(function() {
    typeof p < "u" && M !== null && it.imageSizes(M, p);
  }, [M, p]), y(function() {
    typeof g < "u" && M !== null && it.maxZoom(M, g);
  }, [M, g]), y(function() {
    typeof v < "u" && M !== null && it.minimumClusterSize(M, v);
  }, [M, v]), y(function() {
    typeof h < "u" && M !== null && it.styles(M, h);
  }, [M, h]), y(function() {
    typeof d < "u" && M !== null && it.title(M, d);
  }, [M, d]), y(function() {
    typeof w < "u" && M !== null && it.zoomOnClick(M, w);
  }, [M, w]), y(function() {
    if (_) {
      var W = Pe({}, n || bC), T = new qv(_, [], W);
      return r && it.averageCenter(T, r), o && it.batchSizeIE(T, o), i && it.calculator(T, i), a && it.clusterClass(T, a), s && it.enableRetinaIcons(T, s), u && it.gridSize(T, u), l && it.ignoreHidden(T, l), c && it.imageExtension(T, c), f && it.imagePath(T, f), p && it.imageSizes(T, p), g && it.maxZoom(T, g), v && it.minimumClusterSize(T, v), h && it.styles(T, h), d && it.title(T, d), w && it.zoomOnClick(T, w), E && Y(google.maps.event.addListener(T, Bn.onMouseOut, E)), b && $(google.maps.event.addListener(T, Bn.onMouseOver, b)), L && z(google.maps.event.addListener(T, Bn.onClick, L)), D && ee(google.maps.event.addListener(T, Bn.onClusteringBegin, D)), B && A(google.maps.event.addListener(T, Bn.onClusteringEnd, B)), q(T), O && O(T), function() {
        U !== null && google.maps.event.removeListener(U), m !== null && google.maps.event.removeListener(m), I !== null && google.maps.event.removeListener(I), R !== null && google.maps.event.removeListener(R), k !== null && google.maps.event.removeListener(k), S && S(T);
      };
    }
  }, []), M !== null && t(M) || null;
}
Ze(CC);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      markerClusterer: null
    }, n.setClustererCallback = function() {
      n.state.markerClusterer !== null && n.props.onLoad && n.props.onLoad(n.state.markerClusterer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context) {
      var n = new qv(this.context, [], this.props.options);
      this.registeredEvents = Ge({
        updaterMap: it,
        eventMap: Bn,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          markerClusterer: n
        };
      }, this.setClustererCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.markerClusterer && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: it,
      eventMap: Bn,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Qe(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }, t.prototype.render = function() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }, t.contextType = We, t;
})(Te);
function cf(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Zv = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(l) {
        l.returnValue = !1, l.preventDefault && l.preventDefault(), t.enableEventPropagation || cf(l);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = [
            "mousedown",
            "mouseover",
            "mouseout",
            "mouseup",
            "click",
            "dblclick",
            "touchstart",
            "touchend",
            "touchmove"
          ], a = 0, s = i; a < s.length; a++) {
            var u = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, u, cf));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, u = a.offsetHeight, l = this.pixelOffset.width, c = this.pixelOffset.height, f = this.div.offsetWidth, p = this.div.offsetHeight, g = this.infoBoxClearance.width, v = this.infoBoxClearance.height, h = this.getProjection(), d = h.fromLatLngToContainerPixel(this.position);
          d !== null && (d.x < -l + g ? r = d.x + l - g : d.x + f + l + g > s && (r = d.x + f + l + g - s), this.alignBottom ? d.y < -c + v + p ? o = d.y + c - v - p : d.y + c + v > u && (o = d.y + c + v - u) : d.y < -c + v ? o = d.y + c - v : d.y + p + c + v > u && (o = d.y + p + c + v - u)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = { top: 0, bottom: 0, left: 0, right: 0 };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), ff = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, df = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, wC = {};
function EC(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, a = e.onCloseClick, s = e.onDomReady, u = e.onContentChanged, l = e.onPositionChanged, c = e.onZindexChanged, f = e.onLoad, p = e.onUnmount, g = Ae(We), v = P(null), h = v[0], d = v[1], w = P(null), L = w[0], D = w[1], B = P(null), b = B[0], E = B[1], O = P(null), S = O[0], V = O[1], M = P(null), q = M[0], _ = M[1], j = P(null), I = j[0], z = j[1], X = rt(null);
  return y(function() {
    g && h !== null && (h.close(), n ? h.open(g, n) : h.getPosition() && h.open(g));
  }, [g, h, n]), y(function() {
    r && h !== null && h.setOptions(r);
  }, [h, r]), y(function() {
    if (o && h !== null) {
      var R = o instanceof google.maps.LatLng ? o : new google.maps.LatLng(o.lat, o.lng);
      h.setPosition(R);
    }
  }, [o]), y(function() {
    typeof i == "number" && h !== null && h.setZIndex(i);
  }, [i]), y(function() {
    h && a && (L !== null && google.maps.event.removeListener(L), D(google.maps.event.addListener(h, "closeclick", a)));
  }, [a]), y(function() {
    h && s && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(h, "domready", s)));
  }, [s]), y(function() {
    h && u && (S !== null && google.maps.event.removeListener(S), V(google.maps.event.addListener(h, "content_changed", u)));
  }, [u]), y(function() {
    h && l && (q !== null && google.maps.event.removeListener(q), _(google.maps.event.addListener(h, "position_changed", l)));
  }, [l]), y(function() {
    h && c && (I !== null && google.maps.event.removeListener(I), z(google.maps.event.addListener(h, "zindex_changed", c)));
  }, [c]), y(function() {
    if (g) {
      var R = r || wC, ee = R.position, re = Ml(R, ["position"]), k = void 0;
      ee && !(ee instanceof google.maps.LatLng) && (k = new google.maps.LatLng(ee.lat, ee.lng));
      var A = new Zv(Pe(Pe({}, re), k ? { position: k } : {}));
      X.current = document.createElement("div"), d(A), a && D(google.maps.event.addListener(A, "closeclick", a)), s && E(google.maps.event.addListener(A, "domready", s)), u && V(google.maps.event.addListener(A, "content_changed", u)), l && _(google.maps.event.addListener(A, "position_changed", l)), c && z(google.maps.event.addListener(A, "zindex_changed", c)), A.setContent(X.current), n ? A.open(g, n) : A.getPosition() ? A.open(g) : Nt(!1, "You must provide either an anchor or a position prop for <InfoBox>."), f && f(A);
    }
    return function() {
      h !== null && (L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), q && google.maps.event.removeListener(q), I && google.maps.event.removeListener(I), p && p(h), h.close());
    };
  }, []), X.current ? Pr(Vt.only(t), X.current) : null;
}
Ze(EC);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoBox: null
    }, n.open = function(r, o) {
      o ? n.context !== null && r.open(n.context, o) : r.getPosition() ? n.context !== null && r.open(n.context) : Nt(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }, n.setInfoBoxCallback = function() {
      n.state.infoBox !== null && n.containerElement !== null && (n.state.infoBox.setContent(n.containerElement), n.open(n.state.infoBox, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoBox));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.props.options || {}, r = n.position, o = Ml(n, ["position"]), i;
    r && !(r instanceof google.maps.LatLng) && (i = new google.maps.LatLng(r.lat, r.lng));
    var a = new Zv(Pe(Pe({}, o), i ? { position: i } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Ge({
      updaterMap: df,
      eventMap: ff,
      prevProps: {},
      nextProps: this.props,
      instance: a
    }), this.setState({ infoBox: a }, this.setInfoBoxCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = this.state.infoBox;
    r !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: df,
      eventMap: ff,
      prevProps: n,
      nextProps: this.props,
      instance: r
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n = this.props.onUnmount, r = this.state.infoBox;
    r !== null && (n && n(r), Qe(this.registeredEvents), r.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Pr(Vt.only(this.props.children), this.containerElement) : null;
  }, t.contextType = We, t;
})(Te);
var DC = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, o, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
    for (o = r; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
    for (o = r; o-- !== 0; ) {
      var a = i[o];
      if (!e(t[a], n[a])) return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
}, pf = /* @__PURE__ */ $v(DC);
const hf = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], Bs = 1, xo = 8;
class Pl {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const o = r >> 4;
    if (o !== Bs)
      throw new Error(`Got v${o} data when expected v${Bs}.`);
    const i = hf[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new Pl(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, o) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = hf.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, u = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, xo, t), this.coords = new this.ArrayType(this.data, xo + s + u, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(xo + a + s + u), this.ids = new this.IndexArrayType(this.data, xo, t), this.coords = new this.ArrayType(this.data, xo + s + u, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Bs << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return Au(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: a, nodeSize: s } = this, u = [0, i.length - 1, 0], l = [];
    for (; u.length; ) {
      const c = u.pop() || 0, f = u.pop() || 0, p = u.pop() || 0;
      if (f - p <= s) {
        for (let d = p; d <= f; d++) {
          const w = a[2 * d], L = a[2 * d + 1];
          w >= t && w <= r && L >= n && L <= o && l.push(i[d]);
        }
        continue;
      }
      const g = p + f >> 1, v = a[2 * g], h = a[2 * g + 1];
      v >= t && v <= r && h >= n && h <= o && l.push(i[g]), (c === 0 ? t <= v : n <= h) && (u.push(p), u.push(g - 1), u.push(1 - c)), (c === 0 ? r >= v : o >= h) && (u.push(g + 1), u.push(f), u.push(1 - c));
    }
    return l;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: o, coords: i, nodeSize: a } = this, s = [0, o.length - 1, 0], u = [], l = r * r;
    for (; s.length; ) {
      const c = s.pop() || 0, f = s.pop() || 0, p = s.pop() || 0;
      if (f - p <= a) {
        for (let d = p; d <= f; d++)
          gf(i[2 * d], i[2 * d + 1], t, n) <= l && u.push(o[d]);
        continue;
      }
      const g = p + f >> 1, v = i[2 * g], h = i[2 * g + 1];
      gf(v, h, t, n) <= l && u.push(o[g]), (c === 0 ? t - r <= v : n - r <= h) && (s.push(p), s.push(g - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= h) && (s.push(g + 1), s.push(f), s.push(1 - c));
    }
    return u;
  }
}
function Au(e, t, n, r, o, i) {
  if (o - r <= n) return;
  const a = r + o >> 1;
  Gv(e, t, a, r, o, i), Au(e, t, n, r, a - 1, 1 - i), Au(e, t, n, a + 1, o, 1 - i);
}
function Gv(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      const l = o - r + 1, c = n - r + 1, f = Math.log(l), p = 0.5 * Math.exp(2 * f / 3), g = 0.5 * Math.sqrt(f * p * (l - p) / l) * (c - l / 2 < 0 ? -1 : 1), v = Math.max(r, Math.floor(n - c * p / l + g)), h = Math.min(o, Math.floor(n + (l - c) * p / l + g));
      Gv(e, t, n, v, h, i);
    }
    const a = t[2 * n + i];
    let s = r, u = o;
    for (Lo(e, t, r, n), t[2 * o + i] > a && Lo(e, t, r, o); s < u; ) {
      for (Lo(e, t, s, u), s++, u--; t[2 * s + i] < a; ) s++;
      for (; t[2 * u + i] > a; ) u--;
    }
    t[2 * r + i] === a ? Lo(e, t, r, u) : (u++, Lo(e, t, u, o)), u <= n && (r = u + 1), n <= u && (o = u - 1);
  }
}
function Lo(e, t, n, r) {
  Ts(e, n, r), Ts(t, 2 * n, 2 * r), Ts(t, 2 * n + 1, 2 * r + 1);
}
function Ts(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function gf(e, t, n, r) {
  const o = e - n, i = t - r;
  return o * o + i * i;
}
const xC = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, vf = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), jr = 2, br = 3, As = 4, mr = 5, Kv = 6;
class LC {
  constructor(t) {
    this.options = Object.assign(Object.create(xC), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    const { log: n, minZoom: r, maxZoom: o } = this.options;
    n && console.time("total time");
    const i = `prepare ${t.length} points`;
    n && console.time(i), this.points = t;
    const a = [];
    for (let u = 0; u < t.length; u++) {
      const l = t[u];
      if (!l.geometry) continue;
      const [c, f] = l.geometry.coordinates, p = vf(Ei(c)), g = vf(Di(f));
      a.push(
        p,
        g,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        u,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && a.push(0);
    }
    let s = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (let u = o; u >= r; u--) {
      const l = +Date.now();
      s = this.trees[u] = this._createTree(this._cluster(s, u)), n && console.log("z%d: %d clusters in %dms", u, s.numItems, +Date.now() - l);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    let r = ((t[0] + 180) % 360 + 360) % 360 - 180;
    const o = Math.max(-90, Math.min(90, t[1]));
    let i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
    const a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      const f = this.getClusters([r, o, 180, a], n), p = this.getClusters([-180, o, i, a], n);
      return f.concat(p);
    }
    const s = this.trees[this._limitZoom(n)], u = s.range(Ei(r), Di(a), Ei(i), Di(o)), l = s.data, c = [];
    for (const f of u) {
      const p = this.stride * f;
      c.push(l[p + mr] > 1 ? mf(l, p, this.clusterProps) : this.points[l[p + br]]);
    }
    return c;
  }
  getChildren(t) {
    const n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    const a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    const s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), u = a[n * this.stride], l = a[n * this.stride + 1], c = i.within(u, l, s), f = [];
    for (const p of c) {
      const g = p * this.stride;
      a[g + As] === t && f.push(a[g + mr] > 1 ? mf(a, g, this.clusterProps) : this.points[a[g + br]]);
    }
    if (f.length === 0) throw new Error(o);
    return f;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    const o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    const o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), { extent: a, radius: s } = this.options, u = s / a, l = (r - u) / i, c = (r + 1 + u) / i, f = {
      features: []
    };
    return this._addTileFeatures(
      o.range((n - u) / i, l, (n + 1 + u) / i, c),
      o.data,
      n,
      r,
      i,
      f
    ), n === 0 && this._addTileFeatures(
      o.range(1 - u / i, l, 1, c),
      o.data,
      i,
      r,
      i,
      f
    ), n === i - 1 && this._addTileFeatures(
      o.range(0, l, u / i, c),
      o.data,
      -1,
      r,
      i,
      f
    ), f.features.length ? f : null;
  }
  getClusterExpansionZoom(t) {
    let n = this._getOriginZoom(t) - 1;
    for (; n <= this.options.maxZoom; ) {
      const r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    const a = this.getChildren(n);
    for (const s of a) {
      const u = s.properties;
      if (u && u.cluster ? i + u.point_count <= o ? i += u.point_count : i = this._appendLeaves(t, u.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    const n = new Pl(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (const s of t) {
      const u = s * this.stride, l = n[u + mr] > 1;
      let c, f, p;
      if (l)
        c = Yv(n, u, this.clusterProps), f = n[u], p = n[u + 1];
      else {
        const h = this.points[n[u + br]];
        c = h.properties;
        const [d, w] = h.geometry.coordinates;
        f = Ei(d), p = Di(w);
      }
      const g = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (f * i - r)),
          Math.round(this.options.extent * (p * i - o))
        ]],
        tags: c
      };
      let v;
      l || this.options.generateId ? v = n[u + br] : v = this.points[n[u + br]].id, v !== void 0 && (g.id = v), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    const { radius: r, extent: o, reduce: i, minPoints: a } = this.options, s = r / (o * Math.pow(2, n)), u = t.data, l = [], c = this.stride;
    for (let f = 0; f < u.length; f += c) {
      if (u[f + jr] <= n) continue;
      u[f + jr] = n;
      const p = u[f], g = u[f + 1], v = t.within(u[f], u[f + 1], s), h = u[f + mr];
      let d = h;
      for (const w of v) {
        const L = w * c;
        u[L + jr] > n && (d += u[L + mr]);
      }
      if (d > h && d >= a) {
        let w = p * h, L = g * h, D, B = -1;
        const b = ((f / c | 0) << 5) + (n + 1) + this.points.length;
        for (const E of v) {
          const O = E * c;
          if (u[O + jr] <= n) continue;
          u[O + jr] = n;
          const S = u[O + mr];
          w += u[O] * S, L += u[O + 1] * S, u[O + As] = b, i && (D || (D = this._map(u, f, !0), B = this.clusterProps.length, this.clusterProps.push(D)), i(D, this._map(u, O)));
        }
        u[f + As] = b, l.push(w / d, L / d, 1 / 0, b, -1, d), i && l.push(B);
      } else {
        for (let w = 0; w < c; w++) l.push(u[f + w]);
        if (d > 1)
          for (const w of v) {
            const L = w * c;
            if (!(u[L + jr] <= n)) {
              u[L + jr] = n;
              for (let D = 0; D < c; D++) l.push(u[L + D]);
            }
          }
      }
    }
    return l;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + mr] > 1) {
      const a = this.clusterProps[t[n + Kv]];
      return r ? Object.assign({}, a) : a;
    }
    const o = this.points[t[n + br]].properties, i = this.options.map(o);
    return r && i === o ? Object.assign({}, i) : i;
  }
}
function mf(e, t, n) {
  return {
    type: "Feature",
    id: e[t + br],
    properties: Yv(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [OC(e[t]), SC(e[t + 1])]
    }
  };
}
function Yv(e, t, n) {
  const r = e[t + mr], o = r >= 1e4 ? `${Math.round(r / 1e3)}k` : r >= 1e3 ? `${Math.round(r / 100) / 10}k` : r, i = e[t + Kv], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + br],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Ei(e) {
  return e / 360 + 0.5;
}
function Di(e) {
  const t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function OC(e) {
  return (e - 0.5) * 360;
}
function SC(e) {
  const t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function kC(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class En {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Fu {
  constructor({ markers: t, position: n }) {
    this.markers = t, n && (n instanceof google.maps.LatLng ? this._position = n : this._position = new google.maps.LatLng(n));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const t = new google.maps.LatLngBounds(this._position, this._position);
    for (const n of this.markers)
      t.extend(En.getPosition(n));
    return t;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => En.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (En.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class MC {
  constructor({ maxZoom: t = 16 }) {
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: t }) {
    return PC(t);
  }
}
const PC = (e) => e.map((n) => new Fu({
  position: En.getPosition(n),
  markers: [n]
}));
class BC extends MC {
  constructor(t) {
    var { maxZoom: n, radius: r = 60 } = t, o = kC(t, ["maxZoom", "radius"]);
    super({ maxZoom: n }), this.state = { zoom: -1 }, this.superCluster = new LC(Object.assign({ maxZoom: this.maxZoom, radius: r }, o));
  }
  calculate(t) {
    let n = !1;
    const r = { zoom: t.map.getZoom() };
    if (!pf(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      const o = this.markers.map((i) => {
        const a = En.getPosition(i);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [a.lng(), a.lat()]
          },
          properties: { marker: i }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !pf(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), { clusters: this.clusters, changed: n };
  }
  cluster({ map: t }) {
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t.getZoom())).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [t, n] }, properties: r }) {
    if (r.cluster)
      return new Fu({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((i) => i.properties.marker),
        position: { lat: n, lng: t }
      });
    const o = r.marker;
    return new Fu({
      markers: [o],
      position: En.getPosition(o)
    });
  }
}
class TC {
  constructor(t, n) {
    this.markers = { sum: t.length };
    const r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class AC {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: t, position: n }, r, o) {
    const a = `<svg fill="${t > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>
</svg>`, s = `Cluster of ${t} markers`, u = Number(google.maps.Marker.MAX_ZINDEX) + t;
    if (En.isAdvancedMarkerAvailable(o)) {
      const f = new DOMParser().parseFromString(a, "image/svg+xml").documentElement;
      f.setAttribute("transform", "translate(0 25)");
      const p = {
        map: o,
        position: n,
        zIndex: u,
        title: s,
        content: f
      };
      return new google.maps.marker.AdvancedMarkerElement(p);
    }
    const l = {
      position: n,
      zIndex: u,
      title: s,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(a)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(l);
  }
}
function FC(e, t) {
  for (let n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Bl {
  constructor() {
    FC(Bl, google.maps.OverlayView);
  }
}
var _o;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(_o || (_o = {}));
const IC = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class RC extends Bl {
  constructor({ map: t, markers: n = [], algorithmOptions: r = {}, algorithm: o = new BC(r), renderer: i = new AC(), onClusterClick: a = IC }) {
    super(), this.markers = [...n], this.clusters = [], this.algorithm = o, this.renderer = i, this.onClusterClick = a, t && this.setMap(t);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    const r = this.markers.indexOf(t);
    return r === -1 ? !1 : (En.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    let r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, _o.CLUSTERING_BEGIN, this);
      const { clusters: n, changed: r } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        const o = /* @__PURE__ */ new Set();
        for (const a of n)
          a.markers.length == 1 && o.add(a.markers[0]);
        const i = [];
        for (const a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || En.setMap(a.marker, null) : i.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => i.forEach((a) => En.setMap(a, null)));
      }
      google.maps.event.trigger(this, _o.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => En.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    const t = new TC(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => En.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, _o.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), En.setMap(r.marker, n);
    });
  }
}
function _C(e) {
  var t = qb(), n = P(null), r = n[0], o = n[1];
  return y(function() {
    if (t && r === null) {
      var i = new RC(Pe(Pe({}, e), { map: t }));
      o(i);
    }
  }, [t]), r;
}
function jC(e) {
  var t = e.children, n = e.options, r = _C(n);
  return r !== null ? t(r) : null;
}
Ze(jC);
var yf = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, bf = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
function NC(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, a = e.onCloseClick, s = e.onDomReady, u = e.onContentChanged, l = e.onPositionChanged, c = e.onZindexChanged, f = e.onLoad, p = e.onUnmount, g = Ae(We), v = P(null), h = v[0], d = v[1], w = P(null), L = w[0], D = w[1], B = P(null), b = B[0], E = B[1], O = P(null), S = O[0], V = O[1], M = P(null), q = M[0], _ = M[1], j = P(null), I = j[0], z = j[1], X = rt(null);
  return y(function() {
    h !== null && (h.close(), n ? h.open(g, n) : h.getPosition() && h.open(g));
  }, [g, h, n]), y(function() {
    r && h !== null && h.setOptions(r);
  }, [h, r]), y(function() {
    o && h !== null && h.setPosition(o);
  }, [o]), y(function() {
    typeof i == "number" && h !== null && h.setZIndex(i);
  }, [i]), y(function() {
    h && a && (L !== null && google.maps.event.removeListener(L), D(google.maps.event.addListener(h, "closeclick", a)));
  }, [a]), y(function() {
    h && s && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(h, "domready", s)));
  }, [s]), y(function() {
    h && u && (S !== null && google.maps.event.removeListener(S), V(google.maps.event.addListener(h, "content_changed", u)));
  }, [u]), y(function() {
    h && l && (q !== null && google.maps.event.removeListener(q), _(google.maps.event.addListener(h, "position_changed", l)));
  }, [l]), y(function() {
    h && c && (I !== null && google.maps.event.removeListener(I), z(google.maps.event.addListener(h, "zindex_changed", c)));
  }, [c]), y(function() {
    var R = new google.maps.InfoWindow(Pe({}, r || {}));
    return d(R), X.current = document.createElement("div"), a && D(google.maps.event.addListener(R, "closeclick", a)), s && E(google.maps.event.addListener(R, "domready", s)), u && V(google.maps.event.addListener(R, "content_changed", u)), l && _(google.maps.event.addListener(R, "position_changed", l)), c && z(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(X.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : Nt(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), f && f(R), function() {
      L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), q && google.maps.event.removeListener(q), I && google.maps.event.removeListener(I), p && p(R), R.close();
    };
  }, []), X.current ? Pr(Vt.only(t), X.current) : null;
}
Ze(NC);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoWindow: null
    }, n.open = function(r, o) {
      o ? r.open(n.context, o) : r.getPosition() ? r.open(n.context) : Nt(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }, n.setInfoWindowCallback = function() {
      n.state.infoWindow !== null && n.containerElement !== null && (n.state.infoWindow.setContent(n.containerElement), n.open(n.state.infoWindow, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoWindow));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.InfoWindow(Pe({}, this.props.options || {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Ge({
      updaterMap: bf,
      eventMap: yf,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        infoWindow: n
      };
    }, this.setInfoWindowCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.infoWindow !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: bf,
      eventMap: yf,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.infoWindow !== null && (Qe(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Pr(Vt.only(this.props.children), this.containerElement) : null;
  }, t.contextType = We, t;
})(Te);
var Cf = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, wf = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, zC = {};
function $C(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, a = e.onDblClick, s = e.onDragEnd, u = e.onDragStart, l = e.onMouseDown, c = e.onMouseMove, f = e.onMouseOut, p = e.onMouseOver, g = e.onMouseUp, v = e.onRightClick, h = e.onClick, d = e.onDrag, w = e.onLoad, L = e.onUnmount, D = Ae(We), B = P(null), b = B[0], E = B[1], O = P(null), S = O[0], V = O[1], M = P(null), q = M[0], _ = M[1], j = P(null), I = j[0], z = j[1], X = P(null), R = X[0], ee = X[1], re = P(null), k = re[0], A = re[1], G = P(null), U = G[0], Y = G[1], K = P(null), m = K[0], $ = K[1], W = P(null), T = W[0], J = W[1], te = P(null), N = te[0], se = te[1], ue = P(null), de = ue[0], ge = ue[1], Ce = P(null), me = Ce[0], ye = Ce[1];
  return y(function() {
    b !== null && b.setMap(D);
  }, [D]), y(function() {
    typeof t < "u" && b !== null && b.setOptions(t);
  }, [b, t]), y(function() {
    typeof n < "u" && b !== null && b.setDraggable(n);
  }, [b, n]), y(function() {
    typeof r < "u" && b !== null && b.setEditable(r);
  }, [b, r]), y(function() {
    typeof o < "u" && b !== null && b.setVisible(o);
  }, [b, o]), y(function() {
    typeof i < "u" && b !== null && b.setPath(i);
  }, [b, i]), y(function() {
    b && a && (S !== null && google.maps.event.removeListener(S), V(google.maps.event.addListener(b, "dblclick", a)));
  }, [a]), y(function() {
    b && s && (q !== null && google.maps.event.removeListener(q), _(google.maps.event.addListener(b, "dragend", s)));
  }, [s]), y(function() {
    b && u && (I !== null && google.maps.event.removeListener(I), z(google.maps.event.addListener(b, "dragstart", u)));
  }, [u]), y(function() {
    b && l && (R !== null && google.maps.event.removeListener(R), ee(google.maps.event.addListener(b, "mousedown", l)));
  }, [l]), y(function() {
    b && c && (k !== null && google.maps.event.removeListener(k), A(google.maps.event.addListener(b, "mousemove", c)));
  }, [c]), y(function() {
    b && f && (U !== null && google.maps.event.removeListener(U), Y(google.maps.event.addListener(b, "mouseout", f)));
  }, [f]), y(function() {
    b && p && (m !== null && google.maps.event.removeListener(m), $(google.maps.event.addListener(b, "mouseover", p)));
  }, [p]), y(function() {
    b && g && (T !== null && google.maps.event.removeListener(T), J(google.maps.event.addListener(b, "mouseup", g)));
  }, [g]), y(function() {
    b && v && (N !== null && google.maps.event.removeListener(N), se(google.maps.event.addListener(b, "rightclick", v)));
  }, [v]), y(function() {
    b && h && (de !== null && google.maps.event.removeListener(de), ge(google.maps.event.addListener(b, "click", h)));
  }, [h]), y(function() {
    b && d && (me !== null && google.maps.event.removeListener(me), ye(google.maps.event.addListener(b, "drag", d)));
  }, [d]), y(function() {
    var ce = new google.maps.Polyline(Pe(Pe({}, t || zC), { map: D }));
    return i && ce.setPath(i), typeof o < "u" && ce.setVisible(o), typeof r < "u" && ce.setEditable(r), typeof n < "u" && ce.setDraggable(n), a && V(google.maps.event.addListener(ce, "dblclick", a)), s && _(google.maps.event.addListener(ce, "dragend", s)), u && z(google.maps.event.addListener(ce, "dragstart", u)), l && ee(google.maps.event.addListener(ce, "mousedown", l)), c && A(google.maps.event.addListener(ce, "mousemove", c)), f && Y(google.maps.event.addListener(ce, "mouseout", f)), p && $(google.maps.event.addListener(ce, "mouseover", p)), g && J(google.maps.event.addListener(ce, "mouseup", g)), v && se(google.maps.event.addListener(ce, "rightclick", v)), h && ge(google.maps.event.addListener(ce, "click", h)), d && ye(google.maps.event.addListener(ce, "drag", d)), E(ce), w && w(ce), function() {
      S !== null && google.maps.event.removeListener(S), q !== null && google.maps.event.removeListener(q), I !== null && google.maps.event.removeListener(I), R !== null && google.maps.event.removeListener(R), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), m !== null && google.maps.event.removeListener(m), T !== null && google.maps.event.removeListener(T), N !== null && google.maps.event.removeListener(N), de !== null && google.maps.event.removeListener(de), L && L(ce), ce.setMap(null);
    };
  }, []), null;
}
Ze($C);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polyline: null
    }, n.setPolylineCallback = function() {
      n.state.polyline !== null && n.props.onLoad && n.props.onLoad(n.state.polyline);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polyline(Pe(Pe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ge({
      updaterMap: wf,
      eventMap: Cf,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polyline: n
      };
    }, this.setPolylineCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polyline !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: wf,
      eventMap: Cf,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Qe(this.registeredEvents), this.state.polyline.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = We, t;
})(Te);
var Ef = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Df = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  paths: function(e, t) {
    e.setPaths(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function UC(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, a = e.paths, s = e.onDblClick, u = e.onDragEnd, l = e.onDragStart, c = e.onMouseDown, f = e.onMouseMove, p = e.onMouseOut, g = e.onMouseOver, v = e.onMouseUp, h = e.onRightClick, d = e.onClick, w = e.onDrag, L = e.onLoad, D = e.onUnmount, B = e.onEdit, b = Ae(We), E = P(null), O = E[0], S = E[1], V = P(null), M = V[0], q = V[1], _ = P(null), j = _[0], I = _[1], z = P(null), X = z[0], R = z[1], ee = P(null), re = ee[0], k = ee[1], A = P(null), G = A[0], U = A[1], Y = P(null), K = Y[0], m = Y[1], $ = P(null), W = $[0], T = $[1], J = P(null), te = J[0], N = J[1], se = P(null), ue = se[0], de = se[1], ge = P(null), Ce = ge[0], me = ge[1], ye = P(null), ce = ye[0], Me = ye[1];
  return y(function() {
    O !== null && O.setMap(b);
  }, [b]), y(function() {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), y(function() {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), y(function() {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), y(function() {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), y(function() {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), y(function() {
    typeof a < "u" && O !== null && O.setPaths(a);
  }, [O, a]), y(function() {
    O && s && (M !== null && google.maps.event.removeListener(M), q(google.maps.event.addListener(O, "dblclick", s)));
  }, [s]), y(function() {
    O && (google.maps.event.addListener(O.getPath(), "insert_at", function() {
      B == null || B(O);
    }), google.maps.event.addListener(O.getPath(), "set_at", function() {
      B == null || B(O);
    }));
  }, [O, B]), y(function() {
    O && u && (j !== null && google.maps.event.removeListener(j), I(google.maps.event.addListener(O, "dragend", u)));
  }, [u]), y(function() {
    O && l && (X !== null && google.maps.event.removeListener(X), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), y(function() {
    O && c && (re !== null && google.maps.event.removeListener(re), k(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), y(function() {
    O && f && (G !== null && google.maps.event.removeListener(G), U(google.maps.event.addListener(O, "mousemove", f)));
  }, [f]), y(function() {
    O && p && (K !== null && google.maps.event.removeListener(K), m(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), y(function() {
    O && g && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(O, "mouseover", g)));
  }, [g]), y(function() {
    O && v && (te !== null && google.maps.event.removeListener(te), N(google.maps.event.addListener(O, "mouseup", v)));
  }, [v]), y(function() {
    O && h && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(O, "rightclick", h)));
  }, [h]), y(function() {
    O && d && (Ce !== null && google.maps.event.removeListener(Ce), me(google.maps.event.addListener(O, "click", d)));
  }, [d]), y(function() {
    O && w && (ce !== null && google.maps.event.removeListener(ce), Me(google.maps.event.addListener(O, "drag", w)));
  }, [w]), y(function() {
    var ie = new google.maps.Polygon(Pe(Pe({}, t || {}), { map: b }));
    return i && ie.setPath(i), a && ie.setPaths(a), typeof o < "u" && ie.setVisible(o), typeof r < "u" && ie.setEditable(r), typeof n < "u" && ie.setDraggable(n), s && q(google.maps.event.addListener(ie, "dblclick", s)), u && I(google.maps.event.addListener(ie, "dragend", u)), l && R(google.maps.event.addListener(ie, "dragstart", l)), c && k(google.maps.event.addListener(ie, "mousedown", c)), f && U(google.maps.event.addListener(ie, "mousemove", f)), p && m(google.maps.event.addListener(ie, "mouseout", p)), g && T(google.maps.event.addListener(ie, "mouseover", g)), v && N(google.maps.event.addListener(ie, "mouseup", v)), h && de(google.maps.event.addListener(ie, "rightclick", h)), d && me(google.maps.event.addListener(ie, "click", d)), w && Me(google.maps.event.addListener(ie, "drag", w)), S(ie), L && L(ie), function() {
      M !== null && google.maps.event.removeListener(M), j !== null && google.maps.event.removeListener(j), X !== null && google.maps.event.removeListener(X), re !== null && google.maps.event.removeListener(re), G !== null && google.maps.event.removeListener(G), K !== null && google.maps.event.removeListener(K), W !== null && google.maps.event.removeListener(W), te !== null && google.maps.event.removeListener(te), ue !== null && google.maps.event.removeListener(ue), Ce !== null && google.maps.event.removeListener(Ce), D && D(ie), ie.setMap(null);
    };
  }, []), null;
}
Ze(UC);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polygon: null
    }, n.setPolygonCallback = function() {
      n.state.polygon !== null && n.props.onLoad && n.props.onLoad(n.state.polygon);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polygon(Pe(Pe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ge({
      updaterMap: Df,
      eventMap: Ef,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polygon: n
      };
    }, this.setPolygonCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polygon !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Df,
      eventMap: Ef,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polygon
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polygon !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polygon), Qe(this.registeredEvents), this.state.polygon && this.state.polygon.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = We, t;
})(Te);
var xf = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Lf = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function WC(e) {
  var t = e.options, n = e.bounds, r = e.draggable, o = e.editable, i = e.visible, a = e.onDblClick, s = e.onDragEnd, u = e.onDragStart, l = e.onMouseDown, c = e.onMouseMove, f = e.onMouseOut, p = e.onMouseOver, g = e.onMouseUp, v = e.onRightClick, h = e.onClick, d = e.onDrag, w = e.onBoundsChanged, L = e.onLoad, D = e.onUnmount, B = Ae(We), b = P(null), E = b[0], O = b[1], S = P(null), V = S[0], M = S[1], q = P(null), _ = q[0], j = q[1], I = P(null), z = I[0], X = I[1], R = P(null), ee = R[0], re = R[1], k = P(null), A = k[0], G = k[1], U = P(null), Y = U[0], K = U[1], m = P(null), $ = m[0], W = m[1], T = P(null), J = T[0], te = T[1], N = P(null), se = N[0], ue = N[1], de = P(null), ge = de[0], Ce = de[1], me = P(null), ye = me[0], ce = me[1], Me = P(null), ie = Me[0], Re = Me[1];
  return y(function() {
    E !== null && E.setMap(B);
  }, [B]), y(function() {
    typeof t < "u" && E !== null && E.setOptions(t);
  }, [E, t]), y(function() {
    typeof r < "u" && E !== null && E.setDraggable(r);
  }, [E, r]), y(function() {
    typeof o < "u" && E !== null && E.setEditable(o);
  }, [E, o]), y(function() {
    typeof i < "u" && E !== null && E.setVisible(i);
  }, [E, i]), y(function() {
    typeof n < "u" && E !== null && E.setBounds(n);
  }, [E, n]), y(function() {
    E && a && (V !== null && google.maps.event.removeListener(V), M(google.maps.event.addListener(E, "dblclick", a)));
  }, [a]), y(function() {
    E && s && (_ !== null && google.maps.event.removeListener(_), j(google.maps.event.addListener(E, "dragend", s)));
  }, [s]), y(function() {
    E && u && (z !== null && google.maps.event.removeListener(z), X(google.maps.event.addListener(E, "dragstart", u)));
  }, [u]), y(function() {
    E && l && (ee !== null && google.maps.event.removeListener(ee), re(google.maps.event.addListener(E, "mousedown", l)));
  }, [l]), y(function() {
    E && c && (A !== null && google.maps.event.removeListener(A), G(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(function() {
    E && f && (Y !== null && google.maps.event.removeListener(Y), K(google.maps.event.addListener(E, "mouseout", f)));
  }, [f]), y(function() {
    E && p && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(E, "mouseover", p)));
  }, [p]), y(function() {
    E && g && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(E, "mouseup", g)));
  }, [g]), y(function() {
    E && v && (se !== null && google.maps.event.removeListener(se), ue(google.maps.event.addListener(E, "rightclick", v)));
  }, [v]), y(function() {
    E && h && (ge !== null && google.maps.event.removeListener(ge), Ce(google.maps.event.addListener(E, "click", h)));
  }, [h]), y(function() {
    E && d && (ye !== null && google.maps.event.removeListener(ye), ce(google.maps.event.addListener(E, "drag", d)));
  }, [d]), y(function() {
    E && w && (ie !== null && google.maps.event.removeListener(ie), Re(google.maps.event.addListener(E, "bounds_changed", w)));
  }, [w]), y(function() {
    var ae = new google.maps.Rectangle(Pe(Pe({}, t || {}), { map: B }));
    return typeof i < "u" && ae.setVisible(i), typeof o < "u" && ae.setEditable(o), typeof r < "u" && ae.setDraggable(r), typeof n < "u" && ae.setBounds(n), a && M(google.maps.event.addListener(ae, "dblclick", a)), s && j(google.maps.event.addListener(ae, "dragend", s)), u && X(google.maps.event.addListener(ae, "dragstart", u)), l && re(google.maps.event.addListener(ae, "mousedown", l)), c && G(google.maps.event.addListener(ae, "mousemove", c)), f && K(google.maps.event.addListener(ae, "mouseout", f)), p && W(google.maps.event.addListener(ae, "mouseover", p)), g && te(google.maps.event.addListener(ae, "mouseup", g)), v && ue(google.maps.event.addListener(ae, "rightclick", v)), h && Ce(google.maps.event.addListener(ae, "click", h)), d && ce(google.maps.event.addListener(ae, "drag", d)), w && Re(google.maps.event.addListener(ae, "bounds_changed", w)), O(ae), L && L(ae), function() {
      V !== null && google.maps.event.removeListener(V), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), ee !== null && google.maps.event.removeListener(ee), A !== null && google.maps.event.removeListener(A), Y !== null && google.maps.event.removeListener(Y), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), se !== null && google.maps.event.removeListener(se), ge !== null && google.maps.event.removeListener(ge), ye !== null && google.maps.event.removeListener(ye), ie !== null && google.maps.event.removeListener(ie), D && D(ae), ae.setMap(null);
    };
  }, []), null;
}
Ze(WC);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      rectangle: null
    }, n.setRectangleCallback = function() {
      n.state.rectangle !== null && n.props.onLoad && n.props.onLoad(n.state.rectangle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Rectangle(Pe(Pe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ge({
      updaterMap: Lf,
      eventMap: xf,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        rectangle: n
      };
    }, this.setRectangleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.rectangle !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Lf,
      eventMap: xf,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Qe(this.registeredEvents), this.state.rectangle.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = We, t;
})(Te);
var Of = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Sf = {
  center: function(e, t) {
    e.setCenter(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  radius: function(e, t) {
    e.setRadius(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, HC = {};
function VC(e) {
  var t = e.options, n = e.center, r = e.radius, o = e.draggable, i = e.editable, a = e.visible, s = e.onDblClick, u = e.onDragEnd, l = e.onDragStart, c = e.onMouseDown, f = e.onMouseMove, p = e.onMouseOut, g = e.onMouseOver, v = e.onMouseUp, h = e.onRightClick, d = e.onClick, w = e.onDrag, L = e.onCenterChanged, D = e.onRadiusChanged, B = e.onLoad, b = e.onUnmount, E = Ae(We), O = P(null), S = O[0], V = O[1], M = P(null), q = M[0], _ = M[1], j = P(null), I = j[0], z = j[1], X = P(null), R = X[0], ee = X[1], re = P(null), k = re[0], A = re[1], G = P(null), U = G[0], Y = G[1], K = P(null), m = K[0], $ = K[1], W = P(null), T = W[0], J = W[1], te = P(null), N = te[0], se = te[1], ue = P(null), de = ue[0], ge = ue[1], Ce = P(null), me = Ce[0], ye = Ce[1], ce = P(null), Me = ce[0], ie = ce[1], Re = P(null), ae = Re[0], Le = Re[1], Fe = P(null), ze = Fe[0], Ye = Fe[1];
  return y(function() {
    S !== null && S.setMap(E);
  }, [E]), y(function() {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), y(function() {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), y(function() {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), y(function() {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), y(function() {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), y(function() {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), y(function() {
    S && s && (q !== null && google.maps.event.removeListener(q), _(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), y(function() {
    S && u && (I !== null && google.maps.event.removeListener(I), z(google.maps.event.addListener(S, "dragend", u)));
  }, [u]), y(function() {
    S && l && (R !== null && google.maps.event.removeListener(R), ee(google.maps.event.addListener(S, "dragstart", l)));
  }, [l]), y(function() {
    S && c && (k !== null && google.maps.event.removeListener(k), A(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), y(function() {
    S && f && (U !== null && google.maps.event.removeListener(U), Y(google.maps.event.addListener(S, "mousemove", f)));
  }, [f]), y(function() {
    S && p && (m !== null && google.maps.event.removeListener(m), $(google.maps.event.addListener(S, "mouseout", p)));
  }, [p]), y(function() {
    S && g && (T !== null && google.maps.event.removeListener(T), J(google.maps.event.addListener(S, "mouseover", g)));
  }, [g]), y(function() {
    S && v && (N !== null && google.maps.event.removeListener(N), se(google.maps.event.addListener(S, "mouseup", v)));
  }, [v]), y(function() {
    S && h && (de !== null && google.maps.event.removeListener(de), ge(google.maps.event.addListener(S, "rightclick", h)));
  }, [h]), y(function() {
    S && d && (me !== null && google.maps.event.removeListener(me), ye(google.maps.event.addListener(S, "click", d)));
  }, [d]), y(function() {
    S && w && (Me !== null && google.maps.event.removeListener(Me), ie(google.maps.event.addListener(S, "drag", w)));
  }, [w]), y(function() {
    S && L && (ae !== null && google.maps.event.removeListener(ae), Le(google.maps.event.addListener(S, "center_changed", L)));
  }, [d]), y(function() {
    S && D && (ze !== null && google.maps.event.removeListener(ze), Ye(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), y(function() {
    var we = new google.maps.Circle(Pe(Pe({}, t || HC), { map: E }));
    return typeof r == "number" && we.setRadius(r), typeof n < "u" && we.setCenter(n), typeof r == "number" && we.setRadius(r), typeof a < "u" && we.setVisible(a), typeof i < "u" && we.setEditable(i), typeof o < "u" && we.setDraggable(o), s && _(google.maps.event.addListener(we, "dblclick", s)), u && z(google.maps.event.addListener(we, "dragend", u)), l && ee(google.maps.event.addListener(we, "dragstart", l)), c && A(google.maps.event.addListener(we, "mousedown", c)), f && Y(google.maps.event.addListener(we, "mousemove", f)), p && $(google.maps.event.addListener(we, "mouseout", p)), g && J(google.maps.event.addListener(we, "mouseover", g)), v && se(google.maps.event.addListener(we, "mouseup", v)), h && ge(google.maps.event.addListener(we, "rightclick", h)), d && ye(google.maps.event.addListener(we, "click", d)), w && ie(google.maps.event.addListener(we, "drag", w)), L && Le(google.maps.event.addListener(we, "center_changed", L)), D && Ye(google.maps.event.addListener(we, "radius_changed", D)), V(we), B && B(we), function() {
      q !== null && google.maps.event.removeListener(q), I !== null && google.maps.event.removeListener(I), R !== null && google.maps.event.removeListener(R), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), m !== null && google.maps.event.removeListener(m), T !== null && google.maps.event.removeListener(T), N !== null && google.maps.event.removeListener(N), de !== null && google.maps.event.removeListener(de), me !== null && google.maps.event.removeListener(me), ae !== null && google.maps.event.removeListener(ae), ze !== null && google.maps.event.removeListener(ze), b && b(we), we.setMap(null);
    };
  }, []), null;
}
Ze(VC);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      circle: null
    }, n.setCircleCallback = function() {
      n.state.circle !== null && n.props.onLoad && n.props.onLoad(n.state.circle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Circle(Pe(Pe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ge({
      updaterMap: Sf,
      eventMap: Of,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        circle: n
      };
    }, this.setCircleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.circle !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Sf,
      eventMap: Of,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n;
    this.state.circle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.circle), Qe(this.registeredEvents), (n = this.state.circle) === null || n === void 0 || n.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = We, t;
})(Te);
var kf = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, Mf = {
  add: function(e, t) {
    e.add(t);
  },
  addgeojson: function(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains: function(e, t) {
    e.contains(t);
  },
  foreach: function(e, t) {
    e.forEach(t);
  },
  loadgeojson: function(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle: function(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove: function(e, t) {
    e.remove(t);
  },
  revertstyle: function(e, t) {
    e.revertStyle(t);
  },
  controlposition: function(e, t) {
    e.setControlPosition(t);
  },
  controls: function(e, t) {
    e.setControls(t);
  },
  drawingmode: function(e, t) {
    e.setDrawingMode(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  style: function(e, t) {
    e.setStyle(t);
  },
  togeojson: function(e, t) {
    e.toGeoJson(t);
  }
};
function qC(e) {
  var t = e.options, n = e.onClick, r = e.onDblClick, o = e.onMouseDown, i = e.onMouseMove, a = e.onMouseOut, s = e.onMouseOver, u = e.onMouseUp, l = e.onRightClick, c = e.onAddFeature, f = e.onRemoveFeature, p = e.onRemoveProperty, g = e.onSetGeometry, v = e.onSetProperty, h = e.onLoad, d = e.onUnmount, w = Ae(We), L = P(null), D = L[0], B = L[1], b = P(null), E = b[0], O = b[1], S = P(null), V = S[0], M = S[1], q = P(null), _ = q[0], j = q[1], I = P(null), z = I[0], X = I[1], R = P(null), ee = R[0], re = R[1], k = P(null), A = k[0], G = k[1], U = P(null), Y = U[0], K = U[1], m = P(null), $ = m[0], W = m[1], T = P(null), J = T[0], te = T[1], N = P(null), se = N[0], ue = N[1], de = P(null), ge = de[0], Ce = de[1], me = P(null), ye = me[0], ce = me[1], Me = P(null), ie = Me[0], Re = Me[1];
  return y(function() {
    D !== null && D.setMap(w);
  }, [w]), y(function() {
    D && r && (E !== null && google.maps.event.removeListener(E), O(google.maps.event.addListener(D, "dblclick", r)));
  }, [r]), y(function() {
    D && o && (V !== null && google.maps.event.removeListener(V), M(google.maps.event.addListener(D, "mousedown", o)));
  }, [o]), y(function() {
    D && i && (_ !== null && google.maps.event.removeListener(_), j(google.maps.event.addListener(D, "mousemove", i)));
  }, [i]), y(function() {
    D && a && (z !== null && google.maps.event.removeListener(z), X(google.maps.event.addListener(D, "mouseout", a)));
  }, [a]), y(function() {
    D && s && (ee !== null && google.maps.event.removeListener(ee), re(google.maps.event.addListener(D, "mouseover", s)));
  }, [s]), y(function() {
    D && u && (A !== null && google.maps.event.removeListener(A), G(google.maps.event.addListener(D, "mouseup", u)));
  }, [u]), y(function() {
    D && l && (Y !== null && google.maps.event.removeListener(Y), K(google.maps.event.addListener(D, "rightclick", l)));
  }, [l]), y(function() {
    D && n && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(D, "click", n)));
  }, [n]), y(function() {
    D && c && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(D, "addfeature", c)));
  }, [c]), y(function() {
    D && f && (se !== null && google.maps.event.removeListener(se), ue(google.maps.event.addListener(D, "removefeature", f)));
  }, [f]), y(function() {
    D && p && (ge !== null && google.maps.event.removeListener(ge), Ce(google.maps.event.addListener(D, "removeproperty", p)));
  }, [p]), y(function() {
    D && g && (ye !== null && google.maps.event.removeListener(ye), ce(google.maps.event.addListener(D, "setgeometry", g)));
  }, [g]), y(function() {
    D && v && (ie !== null && google.maps.event.removeListener(ie), Re(google.maps.event.addListener(D, "setproperty", v)));
  }, [v]), y(function() {
    if (w !== null) {
      var ae = new google.maps.Data(Pe(Pe({}, t || {}), { map: w }));
      r && O(google.maps.event.addListener(ae, "dblclick", r)), o && M(google.maps.event.addListener(ae, "mousedown", o)), i && j(google.maps.event.addListener(ae, "mousemove", i)), a && X(google.maps.event.addListener(ae, "mouseout", a)), s && re(google.maps.event.addListener(ae, "mouseover", s)), u && G(google.maps.event.addListener(ae, "mouseup", u)), l && K(google.maps.event.addListener(ae, "rightclick", l)), n && W(google.maps.event.addListener(ae, "click", n)), c && te(google.maps.event.addListener(ae, "addfeature", c)), f && ue(google.maps.event.addListener(ae, "removefeature", f)), p && Ce(google.maps.event.addListener(ae, "removeproperty", p)), g && ce(google.maps.event.addListener(ae, "setgeometry", g)), v && Re(google.maps.event.addListener(ae, "setproperty", v)), B(ae), h && h(ae);
    }
    return function() {
      D && (E !== null && google.maps.event.removeListener(E), V !== null && google.maps.event.removeListener(V), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), ee !== null && google.maps.event.removeListener(ee), A !== null && google.maps.event.removeListener(A), Y !== null && google.maps.event.removeListener(Y), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), se !== null && google.maps.event.removeListener(se), ge !== null && google.maps.event.removeListener(ge), ye !== null && google.maps.event.removeListener(ye), ie !== null && google.maps.event.removeListener(ie), d && d(D), D.setMap(null));
    };
  }, []), null;
}
Ze(qC);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      data: null
    }, n.setDataCallback = function() {
      n.state.data !== null && n.props.onLoad && n.props.onLoad(n.state.data);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context !== null) {
      var n = new google.maps.Data(Pe(Pe({}, this.props.options || {}), { map: this.context }));
      this.registeredEvents = Ge({
        updaterMap: Mf,
        eventMap: kf,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          data: n
        };
      }, this.setDataCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.data !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Mf,
      eventMap: kf,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.data
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Qe(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = We, t;
})(Te);
var Pf = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Bf = {
  options: function(e, t) {
    e.setOptions(t);
  },
  url: function(e, t) {
    e.setUrl(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      kmlLayer: null
    }, n.setKmlLayerCallback = function() {
      n.state.kmlLayer !== null && n.props.onLoad && n.props.onLoad(n.state.kmlLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.KmlLayer(Pe(Pe({}, this.props.options), { map: this.context }));
    this.registeredEvents = Ge({
      updaterMap: Bf,
      eventMap: Pf,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        kmlLayer: n
      };
    }, this.setKmlLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.kmlLayer !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Bf,
      eventMap: Pf,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Qe(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = We, t;
})(Te);
function Xv(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function ZC(e, t) {
  return new t(e.lat, e.lng);
}
function GC(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function KC(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function YC(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function XC(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function JC(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var o = r.x, i = r.y;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Jv(e, t, n, r) {
  return n !== void 0 ? XC(e, t, YC(n, google.maps.LatLngBounds, GC)) : JC(e, t, KC(r, google.maps.LatLng, ZC));
}
function QC(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function e1(e, t, n, r, o) {
  var i = (
    /** @class */
    function(a) {
      yt(s, a);
      function s(u, l, c, f) {
        var p = a.call(this) || this;
        return p.container = u, p.pane = l, p.position = c, p.bounds = f, p;
      }
      return s.prototype.onAdd = function() {
        var u, l = (u = this.getPanes()) === null || u === void 0 ? void 0 : u[this.pane];
        l == null || l.appendChild(this.container);
      }, s.prototype.draw = function() {
        for (var u = this.getProjection(), l = Pe({}, this.container ? Xv(this.container, o) : {
          x: 0,
          y: 0
        }), c = Jv(u, l, this.bounds, this.position), f = 0, p = Object.entries(c); f < p.length; f++) {
          var g = p[f], v = g[0], h = g[1];
          this.container.style[v] = h;
        }
      }, s.prototype.onRemove = function() {
        this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
      }, s;
    }(google.maps.OverlayView)
  );
  return new i(e, t, n, r);
}
function Tf(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function Af(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function t1(e) {
  var t = e.position, n = e.bounds, r = e.mapPaneName, o = e.zIndex, i = e.onLoad, a = e.onUnmount, s = e.getPixelPositionOffset, u = e.children, l = Ae(We), c = Ln(function() {
    var p = document.createElement("div");
    return p.style.position = "absolute", p;
  }, []), f = Ln(function() {
    return e1(c, r, t, n, s);
  }, [c, r, t, n]);
  return y(function() {
    return i == null || i(f), f == null || f.setMap(l), function() {
      a == null || a(f), f == null || f.setMap(null);
    };
  }, [l, f]), y(function() {
    c.style.zIndex = "".concat(o);
  }, [o, c]), ja.createPortal(u, c);
}
Ze(t1);
(function(e) {
  yt(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    r.state = {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }, r.updatePane = function() {
      var i = r.props.mapPaneName, a = r.overlayView.getPanes();
      Nt(!!i, "OverlayView requires props.mapPaneName but got %s", i), a ? r.setState({
        paneEl: a[i]
      }) : r.setState({
        paneEl: null
      });
    }, r.onAdd = function() {
      var i, a;
      r.updatePane(), (a = (i = r.props).onLoad) === null || a === void 0 || a.call(i, r.overlayView);
    }, r.onPositionElement = function() {
      var i = r.overlayView.getProjection(), a = Pe({ x: 0, y: 0 }, r.containerRef.current ? Xv(r.containerRef.current, r.props.getPixelPositionOffset) : {}), s = Jv(i, a, r.props.bounds, r.props.position), u = r.state.containerStyle, l = u.left, c = u.top, f = u.width, p = u.height;
      QC(s, { left: l, top: c, width: f, height: p }) || r.setState({
        containerStyle: {
          top: s.top || 0,
          left: s.left || 0,
          width: s.width || 0,
          height: s.height || 0,
          position: "absolute"
        }
      });
    }, r.draw = function() {
      r.onPositionElement();
    }, r.onRemove = function() {
      var i, a;
      r.setState(function() {
        return {
          paneEl: null
        };
      }), (a = (i = r.props).onUnmount) === null || a === void 0 || a.call(i, r.overlayView);
    }, r.containerRef = Mr();
    var o = new google.maps.OverlayView();
    return o.onAdd = r.onAdd, o.draw = r.draw, o.onRemove = r.onRemove, r.overlayView = o, r;
  }
  return t.prototype.componentDidMount = function() {
    this.overlayView.setMap(this.context);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = Tf(n.position), o = Tf(this.props.position), i = Af(n.bounds), a = Af(this.props.bounds);
    (r !== o || i !== a) && this.overlayView.draw(), n.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }, t.prototype.componentWillUnmount = function() {
    this.overlayView.setMap(null);
  }, t.prototype.render = function() {
    var n = this.state.paneEl;
    return n ? ja.createPortal(F.jsx("div", { ref: this.containerRef, style: this.state.containerStyle, children: Vt.only(this.props.children) }), n) : null;
  }, t.FLOAT_PANE = "floatPane", t.MAP_PANE = "mapPane", t.MARKER_LAYER = "markerLayer", t.OVERLAY_LAYER = "overlayLayer", t.OVERLAY_MOUSE_TARGET = "overlayMouseTarget", t.contextType = We, t;
})(Te);
function n1() {
}
var Ff = {
  onDblClick: "dblclick",
  onClick: "click"
}, If = {
  opacity: function(e, t) {
    e.setOpacity(t);
  }
};
function r1(e) {
  var t = e.url, n = e.bounds, r = e.options, o = e.visible, i = Ae(We), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Ln(function() {
    var u = new google.maps.GroundOverlay(t, a, Pe({}, r));
    return u;
  }, []);
  return y(function() {
    s !== null && s.setMap(i);
  }, [i]), y(function() {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), y(function() {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), y(function() {
    var u = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", u), s.setMap(i));
  }, [s, n]), null;
}
Ze(r1);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      groundOverlay: null
    }, n.setGroundOverlayCallback = function() {
      n.state.groundOverlay !== null && n.props.onLoad && n.props.onLoad(n.state.groundOverlay);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Nt(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var n = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Pe(Pe({}, this.props.options), { map: this.context }));
    this.registeredEvents = Ge({
      updaterMap: If,
      eventMap: Ff,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        groundOverlay: n
      };
    }, this.setGroundOverlayCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.groundOverlay !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: If,
      eventMap: Ff,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.defaultProps = {
    onLoad: n1
  }, t.contextType = We, t;
})(Te);
var Rf = {}, _f = {
  data: function(e, t) {
    e.setData(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function o1(e) {
  var t = e.data, n = e.onLoad, r = e.onUnmount, o = e.options, i = Ae(We), a = P(null), s = a[0], u = a[1];
  return y(function() {
    google.maps.visualization || Nt(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(function() {
    Nt(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), y(function() {
    s !== null && s.setMap(i);
  }, [i]), y(function() {
    o && s !== null && s.setOptions(o);
  }, [s, o]), y(function() {
    var l = new google.maps.visualization.HeatmapLayer(Pe(Pe({}, o || {}), { data: t, map: i }));
    return u(l), n && n(l), function() {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Ze(o1);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      heatmapLayer: null
    }, n.setHeatmapLayerCallback = function() {
      n.state.heatmapLayer !== null && n.props.onLoad && n.props.onLoad(n.state.heatmapLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Nt(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Nt(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var n = new google.maps.visualization.HeatmapLayer(Pe(Pe({}, this.props.options || {}), { data: this.props.data, map: this.context }));
    this.registeredEvents = Ge({
      updaterMap: _f,
      eventMap: Rf,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        heatmapLayer: n
      };
    }, this.setHeatmapLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: _f,
      eventMap: Rf,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Qe(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = We, t;
})(Te);
var jf = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, Nf = {
  register: function(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links: function(e, t) {
    e.setLinks(t);
  },
  motionTracking: function(e, t) {
    e.setMotionTracking(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  pano: function(e, t) {
    e.setPano(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  pov: function(e, t) {
    e.setPov(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      streetViewPanorama: null
    }, n.setStreetViewPanoramaCallback = function() {
      n.state.streetViewPanorama !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewPanorama);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n, r, o = (r = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && r !== void 0 ? r : null;
    this.registeredEvents = Ge({
      updaterMap: Nf,
      eventMap: jf,
      prevProps: {},
      nextProps: this.props,
      instance: o
    }), this.setState(function() {
      return {
        streetViewPanorama: o
      };
    }, this.setStreetViewPanoramaCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.streetViewPanorama !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Nf,
      eventMap: jf,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Qe(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = We, t;
})(Te);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      streetViewService: null
    }, n.setStreetViewServiceCallback = function() {
      n.state.streetViewService !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: n
      };
    }, this.setStreetViewServiceCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = We, t;
})(Te);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      directionsService: null
    }, n.setDirectionsServiceCallback = function() {
      n.state.directionsService !== null && n.props.onLoad && n.props.onLoad(n.state.directionsService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Nt(!!this.props.options, "DirectionsService expected options object as parameter, but got %s", this.props.options);
    var n = new google.maps.DirectionsService();
    this.setState(function() {
      return {
        directionsService: n
      };
    }, this.setDirectionsServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.directionsService !== null && this.state.directionsService.route(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsService !== null && this.props.onUnmount && this.props.onUnmount(this.state.directionsService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Te);
var zf = {
  onDirectionsChanged: "directions_changed"
}, $f = {
  directions: function(e, t) {
    e.setDirections(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  panel: function(e, t) {
    e.setPanel(t);
  },
  routeIndex: function(e, t) {
    e.setRouteIndex(t);
  }
};
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      directionsRenderer: null
    }, n.setDirectionsRendererCallback = function() {
      n.state.directionsRenderer !== null && (n.state.directionsRenderer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.directionsRenderer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Ge({
      updaterMap: $f,
      eventMap: zf,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        directionsRenderer: n
      };
    }, this.setDirectionsRendererCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.directionsRenderer !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: $f,
      eventMap: zf,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Qe(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }, t.prototype.render = function() {
    return F.jsx(F.Fragment, {});
  }, t.contextType = We, t;
})(Te);
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      distanceMatrixService: null
    }, n.setDistanceMatrixServiceCallback = function() {
      n.state.distanceMatrixService !== null && n.props.onLoad && n.props.onLoad(n.state.distanceMatrixService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    Nt(!!this.props.options, "DistanceMatrixService expected options object as parameter, but go %s", this.props.options);
    var n = new google.maps.DistanceMatrixService();
    this.setState(function() {
      return {
        distanceMatrixService: n
      };
    }, this.setDistanceMatrixServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.distanceMatrixService !== null && this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.distanceMatrixService !== null && this.props.onUnmount && this.props.onUnmount(this.state.distanceMatrixService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Te);
var Uf = {
  onPlacesChanged: "places_changed"
}, Wf = {
  bounds: function(e, t) {
    e.setBounds(t);
  }
}, i1 = (
  /** @class */
  function(e) {
    yt(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.registeredEvents = [], n.containerElement = Mr(), n.state = {
        searchBox: null
      }, n.setSearchBoxCallback = function() {
        n.state.searchBox !== null && n.props.onLoad && n.props.onLoad(n.state.searchBox);
      }, n;
    }
    return t.prototype.componentDidMount = function() {
      if (Nt(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
        var n = this.containerElement.current.querySelector("input");
        if (n !== null) {
          var r = new google.maps.places.SearchBox(n, this.props.options);
          this.registeredEvents = Ge({
            updaterMap: Wf,
            eventMap: Uf,
            prevProps: {},
            nextProps: this.props,
            instance: r
          }), this.setState(function() {
            return {
              searchBox: r
            };
          }, this.setSearchBoxCallback);
        }
      }
    }, t.prototype.componentDidUpdate = function(n) {
      this.state.searchBox !== null && (Qe(this.registeredEvents), this.registeredEvents = Ge({
        updaterMap: Wf,
        eventMap: Uf,
        prevProps: n,
        nextProps: this.props,
        instance: this.state.searchBox
      }));
    }, t.prototype.componentWillUnmount = function() {
      this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Qe(this.registeredEvents));
    }, t.prototype.render = function() {
      return F.jsx("div", { ref: this.containerElement, children: Vt.only(this.props.children) });
    }, t.contextType = We, t;
  }(Te)
), Hf = {
  onPlaceChanged: "place_changed"
}, Vf = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  restrictions: function(e, t) {
    e.setComponentRestrictions(t);
  },
  fields: function(e, t) {
    e.setFields(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  types: function(e, t) {
    e.setTypes(t);
  }
};
(function(e) {
  yt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = Mr(), n.state = {
      autocomplete: null
    }, n.setAutocompleteCallback = function() {
      n.state.autocomplete !== null && n.props.onLoad && n.props.onLoad(n.state.autocomplete);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n;
    Nt(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var r = (n = this.containerElement.current) === null || n === void 0 ? void 0 : n.querySelector("input");
    if (r) {
      var o = new google.maps.places.Autocomplete(r, this.props.options);
      this.registeredEvents = Ge({
        updaterMap: Vf,
        eventMap: Hf,
        prevProps: {},
        nextProps: this.props,
        instance: o
      }), this.setState(function() {
        return {
          autocomplete: o
        };
      }, this.setAutocompleteCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    Qe(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Vf,
      eventMap: Hf,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.autocomplete !== null && Qe(this.registeredEvents);
  }, t.prototype.render = function() {
    return F.jsx("div", { ref: this.containerElement, className: this.props.className, children: Vt.only(this.props.children) });
  }, t.defaultProps = {
    className: ""
  }, t.contextType = We, t;
})(Te);
function d_({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ F.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ F.jsx(
    Qb,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ F.jsx(lC, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ F.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ F.jsx(mb, {}) });
}
function p_(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ F.jsx("aside", { className: r.trim(), ...n });
}
function h_(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, a = Vt.count(r) === 0;
  return /* @__PURE__ */ F.jsx("tbody", { className: i.trim(), ...o, children: a ? /* @__PURE__ */ F.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ F.jsx("td", { colSpan: 100, children: /* @__PURE__ */ F.jsx("div", { children: t }) }) }) : r });
}
function g_(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ F.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ F.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function v_(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ F.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ F.jsx("table", { children: t }) });
}
function m_(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ F.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ F.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ F.jsx("tr", { children: /* @__PURE__ */ F.jsx("th", { colSpan: 100, children: /* @__PURE__ */ F.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function y_(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ F.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ F.jsx("tr", { children: n }),
    /* @__PURE__ */ F.jsx("tr", { className: "spacingRow" })
  ] });
}
function b_(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: u,
    className: l = "",
    children: c,
    ...f
  } = e, g = { xs: 12, sm: 16, md: 20, lg: 24 }[i], d = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${l}`;
  return /* @__PURE__ */ F.jsxs("button", { className: d, disabled: u || t, ...f, children: [
    /* @__PURE__ */ F.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ F.jsx(lr, { size: g, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ F.jsxs("div", { className: "arkynButtonContent", children: [
      va(g, a),
      c,
      va(g, s)
    ] })
  ] });
}
function a1() {
  const e = Sl(), t = Iv(), n = Rv(), [r, o] = P(null);
  function i(l, c) {
    return JSON.stringify(l) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  y(() => {
    var c, f;
    let l = ((f = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : f.fieldErrors) || {};
    i(r, l) || Object.entries(l).length !== 0 && o(l);
  }, [n, e]), y(() => {
    var l;
    ((l = n[0]) == null ? void 0 : l.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let u = {};
  return Object.entries(s || {}).forEach(([l, c]) => {
    typeof c == "string" && typeof l == "string" && (u[l] = c);
  }), u;
}
const Qv = ht({});
function C_(e) {
  var f;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = a1(), a = rt(null), s = ((f = a.current) == null ? void 0 : f.name) || "", u = (i == null ? void 0 : i[s]) || null, l = pb(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ F.jsx(Qv.Provider, { value: { error: u, id: l, inputRef: a }, children: /* @__PURE__ */ F.jsx(
    "section",
    {
      id: r || s || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function Pn() {
  return Ae(Qv);
}
function w_(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: a = null,
    onCheck: s,
    value: u,
    ...l
  } = e, { id: c, inputRef: f, error: p } = Pn(), g = o || !!p, [v, h] = P(i || !1), d = typeof a == "boolean" ? a : v, D = `arkynCheckbox ${r} ${g ? "errorTrue" : "errorFalse"} ${d ? "checkedTrue" : "checkedFalse"} ${n}`;
  function B() {
    const b = v;
    h(!b), s && s(b ? "" : u || "checked");
  }
  return /* @__PURE__ */ F.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: D,
      onClick: B,
      ...l,
      children: [
        /* @__PURE__ */ F.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: f,
            value: d ? u || "checked" : ""
          }
        ),
        /* @__PURE__ */ F.jsx(Av, {})
      ]
    }
  );
}
function E_(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = Pn();
  return t ? /* @__PURE__ */ F.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ F.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ F.jsx(F.Fragment, {});
}
function D_(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = Pn(), a = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ F.jsx("label", { className: a.trim(), htmlFor: o, ...r });
}
function Sr(e, t, n) {
  if (!e) return /* @__PURE__ */ F.jsx(F.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ F.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ F.jsx("p", { className: n, children: /* @__PURE__ */ F.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function Tl(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function em(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function tm(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const Al = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, nm = Tl(Al.CNPJ).length;
function s1(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: u,
    leftIcon: l,
    rightIcon: c,
    disabled: f,
    defaultValue: p,
    readOnly: g,
    onFocus: v,
    onBlur: h,
    title: d,
    style: w,
    onChange: L,
    ...D
  } = e;
  function B(I) {
    let z = Tl(I);
    const X = tm(z);
    if (!(z.length > nm))
      return z = em(z, Al[X]), z;
  }
  const b = c ? "right" : "left", q = `arkyn_input ${s ? "hasPrefix" : ""} ${u ? "hasSufix" : ""} ${a} ${o} ${f || g || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, j = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: q,
    prefix: Sr(s, j, "prefix"),
    sufix: Sr(u, j, "sufix"),
    LeftIcon: l,
    RightIcon: c,
    defaultValue: B(p || ""),
    disabled: f,
    readOnly: g,
    onFocus: v,
    onBlur: h,
    title: d,
    style: w,
    onChange: L,
    loadingPosition: b,
    iconSize: j,
    Spinner: /* @__PURE__ */ F.jsx(lr, { className: "spinner", size: j, strokeWidth: 2.5 }),
    ...D
  };
}
function u1(e) {
  const [t, n] = P(!1), r = rt(null), { inputRef: o, id: i, error: a } = Pn(), s = o || r, u = e.isError || !!a, {
    disabled: l,
    title: c,
    style: f,
    className: p,
    prefix: g,
    sufix: v,
    iconSize: h,
    loadingPosition: d,
    isLoading: w,
    LeftIcon: L,
    readOnly: D,
    onFocus: B,
    onBlur: b,
    RightIcon: E,
    Spinner: O,
    onChange: S,
    value: V,
    defaultValue: M,
    ...q
  } = s1({ ...e, id: i, isError: u }, t), [_, j] = P(M), I = L && !w, z = E && !w, X = d === "left" && w, R = d === "right" && w;
  function ee() {
    l || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function re(G) {
    let U = Tl(G.target.value);
    const Y = tm(U);
    U.length > nm || (U = em(U, Al[Y]), G.target.value = U, j(U), S && S(G));
  }
  function k(G) {
    n(!0), B && B(G);
  }
  function A(G) {
    n(!1), b && b(G);
  }
  return /* @__PURE__ */ F.jsxs(
    "section",
    {
      title: c,
      style: f,
      onClick: ee,
      className: p,
      children: [
        g,
        X && O,
        I && /* @__PURE__ */ F.jsx(L, { size: h, strokeWidth: 2.5 }),
        /* @__PURE__ */ F.jsx(
          "input",
          {
            disabled: l || w,
            readOnly: D,
            ref: s,
            value: V || _,
            onFocus: k,
            onChange: re,
            onBlur: A,
            ...q
          }
        ),
        z && /* @__PURE__ */ F.jsx(E, { size: h, strokeWidth: 2.5 }),
        R && O,
        v
      ]
    }
  );
}
const l1 = 3, c1 = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? l1 : 0), xi = 2, qf = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), Iu = (e) => {
  let t = e;
  return typeof e == "string" ? (t = qf(e), t % 1 !== 0 && (t = t.toFixed(xi))) : t = Number.isInteger(e) ? Number(e) * 10 ** xi : e.toFixed(xi), qf(t) / 10 ** xi;
}, Zf = (e, t, n) => {
  if (!t) return [0, ""];
  const r = Iu(t), o = c1(e, r, n);
  return [r, o];
};
function f1(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: u,
    leftIcon: l,
    rightIcon: c,
    disabled: f,
    readOnly: p,
    onFocus: g,
    onBlur: v,
    title: h,
    style: d,
    // showCents = false,
    max: w = 1e9,
    locale: L = "pt-BR",
    currency: D = "BRL",
    ...B
  } = e, b = c ? "right" : "left", q = `arkyn_input ${s ? "hasPrefix" : ""} ${u ? "hasSufix" : ""} ${a} ${o} ${f || p || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, j = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: q,
    prefix: Sr(s, j, "prefix"),
    sufix: Sr(u, j, "sufix"),
    LeftIcon: l,
    RightIcon: c,
    disabled: f,
    locale: L,
    currency: D,
    readOnly: p,
    onFocus: g,
    onBlur: v,
    title: h,
    style: d,
    max: w,
    // showCents,
    loadingPosition: b,
    iconSize: j,
    Spinner: /* @__PURE__ */ F.jsx(lr, { className: "spinner", size: j, strokeWidth: 2.5 }),
    ...B
  };
}
function d1(e) {
  const [t, n] = P(!1), [r, o] = P("0"), i = rt(null), { inputRef: a, id: s, error: u } = Pn(), l = a || i, c = e.isError || !!u, {
    disabled: f,
    title: p,
    style: g,
    className: v,
    prefix: h,
    sufix: d,
    iconSize: w,
    loadingPosition: L,
    isLoading: D,
    LeftIcon: B,
    readOnly: b,
    onFocus: E,
    onBlur: O,
    RightIcon: S,
    Spinner: V,
    value: M,
    max: q,
    onChangeValue: _,
    onKeyPress: j,
    currency: I,
    locale: z,
    name: X,
    defaultValue: R,
    ...ee
  } = f1({ ...e, id: s, isError: c }, t), re = B && !D, k = S && !D, A = L === "left" && D, G = L === "right" && D;
  function U() {
    f || !(l != null && l.current) || (n(!0), l.current.focus());
  }
  function Y(T) {
    n(!0), E && E(T);
  }
  function K(T) {
    n(!1), O && O(T);
  }
  const m = (T) => {
    const [J, te] = Zf(
      z,
      T,
      I
    );
    return !q || J <= q ? (o(te), [J, te]) : [Iu(r), r];
  }, $ = (T) => {
    T.preventDefault();
    const [J, te] = m(T.target.value);
    _(T, String(J), String(te));
  }, W = (T) => j && j(T, T.key, T.key);
  return y(() => {
    const T = M || +R || void 0, [, J] = Zf(z, T, I);
    o(J);
  }, [I, R, M]), /* @__PURE__ */ F.jsxs(
    "section",
    {
      title: p,
      style: g,
      onClick: U,
      className: v,
      children: [
        h,
        A && V,
        re && /* @__PURE__ */ F.jsx(B, { size: w, strokeWidth: 2.5 }),
        /* @__PURE__ */ F.jsx(
          "input",
          {
            value: r,
            onChange: $,
            onBlur: K,
            onFocus: Y,
            onKeyUp: W,
            disabled: f || D,
            readOnly: b,
            ...ee
          }
        ),
        /* @__PURE__ */ F.jsx(
          "input",
          {
            type: "hidden",
            ref: l,
            name: X,
            value: Iu(r)
          }
        ),
        G && V,
        k && /* @__PURE__ */ F.jsx(S, { size: w, strokeWidth: 2.5 }),
        d
      ]
    }
  );
}
function p1(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: u,
    leftIcon: l,
    rightIcon: c,
    disabled: f,
    readOnly: p,
    onFocus: g,
    onBlur: v,
    title: h,
    style: d,
    onChange: w,
    showMask: L = !1,
    type: D,
    ...B
  } = e, b = c ? "right" : "left", q = `arkyn_input ${s ? "hasPrefix" : ""} ${u ? "hasSufix" : ""} ${a} ${o} ${f || p || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, j = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: q,
    prefix: Sr(s, j, "prefix"),
    sufix: Sr(u, j, "sufix"),
    LeftIcon: l,
    RightIcon: c,
    disabled: f,
    readOnly: p,
    onFocus: g,
    onBlur: v,
    title: h,
    style: d,
    onChange: w,
    loadingPosition: b,
    iconSize: j,
    showMask: L,
    Spinner: /* @__PURE__ */ F.jsx(lr, { className: "spinner", size: j, strokeWidth: 2.5 }),
    ...B
  };
}
const h1 = _a((e, t) => /* @__PURE__ */ F.jsx("input", { ref: t, ...e }));
function g1(e) {
  const [t, n] = P(!1), r = rt(null), { inputRef: o, id: i, error: a } = Pn(), s = o || r, u = e.isError || !!a, {
    disabled: l,
    title: c,
    style: f,
    className: p,
    prefix: g,
    sufix: v,
    iconSize: h,
    loadingPosition: d,
    isLoading: w,
    LeftIcon: L,
    readOnly: D,
    onFocus: B,
    onBlur: b,
    RightIcon: E,
    Spinner: O,
    ...S
  } = p1({ ...e, id: i, isError: u }, t), V = L && !w, M = E && !w, q = d === "left" && w, _ = d === "right" && w;
  function j() {
    l || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function I(X) {
    n(!0), B && B(X);
  }
  function z(X) {
    n(!1), b && b(X);
  }
  return /* @__PURE__ */ F.jsxs(
    "section",
    {
      title: c,
      style: f,
      onClick: j,
      className: p,
      children: [
        g,
        q && O,
        V && /* @__PURE__ */ F.jsx(L, { size: h, strokeWidth: 2.5 }),
        /* @__PURE__ */ F.jsx(
          Ab,
          {
            component: h1,
            ref: s,
            onFocus: I,
            onBlur: z,
            disabled: l,
            ...S
          }
        ),
        M && /* @__PURE__ */ F.jsx(E, { size: h, strokeWidth: 2.5 }),
        _ && O,
        v
      ]
    }
  );
}
function v1(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: u,
    leftIcon: l,
    rightIcon: c,
    disabled: f,
    readOnly: p,
    onFocus: g,
    onBlur: v,
    title: h,
    style: d,
    onChange: w,
    ...L
  } = e, D = c ? "right" : "left", V = `arkyn_input ${s ? "hasPrefix" : ""} ${u ? "hasSufix" : ""} ${a} ${o} ${f || p || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, q = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: V,
    prefix: Sr(s, q, "prefix"),
    sufix: Sr(u, q, "sufix"),
    LeftIcon: l,
    RightIcon: c,
    disabled: f,
    readOnly: p,
    onFocus: g,
    onBlur: v,
    title: h,
    style: d,
    onChange: w,
    loadingPosition: D,
    iconSize: q,
    Spinner: /* @__PURE__ */ F.jsx(lr, { className: "spinner", size: q, strokeWidth: 2.5 }),
    ...L
  };
}
function m1(e) {
  const [t, n] = P(!1), r = rt(null), { inputRef: o, id: i, error: a } = Pn(), s = o || r, u = e.isError || !!a, {
    disabled: l,
    title: c,
    style: f,
    className: p,
    prefix: g,
    sufix: v,
    iconSize: h,
    loadingPosition: d,
    isLoading: w,
    LeftIcon: L,
    readOnly: D,
    onFocus: B,
    onBlur: b,
    RightIcon: E,
    type: O,
    Spinner: S,
    ...V
  } = v1({ ...e, id: i, isError: u }, t), M = L && !w, q = E && !w, _ = d === "left" && w, j = d === "right" && w;
  function I() {
    l || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function z(R) {
    n(!0), B && B(R);
  }
  function X(R) {
    n(!1), b && b(R);
  }
  return O === "hidden" ? /* @__PURE__ */ F.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: s,
      ...V
    }
  ) : /* @__PURE__ */ F.jsxs(
    "section",
    {
      title: c,
      style: f,
      onClick: I,
      className: p,
      children: [
        g,
        _ && S,
        M && /* @__PURE__ */ F.jsx(L, { size: h, strokeWidth: 2.5 }),
        /* @__PURE__ */ F.jsx(
          "input",
          {
            disabled: l || w,
            readOnly: D,
            ref: s,
            onFocus: z,
            onBlur: X,
            type: O,
            ...V
          }
        ),
        q && /* @__PURE__ */ F.jsx(E, { size: h, strokeWidth: 2.5 }),
        j && S,
        v
      ]
    }
  );
}
function y1(e) {
  return e.type === "currency" ? /* @__PURE__ */ F.jsx(d1, { ...e }) : e.type === "masked" ? /* @__PURE__ */ F.jsx(g1, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ F.jsx(u1, { ...e }) : /* @__PURE__ */ F.jsx(m1, { ...e });
}
function x_({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = P(null), a = (u) => i(u), s = () => {
    var g, v, h, d;
    const l = o.getPlaces()[0], c = l == null ? void 0 : l.address_components;
    function f(w) {
      const L = c.find((D) => D.types[0] === w);
      return L ? L.long_name : "";
    }
    function p(w) {
      const L = c.find((D) => D.types[0] === w);
      return L ? L.short_name : "";
    }
    if (l) {
      const w = f("route"), L = f("street_number"), D = f("sublocality_level_1"), B = f("administrative_area_level_2"), b = f("administrative_area_level_1"), E = p("administrative_area_level_1"), O = f("postal_code"), S = (v = (g = l.geometry) == null ? void 0 : g.location) == null ? void 0 : v.lat(), V = (d = (h = l.geometry) == null ? void 0 : h.location) == null ? void 0 : d.lng();
      t && t({
        street: w,
        city: B,
        state: b,
        district: D,
        cep: O,
        streetNumber: L,
        stateShortName: E,
        coordinates: { lat: S, lng: V }
      });
    }
  };
  return /* @__PURE__ */ F.jsx(
    i1,
    {
      onLoad: a,
      onPlacesChanged: s,
      options: n,
      children: /* @__PURE__ */ F.jsx(y1, { type: "text", onChange: (u) => e(u.target.value), ...r })
    }
  );
}
function L_(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...u
  } = e, l = { xs: 12, sm: 16, md: 20, lg: 24 }, f = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ F.jsxs(
    "button",
    {
      disabled: a || t,
      className: f.trim(),
      ...u,
      children: [
        /* @__PURE__ */ F.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ F.jsx(lr, { size: l[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ F.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ F.jsx(i, { size: l[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
var mt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function b1(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ru = { exports: {} }, Oo = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Gf;
function C1() {
  if (Gf) return Oo;
  Gf = 1;
  var e = Se, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, u, l) {
    var c, f = {}, p = null, g = null;
    l !== void 0 && (p = "" + l), u.key !== void 0 && (p = "" + u.key), u.ref !== void 0 && (g = u.ref);
    for (c in u) r.call(u, c) && !i.hasOwnProperty(c) && (f[c] = u[c]);
    if (s && s.defaultProps) for (c in u = s.defaultProps, u) f[c] === void 0 && (f[c] = u[c]);
    return { $$typeof: t, type: s, key: p, ref: g, props: f, _owner: o.current };
  }
  return Oo.Fragment = n, Oo.jsx = a, Oo.jsxs = a, Oo;
}
var Li = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Kf;
function w1() {
  return Kf || (Kf = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Se, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), v = Symbol.iterator, h = "@@iterator";
    function d(C) {
      if (C === null || typeof C != "object")
        return null;
      var Z = v && C[v] || C[h];
      return typeof Z == "function" ? Z : null;
    }
    var w = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function L(C) {
      {
        for (var Z = arguments.length, Q = new Array(Z > 1 ? Z - 1 : 0), fe = 1; fe < Z; fe++)
          Q[fe - 1] = arguments[fe];
        D("error", C, Q);
      }
    }
    function D(C, Z, Q) {
      {
        var fe = w.ReactDebugCurrentFrame, De = fe.getStackAddendum();
        De !== "" && (Z += "%s", Q = Q.concat([De]));
        var ke = Q.map(function(Ee) {
          return String(Ee);
        });
        ke.unshift("Warning: " + Z), Function.prototype.apply.call(console[C], console, ke);
      }
    }
    var B = !1, b = !1, E = !1, O = !1, S = !1, V;
    V = Symbol.for("react.module.reference");
    function M(C) {
      return !!(typeof C == "string" || typeof C == "function" || C === r || C === i || S || C === o || C === l || C === c || O || C === g || B || b || E || typeof C == "object" && C !== null && (C.$$typeof === p || C.$$typeof === f || C.$$typeof === a || C.$$typeof === s || C.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      C.$$typeof === V || C.getModuleId !== void 0));
    }
    function q(C, Z, Q) {
      var fe = C.displayName;
      if (fe)
        return fe;
      var De = Z.displayName || Z.name || "";
      return De !== "" ? Q + "(" + De + ")" : Q;
    }
    function _(C) {
      return C.displayName || "Context";
    }
    function j(C) {
      if (C == null)
        return null;
      if (typeof C.tag == "number" && L("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof C == "function")
        return C.displayName || C.name || null;
      if (typeof C == "string")
        return C;
      switch (C) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case l:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof C == "object")
        switch (C.$$typeof) {
          case s:
            var Z = C;
            return _(Z) + ".Consumer";
          case a:
            var Q = C;
            return _(Q._context) + ".Provider";
          case u:
            return q(C, C.render, "ForwardRef");
          case f:
            var fe = C.displayName || null;
            return fe !== null ? fe : j(C.type) || "Memo";
          case p: {
            var De = C, ke = De._payload, Ee = De._init;
            try {
              return j(Ee(ke));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var I = Object.assign, z = 0, X, R, ee, re, k, A, G;
    function U() {
    }
    U.__reactDisabledLog = !0;
    function Y() {
      {
        if (z === 0) {
          X = console.log, R = console.info, ee = console.warn, re = console.error, k = console.group, A = console.groupCollapsed, G = console.groupEnd;
          var C = {
            configurable: !0,
            enumerable: !0,
            value: U,
            writable: !0
          };
          Object.defineProperties(console, {
            info: C,
            log: C,
            warn: C,
            error: C,
            group: C,
            groupCollapsed: C,
            groupEnd: C
          });
        }
        z++;
      }
    }
    function K() {
      {
        if (z--, z === 0) {
          var C = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: I({}, C, {
              value: X
            }),
            info: I({}, C, {
              value: R
            }),
            warn: I({}, C, {
              value: ee
            }),
            error: I({}, C, {
              value: re
            }),
            group: I({}, C, {
              value: k
            }),
            groupCollapsed: I({}, C, {
              value: A
            }),
            groupEnd: I({}, C, {
              value: G
            })
          });
        }
        z < 0 && L("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var m = w.ReactCurrentDispatcher, $;
    function W(C, Z, Q) {
      {
        if ($ === void 0)
          try {
            throw Error();
          } catch (De) {
            var fe = De.stack.trim().match(/\n( *(at )?)/);
            $ = fe && fe[1] || "";
          }
        return `
` + $ + C;
      }
    }
    var T = !1, J;
    {
      var te = typeof WeakMap == "function" ? WeakMap : Map;
      J = new te();
    }
    function N(C, Z) {
      if (!C || T)
        return "";
      {
        var Q = J.get(C);
        if (Q !== void 0)
          return Q;
      }
      var fe;
      T = !0;
      var De = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ke;
      ke = m.current, m.current = null, Y();
      try {
        if (Z) {
          var Ee = function() {
            throw Error();
          };
          if (Object.defineProperty(Ee.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ee, []);
            } catch (Ue) {
              fe = Ue;
            }
            Reflect.construct(C, [], Ee);
          } else {
            try {
              Ee.call();
            } catch (Ue) {
              fe = Ue;
            }
            C.call(Ee.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ue) {
            fe = Ue;
          }
          C();
        }
      } catch (Ue) {
        if (Ue && fe && typeof Ue.stack == "string") {
          for (var be = Ue.stack.split(`
`), $e = fe.stack.split(`
`), Ie = be.length - 1, _e = $e.length - 1; Ie >= 1 && _e >= 0 && be[Ie] !== $e[_e]; )
            _e--;
          for (; Ie >= 1 && _e >= 0; Ie--, _e--)
            if (be[Ie] !== $e[_e]) {
              if (Ie !== 1 || _e !== 1)
                do
                  if (Ie--, _e--, _e < 0 || be[Ie] !== $e[_e]) {
                    var nt = `
` + be[Ie].replace(" at new ", " at ");
                    return C.displayName && nt.includes("<anonymous>") && (nt = nt.replace("<anonymous>", C.displayName)), typeof C == "function" && J.set(C, nt), nt;
                  }
                while (Ie >= 1 && _e >= 0);
              break;
            }
        }
      } finally {
        T = !1, m.current = ke, K(), Error.prepareStackTrace = De;
      }
      var Wt = C ? C.displayName || C.name : "", Ht = Wt ? W(Wt) : "";
      return typeof C == "function" && J.set(C, Ht), Ht;
    }
    function se(C, Z, Q) {
      return N(C, !1);
    }
    function ue(C) {
      var Z = C.prototype;
      return !!(Z && Z.isReactComponent);
    }
    function de(C, Z, Q) {
      if (C == null)
        return "";
      if (typeof C == "function")
        return N(C, ue(C));
      if (typeof C == "string")
        return W(C);
      switch (C) {
        case l:
          return W("Suspense");
        case c:
          return W("SuspenseList");
      }
      if (typeof C == "object")
        switch (C.$$typeof) {
          case u:
            return se(C.render);
          case f:
            return de(C.type, Z, Q);
          case p: {
            var fe = C, De = fe._payload, ke = fe._init;
            try {
              return de(ke(De), Z, Q);
            } catch {
            }
          }
        }
      return "";
    }
    var ge = Object.prototype.hasOwnProperty, Ce = {}, me = w.ReactDebugCurrentFrame;
    function ye(C) {
      if (C) {
        var Z = C._owner, Q = de(C.type, C._source, Z ? Z.type : null);
        me.setExtraStackFrame(Q);
      } else
        me.setExtraStackFrame(null);
    }
    function ce(C, Z, Q, fe, De) {
      {
        var ke = Function.call.bind(ge);
        for (var Ee in C)
          if (ke(C, Ee)) {
            var be = void 0;
            try {
              if (typeof C[Ee] != "function") {
                var $e = Error((fe || "React class") + ": " + Q + " type `" + Ee + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof C[Ee] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw $e.name = "Invariant Violation", $e;
              }
              be = C[Ee](Z, Ee, fe, Q, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ie) {
              be = Ie;
            }
            be && !(be instanceof Error) && (ye(De), L("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", fe || "React class", Q, Ee, typeof be), ye(null)), be instanceof Error && !(be.message in Ce) && (Ce[be.message] = !0, ye(De), L("Failed %s type: %s", Q, be.message), ye(null));
          }
      }
    }
    var Me = Array.isArray;
    function ie(C) {
      return Me(C);
    }
    function Re(C) {
      {
        var Z = typeof Symbol == "function" && Symbol.toStringTag, Q = Z && C[Symbol.toStringTag] || C.constructor.name || "Object";
        return Q;
      }
    }
    function ae(C) {
      try {
        return Le(C), !1;
      } catch {
        return !0;
      }
    }
    function Le(C) {
      return "" + C;
    }
    function Fe(C) {
      if (ae(C))
        return L("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Re(C)), Le(C);
    }
    var ze = w.ReactCurrentOwner, Ye = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, we, Ct, ot;
    ot = {};
    function Jt(C) {
      if (ge.call(C, "ref")) {
        var Z = Object.getOwnPropertyDescriptor(C, "ref").get;
        if (Z && Z.isReactWarning)
          return !1;
      }
      return C.ref !== void 0;
    }
    function _t(C) {
      if (ge.call(C, "key")) {
        var Z = Object.getOwnPropertyDescriptor(C, "key").get;
        if (Z && Z.isReactWarning)
          return !1;
      }
      return C.key !== void 0;
    }
    function $t(C, Z) {
      if (typeof C.ref == "string" && ze.current && Z && ze.current.stateNode !== Z) {
        var Q = j(ze.current.type);
        ot[Q] || (L('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', j(ze.current.type), C.ref), ot[Q] = !0);
      }
    }
    function dn(C, Z) {
      {
        var Q = function() {
          we || (we = !0, L("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Z));
        };
        Q.isReactWarning = !0, Object.defineProperty(C, "key", {
          get: Q,
          configurable: !0
        });
      }
    }
    function pn(C, Z) {
      {
        var Q = function() {
          Ct || (Ct = !0, L("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Z));
        };
        Q.isReactWarning = !0, Object.defineProperty(C, "ref", {
          get: Q,
          configurable: !0
        });
      }
    }
    var hn = function(C, Z, Q, fe, De, ke, Ee) {
      var be = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: C,
        key: Z,
        ref: Q,
        props: Ee,
        // Record the component responsible for creating this element.
        _owner: ke
      };
      return be._store = {}, Object.defineProperty(be._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(be, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: fe
      }), Object.defineProperty(be, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: De
      }), Object.freeze && (Object.freeze(be.props), Object.freeze(be)), be;
    };
    function gn(C, Z, Q, fe, De) {
      {
        var ke, Ee = {}, be = null, $e = null;
        Q !== void 0 && (Fe(Q), be = "" + Q), _t(Z) && (Fe(Z.key), be = "" + Z.key), Jt(Z) && ($e = Z.ref, $t(Z, De));
        for (ke in Z)
          ge.call(Z, ke) && !Ye.hasOwnProperty(ke) && (Ee[ke] = Z[ke]);
        if (C && C.defaultProps) {
          var Ie = C.defaultProps;
          for (ke in Ie)
            Ee[ke] === void 0 && (Ee[ke] = Ie[ke]);
        }
        if (be || $e) {
          var _e = typeof C == "function" ? C.displayName || C.name || "Unknown" : C;
          be && dn(Ee, _e), $e && pn(Ee, _e);
        }
        return hn(C, be, $e, De, fe, ze.current, Ee);
      }
    }
    var jt = w.ReactCurrentOwner, Qt = w.ReactDebugCurrentFrame;
    function Ut(C) {
      if (C) {
        var Z = C._owner, Q = de(C.type, C._source, Z ? Z.type : null);
        Qt.setExtraStackFrame(Q);
      } else
        Qt.setExtraStackFrame(null);
    }
    var Zt;
    Zt = !1;
    function vn(C) {
      return typeof C == "object" && C !== null && C.$$typeof === t;
    }
    function In() {
      {
        if (jt.current) {
          var C = j(jt.current.type);
          if (C)
            return `

Check the render method of \`` + C + "`.";
        }
        return "";
      }
    }
    function mn(C) {
      {
        if (C !== void 0) {
          var Z = C.fileName.replace(/^.*[\\\/]/, ""), Q = C.lineNumber;
          return `

Check your code at ` + Z + ":" + Q + ".";
        }
        return "";
      }
    }
    var Rn = {};
    function Yn(C) {
      {
        var Z = In();
        if (!Z) {
          var Q = typeof C == "string" ? C : C.displayName || C.name;
          Q && (Z = `

Check the top-level render call using <` + Q + ">.");
        }
        return Z;
      }
    }
    function en(C, Z) {
      {
        if (!C._store || C._store.validated || C.key != null)
          return;
        C._store.validated = !0;
        var Q = Yn(Z);
        if (Rn[Q])
          return;
        Rn[Q] = !0;
        var fe = "";
        C && C._owner && C._owner !== jt.current && (fe = " It was passed a child from " + j(C._owner.type) + "."), Ut(C), L('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Q, fe), Ut(null);
      }
    }
    function _n(C, Z) {
      {
        if (typeof C != "object")
          return;
        if (ie(C))
          for (var Q = 0; Q < C.length; Q++) {
            var fe = C[Q];
            vn(fe) && en(fe, Z);
          }
        else if (vn(C))
          C._store && (C._store.validated = !0);
        else if (C) {
          var De = d(C);
          if (typeof De == "function" && De !== C.entries)
            for (var ke = De.call(C), Ee; !(Ee = ke.next()).done; )
              vn(Ee.value) && en(Ee.value, Z);
        }
      }
    }
    function Xn(C) {
      {
        var Z = C.type;
        if (Z == null || typeof Z == "string")
          return;
        var Q;
        if (typeof Z == "function")
          Q = Z.propTypes;
        else if (typeof Z == "object" && (Z.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Z.$$typeof === f))
          Q = Z.propTypes;
        else
          return;
        if (Q) {
          var fe = j(Z);
          ce(Q, C.props, "prop", fe, C);
        } else if (Z.PropTypes !== void 0 && !Zt) {
          Zt = !0;
          var De = j(Z);
          L("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", De || "Unknown");
        }
        typeof Z.getDefaultProps == "function" && !Z.getDefaultProps.isReactClassApproved && L("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yn(C) {
      {
        for (var Z = Object.keys(C.props), Q = 0; Q < Z.length; Q++) {
          var fe = Z[Q];
          if (fe !== "children" && fe !== "key") {
            Ut(C), L("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", fe), Ut(null);
            break;
          }
        }
        C.ref !== null && (Ut(C), L("Invalid attribute `ref` supplied to `React.Fragment`."), Ut(null));
      }
    }
    var jn = {};
    function Nn(C, Z, Q, fe, De, ke) {
      {
        var Ee = M(C);
        if (!Ee) {
          var be = "";
          (C === void 0 || typeof C == "object" && C !== null && Object.keys(C).length === 0) && (be += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var $e = mn(De);
          $e ? be += $e : be += In();
          var Ie;
          C === null ? Ie = "null" : ie(C) ? Ie = "array" : C !== void 0 && C.$$typeof === t ? (Ie = "<" + (j(C.type) || "Unknown") + " />", be = " Did you accidentally export a JSX literal instead of a component?") : Ie = typeof C, L("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ie, be);
        }
        var _e = gn(C, Z, Q, De, ke);
        if (_e == null)
          return _e;
        if (Ee) {
          var nt = Z.children;
          if (nt !== void 0)
            if (fe)
              if (ie(nt)) {
                for (var Wt = 0; Wt < nt.length; Wt++)
                  _n(nt[Wt], C);
                Object.freeze && Object.freeze(nt);
              } else
                L("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              _n(nt, C);
        }
        if (ge.call(Z, "key")) {
          var Ht = j(C), Ue = Object.keys(Z).filter(function(Ps) {
            return Ps !== "key";
          }), he = Ue.length > 0 ? "{key: someKey, " + Ue.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!jn[Ht + he]) {
            var Ms = Ue.length > 0 ? "{" + Ue.join(": ..., ") + ": ...}" : "{}";
            L(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, he, Ht, Ms, Ht), jn[Ht + he] = !0;
          }
        }
        return C === r ? yn(_e) : Xn(_e), _e;
      }
    }
    function bn(C, Z, Q) {
      return Nn(C, Z, Q, !0);
    }
    function Jn(C, Z, Q) {
      return Nn(C, Z, Q, !1);
    }
    var Qn = Jn, Cn = bn;
    Li.Fragment = r, Li.jsx = Qn, Li.jsxs = Cn;
  }()), Li;
}
process.env.NODE_ENV === "production" ? Ru.exports = C1() : Ru.exports = w1();
var st = Ru.exports;
ht({});
function Yf(e, t) {
  return t ? /* @__PURE__ */ st.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ st.jsx(st.Fragment, {});
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var _u = function(e, t) {
  return _u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
  }, _u(e, t);
};
function bt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  _u(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Be = function() {
  return Be = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Be.apply(this, arguments);
};
function Fl(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function E1(e, t, n, r) {
  function o(i) {
    return i instanceof n ? i : new n(function(a) {
      a(i);
    });
  }
  return new (n || (n = Promise))(function(i, a) {
    function s(c) {
      try {
        l(r.next(c));
      } catch (f) {
        a(f);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (f) {
        a(f);
      }
    }
    function l(c) {
      c.done ? i(c.value) : o(c.value).then(s, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
}
function D1(e, t) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, o, i, a;
  return a = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function s(l) {
    return function(c) {
      return u([l, c]);
    };
  }
  function u(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, o && (i = l[0] & 2 ? o.return : l[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, l[1])).done) return i;
      switch (o = 0, i && (l = [l[0] & 2, i.value]), l[0]) {
        case 0:
        case 1:
          i = l;
          break;
        case 4:
          return n.label++, { value: l[1], done: !1 };
        case 5:
          n.label++, o = l[1], l = [0];
          continue;
        case 7:
          l = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            n = 0;
            continue;
          }
          if (l[0] === 3 && (!i || l[1] > i[0] && l[1] < i[3])) {
            n.label = l[1];
            break;
          }
          if (l[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = l;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(l);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      l = t.call(e, n);
    } catch (c) {
      l = [6, c], o = 0;
    } finally {
      r = i = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function rm(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var x1 = process.env.NODE_ENV, L1 = function(e, t, n, r, o, i, a, s) {
  if (x1 !== "production" && t === void 0)
    throw new Error("invariant requires an error message argument");
  if (!e) {
    var u;
    if (t === void 0)
      u = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var l = [n, r, o, i, a, s], c = 0;
      u = new Error(
        t.replace(/%s/g, function() {
          return l[c++];
        })
      ), u.name = "Invariant Violation";
    }
    throw u.framesToPop = 1, u;
  }
}, O1 = L1, zt = /* @__PURE__ */ rm(O1), He = ht(null);
function S1() {
  zt(!!Ae, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Ae(He);
  return zt(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function k1(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function M1(e, t) {
  Object.keys(e).forEach(function(n) {
    return t(e[n], n);
  });
}
function P1(e, t, n, r) {
  var o = {}, i = function(a, s) {
    var u = n[s];
    u !== t[s] && (o[s] = u, a(r, u));
  };
  return M1(e, i), o;
}
function B1(e, t, n) {
  var r = k1(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function T1(e) {
  google.maps.event.removeListener(e);
}
function et(e) {
  e === void 0 && (e = []), e.forEach(T1);
}
function Ke(e) {
  var t = e.updaterMap, n = e.eventMap, r = e.prevProps, o = e.nextProps, i = e.instance, a = B1(o, i, n);
  return P1(t, r, o, i), a;
}
var Xf = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, Jf = {
  extraMapTypes: function(e, t) {
    t.forEach(function(n, r) {
      e.mapTypes.set(String(r), n);
    });
  },
  center: function(e, t) {
    e.setCenter(t);
  },
  clickableIcons: function(e, t) {
    e.setClickableIcons(t);
  },
  heading: function(e, t) {
    e.setHeading(t);
  },
  mapTypeId: function(e, t) {
    e.setMapTypeId(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  streetView: function(e, t) {
    e.setStreetView(t);
  },
  tilt: function(e, t) {
    e.setTilt(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
function A1(e) {
  var t = e.children, n = e.options, r = e.id, o = e.mapContainerStyle, i = e.mapContainerClassName, a = e.center, s = e.onClick, u = e.onDblClick, l = e.onDrag, c = e.onDragEnd, f = e.onDragStart, p = e.onMouseMove, g = e.onMouseOut, v = e.onMouseOver, h = e.onMouseDown, d = e.onMouseUp, w = e.onRightClick, L = e.onCenterChanged, D = e.onLoad, B = e.onUnmount, b = P(null), E = b[0], O = b[1], S = rt(null), V = P(null), M = V[0], q = V[1], _ = P(null), j = _[0], I = _[1], z = P(null), X = z[0], R = z[1], ee = P(null), re = ee[0], k = ee[1], A = P(null), G = A[0], U = A[1], Y = P(null), K = Y[0], m = Y[1], $ = P(null), W = $[0], T = $[1], J = P(null), te = J[0], N = J[1], se = P(null), ue = se[0], de = se[1], ge = P(null), Ce = ge[0], me = ge[1], ye = P(null), ce = ye[0], Me = ye[1], ie = P(null), Re = ie[0], ae = ie[1];
  return y(function() {
    n && E !== null && E.setOptions(n);
  }, [E, n]), y(function() {
    E !== null && typeof a < "u" && E.setCenter(a);
  }, [E, a]), y(function() {
    E && u && (j !== null && google.maps.event.removeListener(j), I(google.maps.event.addListener(E, "dblclick", u)));
  }, [u]), y(function() {
    E && c && (X !== null && google.maps.event.removeListener(X), R(google.maps.event.addListener(E, "dragend", c)));
  }, [c]), y(function() {
    E && f && (re !== null && google.maps.event.removeListener(re), k(google.maps.event.addListener(E, "dragstart", f)));
  }, [f]), y(function() {
    E && h && (G !== null && google.maps.event.removeListener(G), U(google.maps.event.addListener(E, "mousedown", h)));
  }, [h]), y(function() {
    E && p && (K !== null && google.maps.event.removeListener(K), m(google.maps.event.addListener(E, "mousemove", p)));
  }, [p]), y(function() {
    E && g && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(E, "mouseout", g)));
  }, [g]), y(function() {
    E && v && (te !== null && google.maps.event.removeListener(te), N(google.maps.event.addListener(E, "mouseover", v)));
  }, [v]), y(function() {
    E && d && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(E, "mouseup", d)));
  }, [d]), y(function() {
    E && w && (Ce !== null && google.maps.event.removeListener(Ce), me(google.maps.event.addListener(E, "rightclick", w)));
  }, [w]), y(function() {
    E && s && (ce !== null && google.maps.event.removeListener(ce), Me(google.maps.event.addListener(E, "click", s)));
  }, [s]), y(function() {
    E && l && (Re !== null && google.maps.event.removeListener(Re), ae(google.maps.event.addListener(E, "drag", l)));
  }, [l]), y(function() {
    E && L && (M !== null && google.maps.event.removeListener(M), q(google.maps.event.addListener(E, "center_changed", L)));
  }, [s]), y(function() {
    var Le = S.current === null ? null : new google.maps.Map(S.current, n);
    return O(Le), Le !== null && D && D(Le), function() {
      Le !== null && B && B(Le);
    };
  }, []), st.jsx("div", { id: r, ref: S, style: o, className: i, children: st.jsx(He.Provider, { value: E, children: E !== null ? t : null }) });
}
Ze(A1);
/** @class */
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      map: null
    }, n.registeredEvents = [], n.mapRef = null, n.getInstance = function() {
      return n.mapRef === null ? null : new google.maps.Map(n.mapRef, n.props.options);
    }, n.panTo = function(r) {
      var o = n.getInstance();
      o && o.panTo(r);
    }, n.setMapCallback = function() {
      n.state.map !== null && n.props.onLoad && n.props.onLoad(n.state.map);
    }, n.getRef = function(r) {
      n.mapRef = r;
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.getInstance();
    this.registeredEvents = Ke({
      updaterMap: Jf,
      eventMap: Xf,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        map: n
      };
    }, this.setMapCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.map !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: Jf,
      eventMap: Xf,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.map
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), et(this.registeredEvents));
  }, t.prototype.render = function() {
    return st.jsx("div", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName, children: st.jsx(He.Provider, { value: this.state.map, children: this.state.map !== null ? this.props.children : null }) });
  }, t;
})(Te);
var Kr = typeof document < "u";
function om(e) {
  var t = e.url, n = e.id, r = e.nonce;
  return Kr ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var u = a.getAttribute("data-state");
      if (a.src === t && u !== "error") {
        if (u === "ready")
          return o(n);
        var l = s.initMap, c = a.onerror;
        s.initMap = function() {
          l && l(), o(n);
        }, a.onerror = function(p) {
          c && c(p), i(p);
        };
        return;
      } else
        a.remove();
    }
    var f = document.createElement("script");
    f.type = "text/javascript", f.src = t, f.id = n, f.async = !0, f.nonce = r || "", f.onerror = function(p) {
      f.setAttribute("data-state", "error"), i(p);
    }, s.initMap = function() {
      f.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(f);
  }).catch(function(o) {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function Qf(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function im() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return Qf(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return Qf(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
function am(e) {
  var t = e.googleMapsApiKey, n = e.googleMapsClientId, r = e.version, o = r === void 0 ? "weekly" : r, i = e.language, a = e.region, s = e.libraries, u = e.channel, l = e.mapIds, c = e.authReferrerPolicy, f = [];
  return zt(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? f.push("key=".concat(t)) : n && f.push("client=".concat(n)), o && f.push("v=".concat(o)), i && f.push("language=".concat(i)), a && f.push("region=".concat(a)), s && s.length && f.push("libraries=".concat(s.sort().join(","))), u && f.push("channel=".concat(u)), l && l.length && f.push("map_ids=".concat(l.join(","))), c && f.push("auth_referrer_policy=".concat(c)), f.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(f.join("&"));
}
var So = !1;
function sm() {
  return st.jsx("div", { children: "Loading..." });
}
var ju = {
  id: "script-loader",
  version: "weekly"
};
/** @class */
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.check = Mr(), n.state = {
      loaded: !1
    }, n.cleanupCallback = function() {
      delete window.google.maps, n.injectScript();
    }, n.isCleaningUp = function() {
      return E1(n, void 0, void 0, function() {
        function r(o) {
          if (!So)
            o();
          else if (Kr)
            var i = window.setInterval(function() {
              So || (window.clearInterval(i), o());
            }, 1);
        }
        return D1(this, function(o) {
          return [2, new Promise(r)];
        });
      });
    }, n.cleanup = function() {
      So = !0;
      var r = document.getElementById(n.props.id);
      r && r.parentNode && r.parentNode.removeChild(r), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(o) {
        return typeof o.src == "string" && o.src.includes("maps.googleapis");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(o) {
        return o.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(o) {
        return o.innerText !== void 0 && o.innerText.length > 0 && o.innerText.includes(".gm-");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      });
    }, n.injectScript = function() {
      n.props.preventGoogleFontsLoading && im(), zt(!!n.props.id, 'LoadScript requires "id" prop to be a string: %s', n.props.id);
      var r = {
        id: n.props.id,
        nonce: n.props.nonce,
        url: am(n.props)
      };
      om(r).then(function() {
        n.props.onLoad && n.props.onLoad(), n.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch(function(o) {
        n.props.onError && n.props.onError(o), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(n.props.googleMapsApiKey || "-", ") or Client ID (").concat(n.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (Kr) {
      if (window.google && window.google.maps && !So) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.props.libraries !== n.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), Kr && n.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }, t.prototype.componentWillUnmount = function() {
    var n = this;
    if (Kr) {
      this.cleanup();
      var r = function() {
        n.check.current || (delete window.google, So = !1);
      };
      window.setTimeout(r, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }, t.prototype.render = function() {
    return st.jsxs(st.Fragment, { children: [st.jsx("div", { ref: this.check }), this.state.loaded ? this.props.children : this.props.loadingElement || st.jsx(sm, {})] });
  }, t.defaultProps = ju, t;
})(Te);
var ed;
function F1(e) {
  var t = e.id, n = t === void 0 ? ju.id : t, r = e.version, o = r === void 0 ? ju.version : r, i = e.nonce, a = e.googleMapsApiKey, s = e.googleMapsClientId, u = e.language, l = e.region, c = e.libraries, f = e.preventGoogleFontsLoading, p = e.channel, g = e.mapIds, v = e.authReferrerPolicy, h = rt(!1), d = P(!1), w = d[0], L = d[1], D = P(void 0), B = D[0], b = D[1];
  y(function() {
    return h.current = !0, function() {
      h.current = !1;
    };
  }, []), y(function() {
    Kr && f && im();
  }, [f]), y(function() {
    w && zt(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [w]);
  var E = am({
    version: o,
    googleMapsApiKey: a,
    googleMapsClientId: s,
    language: u,
    region: l,
    libraries: c,
    channel: p,
    mapIds: g,
    authReferrerPolicy: v
  });
  y(function() {
    if (!Kr)
      return;
    function S() {
      h.current && (L(!0), ed = E);
    }
    if (window.google && window.google.maps && ed === E) {
      S();
      return;
    }
    om({ id: n, url: E, nonce: i }).then(S).catch(function(V) {
      h.current && b(V), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(a || "-", ") or Client ID (").concat(s || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(V);
    });
  }, [n, E, i]);
  var O = rt();
  return y(function() {
    O.current && c !== O.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), O.current = c;
  }, [c]), { isLoaded: w, loadError: B, url: E };
}
var I1 = st.jsx(sm, {});
function R1(e) {
  var t = e.loadingElement, n = e.onLoad, r = e.onError, o = e.onUnmount, i = e.children, a = Fl(e, ["loadingElement", "onLoad", "onError", "onUnmount", "children"]), s = F1(a), u = s.isLoaded, l = s.loadError;
  return y(function() {
    u && typeof n == "function" && n();
  }, [u, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return function() {
      o && o();
    };
  }, [o]), u ? i : t || I1;
}
Ze(R1);
var td;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(td || (td = {}));
var nd = {}, rd = {
  options: function(e, t) {
    e.setOptions(t);
  }
};
function _1(e) {
  var t = e.options, n = e.onLoad, r = e.onUnmount, o = Ae(He), i = P(null), a = i[0], s = i[1];
  return y(function() {
    a !== null && a.setMap(o);
  }, [o]), y(function() {
    t && a !== null && a.setOptions(t);
  }, [a, t]), y(function() {
    var u = new google.maps.TrafficLayer(Be(Be({}, t || {}), { map: o }));
    return s(u), n && n(u), function() {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Ze(_1);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      trafficLayer: null
    }, n.setTrafficLayerCallback = function() {
      n.state.trafficLayer !== null && n.props.onLoad && n.props.onLoad(n.state.trafficLayer);
    }, n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TrafficLayer(Be(Be({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ke({
      updaterMap: rd,
      eventMap: nd,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        trafficLayer: n
      };
    }, this.setTrafficLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.trafficLayer !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: rd,
      eventMap: nd,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), et(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = He, t;
})(Te);
function j1(e) {
  var t = e.onLoad, n = e.onUnmount, r = Ae(He), o = P(null), i = o[0], a = o[1];
  return y(function() {
    i !== null && i.setMap(r);
  }, [r]), y(function() {
    var s = new google.maps.BicyclingLayer();
    return a(s), s.setMap(r), t && t(s), function() {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
Ze(j1);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      bicyclingLayer: null
    }, n.setBicyclingLayerCallback = function() {
      n.state.bicyclingLayer !== null && (n.state.bicyclingLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.bicyclingLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.BicyclingLayer();
    this.setState(function() {
      return {
        bicyclingLayer: n
      };
    }, this.setBicyclingLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = He, t;
})(Te);
function N1(e) {
  var t = e.onLoad, n = e.onUnmount, r = Ae(He), o = P(null), i = o[0], a = o[1];
  return y(function() {
    i !== null && i.setMap(r);
  }, [r]), y(function() {
    var s = new google.maps.TransitLayer();
    return a(s), s.setMap(r), t && t(s), function() {
      i !== null && (n && n(i), i.setMap(null));
    };
  }, []), null;
}
Ze(N1);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      transitLayer: null
    }, n.setTransitLayerCallback = function() {
      n.state.transitLayer !== null && (n.state.transitLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.transitLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: n
      };
    }, this.setTransitLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = He, t;
})(Te);
var od = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, id = {
  drawingMode: function(e, t) {
    e.setDrawingMode(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function z1(e) {
  var t = e.options, n = e.drawingMode, r = e.onCircleComplete, o = e.onMarkerComplete, i = e.onOverlayComplete, a = e.onPolygonComplete, s = e.onPolylineComplete, u = e.onRectangleComplete, l = e.onLoad, c = e.onUnmount, f = Ae(He), p = P(null), g = p[0], v = p[1], h = P(null), d = h[0], w = h[1], L = P(null), D = L[0], B = L[1], b = P(null), E = b[0], O = b[1], S = P(null), V = S[0], M = S[1], q = P(null), _ = q[0], j = q[1], I = P(null), z = I[0], X = I[1];
  return y(function() {
    g !== null && g.setMap(f);
  }, [f]), y(function() {
    t && g !== null && g.setOptions(t);
  }, [g, t]), y(function() {
    g !== null && g.setDrawingMode(n ?? null);
  }, [g, n]), y(function() {
    g && r && (d !== null && google.maps.event.removeListener(d), w(google.maps.event.addListener(g, "circlecomplete", r)));
  }, [g, r]), y(function() {
    g && o && (D !== null && google.maps.event.removeListener(D), B(google.maps.event.addListener(g, "markercomplete", o)));
  }, [g, o]), y(function() {
    g && i && (E !== null && google.maps.event.removeListener(E), O(google.maps.event.addListener(g, "overlaycomplete", i)));
  }, [g, i]), y(function() {
    g && a && (V !== null && google.maps.event.removeListener(V), M(google.maps.event.addListener(g, "polygoncomplete", a)));
  }, [g, a]), y(function() {
    g && s && (_ !== null && google.maps.event.removeListener(_), j(google.maps.event.addListener(g, "polylinecomplete", s)));
  }, [g, s]), y(function() {
    g && u && (z !== null && google.maps.event.removeListener(z), X(google.maps.event.addListener(g, "rectanglecomplete", u)));
  }, [g, u]), y(function() {
    zt(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(Be(Be({}, t || {}), { map: f }));
    return n && R.setDrawingMode(n), r && w(google.maps.event.addListener(R, "circlecomplete", r)), o && B(google.maps.event.addListener(R, "markercomplete", o)), i && O(google.maps.event.addListener(R, "overlaycomplete", i)), a && M(google.maps.event.addListener(R, "polygoncomplete", a)), s && j(google.maps.event.addListener(R, "polylinecomplete", s)), u && X(google.maps.event.addListener(R, "rectanglecomplete", u)), v(R), l && l(R), function() {
      g !== null && (d && google.maps.event.removeListener(d), D && google.maps.event.removeListener(D), E && google.maps.event.removeListener(E), V && google.maps.event.removeListener(V), _ && google.maps.event.removeListener(_), z && google.maps.event.removeListener(z), c && c(g), g.setMap(null));
    };
  }, []), null;
}
Ze(z1);
(function(e) {
  bt(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    return r.registeredEvents = [], r.state = {
      drawingManager: null
    }, r.setDrawingManagerCallback = function() {
      r.state.drawingManager !== null && r.props.onLoad && r.props.onLoad(r.state.drawingManager);
    }, zt(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing), r;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.drawing.DrawingManager(Be(Be({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ke({
      updaterMap: id,
      eventMap: od,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        drawingManager: n
      };
    }, this.setDrawingManagerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.drawingManager !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: id,
      eventMap: od,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), et(this.registeredEvents), this.state.drawingManager.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = He, t;
})(Te);
var ad = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, sd = {
  animation: function(e, t) {
    e.setAnimation(t);
  },
  clickable: function(e, t) {
    e.setClickable(t);
  },
  cursor: function(e, t) {
    e.setCursor(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  icon: function(e, t) {
    e.setIcon(t);
  },
  label: function(e, t) {
    e.setLabel(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  opacity: function(e, t) {
    e.setOpacity(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  shape: function(e, t) {
    e.setShape(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, ya = {};
function $1(e) {
  var t = e.position, n = e.options, r = e.clusterer, o = e.noClustererRedraw, i = e.children, a = e.draggable, s = e.visible, u = e.animation, l = e.clickable, c = e.cursor, f = e.icon, p = e.label, g = e.opacity, v = e.shape, h = e.title, d = e.zIndex, w = e.onClick, L = e.onDblClick, D = e.onDrag, B = e.onDragEnd, b = e.onDragStart, E = e.onMouseOut, O = e.onMouseOver, S = e.onMouseUp, V = e.onMouseDown, M = e.onRightClick, q = e.onClickableChanged, _ = e.onCursorChanged, j = e.onAnimationChanged, I = e.onDraggableChanged, z = e.onFlatChanged, X = e.onIconChanged, R = e.onPositionChanged, ee = e.onShapeChanged, re = e.onTitleChanged, k = e.onVisibleChanged, A = e.onZindexChanged, G = e.onLoad, U = e.onUnmount, Y = Ae(He), K = P(null), m = K[0], $ = K[1], W = P(null), T = W[0], J = W[1], te = P(null), N = te[0], se = te[1], ue = P(null), de = ue[0], ge = ue[1], Ce = P(null), me = Ce[0], ye = Ce[1], ce = P(null), Me = ce[0], ie = ce[1], Re = P(null), ae = Re[0], Le = Re[1], Fe = P(null), ze = Fe[0], Ye = Fe[1], we = P(null), Ct = we[0], ot = we[1], Jt = P(null), _t = Jt[0], $t = Jt[1], dn = P(null), pn = dn[0], hn = dn[1], gn = P(null), jt = gn[0], Qt = gn[1], Ut = P(null), Zt = Ut[0], vn = Ut[1], In = P(null), mn = In[0], Rn = In[1], Yn = P(null), en = Yn[0], _n = Yn[1], Xn = P(null), yn = Xn[0], jn = Xn[1], Nn = P(null), bn = Nn[0], Jn = Nn[1], Qn = P(null), Cn = Qn[0], C = Qn[1], Z = P(null), Q = Z[0], fe = Z[1], De = P(null), ke = De[0], Ee = De[1], be = P(null), $e = be[0], Ie = be[1], _e = P(null), nt = _e[0], Wt = _e[1];
  y(function() {
    m !== null && m.setMap(Y);
  }, [Y]), y(function() {
    typeof n < "u" && m !== null && m.setOptions(n);
  }, [m, n]), y(function() {
    typeof a < "u" && m !== null && m.setDraggable(a);
  }, [m, a]), y(function() {
    t && m !== null && m.setPosition(t);
  }, [m, t]), y(function() {
    typeof s < "u" && m !== null && m.setVisible(s);
  }, [m, s]), y(function() {
    m == null || m.setAnimation(u);
  }, [m, u]), y(function() {
    m && l !== void 0 && m.setClickable(l);
  }, [m, l]), y(function() {
    m && c !== void 0 && m.setCursor(c);
  }, [m, c]), y(function() {
    m && f !== void 0 && m.setIcon(f);
  }, [m, f]), y(function() {
    m && p !== void 0 && m.setLabel(p);
  }, [m, p]), y(function() {
    m && g !== void 0 && m.setOpacity(g);
  }, [m, g]), y(function() {
    m && v !== void 0 && m.setShape(v);
  }, [m, v]), y(function() {
    m && h !== void 0 && m.setTitle(h);
  }, [m, h]), y(function() {
    m && d !== void 0 && m.setZIndex(d);
  }, [m, d]), y(function() {
    m && L && (T !== null && google.maps.event.removeListener(T), J(google.maps.event.addListener(m, "dblclick", L)));
  }, [L]), y(function() {
    m && B && (N !== null && google.maps.event.removeListener(N), se(google.maps.event.addListener(m, "dragend", B)));
  }, [B]), y(function() {
    m && b && (de !== null && google.maps.event.removeListener(de), ge(google.maps.event.addListener(m, "dragstart", b)));
  }, [b]), y(function() {
    m && V && (me !== null && google.maps.event.removeListener(me), ye(google.maps.event.addListener(m, "mousedown", V)));
  }, [V]), y(function() {
    m && E && (Me !== null && google.maps.event.removeListener(Me), ie(google.maps.event.addListener(m, "mouseout", E)));
  }, [E]), y(function() {
    m && O && (ae !== null && google.maps.event.removeListener(ae), Le(google.maps.event.addListener(m, "mouseover", O)));
  }, [O]), y(function() {
    m && S && (ze !== null && google.maps.event.removeListener(ze), Ye(google.maps.event.addListener(m, "mouseup", S)));
  }, [S]), y(function() {
    m && M && (Ct !== null && google.maps.event.removeListener(Ct), ot(google.maps.event.addListener(m, "rightclick", M)));
  }, [M]), y(function() {
    m && w && (_t !== null && google.maps.event.removeListener(_t), $t(google.maps.event.addListener(m, "click", w)));
  }, [w]), y(function() {
    m && D && (pn !== null && google.maps.event.removeListener(pn), hn(google.maps.event.addListener(m, "drag", D)));
  }, [D]), y(function() {
    m && q && (jt !== null && google.maps.event.removeListener(jt), Qt(google.maps.event.addListener(m, "clickable_changed", q)));
  }, [q]), y(function() {
    m && _ && (Zt !== null && google.maps.event.removeListener(Zt), vn(google.maps.event.addListener(m, "cursor_changed", _)));
  }, [_]), y(function() {
    m && j && (mn !== null && google.maps.event.removeListener(mn), Rn(google.maps.event.addListener(m, "animation_changed", j)));
  }, [j]), y(function() {
    m && I && (en !== null && google.maps.event.removeListener(en), _n(google.maps.event.addListener(m, "draggable_changed", I)));
  }, [I]), y(function() {
    m && z && (yn !== null && google.maps.event.removeListener(yn), jn(google.maps.event.addListener(m, "flat_changed", z)));
  }, [z]), y(function() {
    m && X && (bn !== null && google.maps.event.removeListener(bn), Jn(google.maps.event.addListener(m, "icon_changed", X)));
  }, [X]), y(function() {
    m && R && (Cn !== null && google.maps.event.removeListener(Cn), C(google.maps.event.addListener(m, "position_changed", R)));
  }, [R]), y(function() {
    m && ee && (Q !== null && google.maps.event.removeListener(Q), fe(google.maps.event.addListener(m, "shape_changed", ee)));
  }, [ee]), y(function() {
    m && re && (ke !== null && google.maps.event.removeListener(ke), Ee(google.maps.event.addListener(m, "title_changed", re)));
  }, [re]), y(function() {
    m && k && ($e !== null && google.maps.event.removeListener($e), Ie(google.maps.event.addListener(m, "visible_changed", k)));
  }, [k]), y(function() {
    m && A && (nt !== null && google.maps.event.removeListener(nt), Wt(google.maps.event.addListener(m, "zindex_changed", A)));
  }, [A]), y(function() {
    var Ue = Be(Be(Be({}, n || ya), r ? ya : { map: Y }), { position: t }), he = new google.maps.Marker(Ue);
    return r ? r.addMarker(he, !!o) : he.setMap(Y), t && he.setPosition(t), typeof s < "u" && he.setVisible(s), typeof a < "u" && he.setDraggable(a), typeof l < "u" && he.setClickable(l), typeof c == "string" && he.setCursor(c), f && he.setIcon(f), typeof p < "u" && he.setLabel(p), typeof g < "u" && he.setOpacity(g), v && he.setShape(v), typeof h == "string" && he.setTitle(h), typeof d == "number" && he.setZIndex(d), L && J(google.maps.event.addListener(he, "dblclick", L)), B && se(google.maps.event.addListener(he, "dragend", B)), b && ge(google.maps.event.addListener(he, "dragstart", b)), V && ye(google.maps.event.addListener(he, "mousedown", V)), E && ie(google.maps.event.addListener(he, "mouseout", E)), O && Le(google.maps.event.addListener(he, "mouseover", O)), S && Ye(google.maps.event.addListener(he, "mouseup", S)), M && ot(google.maps.event.addListener(he, "rightclick", M)), w && $t(google.maps.event.addListener(he, "click", w)), D && hn(google.maps.event.addListener(he, "drag", D)), q && Qt(google.maps.event.addListener(he, "clickable_changed", q)), _ && vn(google.maps.event.addListener(he, "cursor_changed", _)), j && Rn(google.maps.event.addListener(he, "animation_changed", j)), I && _n(google.maps.event.addListener(he, "draggable_changed", I)), z && jn(google.maps.event.addListener(he, "flat_changed", z)), X && Jn(google.maps.event.addListener(he, "icon_changed", X)), R && C(google.maps.event.addListener(he, "position_changed", R)), ee && fe(google.maps.event.addListener(he, "shape_changed", ee)), re && Ee(google.maps.event.addListener(he, "title_changed", re)), k && Ie(google.maps.event.addListener(he, "visible_changed", k)), A && Wt(google.maps.event.addListener(he, "zindex_changed", A)), $(he), G && G(he), function() {
      T !== null && google.maps.event.removeListener(T), N !== null && google.maps.event.removeListener(N), de !== null && google.maps.event.removeListener(de), me !== null && google.maps.event.removeListener(me), Me !== null && google.maps.event.removeListener(Me), ae !== null && google.maps.event.removeListener(ae), ze !== null && google.maps.event.removeListener(ze), Ct !== null && google.maps.event.removeListener(Ct), _t !== null && google.maps.event.removeListener(_t), jt !== null && google.maps.event.removeListener(jt), Zt !== null && google.maps.event.removeListener(Zt), mn !== null && google.maps.event.removeListener(mn), en !== null && google.maps.event.removeListener(en), yn !== null && google.maps.event.removeListener(yn), bn !== null && google.maps.event.removeListener(bn), Cn !== null && google.maps.event.removeListener(Cn), ke !== null && google.maps.event.removeListener(ke), $e !== null && google.maps.event.removeListener($e), nt !== null && google.maps.event.removeListener(nt), U && U(he), r ? r.removeMarker(he, !!o) : he && he.setMap(null);
    };
  }, []);
  var Ht = Ln(function() {
    return i ? Vt.map(i, function(Ue) {
      if (!Ia(Ue))
        return Ue;
      var he = Ue;
      return Ra(he, { anchor: m });
    }) : null;
  }, [i, m]);
  return st.jsx(st.Fragment, { children: Ht }) || null;
}
Ze($1);
/** @class */
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = Be(Be(Be({}, this.props.options || ya), this.props.clusterer ? ya : { map: this.context }), { position: this.props.position });
    this.marker = new google.maps.Marker(n), this.props.clusterer ? this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw) : this.marker.setMap(this.context), this.registeredEvents = Ke({
      updaterMap: sd,
      eventMap: ad,
      prevProps: {},
      nextProps: this.props,
      instance: this.marker
    }), this.props.onLoad && this.props.onLoad(this.marker);
  }, t.prototype.componentDidUpdate = function(n) {
    this.marker && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: sd,
      eventMap: ad,
      prevProps: n,
      nextProps: this.props,
      instance: this.marker
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), et(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }, t.prototype.render = function() {
    var n = this, r = null;
    return this.props.children && (r = Vt.map(this.props.children, function(o) {
      if (!Ia(o))
        return o;
      var i = o;
      return Ra(i, { anchor: n.marker });
    })), r || null;
  }, t.contextType = He, t;
})(Te);
var U1 = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, u = this.backgroundPosition.split(" "), l = parseInt(((t = u[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = u[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), f = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(f !== null ? "".concat(f.y, "px") : "0", "; left: ").concat(f !== null ? "".concat(f.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var p = document.createElement("img");
        p.alt = s, p.src = this.url, p.width = this.width, p.height = this.height, p.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(l, "px")), this.cluster.getClusterer().enableRetinaIcons || (p.style.clip = "rect(-".concat(c, "px, -").concat(l + this.width, "px, -").concat(c + this.height, ", -").concat(l, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(p), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), W1 = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new U1(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var u = 0, l = this.markers; u < l.length; u++) {
          var c = l[u];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function H1(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var V1 = 2e3, q1 = 500, Z1 = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", G1 = "png", K1 = [53, 56, 66, 78, 90], Y1 = "cluster", um = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Z1, this.imageExtension = r.imageExtension || G1, this.imageSizes = r.imageSizes || K1, this.calculator = r.calculator || H1, this.batchSize = r.batchSize || V1, this.batchSizeIE = r.batchSizeIE || q1, this.clusterClass = r.clusterClass || Y1, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [
        google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged),
        google.maps.event.addListener(t, "idle", this.onIdle)
      ]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, u = this.listeners; s < u.length; s++) {
        var l = u[s];
        google.maps.event.removeListener(l);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var u = n.getCenter(), l = t.getPosition();
        if (u && l) {
          var c = this.distanceBetweenPoints(u, l);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new W1(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), u = Math.min(t + this.batchSize, this.markers.length), l = t; l < u; l++) {
          var c = this.markers[l];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (u < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(u);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var f = 0, p = this.clusters; f < p.length; f++) {
            var g = p[f];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Tn = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, at = {
  averageCenter: function(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE: function(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator: function(e, t) {
    e.setCalculator(t);
  },
  clusterClass: function(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons: function(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize: function(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden: function(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension: function(e, t) {
    e.setImageExtension(t);
  },
  imagePath: function(e, t) {
    e.setImagePath(t);
  },
  imageSizes: function(e, t) {
    e.setImageSizes(t);
  },
  maxZoom: function(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize: function(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles: function(e, t) {
    e.setStyles(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  zoomOnClick: function(e, t) {
    e.setZoomOnClick(t);
  }
}, X1 = {};
function J1(e) {
  var t = e.children, n = e.options, r = e.averageCenter, o = e.batchSizeIE, i = e.calculator, a = e.clusterClass, s = e.enableRetinaIcons, u = e.gridSize, l = e.ignoreHidden, c = e.imageExtension, f = e.imagePath, p = e.imageSizes, g = e.maxZoom, v = e.minimumClusterSize, h = e.styles, d = e.title, w = e.zoomOnClick, L = e.onClick, D = e.onClusteringBegin, B = e.onClusteringEnd, b = e.onMouseOver, E = e.onMouseOut, O = e.onLoad, S = e.onUnmount, V = P(null), M = V[0], q = V[1], _ = Ae(He), j = P(null), I = j[0], z = j[1], X = P(null), R = X[0], ee = X[1], re = P(null), k = re[0], A = re[1], G = P(null), U = G[0], Y = G[1], K = P(null), m = K[0], $ = K[1];
  return y(function() {
    M && E && (U !== null && google.maps.event.removeListener(U), Y(google.maps.event.addListener(M, Tn.onMouseOut, E)));
  }, [E]), y(function() {
    M && b && (m !== null && google.maps.event.removeListener(m), $(google.maps.event.addListener(M, Tn.onMouseOver, b)));
  }, [b]), y(function() {
    M && L && (I !== null && google.maps.event.removeListener(I), z(google.maps.event.addListener(M, Tn.onClick, L)));
  }, [L]), y(function() {
    M && D && (R !== null && google.maps.event.removeListener(R), ee(google.maps.event.addListener(M, Tn.onClusteringBegin, D)));
  }, [D]), y(function() {
    M && B && (k !== null && google.maps.event.removeListener(k), ee(google.maps.event.addListener(M, Tn.onClusteringEnd, B)));
  }, [B]), y(function() {
    typeof r < "u" && M !== null && at.averageCenter(M, r);
  }, [M, r]), y(function() {
    typeof o < "u" && M !== null && at.batchSizeIE(M, o);
  }, [M, o]), y(function() {
    typeof i < "u" && M !== null && at.calculator(M, i);
  }, [M, i]), y(function() {
    typeof a < "u" && M !== null && at.clusterClass(M, a);
  }, [M, a]), y(function() {
    typeof s < "u" && M !== null && at.enableRetinaIcons(M, s);
  }, [M, s]), y(function() {
    typeof u < "u" && M !== null && at.gridSize(M, u);
  }, [M, u]), y(function() {
    typeof l < "u" && M !== null && at.ignoreHidden(M, l);
  }, [M, l]), y(function() {
    typeof c < "u" && M !== null && at.imageExtension(M, c);
  }, [M, c]), y(function() {
    typeof f < "u" && M !== null && at.imagePath(M, f);
  }, [M, f]), y(function() {
    typeof p < "u" && M !== null && at.imageSizes(M, p);
  }, [M, p]), y(function() {
    typeof g < "u" && M !== null && at.maxZoom(M, g);
  }, [M, g]), y(function() {
    typeof v < "u" && M !== null && at.minimumClusterSize(M, v);
  }, [M, v]), y(function() {
    typeof h < "u" && M !== null && at.styles(M, h);
  }, [M, h]), y(function() {
    typeof d < "u" && M !== null && at.title(M, d);
  }, [M, d]), y(function() {
    typeof w < "u" && M !== null && at.zoomOnClick(M, w);
  }, [M, w]), y(function() {
    if (_) {
      var W = Be({}, n || X1), T = new um(_, [], W);
      return r && at.averageCenter(T, r), o && at.batchSizeIE(T, o), i && at.calculator(T, i), a && at.clusterClass(T, a), s && at.enableRetinaIcons(T, s), u && at.gridSize(T, u), l && at.ignoreHidden(T, l), c && at.imageExtension(T, c), f && at.imagePath(T, f), p && at.imageSizes(T, p), g && at.maxZoom(T, g), v && at.minimumClusterSize(T, v), h && at.styles(T, h), d && at.title(T, d), w && at.zoomOnClick(T, w), E && Y(google.maps.event.addListener(T, Tn.onMouseOut, E)), b && $(google.maps.event.addListener(T, Tn.onMouseOver, b)), L && z(google.maps.event.addListener(T, Tn.onClick, L)), D && ee(google.maps.event.addListener(T, Tn.onClusteringBegin, D)), B && A(google.maps.event.addListener(T, Tn.onClusteringEnd, B)), q(T), O && O(T), function() {
        U !== null && google.maps.event.removeListener(U), m !== null && google.maps.event.removeListener(m), I !== null && google.maps.event.removeListener(I), R !== null && google.maps.event.removeListener(R), k !== null && google.maps.event.removeListener(k), S && S(T);
      };
    }
  }, []), M !== null && t(M) || null;
}
Ze(J1);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      markerClusterer: null
    }, n.setClustererCallback = function() {
      n.state.markerClusterer !== null && n.props.onLoad && n.props.onLoad(n.state.markerClusterer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context) {
      var n = new um(this.context, [], this.props.options);
      this.registeredEvents = Ke({
        updaterMap: at,
        eventMap: Tn,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          markerClusterer: n
        };
      }, this.setClustererCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.markerClusterer && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: at,
      eventMap: Tn,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), et(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }, t.prototype.render = function() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }, t.contextType = He, t;
})(Te);
function ud(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var lm = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(l) {
        l.returnValue = !1, l.preventDefault && l.preventDefault(), t.enableEventPropagation || ud(l);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = [
            "mousedown",
            "mouseover",
            "mouseout",
            "mouseup",
            "click",
            "dblclick",
            "touchstart",
            "touchend",
            "touchmove"
          ], a = 0, s = i; a < s.length; a++) {
            var u = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, u, ud));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, u = a.offsetHeight, l = this.pixelOffset.width, c = this.pixelOffset.height, f = this.div.offsetWidth, p = this.div.offsetHeight, g = this.infoBoxClearance.width, v = this.infoBoxClearance.height, h = this.getProjection(), d = h.fromLatLngToContainerPixel(this.position);
          d !== null && (d.x < -l + g ? r = d.x + l - g : d.x + f + l + g > s && (r = d.x + f + l + g - s), this.alignBottom ? d.y < -c + v + p ? o = d.y + c - v - p : d.y + c + v > u && (o = d.y + c + v - u) : d.y < -c + v ? o = d.y + c - v : d.y + p + c + v > u && (o = d.y + p + c + v - u)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = { top: 0, bottom: 0, left: 0, right: 0 };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), ld = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, cd = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, Q1 = {};
function ew(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, a = e.onCloseClick, s = e.onDomReady, u = e.onContentChanged, l = e.onPositionChanged, c = e.onZindexChanged, f = e.onLoad, p = e.onUnmount, g = Ae(He), v = P(null), h = v[0], d = v[1], w = P(null), L = w[0], D = w[1], B = P(null), b = B[0], E = B[1], O = P(null), S = O[0], V = O[1], M = P(null), q = M[0], _ = M[1], j = P(null), I = j[0], z = j[1], X = rt(null);
  return y(function() {
    g && h !== null && (h.close(), n ? h.open(g, n) : h.getPosition() && h.open(g));
  }, [g, h, n]), y(function() {
    r && h !== null && h.setOptions(r);
  }, [h, r]), y(function() {
    if (o && h !== null) {
      var R = o instanceof google.maps.LatLng ? o : new google.maps.LatLng(o.lat, o.lng);
      h.setPosition(R);
    }
  }, [o]), y(function() {
    typeof i == "number" && h !== null && h.setZIndex(i);
  }, [i]), y(function() {
    h && a && (L !== null && google.maps.event.removeListener(L), D(google.maps.event.addListener(h, "closeclick", a)));
  }, [a]), y(function() {
    h && s && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(h, "domready", s)));
  }, [s]), y(function() {
    h && u && (S !== null && google.maps.event.removeListener(S), V(google.maps.event.addListener(h, "content_changed", u)));
  }, [u]), y(function() {
    h && l && (q !== null && google.maps.event.removeListener(q), _(google.maps.event.addListener(h, "position_changed", l)));
  }, [l]), y(function() {
    h && c && (I !== null && google.maps.event.removeListener(I), z(google.maps.event.addListener(h, "zindex_changed", c)));
  }, [c]), y(function() {
    if (g) {
      var R = r || Q1, ee = R.position, re = Fl(R, ["position"]), k = void 0;
      ee && !(ee instanceof google.maps.LatLng) && (k = new google.maps.LatLng(ee.lat, ee.lng));
      var A = new lm(Be(Be({}, re), k ? { position: k } : {}));
      X.current = document.createElement("div"), d(A), a && D(google.maps.event.addListener(A, "closeclick", a)), s && E(google.maps.event.addListener(A, "domready", s)), u && V(google.maps.event.addListener(A, "content_changed", u)), l && _(google.maps.event.addListener(A, "position_changed", l)), c && z(google.maps.event.addListener(A, "zindex_changed", c)), A.setContent(X.current), n ? A.open(g, n) : A.getPosition() ? A.open(g) : zt(!1, "You must provide either an anchor or a position prop for <InfoBox>."), f && f(A);
    }
    return function() {
      h !== null && (L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), q && google.maps.event.removeListener(q), I && google.maps.event.removeListener(I), p && p(h), h.close());
    };
  }, []), X.current ? Pr(Vt.only(t), X.current) : null;
}
Ze(ew);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoBox: null
    }, n.open = function(r, o) {
      o ? n.context !== null && r.open(n.context, o) : r.getPosition() ? n.context !== null && r.open(n.context) : zt(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }, n.setInfoBoxCallback = function() {
      n.state.infoBox !== null && n.containerElement !== null && (n.state.infoBox.setContent(n.containerElement), n.open(n.state.infoBox, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoBox));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.props.options || {}, r = n.position, o = Fl(n, ["position"]), i;
    r && !(r instanceof google.maps.LatLng) && (i = new google.maps.LatLng(r.lat, r.lng));
    var a = new lm(Be(Be({}, o), i ? { position: i } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Ke({
      updaterMap: cd,
      eventMap: ld,
      prevProps: {},
      nextProps: this.props,
      instance: a
    }), this.setState({ infoBox: a }, this.setInfoBoxCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = this.state.infoBox;
    r !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: cd,
      eventMap: ld,
      prevProps: n,
      nextProps: this.props,
      instance: r
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n = this.props.onUnmount, r = this.state.infoBox;
    r !== null && (n && n(r), et(this.registeredEvents), r.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Pr(Vt.only(this.props.children), this.containerElement) : null;
  }, t.contextType = He, t;
})(Te);
var tw = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, o, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
    for (o = r; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
    for (o = r; o-- !== 0; ) {
      var a = i[o];
      if (!e(t[a], n[a])) return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
}, fd = /* @__PURE__ */ rm(tw);
const dd = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], Fs = 1, ko = 8;
class Il {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const o = r >> 4;
    if (o !== Fs)
      throw new Error(`Got v${o} data when expected v${Fs}.`);
    const i = dd[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new Il(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, o) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = dd.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, u = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, ko, t), this.coords = new this.ArrayType(this.data, ko + s + u, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(ko + a + s + u), this.ids = new this.IndexArrayType(this.data, ko, t), this.coords = new this.ArrayType(this.data, ko + s + u, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Fs << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return Nu(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: a, nodeSize: s } = this, u = [0, i.length - 1, 0], l = [];
    for (; u.length; ) {
      const c = u.pop() || 0, f = u.pop() || 0, p = u.pop() || 0;
      if (f - p <= s) {
        for (let d = p; d <= f; d++) {
          const w = a[2 * d], L = a[2 * d + 1];
          w >= t && w <= r && L >= n && L <= o && l.push(i[d]);
        }
        continue;
      }
      const g = p + f >> 1, v = a[2 * g], h = a[2 * g + 1];
      v >= t && v <= r && h >= n && h <= o && l.push(i[g]), (c === 0 ? t <= v : n <= h) && (u.push(p), u.push(g - 1), u.push(1 - c)), (c === 0 ? r >= v : o >= h) && (u.push(g + 1), u.push(f), u.push(1 - c));
    }
    return l;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: o, coords: i, nodeSize: a } = this, s = [0, o.length - 1, 0], u = [], l = r * r;
    for (; s.length; ) {
      const c = s.pop() || 0, f = s.pop() || 0, p = s.pop() || 0;
      if (f - p <= a) {
        for (let d = p; d <= f; d++)
          pd(i[2 * d], i[2 * d + 1], t, n) <= l && u.push(o[d]);
        continue;
      }
      const g = p + f >> 1, v = i[2 * g], h = i[2 * g + 1];
      pd(v, h, t, n) <= l && u.push(o[g]), (c === 0 ? t - r <= v : n - r <= h) && (s.push(p), s.push(g - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= h) && (s.push(g + 1), s.push(f), s.push(1 - c));
    }
    return u;
  }
}
function Nu(e, t, n, r, o, i) {
  if (o - r <= n) return;
  const a = r + o >> 1;
  cm(e, t, a, r, o, i), Nu(e, t, n, r, a - 1, 1 - i), Nu(e, t, n, a + 1, o, 1 - i);
}
function cm(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      const l = o - r + 1, c = n - r + 1, f = Math.log(l), p = 0.5 * Math.exp(2 * f / 3), g = 0.5 * Math.sqrt(f * p * (l - p) / l) * (c - l / 2 < 0 ? -1 : 1), v = Math.max(r, Math.floor(n - c * p / l + g)), h = Math.min(o, Math.floor(n + (l - c) * p / l + g));
      cm(e, t, n, v, h, i);
    }
    const a = t[2 * n + i];
    let s = r, u = o;
    for (Mo(e, t, r, n), t[2 * o + i] > a && Mo(e, t, r, o); s < u; ) {
      for (Mo(e, t, s, u), s++, u--; t[2 * s + i] < a; ) s++;
      for (; t[2 * u + i] > a; ) u--;
    }
    t[2 * r + i] === a ? Mo(e, t, r, u) : (u++, Mo(e, t, u, o)), u <= n && (r = u + 1), n <= u && (o = u - 1);
  }
}
function Mo(e, t, n, r) {
  Is(e, n, r), Is(t, 2 * n, 2 * r), Is(t, 2 * n + 1, 2 * r + 1);
}
function Is(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function pd(e, t, n, r) {
  const o = e - n, i = t - r;
  return o * o + i * i;
}
const nw = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, hd = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Nr = 2, Cr = 3, Rs = 4, yr = 5, fm = 6;
class rw {
  constructor(t) {
    this.options = Object.assign(Object.create(nw), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    const { log: n, minZoom: r, maxZoom: o } = this.options;
    n && console.time("total time");
    const i = `prepare ${t.length} points`;
    n && console.time(i), this.points = t;
    const a = [];
    for (let u = 0; u < t.length; u++) {
      const l = t[u];
      if (!l.geometry) continue;
      const [c, f] = l.geometry.coordinates, p = hd(Oi(c)), g = hd(Si(f));
      a.push(
        p,
        g,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        u,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && a.push(0);
    }
    let s = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (let u = o; u >= r; u--) {
      const l = +Date.now();
      s = this.trees[u] = this._createTree(this._cluster(s, u)), n && console.log("z%d: %d clusters in %dms", u, s.numItems, +Date.now() - l);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    let r = ((t[0] + 180) % 360 + 360) % 360 - 180;
    const o = Math.max(-90, Math.min(90, t[1]));
    let i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
    const a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      const f = this.getClusters([r, o, 180, a], n), p = this.getClusters([-180, o, i, a], n);
      return f.concat(p);
    }
    const s = this.trees[this._limitZoom(n)], u = s.range(Oi(r), Si(a), Oi(i), Si(o)), l = s.data, c = [];
    for (const f of u) {
      const p = this.stride * f;
      c.push(l[p + yr] > 1 ? gd(l, p, this.clusterProps) : this.points[l[p + Cr]]);
    }
    return c;
  }
  getChildren(t) {
    const n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    const a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    const s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), u = a[n * this.stride], l = a[n * this.stride + 1], c = i.within(u, l, s), f = [];
    for (const p of c) {
      const g = p * this.stride;
      a[g + Rs] === t && f.push(a[g + yr] > 1 ? gd(a, g, this.clusterProps) : this.points[a[g + Cr]]);
    }
    if (f.length === 0) throw new Error(o);
    return f;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    const o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    const o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), { extent: a, radius: s } = this.options, u = s / a, l = (r - u) / i, c = (r + 1 + u) / i, f = {
      features: []
    };
    return this._addTileFeatures(
      o.range((n - u) / i, l, (n + 1 + u) / i, c),
      o.data,
      n,
      r,
      i,
      f
    ), n === 0 && this._addTileFeatures(
      o.range(1 - u / i, l, 1, c),
      o.data,
      i,
      r,
      i,
      f
    ), n === i - 1 && this._addTileFeatures(
      o.range(0, l, u / i, c),
      o.data,
      -1,
      r,
      i,
      f
    ), f.features.length ? f : null;
  }
  getClusterExpansionZoom(t) {
    let n = this._getOriginZoom(t) - 1;
    for (; n <= this.options.maxZoom; ) {
      const r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    const a = this.getChildren(n);
    for (const s of a) {
      const u = s.properties;
      if (u && u.cluster ? i + u.point_count <= o ? i += u.point_count : i = this._appendLeaves(t, u.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    const n = new Il(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (const s of t) {
      const u = s * this.stride, l = n[u + yr] > 1;
      let c, f, p;
      if (l)
        c = dm(n, u, this.clusterProps), f = n[u], p = n[u + 1];
      else {
        const h = this.points[n[u + Cr]];
        c = h.properties;
        const [d, w] = h.geometry.coordinates;
        f = Oi(d), p = Si(w);
      }
      const g = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (f * i - r)),
          Math.round(this.options.extent * (p * i - o))
        ]],
        tags: c
      };
      let v;
      l || this.options.generateId ? v = n[u + Cr] : v = this.points[n[u + Cr]].id, v !== void 0 && (g.id = v), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    const { radius: r, extent: o, reduce: i, minPoints: a } = this.options, s = r / (o * Math.pow(2, n)), u = t.data, l = [], c = this.stride;
    for (let f = 0; f < u.length; f += c) {
      if (u[f + Nr] <= n) continue;
      u[f + Nr] = n;
      const p = u[f], g = u[f + 1], v = t.within(u[f], u[f + 1], s), h = u[f + yr];
      let d = h;
      for (const w of v) {
        const L = w * c;
        u[L + Nr] > n && (d += u[L + yr]);
      }
      if (d > h && d >= a) {
        let w = p * h, L = g * h, D, B = -1;
        const b = ((f / c | 0) << 5) + (n + 1) + this.points.length;
        for (const E of v) {
          const O = E * c;
          if (u[O + Nr] <= n) continue;
          u[O + Nr] = n;
          const S = u[O + yr];
          w += u[O] * S, L += u[O + 1] * S, u[O + Rs] = b, i && (D || (D = this._map(u, f, !0), B = this.clusterProps.length, this.clusterProps.push(D)), i(D, this._map(u, O)));
        }
        u[f + Rs] = b, l.push(w / d, L / d, 1 / 0, b, -1, d), i && l.push(B);
      } else {
        for (let w = 0; w < c; w++) l.push(u[f + w]);
        if (d > 1)
          for (const w of v) {
            const L = w * c;
            if (!(u[L + Nr] <= n)) {
              u[L + Nr] = n;
              for (let D = 0; D < c; D++) l.push(u[L + D]);
            }
          }
      }
    }
    return l;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + yr] > 1) {
      const a = this.clusterProps[t[n + fm]];
      return r ? Object.assign({}, a) : a;
    }
    const o = this.points[t[n + Cr]].properties, i = this.options.map(o);
    return r && i === o ? Object.assign({}, i) : i;
  }
}
function gd(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Cr],
    properties: dm(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [ow(e[t]), iw(e[t + 1])]
    }
  };
}
function dm(e, t, n) {
  const r = e[t + yr], o = r >= 1e4 ? `${Math.round(r / 1e3)}k` : r >= 1e3 ? `${Math.round(r / 100) / 10}k` : r, i = e[t + fm], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Cr],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Oi(e) {
  return e / 360 + 0.5;
}
function Si(e) {
  const t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function ow(e) {
  return (e - 0.5) * 360;
}
function iw(e) {
  const t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function aw(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Dn {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class zu {
  constructor({ markers: t, position: n }) {
    this.markers = t, n && (n instanceof google.maps.LatLng ? this._position = n : this._position = new google.maps.LatLng(n));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const t = new google.maps.LatLngBounds(this._position, this._position);
    for (const n of this.markers)
      t.extend(Dn.getPosition(n));
    return t;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Dn.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Dn.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class sw {
  constructor({ maxZoom: t = 16 }) {
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: t }) {
    return uw(t);
  }
}
const uw = (e) => e.map((t) => new zu({
  position: Dn.getPosition(t),
  markers: [t]
}));
class lw extends sw {
  constructor(t) {
    var { maxZoom: n, radius: r = 60 } = t, o = aw(t, ["maxZoom", "radius"]);
    super({ maxZoom: n }), this.state = { zoom: -1 }, this.superCluster = new rw(Object.assign({ maxZoom: this.maxZoom, radius: r }, o));
  }
  calculate(t) {
    let n = !1;
    const r = { zoom: t.map.getZoom() };
    if (!fd(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      const o = this.markers.map((i) => {
        const a = Dn.getPosition(i);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [a.lng(), a.lat()]
          },
          properties: { marker: i }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !fd(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), { clusters: this.clusters, changed: n };
  }
  cluster({ map: t }) {
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t.getZoom())).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [t, n] }, properties: r }) {
    if (r.cluster)
      return new zu({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((i) => i.properties.marker),
        position: { lat: n, lng: t }
      });
    const o = r.marker;
    return new zu({
      markers: [o],
      position: Dn.getPosition(o)
    });
  }
}
class cw {
  constructor(t, n) {
    this.markers = { sum: t.length };
    const r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class fw {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: t, position: n }, r, o) {
    const i = `<svg fill="${t > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>
</svg>`, a = `Cluster of ${t} markers`, s = Number(google.maps.Marker.MAX_ZINDEX) + t;
    if (Dn.isAdvancedMarkerAvailable(o)) {
      const l = new DOMParser().parseFromString(i, "image/svg+xml").documentElement;
      l.setAttribute("transform", "translate(0 25)");
      const c = {
        map: o,
        position: n,
        zIndex: s,
        title: a,
        content: l
      };
      return new google.maps.marker.AdvancedMarkerElement(c);
    }
    const u = {
      position: n,
      zIndex: s,
      title: a,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(i)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(u);
  }
}
function dw(e, t) {
  for (let n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Rl {
  constructor() {
    dw(Rl, google.maps.OverlayView);
  }
}
var jo;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(jo || (jo = {}));
const pw = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class hw extends Rl {
  constructor({ map: t, markers: n = [], algorithmOptions: r = {}, algorithm: o = new lw(r), renderer: i = new fw(), onClusterClick: a = pw }) {
    super(), this.markers = [...n], this.clusters = [], this.algorithm = o, this.renderer = i, this.onClusterClick = a, t && this.setMap(t);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    const r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Dn.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    let r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, jo.CLUSTERING_BEGIN, this);
      const { clusters: n, changed: r } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        const o = /* @__PURE__ */ new Set();
        for (const a of n)
          a.markers.length == 1 && o.add(a.markers[0]);
        const i = [];
        for (const a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || Dn.setMap(a.marker, null) : i.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => i.forEach((a) => Dn.setMap(a, null)));
      }
      google.maps.event.trigger(this, jo.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Dn.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    const t = new cw(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Dn.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, jo.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Dn.setMap(r.marker, n);
    });
  }
}
function gw(e) {
  var t = S1(), n = P(null), r = n[0], o = n[1];
  return y(function() {
    if (t && r === null) {
      var i = new hw(Be(Be({}, e), { map: t }));
      o(i);
    }
  }, [t]), r;
}
function vw(e) {
  var t = e.children, n = e.options, r = gw(n);
  return r !== null ? t(r) : null;
}
Ze(vw);
var vd = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, md = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
function mw(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, a = e.onCloseClick, s = e.onDomReady, u = e.onContentChanged, l = e.onPositionChanged, c = e.onZindexChanged, f = e.onLoad, p = e.onUnmount, g = Ae(He), v = P(null), h = v[0], d = v[1], w = P(null), L = w[0], D = w[1], B = P(null), b = B[0], E = B[1], O = P(null), S = O[0], V = O[1], M = P(null), q = M[0], _ = M[1], j = P(null), I = j[0], z = j[1], X = rt(null);
  return y(function() {
    h !== null && (h.close(), n ? h.open(g, n) : h.getPosition() && h.open(g));
  }, [g, h, n]), y(function() {
    r && h !== null && h.setOptions(r);
  }, [h, r]), y(function() {
    o && h !== null && h.setPosition(o);
  }, [o]), y(function() {
    typeof i == "number" && h !== null && h.setZIndex(i);
  }, [i]), y(function() {
    h && a && (L !== null && google.maps.event.removeListener(L), D(google.maps.event.addListener(h, "closeclick", a)));
  }, [a]), y(function() {
    h && s && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(h, "domready", s)));
  }, [s]), y(function() {
    h && u && (S !== null && google.maps.event.removeListener(S), V(google.maps.event.addListener(h, "content_changed", u)));
  }, [u]), y(function() {
    h && l && (q !== null && google.maps.event.removeListener(q), _(google.maps.event.addListener(h, "position_changed", l)));
  }, [l]), y(function() {
    h && c && (I !== null && google.maps.event.removeListener(I), z(google.maps.event.addListener(h, "zindex_changed", c)));
  }, [c]), y(function() {
    var R = new google.maps.InfoWindow(Be({}, r || {}));
    return d(R), X.current = document.createElement("div"), a && D(google.maps.event.addListener(R, "closeclick", a)), s && E(google.maps.event.addListener(R, "domready", s)), u && V(google.maps.event.addListener(R, "content_changed", u)), l && _(google.maps.event.addListener(R, "position_changed", l)), c && z(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(X.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : zt(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), f && f(R), function() {
      L && google.maps.event.removeListener(L), S && google.maps.event.removeListener(S), b && google.maps.event.removeListener(b), q && google.maps.event.removeListener(q), I && google.maps.event.removeListener(I), p && p(R), R.close();
    };
  }, []), X.current ? Pr(Vt.only(t), X.current) : null;
}
Ze(mw);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoWindow: null
    }, n.open = function(r, o) {
      o ? r.open(n.context, o) : r.getPosition() ? r.open(n.context) : zt(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }, n.setInfoWindowCallback = function() {
      n.state.infoWindow !== null && n.containerElement !== null && (n.state.infoWindow.setContent(n.containerElement), n.open(n.state.infoWindow, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoWindow));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.InfoWindow(Be({}, this.props.options || {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Ke({
      updaterMap: md,
      eventMap: vd,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        infoWindow: n
      };
    }, this.setInfoWindowCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.infoWindow !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: md,
      eventMap: vd,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.infoWindow !== null && (et(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Pr(Vt.only(this.props.children), this.containerElement) : null;
  }, t.contextType = He, t;
})(Te);
var yd = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, bd = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, yw = {};
function bw(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, a = e.onDblClick, s = e.onDragEnd, u = e.onDragStart, l = e.onMouseDown, c = e.onMouseMove, f = e.onMouseOut, p = e.onMouseOver, g = e.onMouseUp, v = e.onRightClick, h = e.onClick, d = e.onDrag, w = e.onLoad, L = e.onUnmount, D = Ae(He), B = P(null), b = B[0], E = B[1], O = P(null), S = O[0], V = O[1], M = P(null), q = M[0], _ = M[1], j = P(null), I = j[0], z = j[1], X = P(null), R = X[0], ee = X[1], re = P(null), k = re[0], A = re[1], G = P(null), U = G[0], Y = G[1], K = P(null), m = K[0], $ = K[1], W = P(null), T = W[0], J = W[1], te = P(null), N = te[0], se = te[1], ue = P(null), de = ue[0], ge = ue[1], Ce = P(null), me = Ce[0], ye = Ce[1];
  return y(function() {
    b !== null && b.setMap(D);
  }, [D]), y(function() {
    typeof t < "u" && b !== null && b.setOptions(t);
  }, [b, t]), y(function() {
    typeof n < "u" && b !== null && b.setDraggable(n);
  }, [b, n]), y(function() {
    typeof r < "u" && b !== null && b.setEditable(r);
  }, [b, r]), y(function() {
    typeof o < "u" && b !== null && b.setVisible(o);
  }, [b, o]), y(function() {
    typeof i < "u" && b !== null && b.setPath(i);
  }, [b, i]), y(function() {
    b && a && (S !== null && google.maps.event.removeListener(S), V(google.maps.event.addListener(b, "dblclick", a)));
  }, [a]), y(function() {
    b && s && (q !== null && google.maps.event.removeListener(q), _(google.maps.event.addListener(b, "dragend", s)));
  }, [s]), y(function() {
    b && u && (I !== null && google.maps.event.removeListener(I), z(google.maps.event.addListener(b, "dragstart", u)));
  }, [u]), y(function() {
    b && l && (R !== null && google.maps.event.removeListener(R), ee(google.maps.event.addListener(b, "mousedown", l)));
  }, [l]), y(function() {
    b && c && (k !== null && google.maps.event.removeListener(k), A(google.maps.event.addListener(b, "mousemove", c)));
  }, [c]), y(function() {
    b && f && (U !== null && google.maps.event.removeListener(U), Y(google.maps.event.addListener(b, "mouseout", f)));
  }, [f]), y(function() {
    b && p && (m !== null && google.maps.event.removeListener(m), $(google.maps.event.addListener(b, "mouseover", p)));
  }, [p]), y(function() {
    b && g && (T !== null && google.maps.event.removeListener(T), J(google.maps.event.addListener(b, "mouseup", g)));
  }, [g]), y(function() {
    b && v && (N !== null && google.maps.event.removeListener(N), se(google.maps.event.addListener(b, "rightclick", v)));
  }, [v]), y(function() {
    b && h && (de !== null && google.maps.event.removeListener(de), ge(google.maps.event.addListener(b, "click", h)));
  }, [h]), y(function() {
    b && d && (me !== null && google.maps.event.removeListener(me), ye(google.maps.event.addListener(b, "drag", d)));
  }, [d]), y(function() {
    var ce = new google.maps.Polyline(Be(Be({}, t || yw), { map: D }));
    return i && ce.setPath(i), typeof o < "u" && ce.setVisible(o), typeof r < "u" && ce.setEditable(r), typeof n < "u" && ce.setDraggable(n), a && V(google.maps.event.addListener(ce, "dblclick", a)), s && _(google.maps.event.addListener(ce, "dragend", s)), u && z(google.maps.event.addListener(ce, "dragstart", u)), l && ee(google.maps.event.addListener(ce, "mousedown", l)), c && A(google.maps.event.addListener(ce, "mousemove", c)), f && Y(google.maps.event.addListener(ce, "mouseout", f)), p && $(google.maps.event.addListener(ce, "mouseover", p)), g && J(google.maps.event.addListener(ce, "mouseup", g)), v && se(google.maps.event.addListener(ce, "rightclick", v)), h && ge(google.maps.event.addListener(ce, "click", h)), d && ye(google.maps.event.addListener(ce, "drag", d)), E(ce), w && w(ce), function() {
      S !== null && google.maps.event.removeListener(S), q !== null && google.maps.event.removeListener(q), I !== null && google.maps.event.removeListener(I), R !== null && google.maps.event.removeListener(R), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), m !== null && google.maps.event.removeListener(m), T !== null && google.maps.event.removeListener(T), N !== null && google.maps.event.removeListener(N), de !== null && google.maps.event.removeListener(de), L && L(ce), ce.setMap(null);
    };
  }, []), null;
}
Ze(bw);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polyline: null
    }, n.setPolylineCallback = function() {
      n.state.polyline !== null && n.props.onLoad && n.props.onLoad(n.state.polyline);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polyline(Be(Be({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ke({
      updaterMap: bd,
      eventMap: yd,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polyline: n
      };
    }, this.setPolylineCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polyline !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: bd,
      eventMap: yd,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), et(this.registeredEvents), this.state.polyline.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = He, t;
})(Te);
var Cd = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, wd = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  paths: function(e, t) {
    e.setPaths(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function Cw(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, a = e.paths, s = e.onDblClick, u = e.onDragEnd, l = e.onDragStart, c = e.onMouseDown, f = e.onMouseMove, p = e.onMouseOut, g = e.onMouseOver, v = e.onMouseUp, h = e.onRightClick, d = e.onClick, w = e.onDrag, L = e.onLoad, D = e.onUnmount, B = e.onEdit, b = Ae(He), E = P(null), O = E[0], S = E[1], V = P(null), M = V[0], q = V[1], _ = P(null), j = _[0], I = _[1], z = P(null), X = z[0], R = z[1], ee = P(null), re = ee[0], k = ee[1], A = P(null), G = A[0], U = A[1], Y = P(null), K = Y[0], m = Y[1], $ = P(null), W = $[0], T = $[1], J = P(null), te = J[0], N = J[1], se = P(null), ue = se[0], de = se[1], ge = P(null), Ce = ge[0], me = ge[1], ye = P(null), ce = ye[0], Me = ye[1];
  return y(function() {
    O !== null && O.setMap(b);
  }, [b]), y(function() {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), y(function() {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), y(function() {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), y(function() {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), y(function() {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), y(function() {
    typeof a < "u" && O !== null && O.setPaths(a);
  }, [O, a]), y(function() {
    O && s && (M !== null && google.maps.event.removeListener(M), q(google.maps.event.addListener(O, "dblclick", s)));
  }, [s]), y(function() {
    O && (google.maps.event.addListener(O.getPath(), "insert_at", function() {
      B == null || B(O);
    }), google.maps.event.addListener(O.getPath(), "set_at", function() {
      B == null || B(O);
    }));
  }, [O, B]), y(function() {
    O && u && (j !== null && google.maps.event.removeListener(j), I(google.maps.event.addListener(O, "dragend", u)));
  }, [u]), y(function() {
    O && l && (X !== null && google.maps.event.removeListener(X), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), y(function() {
    O && c && (re !== null && google.maps.event.removeListener(re), k(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), y(function() {
    O && f && (G !== null && google.maps.event.removeListener(G), U(google.maps.event.addListener(O, "mousemove", f)));
  }, [f]), y(function() {
    O && p && (K !== null && google.maps.event.removeListener(K), m(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), y(function() {
    O && g && (W !== null && google.maps.event.removeListener(W), T(google.maps.event.addListener(O, "mouseover", g)));
  }, [g]), y(function() {
    O && v && (te !== null && google.maps.event.removeListener(te), N(google.maps.event.addListener(O, "mouseup", v)));
  }, [v]), y(function() {
    O && h && (ue !== null && google.maps.event.removeListener(ue), de(google.maps.event.addListener(O, "rightclick", h)));
  }, [h]), y(function() {
    O && d && (Ce !== null && google.maps.event.removeListener(Ce), me(google.maps.event.addListener(O, "click", d)));
  }, [d]), y(function() {
    O && w && (ce !== null && google.maps.event.removeListener(ce), Me(google.maps.event.addListener(O, "drag", w)));
  }, [w]), y(function() {
    var ie = new google.maps.Polygon(Be(Be({}, t || {}), { map: b }));
    return i && ie.setPath(i), a && ie.setPaths(a), typeof o < "u" && ie.setVisible(o), typeof r < "u" && ie.setEditable(r), typeof n < "u" && ie.setDraggable(n), s && q(google.maps.event.addListener(ie, "dblclick", s)), u && I(google.maps.event.addListener(ie, "dragend", u)), l && R(google.maps.event.addListener(ie, "dragstart", l)), c && k(google.maps.event.addListener(ie, "mousedown", c)), f && U(google.maps.event.addListener(ie, "mousemove", f)), p && m(google.maps.event.addListener(ie, "mouseout", p)), g && T(google.maps.event.addListener(ie, "mouseover", g)), v && N(google.maps.event.addListener(ie, "mouseup", v)), h && de(google.maps.event.addListener(ie, "rightclick", h)), d && me(google.maps.event.addListener(ie, "click", d)), w && Me(google.maps.event.addListener(ie, "drag", w)), S(ie), L && L(ie), function() {
      M !== null && google.maps.event.removeListener(M), j !== null && google.maps.event.removeListener(j), X !== null && google.maps.event.removeListener(X), re !== null && google.maps.event.removeListener(re), G !== null && google.maps.event.removeListener(G), K !== null && google.maps.event.removeListener(K), W !== null && google.maps.event.removeListener(W), te !== null && google.maps.event.removeListener(te), ue !== null && google.maps.event.removeListener(ue), Ce !== null && google.maps.event.removeListener(Ce), D && D(ie), ie.setMap(null);
    };
  }, []), null;
}
Ze(Cw);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polygon: null
    }, n.setPolygonCallback = function() {
      n.state.polygon !== null && n.props.onLoad && n.props.onLoad(n.state.polygon);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polygon(Be(Be({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ke({
      updaterMap: wd,
      eventMap: Cd,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polygon: n
      };
    }, this.setPolygonCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polygon !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: wd,
      eventMap: Cd,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polygon
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polygon !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polygon), et(this.registeredEvents), this.state.polygon && this.state.polygon.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = He, t;
})(Te);
var Ed = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Dd = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function ww(e) {
  var t = e.options, n = e.bounds, r = e.draggable, o = e.editable, i = e.visible, a = e.onDblClick, s = e.onDragEnd, u = e.onDragStart, l = e.onMouseDown, c = e.onMouseMove, f = e.onMouseOut, p = e.onMouseOver, g = e.onMouseUp, v = e.onRightClick, h = e.onClick, d = e.onDrag, w = e.onBoundsChanged, L = e.onLoad, D = e.onUnmount, B = Ae(He), b = P(null), E = b[0], O = b[1], S = P(null), V = S[0], M = S[1], q = P(null), _ = q[0], j = q[1], I = P(null), z = I[0], X = I[1], R = P(null), ee = R[0], re = R[1], k = P(null), A = k[0], G = k[1], U = P(null), Y = U[0], K = U[1], m = P(null), $ = m[0], W = m[1], T = P(null), J = T[0], te = T[1], N = P(null), se = N[0], ue = N[1], de = P(null), ge = de[0], Ce = de[1], me = P(null), ye = me[0], ce = me[1], Me = P(null), ie = Me[0], Re = Me[1];
  return y(function() {
    E !== null && E.setMap(B);
  }, [B]), y(function() {
    typeof t < "u" && E !== null && E.setOptions(t);
  }, [E, t]), y(function() {
    typeof r < "u" && E !== null && E.setDraggable(r);
  }, [E, r]), y(function() {
    typeof o < "u" && E !== null && E.setEditable(o);
  }, [E, o]), y(function() {
    typeof i < "u" && E !== null && E.setVisible(i);
  }, [E, i]), y(function() {
    typeof n < "u" && E !== null && E.setBounds(n);
  }, [E, n]), y(function() {
    E && a && (V !== null && google.maps.event.removeListener(V), M(google.maps.event.addListener(E, "dblclick", a)));
  }, [a]), y(function() {
    E && s && (_ !== null && google.maps.event.removeListener(_), j(google.maps.event.addListener(E, "dragend", s)));
  }, [s]), y(function() {
    E && u && (z !== null && google.maps.event.removeListener(z), X(google.maps.event.addListener(E, "dragstart", u)));
  }, [u]), y(function() {
    E && l && (ee !== null && google.maps.event.removeListener(ee), re(google.maps.event.addListener(E, "mousedown", l)));
  }, [l]), y(function() {
    E && c && (A !== null && google.maps.event.removeListener(A), G(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(function() {
    E && f && (Y !== null && google.maps.event.removeListener(Y), K(google.maps.event.addListener(E, "mouseout", f)));
  }, [f]), y(function() {
    E && p && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(E, "mouseover", p)));
  }, [p]), y(function() {
    E && g && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(E, "mouseup", g)));
  }, [g]), y(function() {
    E && v && (se !== null && google.maps.event.removeListener(se), ue(google.maps.event.addListener(E, "rightclick", v)));
  }, [v]), y(function() {
    E && h && (ge !== null && google.maps.event.removeListener(ge), Ce(google.maps.event.addListener(E, "click", h)));
  }, [h]), y(function() {
    E && d && (ye !== null && google.maps.event.removeListener(ye), ce(google.maps.event.addListener(E, "drag", d)));
  }, [d]), y(function() {
    E && w && (ie !== null && google.maps.event.removeListener(ie), Re(google.maps.event.addListener(E, "bounds_changed", w)));
  }, [w]), y(function() {
    var ae = new google.maps.Rectangle(Be(Be({}, t || {}), { map: B }));
    return typeof i < "u" && ae.setVisible(i), typeof o < "u" && ae.setEditable(o), typeof r < "u" && ae.setDraggable(r), typeof n < "u" && ae.setBounds(n), a && M(google.maps.event.addListener(ae, "dblclick", a)), s && j(google.maps.event.addListener(ae, "dragend", s)), u && X(google.maps.event.addListener(ae, "dragstart", u)), l && re(google.maps.event.addListener(ae, "mousedown", l)), c && G(google.maps.event.addListener(ae, "mousemove", c)), f && K(google.maps.event.addListener(ae, "mouseout", f)), p && W(google.maps.event.addListener(ae, "mouseover", p)), g && te(google.maps.event.addListener(ae, "mouseup", g)), v && ue(google.maps.event.addListener(ae, "rightclick", v)), h && Ce(google.maps.event.addListener(ae, "click", h)), d && ce(google.maps.event.addListener(ae, "drag", d)), w && Re(google.maps.event.addListener(ae, "bounds_changed", w)), O(ae), L && L(ae), function() {
      V !== null && google.maps.event.removeListener(V), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), ee !== null && google.maps.event.removeListener(ee), A !== null && google.maps.event.removeListener(A), Y !== null && google.maps.event.removeListener(Y), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), se !== null && google.maps.event.removeListener(se), ge !== null && google.maps.event.removeListener(ge), ye !== null && google.maps.event.removeListener(ye), ie !== null && google.maps.event.removeListener(ie), D && D(ae), ae.setMap(null);
    };
  }, []), null;
}
Ze(ww);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      rectangle: null
    }, n.setRectangleCallback = function() {
      n.state.rectangle !== null && n.props.onLoad && n.props.onLoad(n.state.rectangle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Rectangle(Be(Be({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ke({
      updaterMap: Dd,
      eventMap: Ed,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        rectangle: n
      };
    }, this.setRectangleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.rectangle !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: Dd,
      eventMap: Ed,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), et(this.registeredEvents), this.state.rectangle.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = He, t;
})(Te);
var xd = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Ld = {
  center: function(e, t) {
    e.setCenter(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  radius: function(e, t) {
    e.setRadius(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, Ew = {};
function Dw(e) {
  var t = e.options, n = e.center, r = e.radius, o = e.draggable, i = e.editable, a = e.visible, s = e.onDblClick, u = e.onDragEnd, l = e.onDragStart, c = e.onMouseDown, f = e.onMouseMove, p = e.onMouseOut, g = e.onMouseOver, v = e.onMouseUp, h = e.onRightClick, d = e.onClick, w = e.onDrag, L = e.onCenterChanged, D = e.onRadiusChanged, B = e.onLoad, b = e.onUnmount, E = Ae(He), O = P(null), S = O[0], V = O[1], M = P(null), q = M[0], _ = M[1], j = P(null), I = j[0], z = j[1], X = P(null), R = X[0], ee = X[1], re = P(null), k = re[0], A = re[1], G = P(null), U = G[0], Y = G[1], K = P(null), m = K[0], $ = K[1], W = P(null), T = W[0], J = W[1], te = P(null), N = te[0], se = te[1], ue = P(null), de = ue[0], ge = ue[1], Ce = P(null), me = Ce[0], ye = Ce[1], ce = P(null), Me = ce[0], ie = ce[1], Re = P(null), ae = Re[0], Le = Re[1], Fe = P(null), ze = Fe[0], Ye = Fe[1];
  return y(function() {
    S !== null && S.setMap(E);
  }, [E]), y(function() {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), y(function() {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), y(function() {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), y(function() {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), y(function() {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), y(function() {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), y(function() {
    S && s && (q !== null && google.maps.event.removeListener(q), _(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), y(function() {
    S && u && (I !== null && google.maps.event.removeListener(I), z(google.maps.event.addListener(S, "dragend", u)));
  }, [u]), y(function() {
    S && l && (R !== null && google.maps.event.removeListener(R), ee(google.maps.event.addListener(S, "dragstart", l)));
  }, [l]), y(function() {
    S && c && (k !== null && google.maps.event.removeListener(k), A(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), y(function() {
    S && f && (U !== null && google.maps.event.removeListener(U), Y(google.maps.event.addListener(S, "mousemove", f)));
  }, [f]), y(function() {
    S && p && (m !== null && google.maps.event.removeListener(m), $(google.maps.event.addListener(S, "mouseout", p)));
  }, [p]), y(function() {
    S && g && (T !== null && google.maps.event.removeListener(T), J(google.maps.event.addListener(S, "mouseover", g)));
  }, [g]), y(function() {
    S && v && (N !== null && google.maps.event.removeListener(N), se(google.maps.event.addListener(S, "mouseup", v)));
  }, [v]), y(function() {
    S && h && (de !== null && google.maps.event.removeListener(de), ge(google.maps.event.addListener(S, "rightclick", h)));
  }, [h]), y(function() {
    S && d && (me !== null && google.maps.event.removeListener(me), ye(google.maps.event.addListener(S, "click", d)));
  }, [d]), y(function() {
    S && w && (Me !== null && google.maps.event.removeListener(Me), ie(google.maps.event.addListener(S, "drag", w)));
  }, [w]), y(function() {
    S && L && (ae !== null && google.maps.event.removeListener(ae), Le(google.maps.event.addListener(S, "center_changed", L)));
  }, [d]), y(function() {
    S && D && (ze !== null && google.maps.event.removeListener(ze), Ye(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), y(function() {
    var we = new google.maps.Circle(Be(Be({}, t || Ew), { map: E }));
    return typeof r == "number" && we.setRadius(r), typeof n < "u" && we.setCenter(n), typeof r == "number" && we.setRadius(r), typeof a < "u" && we.setVisible(a), typeof i < "u" && we.setEditable(i), typeof o < "u" && we.setDraggable(o), s && _(google.maps.event.addListener(we, "dblclick", s)), u && z(google.maps.event.addListener(we, "dragend", u)), l && ee(google.maps.event.addListener(we, "dragstart", l)), c && A(google.maps.event.addListener(we, "mousedown", c)), f && Y(google.maps.event.addListener(we, "mousemove", f)), p && $(google.maps.event.addListener(we, "mouseout", p)), g && J(google.maps.event.addListener(we, "mouseover", g)), v && se(google.maps.event.addListener(we, "mouseup", v)), h && ge(google.maps.event.addListener(we, "rightclick", h)), d && ye(google.maps.event.addListener(we, "click", d)), w && ie(google.maps.event.addListener(we, "drag", w)), L && Le(google.maps.event.addListener(we, "center_changed", L)), D && Ye(google.maps.event.addListener(we, "radius_changed", D)), V(we), B && B(we), function() {
      q !== null && google.maps.event.removeListener(q), I !== null && google.maps.event.removeListener(I), R !== null && google.maps.event.removeListener(R), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), m !== null && google.maps.event.removeListener(m), T !== null && google.maps.event.removeListener(T), N !== null && google.maps.event.removeListener(N), de !== null && google.maps.event.removeListener(de), me !== null && google.maps.event.removeListener(me), ae !== null && google.maps.event.removeListener(ae), ze !== null && google.maps.event.removeListener(ze), b && b(we), we.setMap(null);
    };
  }, []), null;
}
Ze(Dw);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      circle: null
    }, n.setCircleCallback = function() {
      n.state.circle !== null && n.props.onLoad && n.props.onLoad(n.state.circle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Circle(Be(Be({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = Ke({
      updaterMap: Ld,
      eventMap: xd,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        circle: n
      };
    }, this.setCircleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.circle !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: Ld,
      eventMap: xd,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n;
    this.state.circle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.circle), et(this.registeredEvents), (n = this.state.circle) === null || n === void 0 || n.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = He, t;
})(Te);
var Od = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, Sd = {
  add: function(e, t) {
    e.add(t);
  },
  addgeojson: function(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains: function(e, t) {
    e.contains(t);
  },
  foreach: function(e, t) {
    e.forEach(t);
  },
  loadgeojson: function(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle: function(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove: function(e, t) {
    e.remove(t);
  },
  revertstyle: function(e, t) {
    e.revertStyle(t);
  },
  controlposition: function(e, t) {
    e.setControlPosition(t);
  },
  controls: function(e, t) {
    e.setControls(t);
  },
  drawingmode: function(e, t) {
    e.setDrawingMode(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  style: function(e, t) {
    e.setStyle(t);
  },
  togeojson: function(e, t) {
    e.toGeoJson(t);
  }
};
function xw(e) {
  var t = e.options, n = e.onClick, r = e.onDblClick, o = e.onMouseDown, i = e.onMouseMove, a = e.onMouseOut, s = e.onMouseOver, u = e.onMouseUp, l = e.onRightClick, c = e.onAddFeature, f = e.onRemoveFeature, p = e.onRemoveProperty, g = e.onSetGeometry, v = e.onSetProperty, h = e.onLoad, d = e.onUnmount, w = Ae(He), L = P(null), D = L[0], B = L[1], b = P(null), E = b[0], O = b[1], S = P(null), V = S[0], M = S[1], q = P(null), _ = q[0], j = q[1], I = P(null), z = I[0], X = I[1], R = P(null), ee = R[0], re = R[1], k = P(null), A = k[0], G = k[1], U = P(null), Y = U[0], K = U[1], m = P(null), $ = m[0], W = m[1], T = P(null), J = T[0], te = T[1], N = P(null), se = N[0], ue = N[1], de = P(null), ge = de[0], Ce = de[1], me = P(null), ye = me[0], ce = me[1], Me = P(null), ie = Me[0], Re = Me[1];
  return y(function() {
    D !== null && D.setMap(w);
  }, [w]), y(function() {
    D && r && (E !== null && google.maps.event.removeListener(E), O(google.maps.event.addListener(D, "dblclick", r)));
  }, [r]), y(function() {
    D && o && (V !== null && google.maps.event.removeListener(V), M(google.maps.event.addListener(D, "mousedown", o)));
  }, [o]), y(function() {
    D && i && (_ !== null && google.maps.event.removeListener(_), j(google.maps.event.addListener(D, "mousemove", i)));
  }, [i]), y(function() {
    D && a && (z !== null && google.maps.event.removeListener(z), X(google.maps.event.addListener(D, "mouseout", a)));
  }, [a]), y(function() {
    D && s && (ee !== null && google.maps.event.removeListener(ee), re(google.maps.event.addListener(D, "mouseover", s)));
  }, [s]), y(function() {
    D && u && (A !== null && google.maps.event.removeListener(A), G(google.maps.event.addListener(D, "mouseup", u)));
  }, [u]), y(function() {
    D && l && (Y !== null && google.maps.event.removeListener(Y), K(google.maps.event.addListener(D, "rightclick", l)));
  }, [l]), y(function() {
    D && n && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(D, "click", n)));
  }, [n]), y(function() {
    D && c && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(D, "addfeature", c)));
  }, [c]), y(function() {
    D && f && (se !== null && google.maps.event.removeListener(se), ue(google.maps.event.addListener(D, "removefeature", f)));
  }, [f]), y(function() {
    D && p && (ge !== null && google.maps.event.removeListener(ge), Ce(google.maps.event.addListener(D, "removeproperty", p)));
  }, [p]), y(function() {
    D && g && (ye !== null && google.maps.event.removeListener(ye), ce(google.maps.event.addListener(D, "setgeometry", g)));
  }, [g]), y(function() {
    D && v && (ie !== null && google.maps.event.removeListener(ie), Re(google.maps.event.addListener(D, "setproperty", v)));
  }, [v]), y(function() {
    if (w !== null) {
      var ae = new google.maps.Data(Be(Be({}, t || {}), { map: w }));
      r && O(google.maps.event.addListener(ae, "dblclick", r)), o && M(google.maps.event.addListener(ae, "mousedown", o)), i && j(google.maps.event.addListener(ae, "mousemove", i)), a && X(google.maps.event.addListener(ae, "mouseout", a)), s && re(google.maps.event.addListener(ae, "mouseover", s)), u && G(google.maps.event.addListener(ae, "mouseup", u)), l && K(google.maps.event.addListener(ae, "rightclick", l)), n && W(google.maps.event.addListener(ae, "click", n)), c && te(google.maps.event.addListener(ae, "addfeature", c)), f && ue(google.maps.event.addListener(ae, "removefeature", f)), p && Ce(google.maps.event.addListener(ae, "removeproperty", p)), g && ce(google.maps.event.addListener(ae, "setgeometry", g)), v && Re(google.maps.event.addListener(ae, "setproperty", v)), B(ae), h && h(ae);
    }
    return function() {
      D && (E !== null && google.maps.event.removeListener(E), V !== null && google.maps.event.removeListener(V), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), ee !== null && google.maps.event.removeListener(ee), A !== null && google.maps.event.removeListener(A), Y !== null && google.maps.event.removeListener(Y), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), se !== null && google.maps.event.removeListener(se), ge !== null && google.maps.event.removeListener(ge), ye !== null && google.maps.event.removeListener(ye), ie !== null && google.maps.event.removeListener(ie), d && d(D), D.setMap(null));
    };
  }, []), null;
}
Ze(xw);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      data: null
    }, n.setDataCallback = function() {
      n.state.data !== null && n.props.onLoad && n.props.onLoad(n.state.data);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context !== null) {
      var n = new google.maps.Data(Be(Be({}, this.props.options || {}), { map: this.context }));
      this.registeredEvents = Ke({
        updaterMap: Sd,
        eventMap: Od,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          data: n
        };
      }, this.setDataCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.data !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: Sd,
      eventMap: Od,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.data
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), et(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = He, t;
})(Te);
var kd = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Md = {
  options: function(e, t) {
    e.setOptions(t);
  },
  url: function(e, t) {
    e.setUrl(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      kmlLayer: null
    }, n.setKmlLayerCallback = function() {
      n.state.kmlLayer !== null && n.props.onLoad && n.props.onLoad(n.state.kmlLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.KmlLayer(Be(Be({}, this.props.options), { map: this.context }));
    this.registeredEvents = Ke({
      updaterMap: Md,
      eventMap: kd,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        kmlLayer: n
      };
    }, this.setKmlLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.kmlLayer !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: Md,
      eventMap: kd,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), et(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = He, t;
})(Te);
function pm(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Lw(e, t) {
  return new t(e.lat, e.lng);
}
function Ow(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Sw(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function kw(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Mw(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Pw(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var o = r.x, i = r.y;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function hm(e, t, n, r) {
  return n !== void 0 ? Mw(e, t, kw(n, google.maps.LatLngBounds, Ow)) : Pw(e, t, Sw(r, google.maps.LatLng, Lw));
}
function Bw(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function Tw(e, t, n, r, o) {
  var i = (
    /** @class */
    function(a) {
      bt(s, a);
      function s(u, l, c, f) {
        var p = a.call(this) || this;
        return p.container = u, p.pane = l, p.position = c, p.bounds = f, p;
      }
      return s.prototype.onAdd = function() {
        var u, l = (u = this.getPanes()) === null || u === void 0 ? void 0 : u[this.pane];
        l == null || l.appendChild(this.container);
      }, s.prototype.draw = function() {
        for (var u = this.getProjection(), l = Be({}, this.container ? pm(this.container, o) : {
          x: 0,
          y: 0
        }), c = hm(u, l, this.bounds, this.position), f = 0, p = Object.entries(c); f < p.length; f++) {
          var g = p[f], v = g[0], h = g[1];
          this.container.style[v] = h;
        }
      }, s.prototype.onRemove = function() {
        this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
      }, s;
    }(google.maps.OverlayView)
  );
  return new i(e, t, n, r);
}
function Pd(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function Bd(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Aw(e) {
  var t = e.position, n = e.bounds, r = e.mapPaneName, o = e.zIndex, i = e.onLoad, a = e.onUnmount, s = e.getPixelPositionOffset, u = e.children, l = Ae(He), c = Ln(function() {
    var p = document.createElement("div");
    return p.style.position = "absolute", p;
  }, []), f = Ln(function() {
    return Tw(c, r, t, n, s);
  }, [c, r, t, n]);
  return y(function() {
    return i == null || i(f), f == null || f.setMap(l), function() {
      a == null || a(f), f == null || f.setMap(null);
    };
  }, [l, f]), y(function() {
    c.style.zIndex = "".concat(o);
  }, [o, c]), ja.createPortal(u, c);
}
Ze(Aw);
(function(e) {
  bt(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    r.state = {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }, r.updatePane = function() {
      var i = r.props.mapPaneName, a = r.overlayView.getPanes();
      zt(!!i, "OverlayView requires props.mapPaneName but got %s", i), a ? r.setState({
        paneEl: a[i]
      }) : r.setState({
        paneEl: null
      });
    }, r.onAdd = function() {
      var i, a;
      r.updatePane(), (a = (i = r.props).onLoad) === null || a === void 0 || a.call(i, r.overlayView);
    }, r.onPositionElement = function() {
      var i = r.overlayView.getProjection(), a = Be({ x: 0, y: 0 }, r.containerRef.current ? pm(r.containerRef.current, r.props.getPixelPositionOffset) : {}), s = hm(i, a, r.props.bounds, r.props.position), u = r.state.containerStyle, l = u.left, c = u.top, f = u.width, p = u.height;
      Bw(s, { left: l, top: c, width: f, height: p }) || r.setState({
        containerStyle: {
          top: s.top || 0,
          left: s.left || 0,
          width: s.width || 0,
          height: s.height || 0,
          position: "absolute"
        }
      });
    }, r.draw = function() {
      r.onPositionElement();
    }, r.onRemove = function() {
      var i, a;
      r.setState(function() {
        return {
          paneEl: null
        };
      }), (a = (i = r.props).onUnmount) === null || a === void 0 || a.call(i, r.overlayView);
    }, r.containerRef = Mr();
    var o = new google.maps.OverlayView();
    return o.onAdd = r.onAdd, o.draw = r.draw, o.onRemove = r.onRemove, r.overlayView = o, r;
  }
  return t.prototype.componentDidMount = function() {
    this.overlayView.setMap(this.context);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = Pd(n.position), o = Pd(this.props.position), i = Bd(n.bounds), a = Bd(this.props.bounds);
    (r !== o || i !== a) && this.overlayView.draw(), n.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }, t.prototype.componentWillUnmount = function() {
    this.overlayView.setMap(null);
  }, t.prototype.render = function() {
    var n = this.state.paneEl;
    return n ? ja.createPortal(st.jsx("div", { ref: this.containerRef, style: this.state.containerStyle, children: Vt.only(this.props.children) }), n) : null;
  }, t.FLOAT_PANE = "floatPane", t.MAP_PANE = "mapPane", t.MARKER_LAYER = "markerLayer", t.OVERLAY_LAYER = "overlayLayer", t.OVERLAY_MOUSE_TARGET = "overlayMouseTarget", t.contextType = He, t;
})(Te);
function Fw() {
}
var Td = {
  onDblClick: "dblclick",
  onClick: "click"
}, Ad = {
  opacity: function(e, t) {
    e.setOpacity(t);
  }
};
function Iw(e) {
  var t = e.url, n = e.bounds, r = e.options, o = e.visible, i = Ae(He), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Ln(function() {
    var u = new google.maps.GroundOverlay(t, a, Be({}, r));
    return u;
  }, []);
  return y(function() {
    s !== null && s.setMap(i);
  }, [i]), y(function() {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), y(function() {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), y(function() {
    var u = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", u), s.setMap(i));
  }, [s, n]), null;
}
Ze(Iw);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      groundOverlay: null
    }, n.setGroundOverlayCallback = function() {
      n.state.groundOverlay !== null && n.props.onLoad && n.props.onLoad(n.state.groundOverlay);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    zt(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var n = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Be(Be({}, this.props.options), { map: this.context }));
    this.registeredEvents = Ke({
      updaterMap: Ad,
      eventMap: Td,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        groundOverlay: n
      };
    }, this.setGroundOverlayCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.groundOverlay !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: Ad,
      eventMap: Td,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.defaultProps = {
    onLoad: Fw
  }, t.contextType = He, t;
})(Te);
var Fd = {}, Id = {
  data: function(e, t) {
    e.setData(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function Rw(e) {
  var t = e.data, n = e.onLoad, r = e.onUnmount, o = e.options, i = Ae(He), a = P(null), s = a[0], u = a[1];
  return y(function() {
    google.maps.visualization || zt(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(function() {
    zt(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), y(function() {
    s !== null && s.setMap(i);
  }, [i]), y(function() {
    o && s !== null && s.setOptions(o);
  }, [s, o]), y(function() {
    var l = new google.maps.visualization.HeatmapLayer(Be(Be({}, o || {}), { data: t, map: i }));
    return u(l), n && n(l), function() {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Ze(Rw);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      heatmapLayer: null
    }, n.setHeatmapLayerCallback = function() {
      n.state.heatmapLayer !== null && n.props.onLoad && n.props.onLoad(n.state.heatmapLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    zt(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), zt(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var n = new google.maps.visualization.HeatmapLayer(Be(Be({}, this.props.options || {}), { data: this.props.data, map: this.context }));
    this.registeredEvents = Ke({
      updaterMap: Id,
      eventMap: Fd,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        heatmapLayer: n
      };
    }, this.setHeatmapLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: Id,
      eventMap: Fd,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), et(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = He, t;
})(Te);
var Rd = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, _d = {
  register: function(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links: function(e, t) {
    e.setLinks(t);
  },
  motionTracking: function(e, t) {
    e.setMotionTracking(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  pano: function(e, t) {
    e.setPano(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  pov: function(e, t) {
    e.setPov(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      streetViewPanorama: null
    }, n.setStreetViewPanoramaCallback = function() {
      n.state.streetViewPanorama !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewPanorama);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n, r, o = (r = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && r !== void 0 ? r : null;
    this.registeredEvents = Ke({
      updaterMap: _d,
      eventMap: Rd,
      prevProps: {},
      nextProps: this.props,
      instance: o
    }), this.setState(function() {
      return {
        streetViewPanorama: o
      };
    }, this.setStreetViewPanoramaCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.streetViewPanorama !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: _d,
      eventMap: Rd,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), et(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = He, t;
})(Te);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      streetViewService: null
    }, n.setStreetViewServiceCallback = function() {
      n.state.streetViewService !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: n
      };
    }, this.setStreetViewServiceCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = He, t;
})(Te);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      directionsService: null
    }, n.setDirectionsServiceCallback = function() {
      n.state.directionsService !== null && n.props.onLoad && n.props.onLoad(n.state.directionsService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    zt(!!this.props.options, "DirectionsService expected options object as parameter, but got %s", this.props.options);
    var n = new google.maps.DirectionsService();
    this.setState(function() {
      return {
        directionsService: n
      };
    }, this.setDirectionsServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.directionsService !== null && this.state.directionsService.route(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsService !== null && this.props.onUnmount && this.props.onUnmount(this.state.directionsService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Te);
var jd = {
  onDirectionsChanged: "directions_changed"
}, Nd = {
  directions: function(e, t) {
    e.setDirections(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  panel: function(e, t) {
    e.setPanel(t);
  },
  routeIndex: function(e, t) {
    e.setRouteIndex(t);
  }
};
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      directionsRenderer: null
    }, n.setDirectionsRendererCallback = function() {
      n.state.directionsRenderer !== null && (n.state.directionsRenderer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.directionsRenderer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Ke({
      updaterMap: Nd,
      eventMap: jd,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        directionsRenderer: n
      };
    }, this.setDirectionsRendererCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.directionsRenderer !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: Nd,
      eventMap: jd,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), et(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }, t.prototype.render = function() {
    return st.jsx(st.Fragment, {});
  }, t.contextType = He, t;
})(Te);
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      distanceMatrixService: null
    }, n.setDistanceMatrixServiceCallback = function() {
      n.state.distanceMatrixService !== null && n.props.onLoad && n.props.onLoad(n.state.distanceMatrixService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    zt(!!this.props.options, "DistanceMatrixService expected options object as parameter, but go %s", this.props.options);
    var n = new google.maps.DistanceMatrixService();
    this.setState(function() {
      return {
        distanceMatrixService: n
      };
    }, this.setDistanceMatrixServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.distanceMatrixService !== null && this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.distanceMatrixService !== null && this.props.onUnmount && this.props.onUnmount(this.state.distanceMatrixService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(Te);
var zd = {
  onPlacesChanged: "places_changed"
}, $d = {
  bounds: function(e, t) {
    e.setBounds(t);
  }
};
/** @class */
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = Mr(), n.state = {
      searchBox: null
    }, n.setSearchBoxCallback = function() {
      n.state.searchBox !== null && n.props.onLoad && n.props.onLoad(n.state.searchBox);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (zt(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var n = this.containerElement.current.querySelector("input");
      if (n !== null) {
        var r = new google.maps.places.SearchBox(n, this.props.options);
        this.registeredEvents = Ke({
          updaterMap: $d,
          eventMap: zd,
          prevProps: {},
          nextProps: this.props,
          instance: r
        }), this.setState(function() {
          return {
            searchBox: r
          };
        }, this.setSearchBoxCallback);
      }
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.searchBox !== null && (et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: $d,
      eventMap: zd,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), et(this.registeredEvents));
  }, t.prototype.render = function() {
    return st.jsx("div", { ref: this.containerElement, children: Vt.only(this.props.children) });
  }, t.contextType = He, t;
})(Te);
var Ud = {
  onPlaceChanged: "place_changed"
}, Wd = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  restrictions: function(e, t) {
    e.setComponentRestrictions(t);
  },
  fields: function(e, t) {
    e.setFields(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  types: function(e, t) {
    e.setTypes(t);
  }
};
(function(e) {
  bt(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = Mr(), n.state = {
      autocomplete: null
    }, n.setAutocompleteCallback = function() {
      n.state.autocomplete !== null && n.props.onLoad && n.props.onLoad(n.state.autocomplete);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n;
    zt(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var r = (n = this.containerElement.current) === null || n === void 0 ? void 0 : n.querySelector("input");
    if (r) {
      var o = new google.maps.places.Autocomplete(r, this.props.options);
      this.registeredEvents = Ke({
        updaterMap: Wd,
        eventMap: Ud,
        prevProps: {},
        nextProps: this.props,
        instance: o
      }), this.setState(function() {
        return {
          autocomplete: o
        };
      }, this.setAutocompleteCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    et(this.registeredEvents), this.registeredEvents = Ke({
      updaterMap: Wd,
      eventMap: Ud,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.autocomplete !== null && et(this.registeredEvents);
  }, t.prototype.render = function() {
    return st.jsx("div", { ref: this.containerElement, className: this.props.className, children: Vt.only(this.props.children) });
  }, t.defaultProps = {
    className: ""
  }, t.contextType = He, t;
})(Te);
function gm(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: u,
    className: l = "",
    children: c,
    ...f
  } = e, p = { xs: 12, sm: 16, md: 20, lg: 24 }[i], g = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${l}`;
  return /* @__PURE__ */ st.jsxs("button", { className: g, disabled: u || t, ...f, children: [
    /* @__PURE__ */ st.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ st.jsx(lr, { size: p, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ st.jsxs("div", { className: "arkynButtonContent", children: [
      Yf(p, a),
      c,
      Yf(p, s)
    ] })
  ] });
}
function _w() {
  const e = Sl(), t = Iv(), n = Rv(), [r, o] = P(null);
  function i(l, c) {
    return JSON.stringify(l) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  y(() => {
    var l, c;
    let f = ((c = (l = n[0]) == null ? void 0 : l.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, f) || Object.entries(f).length !== 0 && o(f);
  }, [n, e]), y(() => {
    var l;
    ((l = n[0]) == null ? void 0 : l.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let u = {};
  return Object.entries(s || {}).forEach(([l, c]) => {
    typeof c == "string" && typeof l == "string" && (u[l] = c);
  }), u;
}
ht({});
function jw(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Nw = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
jw(Nw.CNPJ).length;
_a((e, t) => /* @__PURE__ */ st.jsx("input", { ref: t, ...e }));
function zw(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...u
  } = e, l = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ st.jsxs(
    "button",
    {
      disabled: a || t,
      className: c.trim(),
      ...u,
      children: [
        /* @__PURE__ */ st.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ st.jsx(lr, { size: l[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ st.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ st.jsx(i, { size: l[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
ht({});
var cr = {};
Object.defineProperty(cr, "__esModule", {
  value: !0
});
var $w = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), _s = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, vm = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: $w ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, _l = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var ki = 1; ki < 20; ki++)
  _l["f" + ki] = 111 + ki;
function za(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return mm(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return ym(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function Uw(e, t) {
  return za(e, t);
}
function Ww(e, t) {
  return za(e, { byKey: !0 }, t);
}
function mm(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in _s)
    r[_s[a]] = !1;
  var s = !0, u = !1, l = void 0;
  try {
    for (var c = o[Symbol.iterator](), f; !(s = (f = c.next()).done); s = !0) {
      var p = f.value, g = p.endsWith("?") && p.length > 1;
      g && (p = p.slice(0, -1));
      var v = jl(p), h = _s[v];
      if (p.length > 1 && !h && !vm[p] && !_l[v])
        throw new TypeError('Unknown modifier: "' + p + '"');
      (i === 1 || !h) && (n ? r.key = v : r.which = bm(p)), h && (r[h] = g ? null : !0);
    }
  } catch (d) {
    u = !0, l = d;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (u)
        throw l;
    }
  }
  return r;
}
function ym(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function bm(e) {
  e = jl(e);
  var t = _l[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function jl(e) {
  return e = e.toLowerCase(), e = vm[e] || e, e;
}
cr.default = za;
var js = cr.isHotkey = za;
cr.isCodeHotkey = Uw;
cr.isKeyHotkey = Ww;
cr.parseHotkey = mm;
cr.compareHotkey = ym;
cr.toKeyCode = bm;
cr.toKeyName = jl;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Hd(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Yt(e) {
  var t, n;
  return Hd(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(Hd(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Cm = Symbol.for("immer-nothing"), Vd = Symbol.for("immer-draftable"), On = Symbol.for("immer-state"), Hw = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function un(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Hw[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var po = Object.getPrototypeOf;
function to(e) {
  return !!e && !!e[On];
}
function no(e) {
  var t;
  return e ? wm(e) || Array.isArray(e) || !!e[Vd] || !!((t = e.constructor) != null && t[Vd]) || Ua(e) || Wa(e) : !1;
}
var Vw = Object.prototype.constructor.toString();
function wm(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = po(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Vw;
}
function ba(e, t) {
  $a(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function $a(e) {
  const t = e[On];
  return t ? t.type_ : Array.isArray(e) ? 1 : Ua(e) ? 2 : Wa(e) ? 3 : 0;
}
function $u(e, t) {
  return $a(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Em(e, t, n) {
  const r = $a(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function qw(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Ua(e) {
  return e instanceof Map;
}
function Wa(e) {
  return e instanceof Set;
}
function Wr(e) {
  return e.copy_ || e.base_;
}
function Uu(e, t) {
  if (Ua(e))
    return new Map(e);
  if (Wa(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = wm(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[On];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(po(e), r);
  } else {
    const r = po(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Nl(e, t = !1) {
  return Ha(e) || to(e) || !no(e) || ($a(e) > 1 && (e.set = e.add = e.clear = e.delete = Zw), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Nl(r, !0))), e;
}
function Zw() {
  un(2);
}
function Ha(e) {
  return Object.isFrozen(e);
}
var Gw = {};
function ro(e) {
  const t = Gw[e];
  return t || un(0, e), t;
}
var Ko;
function Dm() {
  return Ko;
}
function Kw(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function qd(e, t) {
  t && (ro("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Wu(e) {
  Hu(e), e.drafts_.forEach(Yw), e.drafts_ = null;
}
function Hu(e) {
  e === Ko && (Ko = e.parent_);
}
function Zd(e) {
  return Ko = Kw(Ko, e);
}
function Yw(e) {
  const t = e[On];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Gd(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[On].modified_ && (Wu(t), un(4)), no(e) && (e = Ca(t, e), t.parent_ || wa(t, e)), t.patches_ && ro("Patches").generateReplacementPatches_(
    n[On].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Ca(t, n, []), Wu(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== Cm ? e : void 0;
}
function Ca(e, t, n) {
  if (Ha(t))
    return t;
  const r = t[On];
  if (!r)
    return ba(
      t,
      (o, i) => Kd(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return wa(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), ba(
      i,
      (s, u) => Kd(e, r, o, s, u, n, a)
    ), wa(e, o, !1), n && e.patches_ && ro("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Kd(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && un(5), to(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !$u(t.assigned_, r) ? i.concat(r) : void 0, u = Ca(e, o, s);
    if (Em(n, r, u), to(u))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (no(o) && !Ha(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Ca(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && wa(e, o);
  }
}
function wa(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Nl(t, n);
}
function Xw(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Dm(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = zl;
  n && (o = [r], i = Yo);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var zl = {
  get(e, t) {
    if (t === On)
      return e;
    const n = Wr(e);
    if (!$u(n, t))
      return Jw(e, n, t);
    const r = n[t];
    return e.finalized_ || !no(r) ? r : r === Ns(e.base_, t) ? (zs(e), e.copy_[t] = qu(r, e)) : r;
  },
  has(e, t) {
    return t in Wr(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Wr(e));
  },
  set(e, t, n) {
    const r = xm(Wr(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Ns(Wr(e), t), i = o == null ? void 0 : o[On];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (qw(n, o) && (n !== void 0 || $u(e.base_, t)))
        return !0;
      zs(e), Vu(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Ns(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, zs(e), Vu(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Wr(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    un(11);
  },
  getPrototypeOf(e) {
    return po(e.base_);
  },
  setPrototypeOf() {
    un(12);
  }
}, Yo = {};
ba(zl, (e, t) => {
  Yo[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Yo.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && un(13), Yo.set.call(this, e, t, void 0);
};
Yo.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && un(14), zl.set.call(this, e[0], t, n, e[0]);
};
function Ns(e, t) {
  const n = e[On];
  return (n ? Wr(n) : e)[t];
}
function Jw(e, t, n) {
  var r;
  const o = xm(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function xm(e, t) {
  if (!(t in e))
    return;
  let n = po(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = po(n);
  }
}
function Vu(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Vu(e.parent_));
}
function zs(e) {
  e.copy_ || (e.copy_ = Uu(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Qw = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...u) {
          return a.produce(s, (l) => n.call(this, l, ...u));
        };
      }
      typeof n != "function" && un(6), r !== void 0 && typeof r != "function" && un(7);
      let o;
      if (no(t)) {
        const i = Zd(this), a = qu(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? Wu(i) : Hu(i);
        }
        return qd(i, r), Gd(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === Cm && (o = void 0), this.autoFreeze_ && Nl(o, !0), r) {
          const i = [], a = [];
          ro("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        un(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    no(e) || un(8), to(e) && (e = eE(e));
    const t = Zd(this), n = qu(e, void 0);
    return n[On].isManual_ = !0, Hu(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[On];
    (!n || !n.isManual_) && un(9);
    const { scope_: r } = n;
    return qd(r, t), Gd(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = ro("Patches").applyPatches_;
    return to(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function qu(e, t) {
  const n = Ua(e) ? ro("MapSet").proxyMap_(e, t) : Wa(e) ? ro("MapSet").proxySet_(e, t) : Xw(e, t);
  return (t ? t.scope_ : Dm()).drafts_.push(n), n;
}
function eE(e) {
  return to(e) || un(10, e), Lm(e);
}
function Lm(e) {
  if (!no(e) || Ha(e))
    return e;
  const t = e[On];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Uu(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Uu(e, !0);
  return ba(n, (r, o) => {
    Em(n, r, Lm(o));
  }), t && (t.finalized_ = !1), n;
}
var Sn = new Qw(), $l = Sn.produce;
Sn.produceWithPatches.bind(
  Sn
);
Sn.setAutoFreeze.bind(Sn);
Sn.setUseStrictShallowCopy.bind(Sn);
Sn.applyPatches.bind(Sn);
var Yd = Sn.createDraft.bind(Sn), Xd = Sn.finishDraft.bind(Sn), pe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = pe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return pe.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return pe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return pe.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return pe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && pe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return pe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && pe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && pe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && pe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && pe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && pe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!pe.isAncestor(t, e) && !pe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (pe.equals(i, r) || pe.endsBefore(i, r) || pe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (pe.equals(a, r) || pe.isAncestor(a, r))
          return null;
        pe.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: u
        } = t;
        pe.equals(s, r) || pe.endsBefore(s, r) ? r[s.length - 1] -= 1 : pe.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += u);
        break;
      }
      case "split_node": {
        var {
          path: l,
          position: c
        } = t;
        if (pe.equals(l, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else pe.endsBefore(l, r) ? r[l.length - 1] += 1 : pe.isAncestor(l, r) && e[l.length] >= c && (r[l.length - 1] += 1, r[l.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: f,
          newPath: p
        } = t;
        if (pe.equals(f, p))
          return r;
        if (pe.isAncestor(f, r) || pe.equals(f, r)) {
          var g = p.slice();
          return pe.endsBefore(f, p) && f.length < p.length && (g[f.length - 1] -= 1), g.concat(r.slice(f.length));
        } else pe.isSibling(f, p) && (pe.isAncestor(p, r) || pe.equals(p, r)) ? pe.endsBefore(f, r) ? r[f.length - 1] -= 1 : r[f.length - 1] += 1 : pe.endsBefore(p, r) || pe.equals(p, r) || pe.isAncestor(p, r) ? (pe.endsBefore(f, r) && (r[f.length - 1] -= 1), r[p.length - 1] += 1) : pe.endsBefore(f, r) && (pe.equals(p, r) && (r[p.length - 1] += 1), r[f.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Xo(e) {
  "@babel/helpers - typeof";
  return Xo = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Xo(e);
}
function tE(e, t) {
  if (Xo(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Xo(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function nE(e) {
  var t = tE(e, "string");
  return Xo(t) === "symbol" ? t : String(t);
}
function mo(e, t, n) {
  return t = nE(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Jd(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Po(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Jd(Object(n), !0).forEach(function(r) {
      mo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Jd(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rE = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Ne.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, u] of Ve.points(t))
          t[u] = Et.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: l,
        offset: c,
        text: f
      } = n;
      if (f.length === 0) break;
      var p = Ne.leaf(e, l), g = p.text.slice(0, c), v = p.text.slice(c);
      if (p.text = g + f + v, t)
        for (var [h, d] of Ve.points(t))
          t[d] = Et.transform(h, n);
      break;
    }
    case "merge_node": {
      var {
        path: w
      } = n, L = Ne.get(e, w), D = pe.previous(w), B = Ne.get(e, D), b = Ne.parent(e, w), E = w[w.length - 1];
      if (Ft.isText(L) && Ft.isText(B))
        B.text += L.text;
      else if (!Ft.isText(L) && !Ft.isText(B))
        B.children.push(...L.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(w, "] to nodes of different interfaces: ").concat(wn.stringify(L), " ").concat(wn.stringify(B)));
      if (b.children.splice(E, 1), t)
        for (var [O, S] of Ve.points(t))
          t[S] = Et.transform(O, n);
      break;
    }
    case "move_node": {
      var {
        path: V,
        newPath: M
      } = n;
      if (pe.isAncestor(V, M))
        throw new Error("Cannot move a path [".concat(V, "] to new path [").concat(M, "] because the destination is inside itself."));
      var q = Ne.get(e, V), _ = Ne.parent(e, V), j = V[V.length - 1];
      _.children.splice(j, 1);
      var I = pe.transform(V, n), z = Ne.get(e, pe.parent(I)), X = I[I.length - 1];
      if (z.children.splice(X, 0, q), t)
        for (var [R, ee] of Ve.points(t))
          t[ee] = Et.transform(R, n);
      break;
    }
    case "remove_node": {
      var {
        path: re
      } = n, k = re[re.length - 1], A = Ne.parent(e, re);
      if (A.children.splice(k, 1), t)
        for (var [G, U] of Ve.points(t)) {
          var Y = Et.transform(G, n);
          if (t != null && Y != null)
            t[U] = Y;
          else {
            var K = void 0, m = void 0;
            for (var [$, W] of Ne.texts(e))
              if (pe.compare(W, re) === -1)
                K = [$, W];
              else {
                m = [$, W];
                break;
              }
            var T = !1;
            K && m && (pe.equals(m[1], re) ? T = !pe.hasPrevious(m[1]) : T = pe.common(K[1], re).length < pe.common(m[1], re).length), K && !T ? (G.path = K[1], G.offset = K[0].text.length) : m ? (G.path = m[1], G.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: J,
        offset: te,
        text: N
      } = n;
      if (N.length === 0) break;
      var se = Ne.leaf(e, J), ue = se.text.slice(0, te), de = se.text.slice(te + N.length);
      if (se.text = ue + de, t)
        for (var [ge, Ce] of Ve.points(t))
          t[Ce] = Et.transform(ge, n);
      break;
    }
    case "set_node": {
      var {
        path: me,
        properties: ye,
        newProperties: ce
      } = n;
      if (me.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Me = Ne.get(e, me);
      for (var ie in ce) {
        if (ie === "children" || ie === "text")
          throw new Error('Cannot set the "'.concat(ie, '" property of nodes!'));
        var Re = ce[ie];
        Re == null ? delete Me[ie] : Me[ie] = Re;
      }
      for (var ae in ye)
        ce.hasOwnProperty(ae) || delete Me[ae];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Le
      } = n;
      if (Le == null)
        t = Le;
      else {
        if (t == null) {
          if (!Ve.isRange(Le))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(wn.stringify(Le), " when there is no current selection."));
          t = Po({}, Le);
        }
        for (var Fe in Le) {
          var ze = Le[Fe];
          if (ze == null) {
            if (Fe === "anchor" || Fe === "focus")
              throw new Error('Cannot remove the "'.concat(Fe, '" selection property'));
            delete t[Fe];
          } else
            t[Fe] = ze;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ye,
        position: we,
        properties: Ct
      } = n;
      if (Ye.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ye, "] because the root node cannot be split."));
      var ot = Ne.get(e, Ye), Jt = Ne.parent(e, Ye), _t = Ye[Ye.length - 1], $t;
      if (Ft.isText(ot)) {
        var dn = ot.text.slice(0, we), pn = ot.text.slice(we);
        ot.text = dn, $t = Po(Po({}, Ct), {}, {
          text: pn
        });
      } else {
        var hn = ot.children.slice(0, we), gn = ot.children.slice(we);
        ot.children = hn, $t = Po(Po({}, Ct), {}, {
          children: gn
        });
      }
      if (Jt.children.splice(_t + 1, 0, $t), t)
        for (var [jt, Qt] of Ve.points(t))
          t[Qt] = Et.transform(jt, n);
      break;
    }
  }
  return t;
}, oE = {
  transform(e, t) {
    e.children = Yd(e.children);
    var n = e.selection && Yd(e.selection);
    try {
      n = rE(e, n, t);
    } finally {
      e.children = Xd(e.children), n ? e.selection = to(n) ? Xd(n) : n : e.selection = null;
    }
  }
}, iE = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, aE = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Om = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Yt(r) && Yt(o)) {
      if (!Om(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function sE(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Jo(e, t) {
  if (e == null) return {};
  var n = sE(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var uE = ["anchor", "focus"];
function Qd(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qd(Object(n), !0).forEach(function(r) {
      mo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Qd(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ve = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Ve.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Ve.edges(e);
    return t;
  },
  equals(e, t) {
    return Et.equals(e.anchor, t.anchor) && Et.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Ve.isRange(t)) {
      if (Ve.includes(e, t.anchor) || Ve.includes(e, t.focus))
        return !0;
      var [n, r] = Ve.edges(e), [o, i] = Ve.edges(t);
      return Et.isBefore(n, o) && Et.isAfter(r, i);
    }
    var [a, s] = Ve.edges(e), u = !1, l = !1;
    return Et.isPoint(t) ? (u = Et.compare(t, a) >= 0, l = Et.compare(t, s) <= 0) : (u = pe.compare(t, a.path) >= 0, l = pe.compare(t, s.path) <= 0), u && l;
  },
  intersection(e, t) {
    var n = Jo(e, uE), [r, o] = Ve.edges(e), [i, a] = Ve.edges(t), s = Et.isBefore(r, i) ? i : r, u = Et.isBefore(o, a) ? o : a;
    return Et.isBefore(u, s) ? null : lE({
      anchor: s,
      focus: u
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Et.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Et.equals(t, n);
  },
  isExpanded(e) {
    return !Ve.isCollapsed(e);
  },
  isForward(e) {
    return !Ve.isBackward(e);
  },
  isRange(e) {
    return Yt(e) && Et.isPoint(e.anchor) && Et.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Ve.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return $l(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Ve.isCollapsed(r);
        Ve.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Ve.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var u = Et.transform(r.anchor, t, {
        affinity: i
      }), l = Et.transform(r.focus, t, {
        affinity: a
      });
      if (!u || !l)
        return null;
      r.anchor = u, r.focus = l;
    });
  }
}, ep = (e) => Yt(e) && Ne.isNodeList(e.children) && !gt.isEditor(e), or = {
  isAncestor(e) {
    return Yt(e) && Ne.isNodeList(e.children);
  },
  isElement: ep,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => or.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return ep(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, cE = ["children"], fE = ["text"], tp = /* @__PURE__ */ new WeakMap(), Ne = {
  ancestor(e, t) {
    var n = Ne.get(e, t);
    if (Ft.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(wn.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of pe.ancestors(t, n)) {
        var o = Ne.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Ft.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(wn.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(wn.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Ne.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Ne.child(o, a), u = t.concat(a);
        yield [s, u], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = pe.common(t, n), o = Ne.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Ne.get(e, t);
    if (gt.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(wn.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ne.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ne.nodes(e, t))
        or.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (or.isAncestor(e)) {
      var t = Jo(e, cE);
      return t;
    } else {
      var t = Jo(e, fE);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Ne.get(e, n); r && !(Ft.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Ft.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(wn.stringify(e)));
    var n = $l({
      children: e.children
    }, (r) => {
      var [o, i] = Ve.edges(t), a = Ne.nodes(r, {
        reverse: !0,
        pass: (p) => {
          var [, g] = p;
          return !Ve.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Ve.includes(t, s)) {
          var u = Ne.parent(r, s), l = s[s.length - 1];
          u.children.splice(l, 1);
        }
        if (pe.equals(s, i.path)) {
          var c = Ne.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (pe.equals(s, o.path)) {
          var f = Ne.leaf(r, s);
          f.text = f.text.slice(o.offset);
        }
      }
      gt.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ft.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(wn.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ft.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Ft.isText(e) || or.isElement(e) || gt.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = tp.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Ne.isNode(r));
    return tp.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Ne.get(e, n); r && !(Ft.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Ne.get(e, t);
    if (!Ft.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(wn.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of pe.levels(t, n)) {
        var o = Ne.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return or.isElement(e) && or.isElementProps(t) && or.matches(e, t) || Ft.isText(e) && Ft.isTextProps(t) && Ft.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], u = e; !(i && (r ? pe.isBefore(s, i) : pe.isAfter(s, i))); ) {
        if (a.has(u) || (yield [u, s]), !a.has(u) && !Ft.isText(u) && u.children.length !== 0 && (n == null || n([u, s]) === !1)) {
          a.add(u);
          var l = r ? u.children.length - 1 : 0;
          pe.isAncestor(s, o) && (l = o[s.length]), s = s.concat(l), u = Ne.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = pe.next(s);
          if (Ne.has(e, c)) {
            s = c, u = Ne.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var f = pe.previous(s);
          s = f, u = Ne.get(e, s);
          continue;
        }
        s = pe.parent(s), u = Ne.get(e, s), a.add(u);
      }
    }();
  },
  parent(e, t) {
    var n = pe.parent(t), r = Ne.get(e, n);
    if (Ft.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Ft.isText(e) ? e.text : e.children.map(Ne.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ne.nodes(e, t))
        Ft.isText(n) && (yield [n, r]);
    }();
  }
};
function np(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? np(Object(n), !0).forEach(function(r) {
      mo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : np(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fo = {
  isNodeOperation(e) {
    return Fo.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Yt(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return pe.isPath(e.path) && Ne.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && pe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && pe.isPath(e.path) && Yt(e.properties);
      case "move_node":
        return pe.isPath(e.path) && pe.isPath(e.newPath);
      case "remove_node":
        return pe.isPath(e.path) && Ne.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && pe.isPath(e.path);
      case "set_node":
        return pe.isPath(e.path) && Yt(e.properties) && Yt(e.newProperties);
      case "set_selection":
        return e.properties === null && Ve.isRange(e.newProperties) || e.newProperties === null && Ve.isRange(e.properties) || Yt(e.properties) && Yt(e.newProperties);
      case "split_node":
        return pe.isPath(e.path) && typeof e.position == "number" && Yt(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Fo.isOperation(t));
  },
  isSelectionOperation(e) {
    return Fo.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Fo.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Dt(Dt({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Dt(Dt({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Dt(Dt({}, e), {}, {
          type: "split_node",
          path: pe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (pe.equals(t, n))
          return e;
        if (pe.isSibling(n, t))
          return Dt(Dt({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = pe.transform(n, e), o = pe.transform(pe.next(n), e);
        return Dt(Dt({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Dt(Dt({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Dt(Dt({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Dt(Dt({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: u
        } = e;
        return s == null ? Dt(Dt({}, e), {}, {
          properties: u,
          newProperties: null
        }) : u == null ? Dt(Dt({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Dt(Dt({}, e), {}, {
          properties: u,
          newProperties: s
        });
      }
      case "split_node":
        return Dt(Dt({}, e), {}, {
          type: "merge_node",
          path: pe.next(e.path)
        });
    }
  }
}, rp = /* @__PURE__ */ new WeakMap(), dE = (e) => {
  var t = rp.get(e);
  if (t !== void 0)
    return t;
  if (!Yt(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Yt(e.marks)) && (e.selection === null || Ve.isRange(e.selection)) && Ne.isNodeList(e.children) && Fo.isOperationList(e.operations);
  return rp.set(e, n), n;
}, gt = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return dE(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function op(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ip(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? op(Object(n), !0).forEach(function(r) {
      mo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : op(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Et = {
  compare(e, t) {
    var n = pe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Et.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Et.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && pe.equals(e.path, t.path);
  },
  isPoint(e) {
    return Yt(e) && typeof e.offset == "number" && pe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return $l(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = pe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          pe.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          pe.equals(t.path, i) && (r.offset += t.position), r.path = pe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          pe.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (pe.equals(t.path, i) || pe.isAncestor(t.path, i))
            return null;
          r.path = pe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (pe.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = pe.transform(i, t, ip(ip({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = pe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, ap = void 0, wn = {
  setScrubber(e) {
    ap = e;
  },
  stringify(e) {
    return JSON.stringify(e, ap);
  }
}, pE = ["text"], hE = ["anchor", "focus"];
function sp(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function er(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sp(Object(n), !0).forEach(function(r) {
      mo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sp(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ft = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Jo(i, pE);
      return a;
    }
    return Om(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Yt(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Ft.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [er({}, e)];
    for (var r of t) {
      var o = Jo(r, hE), [i, a] = Ve.edges(r), s = [], u = 0, l = i.offset, c = a.offset;
      for (var f of n) {
        var {
          length: p
        } = f.text, g = u;
        if (u += p, l <= g && u <= c) {
          Object.assign(f, o), s.push(f);
          continue;
        }
        if (l !== c && (l === u || c === g) || l > u || c < g || c === g && g !== 0) {
          s.push(f);
          continue;
        }
        var v = f, h = void 0, d = void 0;
        if (c < u) {
          var w = c - g;
          d = er(er({}, v), {}, {
            text: v.text.slice(w)
          }), v = er(er({}, v), {}, {
            text: v.text.slice(0, w)
          });
        }
        if (l > g) {
          var L = l - g;
          h = er(er({}, v), {}, {
            text: v.text.slice(0, L)
          }), v = er(er({}, v), {}, {
            text: v.text.slice(L)
          });
        }
        Object.assign(v, o), h && s.push(h), s.push(v), d && s.push(d);
      }
      n = s;
    }
    return n;
  }
}, gE = (e) => e.selection ? e.selection : e.children.length > 0 ? gt.end(e, []) : [0], wt;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(wt || (wt = {}));
wt.L, wt.L | wt.V | wt.LV | wt.LVT, wt.LV | wt.V, wt.V | wt.T, wt.LVT | wt.T, wt.T, wt.Any, wt.Extend | wt.ZWJ, wt.Any, wt.SpacingMark, wt.Prepend, wt.Any, wt.ZWJ, wt.ExtPict, wt.RI, wt.RI;
var vE = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    gt.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = gE(e)
      } = n;
      if (pe.isPath(o) && (o = gt.range(e, o)), Ve.isRange(o))
        if (Ve.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Ve.end(o);
          if (!r && gt.void(e, {
            at: i
          }))
            return;
          var a = Ve.start(o), s = gt.pointRef(e, a), u = gt.pointRef(e, i);
          Ea.delete(e, {
            at: o,
            voids: r
          });
          var l = s.unref(), c = u.unref();
          o = l || c, Ea.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && gt.void(e, {
        at: o
      }) || gt.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: f,
          offset: p
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: f,
          offset: p,
          text: t
        });
      }
    });
  }
};
function up(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? up(Object(n), !0).forEach(function(r) {
      mo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : up(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ea = Mi(Mi(Mi(Mi({}, oE), iE), aE), vE), mE = typeof mt == "object" && mt && mt.Object === Object && mt, yE = mE, bE = yE, CE = typeof self == "object" && self && self.Object === Object && self, wE = bE || CE || Function("return this")(), EE = wE, DE = EE, xE = DE.Symbol, Sm = xE, lp = Sm;
lp && lp.toStringTag;
var cp = Sm;
cp && cp.toStringTag;
var fp;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(fp || (fp = {}));
var Ul = function(e) {
  return Object.freeze(e);
}, LE = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Ul(this);
  }
  return e;
}(), OE = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Ul(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, u = t.width, l = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: u, height: l };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), dp = typeof window < "u" ? window : {};
/msie|trident/i.test(dp.navigator && dp.navigator.userAgent);
var $s = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new LE((n ? t : e) || 0, (n ? e : t) || 0);
};
Ul({
  devicePixelContentBoxSize: $s(),
  borderBoxSize: $s(),
  contentBoxSize: $s(),
  contentRect: new OE(0, 0, 0, 0)
});
function Qo(e) {
  "@babel/helpers - typeof";
  return Qo = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Qo(e);
}
function SE(e, t) {
  if (Qo(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Qo(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function kE(e) {
  var t = SE(e, "string");
  return Qo(t) === "symbol" ? t : String(t);
}
function No(e, t, n) {
  return t = kE(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var ME = /* @__PURE__ */ ht(null), Us, Ws;
parseInt(Se.version.split(".")[0], 10);
var pp = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Hs = typeof navigator < "u" && /Android/.test(navigator.userAgent), Pi = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), PE = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Us = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Us !== void 0 && Us[1] && parseInt((Ws = navigator.userAgent.match(/Version\/(\d+)/)) === null || Ws === void 0 ? void 0 : Ws[1], 10) < 17;
var BE = /* @__PURE__ */ new WeakMap(), TE = /* @__PURE__ */ new WeakMap(), AE = /* @__PURE__ */ new WeakMap(), FE = /* @__PURE__ */ new WeakMap(), IE = /* @__PURE__ */ new WeakMap(), hp = /* @__PURE__ */ new WeakMap(), RE = /* @__PURE__ */ new WeakMap(), gp = /* @__PURE__ */ new WeakMap(), Bi = /* @__PURE__ */ new WeakMap(), _E = /* @__PURE__ */ new WeakMap(), jE = /* @__PURE__ */ new WeakMap(), NE = /* @__PURE__ */ new WeakMap(), km = globalThis.Node, zE = globalThis.Text, Mm = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, $E = (e) => Da(e) && e.nodeType === 8, Zn = (e) => Da(e) && e.nodeType === 1, Da = (e) => {
  var t = Mm(e);
  return !!t && e instanceof t.Node;
}, vp = (e) => {
  var t = e && e.anchorNode && Mm(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, UE = (e) => {
  var [t, n] = e;
  if (Zn(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Pm(t, o, r ? "backward" : "forward"), r = o < n; Zn(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = HE(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, WE = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Pm = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; ($E(o) || Zn(o) && o.childNodes.length === 0 || Zn(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, HE = (e, t, n) => {
  var [r] = Pm(e, t, n);
  return r;
}, mp = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Bm = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Zn(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = tt.getWindow(e);
  if (o.contains(r))
    return tt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: u
    } = a;
    for (var l of s)
      if (l === r || l.contains(r))
        return !0;
    for (var c of u)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Bm(e, i, n);
}, yp = (e, t) => !!(e.compareDocumentPosition(t) & km.DOCUMENT_POSITION_PRECEDING), VE = (e, t) => !!(e.compareDocumentPosition(t) & km.DOCUMENT_POSITION_FOLLOWING), qE = 0;
class ZE {
  constructor() {
    No(this, "id", void 0), this.id = "".concat(qE++);
  }
}
var tt = {
  androidPendingDiffs: (e) => NE.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = jE.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = tt.toDOMNode(e, e), n = tt.findDocumentOrShadowRoot(e);
    Bi.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = tt.findDocumentOrShadowRoot(e), r = mp(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Ea.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = tt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = tt.toSlateNode(e, t.target), a = tt.findPath(e, i);
    if (or.isElement(i) && gt.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), u = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, l = gt.point(e, a, {
        edge: u ? "start" : "end"
      }), c = u ? gt.before(e, l) : gt.after(e, l);
      if (c) {
        var f = gt.range(e, c);
        return f;
      }
    }
    var p, {
      document: g
    } = tt.getWindow(e);
    if (g.caretRangeFromPoint)
      p = g.caretRangeFromPoint(n, r);
    else {
      var v = g.caretPositionFromPoint(n, r);
      v && (p = g.createRange(), p.setStart(v.offsetNode, v.offset), p.setEnd(v.offsetNode, v.offset));
    }
    if (!p)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var h = tt.toSlateRange(e, p, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return h;
  },
  findKey: (e, t) => {
    var n = hp.get(t);
    return n || (n = new ZE(), hp.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = TE.get(r);
      if (o == null) {
        if (gt.isEditor(r))
          return n;
        break;
      }
      var i = BE.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(wn.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Bi.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          tt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = tt.toDOMNode(e, e), r = tt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = mp(r), i = tt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Ea.select(e, gt.start(e, [])), Bi.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = AE.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = tt.toDOMNode(e, e), i;
    try {
      i = Zn(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Da(t) && tt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return gt.hasPath(e, n.path) && gt.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => tt.hasEditableTarget(e, t) || tt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Da(t) && tt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!_E.get(e),
  isFocused: (e) => !!Bi.get(e),
  isReadOnly: (e) => !!gp.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (gp.get(e)) return !1;
    var n = tt.hasTarget(e, t) && tt.toSlateNode(e, t);
    return or.isElement(n) && gt.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = RE.get(e), r = gt.isEditor(t) ? FE.get(e) : n == null ? void 0 : n.get(tt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(wn.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = gt.node(e, t.path), r = tt.toDOMNode(e, n), o;
    gt.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, u = 0; u < a.length; u++) {
      var l = a[u], c = l.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: f
        } = c.textContent, p = l.getAttribute("data-slate-length"), g = p == null ? f : parseInt(p, 10), v = s + g, h = a[u + 1];
        if (t.offset === v && h !== null && h !== void 0 && h.hasAttribute("data-slate-mark-placeholder")) {
          var d, w = h.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            w instanceof zE ? w : h,
            (d = h.textContent) !== null && d !== void 0 && d.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= v) {
          var L = Math.min(f, Math.max(0, t.offset - s));
          o = [c, L];
          break;
        }
        s = v;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(wn.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Ve.isBackward(t), i = tt.toDOMPoint(e, n), a = Ve.isCollapsed(t) ? i : tt.toDOMPoint(e, r), s = tt.getWindow(e), u = s.document.createRange(), [l, c] = o ? a : i, [f, p] = o ? i : a, g = Zn(l) ? l : l.parentElement, v = !!g.getAttribute("data-slate-zero-width"), h = Zn(f) ? f : f.parentElement, d = !!h.getAttribute("data-slate-zero-width");
    return u.setStart(l, v ? 1 : c), u.setEnd(f, d ? 1 : p), u;
  },
  toSlateNode: (e, t) => {
    var n = Zn(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? IE.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : UE(t), u = a.parentNode, l = null, c = 0;
    if (u) {
      var f, p, g = tt.toDOMNode(e, e), v = u.closest('[data-slate-void="true"]'), h = v && g.contains(v) ? v : null, d = u.closest('[contenteditable="false"]'), w = d && g.contains(d) ? d : null, L = u.closest("[data-slate-leaf]"), D = null;
      if (L) {
        if (l = L.closest('[data-slate-node="text"]'), l) {
          var B = tt.getWindow(e), b = B.document.createRange();
          b.setStart(l, 0), b.setEnd(a, s);
          var E = b.cloneContents(), O = [...Array.prototype.slice.call(E.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(E.querySelectorAll("[contenteditable=false]"))];
          O.forEach((U) => {
            if (Hs && !r && U.hasAttribute("data-slate-zero-width") && U.textContent.length > 0 && U.textContext !== "\uFEFF") {
              U.textContent.startsWith("\uFEFF") && (U.textContent = U.textContent.slice(1));
              return;
            }
            U.parentNode.removeChild(U);
          }), c = E.textContent.length, D = l;
        }
      } else if (h) {
        for (var S = h.querySelectorAll("[data-slate-leaf]"), V = 0; V < S.length; V++) {
          var M = S[V];
          if (tt.hasDOMNode(e, M)) {
            L = M;
            break;
          }
        }
        L ? (l = L.closest('[data-slate-node="text"]'), D = L, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((U) => {
          c -= U.textContent.length;
        })) : c = 1;
      } else if (w) {
        var q = (U) => U ? U.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], _ = w.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var j, I = [...q(_), ...q(_ == null ? void 0 : _.nextElementSibling)];
          L = (j = I.find((U) => VE(w, U))) !== null && j !== void 0 ? j : null;
        } else {
          var z, X = [...q(_ == null ? void 0 : _.previousElementSibling), ...q(_)];
          L = (z = X.findLast((U) => yp(w, U))) !== null && z !== void 0 ? z : null;
        }
        L && (l = L.closest('[data-slate-node="text"]'), D = L, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((U) => {
          c -= U.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Hs && D.getAttribute("data-slate-zero-width") === "z" && (f = D.textContent) !== null && f !== void 0 && f.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (u.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Pi && (p = D.textContent) !== null && p !== void 0 && p.endsWith(`

`)) && c--;
    }
    if (Hs && !l && !r) {
      var R = u.hasAttribute("data-slate-node") ? u : u.closest("[data-slate-node]");
      if (R && tt.hasDOMNode(e, R, {
        editable: !0
      })) {
        var ee = tt.toSlateNode(e, R), {
          path: re,
          offset: k
        } = gt.start(e, tt.findPath(e, ee));
        return R.querySelector("[data-slate-leaf]") || (k = s), {
          path: re,
          offset: k
        };
      }
    }
    if (!l) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var A = tt.toSlateNode(e, l), G = tt.findPath(e, A);
    return {
      path: G,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = vp(t) ? t.anchorNode : t.startContainer, s, u, l, c, f;
    if (a)
      if (vp(t)) {
        if (Pi && t.rangeCount > 1) {
          l = t.focusNode;
          var p = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (l instanceof HTMLTableRowElement && p.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let E = function(O) {
              return O.childElementCount > 0 ? E(O.children[0]) : O;
            };
            var v = p.startContainer, h = g.startContainer, d = E(v.children[p.startOffset]), w = E(h.children[g.startOffset]);
            c = 0, w.childNodes.length > 0 ? s = w.childNodes[0] : s = w, d.childNodes.length > 0 ? l = d.childNodes[0] : l = d, w instanceof HTMLElement ? u = w.innerHTML.length : u = 0;
          } else
            p.startContainer === l ? (s = g.endContainer, u = g.endOffset, c = p.startOffset) : (s = p.startContainer, u = p.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, u = t.anchorOffset, l = t.focusNode, c = t.focusOffset;
        PE && WE(s) || Pi ? f = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : f = t.isCollapsed;
      } else
        s = t.startContainer, u = t.startOffset, l = t.endContainer, c = t.endOffset, f = t.collapsed;
    if (s == null || l == null || u == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Pi && (r = l.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === l.textContent.length && c--;
    var L = tt.toSlatePoint(e, [s, u], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!L)
      return null;
    var D = yp(s, l) || s === l && c < u, B = f ? L : tt.toSlatePoint(e, [l, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!B)
      return null;
    var b = {
      anchor: L,
      focus: B
    };
    return Ve.isExpanded(b) && Ve.isForward(b) && Zn(l) && gt.void(e, {
      at: b.focus,
      mode: "highest"
    }) && (b = gt.unhangRange(e, b, {
      voids: !0
    })), b;
  }
}, GE = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, KE = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, YE = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, xt = (e) => {
  var t = GE[e], n = KE[e], r = YE[e], o = t && js(t), i = n && js(n), a = r && js(r);
  return (s) => !!(o && o(s) || pp && i && i(s) || !pp && a && a(s));
};
xt("bold"), xt("compose"), xt("moveBackward"), xt("moveForward"), xt("deleteBackward"), xt("deleteForward"), xt("deleteLineBackward"), xt("deleteLineForward"), xt("deleteWordBackward"), xt("deleteWordForward"), xt("extendBackward"), xt("extendForward"), xt("extendLineBackward"), xt("extendLineForward"), xt("italic"), xt("moveLineBackward"), xt("moveLineForward"), xt("moveWordBackward"), xt("moveWordForward"), xt("redo"), xt("insertSoftBreak"), xt("splitBlock"), xt("transposeCharacter"), xt("undo");
var XE = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((u) => Bm(e, u, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, JE = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class QE extends Mv {
  constructor() {
    super(...arguments), No(this, "context", null), No(this, "manager", null), No(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, JE);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = XE(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
No(QE, "contextType", ME);
var Tm = {}, Wl = {}, Hl = {};
Object.defineProperty(Hl, "__esModule", { value: !0 });
Hl.default = rD;
var bp = "html", Cp = "head", Ti = "body", eD = /<([a-zA-Z]+[0-9]?)/, wp = /<head[^]*>/i, Ep = /<body[^]*>/i, xa = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Zu = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, Dp = typeof window == "object" && window.DOMParser;
if (typeof Dp == "function") {
  var tD = new Dp(), nD = "text/html";
  Zu = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), tD.parseFromString(e, nD);
  }, xa = Zu;
}
if (typeof document == "object" && document.implementation) {
  var Ai = document.implementation.createHTMLDocument();
  xa = function(e, t) {
    if (t) {
      var n = Ai.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Ai;
    }
    return Ai.documentElement.innerHTML = e, Ai;
  };
}
var Fi = typeof document == "object" && document.createElement("template"), Gu;
Fi && Fi.content && (Gu = function(e) {
  return Fi.innerHTML = e, Fi.content.childNodes;
});
function rD(e) {
  var t, n, r = e.match(eD), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case bp: {
      var i = Zu(e);
      if (!wp.test(e)) {
        var a = i.querySelector(Cp);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!Ep.test(e)) {
        var a = i.querySelector(Ti);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(bp);
    }
    case Cp:
    case Ti: {
      var s = xa(e).querySelectorAll(o);
      return Ep.test(e) && wp.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (Gu)
        return Gu(e);
      var a = xa(e, Ti).querySelector(Ti);
      return a.childNodes;
    }
  }
}
var Va = {}, Vl = {}, ql = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(ql);
var Xe = {}, Br = mt && mt.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), zo = mt && mt.__assign || function() {
  return zo = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, zo.apply(this, arguments);
};
Object.defineProperty(Xe, "__esModule", { value: !0 });
Xe.cloneNode = Xe.hasChildren = Xe.isDocument = Xe.isDirective = Xe.isComment = Xe.isText = Xe.isCDATA = Xe.isTag = Xe.Element = Xe.Document = Xe.CDATA = Xe.NodeWithChildren = Xe.ProcessingInstruction = Xe.Comment = Xe.Text = Xe.DataNode = Xe.Node = void 0;
var cn = ql, Zl = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Gl(this, t);
    }, e;
  }()
);
Xe.Node = Zl;
var qa = (
  /** @class */
  function(e) {
    Br(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zl)
);
Xe.DataNode = qa;
var Am = (
  /** @class */
  function(e) {
    Br(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = cn.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qa)
);
Xe.Text = Am;
var Fm = (
  /** @class */
  function(e) {
    Br(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = cn.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qa)
);
Xe.Comment = Fm;
var Im = (
  /** @class */
  function(e) {
    Br(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = cn.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qa)
);
Xe.ProcessingInstruction = Im;
var Za = (
  /** @class */
  function(e) {
    Br(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zl)
);
Xe.NodeWithChildren = Za;
var Rm = (
  /** @class */
  function(e) {
    Br(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = cn.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Za)
);
Xe.CDATA = Rm;
var _m = (
  /** @class */
  function(e) {
    Br(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = cn.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Za)
);
Xe.Document = _m;
var jm = (
  /** @class */
  function(e) {
    Br(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? cn.ElementType.Script : n === "style" ? cn.ElementType.Style : cn.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Za)
);
Xe.Element = jm;
function Nm(e) {
  return (0, cn.isTag)(e);
}
Xe.isTag = Nm;
function zm(e) {
  return e.type === cn.ElementType.CDATA;
}
Xe.isCDATA = zm;
function $m(e) {
  return e.type === cn.ElementType.Text;
}
Xe.isText = $m;
function Um(e) {
  return e.type === cn.ElementType.Comment;
}
Xe.isComment = Um;
function Wm(e) {
  return e.type === cn.ElementType.Directive;
}
Xe.isDirective = Wm;
function Hm(e) {
  return e.type === cn.ElementType.Root;
}
Xe.isDocument = Hm;
function oD(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Xe.hasChildren = oD;
function Gl(e, t) {
  t === void 0 && (t = !1);
  var n;
  if ($m(e))
    n = new Am(e.data);
  else if (Um(e))
    n = new Fm(e.data);
  else if (Nm(e)) {
    var r = t ? Vs(e.children) : [], o = new jm(e.name, zo({}, e.attribs), r);
    r.forEach(function(u) {
      return u.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = zo({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = zo({}, e["x-attribsPrefix"])), n = o;
  } else if (zm(e)) {
    var r = t ? Vs(e.children) : [], i = new Rm(r);
    r.forEach(function(l) {
      return l.parent = i;
    }), n = i;
  } else if (Hm(e)) {
    var r = t ? Vs(e.children) : [], a = new _m(r);
    r.forEach(function(l) {
      return l.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (Wm(e)) {
    var s = new Im(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Xe.cloneNode = Gl;
function Vs(e) {
  for (var t = e.map(function(r) {
    return Gl(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = mt && mt.__createBinding || (Object.create ? function(s, u, l, c) {
    c === void 0 && (c = l);
    var f = Object.getOwnPropertyDescriptor(u, l);
    (!f || ("get" in f ? !u.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return u[l];
    } }), Object.defineProperty(s, c, f);
  } : function(s, u, l, c) {
    c === void 0 && (c = l), s[c] = u[l];
  }), n = mt && mt.__exportStar || function(s, u) {
    for (var l in s) l !== "default" && !Object.prototype.hasOwnProperty.call(u, l) && t(u, s, l);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = ql, o = Xe;
  n(Xe, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(u, l, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof l == "function" && (c = l, l = i), typeof u == "object" && (l = u, u = void 0), this.callback = u ?? null, this.options = l ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(u) {
        this.parser = u;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(u) {
        this.handleCallback(u);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var u = this.tagStack.pop();
        this.options.withEndIndices && (u.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(u);
      }, s.prototype.onopentag = function(u, l) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, f = new o.Element(u, l, void 0, c);
        this.addNode(f), this.tagStack.push(f);
      }, s.prototype.ontext = function(u) {
        var l = this.lastNode;
        if (l && l.type === r.ElementType.Text)
          l.data += u, this.options.withEndIndices && (l.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(u);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(u) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += u;
          return;
        }
        var l = new o.Comment(u);
        this.addNode(l), this.lastNode = l;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var u = new o.Text(""), l = new o.CDATA([u]);
        this.addNode(l), u.parent = l, this.lastNode = u;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(u, l) {
        var c = new o.ProcessingInstruction(u, l);
        this.addNode(c);
      }, s.prototype.handleCallback = function(u) {
        if (typeof this.callback == "function")
          this.callback(u, this.dom);
        else if (u)
          throw u;
      }, s.prototype.addNode = function(u) {
        var l = this.tagStack[this.tagStack.length - 1], c = l.children[l.children.length - 1];
        this.options.withStartIndices && (u.startIndex = this.parser.startIndex), this.options.withEndIndices && (u.endIndex = this.parser.endIndex), l.children.push(u), c && (u.prev = c, c.next = u), u.parent = l, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(Vl);
var Vm = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(Vm);
Object.defineProperty(Va, "__esModule", { value: !0 });
Va.formatAttributes = qm;
Va.formatDOM = Zm;
var Ii = Vl, iD = Vm;
function aD(e) {
  return iD.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function qm(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function sD(e) {
  e = e.toLowerCase();
  var t = aD(e);
  return t || e;
}
function Zm(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var u = sD(s.nodeName);
        o = new Ii.Element(u, qm(s.attributes)), o.children = Zm(
          // template children are on content
          u === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Ii.Text(s.nodeValue);
        break;
      case 8:
        o = new Ii.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var l = r[i - 1] || null;
    l && (l.next = o), o.parent = t, o.prev = l, o.next = null, r.push(o);
  }
  return n && (o = new Ii.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var uD = mt && mt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Wl, "__esModule", { value: !0 });
Wl.default = dD;
var lD = uD(Hl), cD = Va, fD = /<(![a-zA-Z\s]+)>/;
function dD(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(fD), n = t ? t[1] : void 0;
  return (0, cD.formatDOM)((0, lD.default)(e), null, n);
}
var Ga = {}, $n = {}, Ka = {}, pD = 0;
Ka.SAME = pD;
var hD = 1;
Ka.CAMELCASE = hD;
Ka.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const Gm = 0, Tr = 1, Ya = 2, Xa = 3, Kl = 4, Km = 5, Ym = 6;
function gD(e) {
  return Gt.hasOwnProperty(e) ? Gt[e] : null;
}
function rn(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Ya || t === Xa || t === Kl, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Gt = {}, vD = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
vD.forEach((e) => {
  Gt[e] = new rn(
    e,
    Gm,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Gt[e] = new rn(
    e,
    Tr,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Gt[e] = new rn(
    e,
    Ya,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Gt[e] = new rn(
    e,
    Ya,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Gt[e] = new rn(
    e,
    Xa,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Gt[e] = new rn(
    e,
    Xa,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Gt[e] = new rn(
    e,
    Kl,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Gt[e] = new rn(
    e,
    Ym,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Gt[e] = new rn(
    e,
    Km,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Yl = /[\-\:]([a-z])/g, Xl = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Yl, Xl);
  Gt[t] = new rn(
    t,
    Tr,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Yl, Xl);
  Gt[t] = new rn(
    t,
    Tr,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Yl, Xl);
  Gt[t] = new rn(
    t,
    Tr,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Gt[e] = new rn(
    e,
    Tr,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const mD = "xlinkHref";
Gt[mD] = new rn(
  "xlinkHref",
  Tr,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Gt[e] = new rn(
    e,
    Tr,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: yD,
  SAME: bD,
  possibleStandardNames: xp
} = Ka, CD = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", wD = CD + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ED = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + wD + "]*$")
), DD = Object.keys(
  xp
).reduce((e, t) => {
  const n = xp[t];
  return n === bD ? e[t] = t : n === yD ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
$n.BOOLEAN = Xa;
$n.BOOLEANISH_STRING = Ya;
$n.NUMERIC = Km;
$n.OVERLOADED_BOOLEAN = Kl;
$n.POSITIVE_NUMERIC = Ym;
$n.RESERVED = Gm;
$n.STRING = Tr;
$n.getPropertyInfo = gD;
$n.isCustomAttribute = ED;
$n.possibleStandardNames = DD;
var Jl = {}, Ql = {}, Lp = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, xD = /\n/g, LD = /^\s*/, OD = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, SD = /^:\s*/, kD = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, MD = /^[;\s]*/, PD = /^\s+|\s+$/g, BD = `
`, Op = "/", Sp = "*", qr = "", TD = "comment", AD = "declaration", FD = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(v) {
    var h = v.match(xD);
    h && (n += h.length);
    var d = v.lastIndexOf(BD);
    r = ~d ? v.length - d : r + v.length;
  }
  function i() {
    var v = { line: n, column: r };
    return function(h) {
      return h.position = new a(v), l(), h;
    };
  }
  function a(v) {
    this.start = v, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(v) {
    var h = new Error(
      t.source + ":" + n + ":" + r + ": " + v
    );
    if (h.reason = v, h.filename = t.source, h.line = n, h.column = r, h.source = e, !t.silent) throw h;
  }
  function u(v) {
    var h = v.exec(e);
    if (h) {
      var d = h[0];
      return o(d), e = e.slice(d.length), h;
    }
  }
  function l() {
    u(LD);
  }
  function c(v) {
    var h;
    for (v = v || []; h = f(); )
      h !== !1 && v.push(h);
    return v;
  }
  function f() {
    var v = i();
    if (!(Op != e.charAt(0) || Sp != e.charAt(1))) {
      for (var h = 2; qr != e.charAt(h) && (Sp != e.charAt(h) || Op != e.charAt(h + 1)); )
        ++h;
      if (h += 2, qr === e.charAt(h - 1))
        return s("End of comment missing");
      var d = e.slice(2, h - 2);
      return r += 2, o(d), e = e.slice(h), r += 2, v({
        type: TD,
        comment: d
      });
    }
  }
  function p() {
    var v = i(), h = u(OD);
    if (h) {
      if (f(), !u(SD)) return s("property missing ':'");
      var d = u(kD), w = v({
        type: AD,
        property: kp(h[0].replace(Lp, qr)),
        value: d ? kp(d[0].replace(Lp, qr)) : qr
      });
      return u(MD), w;
    }
  }
  function g() {
    var v = [];
    c(v);
    for (var h; h = p(); )
      h !== !1 && (v.push(h), c(v));
    return v;
  }
  return l(), g();
};
function kp(e) {
  return e ? e.replace(PD, qr) : qr;
}
var ID = mt && mt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ql, "__esModule", { value: !0 });
Ql.default = _D;
var RD = ID(FD);
function _D(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, RD.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Ja = {};
Object.defineProperty(Ja, "__esModule", { value: !0 });
Ja.camelCase = void 0;
var jD = /^--[a-zA-Z0-9-]+$/, ND = /-([a-z])/g, zD = /^[^-]+$/, $D = /^-(webkit|moz|ms|o|khtml)-/, UD = /^-(ms)-/, WD = function(e) {
  return !e || zD.test(e) || jD.test(e);
}, HD = function(e, t) {
  return t.toUpperCase();
}, Mp = function(e, t) {
  return "".concat(t, "-");
}, VD = function(e, t) {
  return t === void 0 && (t = {}), WD(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(UD, Mp) : e = e.replace($D, Mp), e.replace(ND, HD));
};
Ja.camelCase = VD;
var qD = mt && mt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, ZD = qD(Ql), GD = Ja;
function Ku(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, ZD.default)(e, function(r, o) {
    r && o && (n[(0, GD.camelCase)(r, t)] = o);
  }), n;
}
Ku.default = Ku;
var KD = Ku;
(function(e) {
  var t = mt && mt.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Se, r = t(KD), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, f) {
    return c.includes("-") ? !o.has(c) : !!(f && typeof f.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, f) {
    if (typeof c == "string") {
      if (!c.trim()) {
        f.style = {};
        return;
      }
      try {
        f.style = (0, r.default)(c, a);
      } catch {
        f.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var u = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = u;
  var l = function(c) {
    return c;
  };
  e.returnFirstArg = l;
})(Jl);
Object.defineProperty(Ga, "__esModule", { value: !0 });
Ga.default = QD;
var Io = $n, Pp = Jl, YD = ["checked", "value"], XD = ["input", "select", "textarea"], JD = {
  reset: !0,
  submit: !0
};
function QD(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && JD[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Io.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = Bp(a);
    if (s) {
      var u = (0, Io.getPropertyInfo)(s);
      switch (YD.includes(s) && XD.includes(t) && !r && (s = Bp("default" + a)), n[s] = i, u && u.type) {
        case Io.BOOLEAN:
          n[s] = !0;
          break;
        case Io.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    Pp.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, Pp.setStyleProp)(e.style, n), n;
}
function Bp(e) {
  return Io.possibleStandardNames[e];
}
var ec = {}, ex = mt && mt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ec, "__esModule", { value: !0 });
ec.default = Xm;
var qs = Se, tx = ex(Ga), $o = Jl, nx = {
  cloneElement: qs.cloneElement,
  createElement: qs.createElement,
  isValidElement: qs.isValidElement
};
function Xm(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || $o.returnFirstArg, i = t.library || nx, a = i.cloneElement, s = i.createElement, u = i.isValidElement, l = e.length, c = 0; c < l; c++) {
    var f = e[c];
    if (r) {
      var p = t.replace(f, c);
      if (u(p)) {
        l > 1 && (p = a(p, {
          key: p.key || c
        })), n.push(o(p, f, c));
        continue;
      }
    }
    if (f.type === "text") {
      var g = !f.data.trim().length;
      if (g && f.parent && !(0, $o.canTextBeChildOfNode)(f.parent) || t.trim && g)
        continue;
      n.push(o(f.data, f, c));
      continue;
    }
    var v = f, h = {};
    rx(v) ? ((0, $o.setStyleProp)(v.attribs.style, v.attribs), h = v.attribs) : v.attribs && (h = (0, tx.default)(v.attribs, v.name));
    var d = void 0;
    switch (f.type) {
      case "script":
      case "style":
        f.children[0] && (h.dangerouslySetInnerHTML = {
          __html: f.children[0].data
        });
        break;
      case "tag":
        f.name === "textarea" && f.children[0] ? h.defaultValue = f.children[0].data : f.children && f.children.length && (d = Xm(f.children, t));
        break;
      default:
        continue;
    }
    l > 1 && (h.key = c), n.push(o(s(f.name, h, d), f, c));
  }
  return n.length === 1 ? n[0] : n;
}
function rx(e) {
  return $o.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, $o.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = mt && mt.__importDefault || function(u) {
    return u && u.__esModule ? u : { default: u };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(Wl);
  e.htmlToDOM = n.default;
  var r = t(Ga);
  e.attributesToProps = r.default;
  var o = t(ec);
  e.domToReact = o.default;
  var i = Vl;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(u, l) {
    if (typeof u != "string")
      throw new TypeError("First argument must be a string");
    return u ? (0, o.default)((0, n.default)(u, (l == null ? void 0 : l.htmlparser2) || a), l) : [];
  }
})(Tm);
const Tp = /* @__PURE__ */ b1(Tm);
Tp.default;
ht({});
ht({});
ht({});
function ox(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ st.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ st.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
var It = {}, tc = {}, si = {}, ui = {}, Jm = "Expected a function", Ap = NaN, ix = "[object Symbol]", ax = /^\s+|\s+$/g, sx = /^[-+]0x[0-9a-f]+$/i, ux = /^0b[01]+$/i, lx = /^0o[0-7]+$/i, cx = parseInt, fx = typeof mt == "object" && mt && mt.Object === Object && mt, dx = typeof self == "object" && self && self.Object === Object && self, px = fx || dx || Function("return this")(), hx = Object.prototype, gx = hx.toString, vx = Math.max, mx = Math.min, Zs = function() {
  return px.Date.now();
};
function yx(e, t, n) {
  var r, o, i, a, s, u, l = 0, c = !1, f = !1, p = !0;
  if (typeof e != "function")
    throw new TypeError(Jm);
  t = Fp(t) || 0, La(n) && (c = !!n.leading, f = "maxWait" in n, i = f ? vx(Fp(n.maxWait) || 0, t) : i, p = "trailing" in n ? !!n.trailing : p);
  function g(E) {
    var O = r, S = o;
    return r = o = void 0, l = E, a = e.apply(S, O), a;
  }
  function v(E) {
    return l = E, s = setTimeout(w, t), c ? g(E) : a;
  }
  function h(E) {
    var O = E - u, S = E - l, V = t - O;
    return f ? mx(V, i - S) : V;
  }
  function d(E) {
    var O = E - u, S = E - l;
    return u === void 0 || O >= t || O < 0 || f && S >= i;
  }
  function w() {
    var E = Zs();
    if (d(E))
      return L(E);
    s = setTimeout(w, h(E));
  }
  function L(E) {
    return s = void 0, p && r ? g(E) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), l = 0, r = u = o = s = void 0;
  }
  function B() {
    return s === void 0 ? a : L(Zs());
  }
  function b() {
    var E = Zs(), O = d(E);
    if (r = arguments, o = this, u = E, O) {
      if (s === void 0)
        return v(u);
      if (f)
        return s = setTimeout(w, t), g(u);
    }
    return s === void 0 && (s = setTimeout(w, t)), a;
  }
  return b.cancel = D, b.flush = B, b;
}
function bx(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Jm);
  return La(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), yx(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function La(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Cx(e) {
  return !!e && typeof e == "object";
}
function wx(e) {
  return typeof e == "symbol" || Cx(e) && gx.call(e) == ix;
}
function Fp(e) {
  if (typeof e == "number")
    return e;
  if (wx(e))
    return Ap;
  if (La(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = La(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(ax, "");
  var n = ux.test(e);
  return n || lx.test(e) ? cx(e.slice(2), n ? 2 : 8) : sx.test(e) ? Ap : +e;
}
var Ex = bx, li = {};
Object.defineProperty(li, "__esModule", {
  value: !0
});
li.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), aa.has(t) || aa.set(t, /* @__PURE__ */ new Set());
  var o = aa.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
li.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), aa.get(t).delete(n.name || t);
};
var aa = /* @__PURE__ */ new Map();
Object.defineProperty(ui, "__esModule", {
  value: !0
});
var Dx = Ex, xx = Ox(Dx), Lx = li;
function Ox(e) {
  return e && e.__esModule ? e : { default: e };
}
var Sx = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, xx.default)(e, t);
}, Pt = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = Sx(function(r) {
        Pt.scrollHandler(e);
      }, t);
      Pt.scrollSpyContainers.push(e), (0, Lx.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return Pt.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Pt.scrollSpyContainers[Pt.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Pt.currentPositionX(e), Pt.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Pt.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Pt.scrollSpyContainers[Pt.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(Pt.currentPositionX(t), Pt.currentPositionY(t));
  },
  updateStates: function() {
    Pt.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Pt.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Pt.spySetState && Pt.spySetState.length && Pt.spySetState.indexOf(e) > -1 && Pt.spySetState.splice(Pt.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Pt.scrollHandler);
  },
  update: function() {
    return Pt.scrollSpyContainers.forEach(function(e) {
      return Pt.scrollHandler(e);
    });
  }
};
ui.default = Pt;
var yo = {}, ci = {};
Object.defineProperty(ci, "__esModule", {
  value: !0
});
var kx = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, Mx = function() {
  return window.location.hash.replace(/^#/, "");
}, Px = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Bx = function(e) {
  return getComputedStyle(e).position !== "static";
}, Gs = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, Tx = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Bx(e)) {
    if (t.offsetParent !== e) {
      var r = function(u) {
        return u === e || u === document;
      }, o = Gs(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(u) {
    return u === document;
  };
  return Gs(t, s).offsetTop - Gs(e, s).offsetTop;
};
ci.default = {
  updateHash: kx,
  getHash: Mx,
  filterElementInContainer: Px,
  scrollOffset: Tx
};
var Qa = {}, nc = {};
Object.defineProperty(nc, "__esModule", {
  value: !0
});
nc.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var rc = {};
Object.defineProperty(rc, "__esModule", {
  value: !0
});
var Ax = li, Fx = ["mousedown", "mousewheel", "touchmove", "keydown"];
rc.default = {
  subscribe: function(e) {
    return typeof document < "u" && Fx.forEach(function(t) {
      return (0, Ax.addPassiveEventListener)(document, t, e);
    });
  }
};
var fi = {};
Object.defineProperty(fi, "__esModule", {
  value: !0
});
var Yu = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Yu.registered[e] = t;
    },
    remove: function(e) {
      Yu.registered[e] = null;
    }
  }
};
fi.default = Yu;
Object.defineProperty(Qa, "__esModule", {
  value: !0
});
var Ix = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Rx = ci;
es(Rx);
var _x = nc, Ip = es(_x), jx = rc, Nx = es(jx), zx = fi, Vn = es(zx);
function es(e) {
  return e && e.__esModule ? e : { default: e };
}
var Qm = function(e) {
  return Ip.default[e.smooth] || Ip.default.defaultEasing;
}, $x = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Ux = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Xu = function() {
  return Ux() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), ey = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, ty = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, ny = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, Wx = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, Hx = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Vx = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Vn.default.registered.end && Vn.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Xu.call(window, i);
    return;
  }
  Vn.default.registered.end && Vn.default.registered.end(o.to, o.target, o.currentPosition);
}, oc = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, di = function(e, t, n, r) {
  t.data = t.data || ey(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (Nx.default.subscribe(o), oc(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? ty(t) : ny(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Vn.default.registered.end && Vn.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = $x(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Qm(t), a = Vx.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Vn.default.registered.begin && Vn.default.registered.begin(t.data.to, t.data.target), Xu.call(window, a);
    }, t.delay);
    return;
  }
  Vn.default.registered.begin && Vn.default.registered.begin(t.data.to, t.data.target), Xu.call(window, a);
}, ts = function(e) {
  return e = Ix({}, e), e.data = e.data || ey(), e.absolute = !0, e;
}, qx = function(e) {
  di(0, ts(e));
}, Zx = function(e, t) {
  di(e, ts(t));
}, Gx = function(e) {
  e = ts(e), oc(e), di(e.horizontal ? Wx(e) : Hx(e), e);
}, Kx = function(e, t) {
  t = ts(t), oc(t);
  var n = t.horizontal ? ty(t) : ny(t);
  di(e + n, t);
};
Qa.default = {
  animateTopScroll: di,
  getAnimationType: Qm,
  scrollToTop: qx,
  scrollToBottom: Gx,
  scrollTo: Zx,
  scrollMore: Kx
};
Object.defineProperty(yo, "__esModule", {
  value: !0
});
var Yx = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Xx = ci, Jx = ic(Xx), Qx = Qa, eL = ic(Qx), tL = fi, Ri = ic(tL);
function ic(e) {
  return e && e.__esModule ? e : { default: e };
}
var _i = {}, Rp = void 0;
yo.default = {
  unmount: function() {
    _i = {};
  },
  register: function(e, t) {
    _i[e] = t;
  },
  unregister: function(e) {
    delete _i[e];
  },
  get: function(e) {
    return _i[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return Rp = e;
  },
  getActiveLink: function() {
    return Rp;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Yx({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = Jx.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Ri.default.registered.begin && Ri.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Ri.default.registered.end && Ri.default.registered.end(e, n);
      return;
    }
    eL.default.animateTopScroll(s, t, e, n);
  }
};
var Ju = { exports: {} }, Ks = { exports: {} }, lt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _p;
function nL() {
  if (_p) return lt;
  _p = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, u = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, v = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, d = e ? Symbol.for("react.fundamental") : 60117, w = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
  function D(b) {
    if (typeof b == "object" && b !== null) {
      var E = b.$$typeof;
      switch (E) {
        case t:
          switch (b = b.type, b) {
            case u:
            case l:
            case r:
            case i:
            case o:
            case f:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case s:
                case c:
                case v:
                case g:
                case a:
                  return b;
                default:
                  return E;
              }
          }
        case n:
          return E;
      }
    }
  }
  function B(b) {
    return D(b) === l;
  }
  return lt.AsyncMode = u, lt.ConcurrentMode = l, lt.ContextConsumer = s, lt.ContextProvider = a, lt.Element = t, lt.ForwardRef = c, lt.Fragment = r, lt.Lazy = v, lt.Memo = g, lt.Portal = n, lt.Profiler = i, lt.StrictMode = o, lt.Suspense = f, lt.isAsyncMode = function(b) {
    return B(b) || D(b) === u;
  }, lt.isConcurrentMode = B, lt.isContextConsumer = function(b) {
    return D(b) === s;
  }, lt.isContextProvider = function(b) {
    return D(b) === a;
  }, lt.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === t;
  }, lt.isForwardRef = function(b) {
    return D(b) === c;
  }, lt.isFragment = function(b) {
    return D(b) === r;
  }, lt.isLazy = function(b) {
    return D(b) === v;
  }, lt.isMemo = function(b) {
    return D(b) === g;
  }, lt.isPortal = function(b) {
    return D(b) === n;
  }, lt.isProfiler = function(b) {
    return D(b) === i;
  }, lt.isStrictMode = function(b) {
    return D(b) === o;
  }, lt.isSuspense = function(b) {
    return D(b) === f;
  }, lt.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === r || b === l || b === i || b === o || b === f || b === p || typeof b == "object" && b !== null && (b.$$typeof === v || b.$$typeof === g || b.$$typeof === a || b.$$typeof === s || b.$$typeof === c || b.$$typeof === d || b.$$typeof === w || b.$$typeof === L || b.$$typeof === h);
  }, lt.typeOf = D, lt;
}
var pt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jp;
function rL() {
  return jp || (jp = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, u = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, v = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, d = e ? Symbol.for("react.fundamental") : 60117, w = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === l || N === i || N === o || N === f || N === p || typeof N == "object" && N !== null && (N.$$typeof === v || N.$$typeof === g || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === d || N.$$typeof === w || N.$$typeof === L || N.$$typeof === h);
    }
    function B(N) {
      if (typeof N == "object" && N !== null) {
        var se = N.$$typeof;
        switch (se) {
          case t:
            var ue = N.type;
            switch (ue) {
              case u:
              case l:
              case r:
              case i:
              case o:
              case f:
                return ue;
              default:
                var de = ue && ue.$$typeof;
                switch (de) {
                  case s:
                  case c:
                  case v:
                  case g:
                  case a:
                    return de;
                  default:
                    return se;
                }
            }
          case n:
            return se;
        }
      }
    }
    var b = u, E = l, O = s, S = a, V = t, M = c, q = r, _ = v, j = g, I = n, z = i, X = o, R = f, ee = !1;
    function re(N) {
      return ee || (ee = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || B(N) === u;
    }
    function k(N) {
      return B(N) === l;
    }
    function A(N) {
      return B(N) === s;
    }
    function G(N) {
      return B(N) === a;
    }
    function U(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function Y(N) {
      return B(N) === c;
    }
    function K(N) {
      return B(N) === r;
    }
    function m(N) {
      return B(N) === v;
    }
    function $(N) {
      return B(N) === g;
    }
    function W(N) {
      return B(N) === n;
    }
    function T(N) {
      return B(N) === i;
    }
    function J(N) {
      return B(N) === o;
    }
    function te(N) {
      return B(N) === f;
    }
    pt.AsyncMode = b, pt.ConcurrentMode = E, pt.ContextConsumer = O, pt.ContextProvider = S, pt.Element = V, pt.ForwardRef = M, pt.Fragment = q, pt.Lazy = _, pt.Memo = j, pt.Portal = I, pt.Profiler = z, pt.StrictMode = X, pt.Suspense = R, pt.isAsyncMode = re, pt.isConcurrentMode = k, pt.isContextConsumer = A, pt.isContextProvider = G, pt.isElement = U, pt.isForwardRef = Y, pt.isFragment = K, pt.isLazy = m, pt.isMemo = $, pt.isPortal = W, pt.isProfiler = T, pt.isStrictMode = J, pt.isSuspense = te, pt.isValidElementType = D, pt.typeOf = B;
  }()), pt;
}
var Np;
function ry() {
  return Np || (Np = 1, process.env.NODE_ENV === "production" ? Ks.exports = nL() : Ks.exports = rL()), Ks.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Ys, zp;
function oL() {
  if (zp) return Ys;
  zp = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var u = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (u.join("") !== "0123456789")
        return !1;
      var l = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        l[c] = c;
      }), Object.keys(Object.assign({}, l)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Ys = o() ? Object.assign : function(i, a) {
    for (var s, u = r(i), l, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var f in s)
        t.call(s, f) && (u[f] = s[f]);
      if (e) {
        l = e(s);
        for (var p = 0; p < l.length; p++)
          n.call(s, l[p]) && (u[l[p]] = s[l[p]]);
      }
    }
    return u;
  }, Ys;
}
var Xs, $p;
function ac() {
  if ($p) return Xs;
  $p = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Xs = e, Xs;
}
var Up, Wp;
function oy() {
  return Wp || (Wp = 1, Up = Function.call.bind(Object.prototype.hasOwnProperty)), Up;
}
var Js, Hp;
function iL() {
  if (Hp) return Js;
  Hp = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = ac(), n = {}, r = oy();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, u, l) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var f;
          try {
            if (typeof i[c] != "function") {
              var p = Error(
                (u || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            f = i[c](a, c, u, s, null, t);
          } catch (v) {
            f = v;
          }
          if (f && !(f instanceof Error) && e(
            (u || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in n)) {
            n[f.message] = !0;
            var g = l ? l() : "";
            e(
              "Failed " + s + " type: " + f.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Js = o, Js;
}
var Qs, Vp;
function aL() {
  if (Vp) return Qs;
  Vp = 1;
  var e = ry(), t = oL(), n = ac(), r = oy(), o = iL(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var u = "Warning: " + s;
    typeof console < "u" && console.error(u);
    try {
      throw new Error(u);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Qs = function(s, u) {
    var l = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function f(k) {
      var A = k && (l && k[l] || k[c]);
      if (typeof A == "function")
        return A;
    }
    var p = "<<anonymous>>", g = {
      array: w("array"),
      bigint: w("bigint"),
      bool: w("boolean"),
      func: w("function"),
      number: w("number"),
      object: w("object"),
      string: w("string"),
      symbol: w("symbol"),
      any: L(),
      arrayOf: D,
      element: B(),
      elementType: b(),
      instanceOf: E,
      node: M(),
      objectOf: S,
      oneOf: O,
      oneOfType: V,
      shape: _,
      exact: j
    };
    function v(k, A) {
      return k === A ? k !== 0 || 1 / k === 1 / A : k !== k && A !== A;
    }
    function h(k, A) {
      this.message = k, this.data = A && typeof A == "object" ? A : {}, this.stack = "";
    }
    h.prototype = Error.prototype;
    function d(k) {
      if (process.env.NODE_ENV !== "production")
        var A = {}, G = 0;
      function U(K, m, $, W, T, J, te) {
        if (W = W || p, J = J || $, te !== n) {
          if (u) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var se = W + ":" + $;
            !A[se] && // Avoid spamming the console because they are often not actionable except for lib authors
            G < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + J + "` prop on `" + W + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), A[se] = !0, G++);
          }
        }
        return m[$] == null ? K ? m[$] === null ? new h("The " + T + " `" + J + "` is marked as required " + ("in `" + W + "`, but its value is `null`.")) : new h("The " + T + " `" + J + "` is marked as required in " + ("`" + W + "`, but its value is `undefined`.")) : null : k(m, $, W, T, J);
      }
      var Y = U.bind(null, !1);
      return Y.isRequired = U.bind(null, !0), Y;
    }
    function w(k) {
      function A(G, U, Y, K, m, $) {
        var W = G[U], T = X(W);
        if (T !== k) {
          var J = R(W);
          return new h(
            "Invalid " + K + " `" + m + "` of type " + ("`" + J + "` supplied to `" + Y + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return d(A);
    }
    function L() {
      return d(a);
    }
    function D(k) {
      function A(G, U, Y, K, m) {
        if (typeof k != "function")
          return new h("Property `" + m + "` of component `" + Y + "` has invalid PropType notation inside arrayOf.");
        var $ = G[U];
        if (!Array.isArray($)) {
          var W = X($);
          return new h("Invalid " + K + " `" + m + "` of type " + ("`" + W + "` supplied to `" + Y + "`, expected an array."));
        }
        for (var T = 0; T < $.length; T++) {
          var J = k($, T, Y, K, m + "[" + T + "]", n);
          if (J instanceof Error)
            return J;
        }
        return null;
      }
      return d(A);
    }
    function B() {
      function k(A, G, U, Y, K) {
        var m = A[G];
        if (!s(m)) {
          var $ = X(m);
          return new h("Invalid " + Y + " `" + K + "` of type " + ("`" + $ + "` supplied to `" + U + "`, expected a single ReactElement."));
        }
        return null;
      }
      return d(k);
    }
    function b() {
      function k(A, G, U, Y, K) {
        var m = A[G];
        if (!e.isValidElementType(m)) {
          var $ = X(m);
          return new h("Invalid " + Y + " `" + K + "` of type " + ("`" + $ + "` supplied to `" + U + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return d(k);
    }
    function E(k) {
      function A(G, U, Y, K, m) {
        if (!(G[U] instanceof k)) {
          var $ = k.name || p, W = re(G[U]);
          return new h("Invalid " + K + " `" + m + "` of type " + ("`" + W + "` supplied to `" + Y + "`, expected ") + ("instance of `" + $ + "`."));
        }
        return null;
      }
      return d(A);
    }
    function O(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function A(G, U, Y, K, m) {
        for (var $ = G[U], W = 0; W < k.length; W++)
          if (v($, k[W]))
            return null;
        var T = JSON.stringify(k, function(J, te) {
          var N = R(te);
          return N === "symbol" ? String(te) : te;
        });
        return new h("Invalid " + K + " `" + m + "` of value `" + String($) + "` " + ("supplied to `" + Y + "`, expected one of " + T + "."));
      }
      return d(A);
    }
    function S(k) {
      function A(G, U, Y, K, m) {
        if (typeof k != "function")
          return new h("Property `" + m + "` of component `" + Y + "` has invalid PropType notation inside objectOf.");
        var $ = G[U], W = X($);
        if (W !== "object")
          return new h("Invalid " + K + " `" + m + "` of type " + ("`" + W + "` supplied to `" + Y + "`, expected an object."));
        for (var T in $)
          if (r($, T)) {
            var J = k($, T, Y, K, m + "." + T, n);
            if (J instanceof Error)
              return J;
          }
        return null;
      }
      return d(A);
    }
    function V(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var A = 0; A < k.length; A++) {
        var G = k[A];
        if (typeof G != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ee(G) + " at index " + A + "."
          ), a;
      }
      function U(Y, K, m, $, W) {
        for (var T = [], J = 0; J < k.length; J++) {
          var te = k[J], N = te(Y, K, m, $, W, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && T.push(N.data.expectedType);
        }
        var se = T.length > 0 ? ", expected one of type [" + T.join(", ") + "]" : "";
        return new h("Invalid " + $ + " `" + W + "` supplied to " + ("`" + m + "`" + se + "."));
      }
      return d(U);
    }
    function M() {
      function k(A, G, U, Y, K) {
        return I(A[G]) ? null : new h("Invalid " + Y + " `" + K + "` supplied to " + ("`" + U + "`, expected a ReactNode."));
      }
      return d(k);
    }
    function q(k, A, G, U, Y) {
      return new h(
        (k || "React class") + ": " + A + " type `" + G + "." + U + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Y + "`."
      );
    }
    function _(k) {
      function A(G, U, Y, K, m) {
        var $ = G[U], W = X($);
        if (W !== "object")
          return new h("Invalid " + K + " `" + m + "` of type `" + W + "` " + ("supplied to `" + Y + "`, expected `object`."));
        for (var T in k) {
          var J = k[T];
          if (typeof J != "function")
            return q(Y, K, m, T, R(J));
          var te = J($, T, Y, K, m + "." + T, n);
          if (te)
            return te;
        }
        return null;
      }
      return d(A);
    }
    function j(k) {
      function A(G, U, Y, K, m) {
        var $ = G[U], W = X($);
        if (W !== "object")
          return new h("Invalid " + K + " `" + m + "` of type `" + W + "` " + ("supplied to `" + Y + "`, expected `object`."));
        var T = t({}, G[U], k);
        for (var J in T) {
          var te = k[J];
          if (r(k, J) && typeof te != "function")
            return q(Y, K, m, J, R(te));
          if (!te)
            return new h(
              "Invalid " + K + " `" + m + "` key `" + J + "` supplied to `" + Y + "`.\nBad object: " + JSON.stringify(G[U], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = te($, J, Y, K, m + "." + J, n);
          if (N)
            return N;
        }
        return null;
      }
      return d(A);
    }
    function I(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(I);
          if (k === null || s(k))
            return !0;
          var A = f(k);
          if (A) {
            var G = A.call(k), U;
            if (A !== k.entries) {
              for (; !(U = G.next()).done; )
                if (!I(U.value))
                  return !1;
            } else
              for (; !(U = G.next()).done; ) {
                var Y = U.value;
                if (Y && !I(Y[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function z(k, A) {
      return k === "symbol" ? !0 : A ? A["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && A instanceof Symbol : !1;
    }
    function X(k) {
      var A = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : z(A, k) ? "symbol" : A;
    }
    function R(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var A = X(k);
      if (A === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return A;
    }
    function ee(k) {
      var A = R(k);
      switch (A) {
        case "array":
        case "object":
          return "an " + A;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + A;
        default:
          return A;
      }
    }
    function re(k) {
      return !k.constructor || !k.constructor.name ? p : k.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, Qs;
}
var eu, qp;
function sL() {
  if (qp) return eu;
  qp = 1;
  var e = ac();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, eu = function() {
    function r(a, s, u, l, c, f) {
      if (f !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, eu;
}
if (process.env.NODE_ENV !== "production") {
  var uL = ry(), lL = !0;
  Ju.exports = aL()(uL.isElement, lL);
} else
  Ju.exports = sL()();
var ns = Ju.exports, rs = {};
Object.defineProperty(rs, "__esModule", {
  value: !0
});
var cL = ci, tu = fL(cL);
function fL(e) {
  return e && e.__esModule ? e : { default: e };
}
var dL = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return tu.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && tu.default.getHash() !== e && tu.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
rs.default = dL;
Object.defineProperty(si, "__esModule", {
  value: !0
});
var ji = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, pL = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), hL = Se, Zp = pi(hL), gL = ui, Ni = pi(gL), vL = yo, mL = pi(vL), yL = ns, Lt = pi(yL), bL = rs, dr = pi(bL);
function pi(e) {
  return e && e.__esModule ? e : { default: e };
}
function CL(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function wL(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function EL(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Gp = {
  to: Lt.default.string.isRequired,
  containerId: Lt.default.string,
  container: Lt.default.object,
  activeClass: Lt.default.string,
  activeStyle: Lt.default.object,
  spy: Lt.default.bool,
  horizontal: Lt.default.bool,
  smooth: Lt.default.oneOfType([Lt.default.bool, Lt.default.string]),
  offset: Lt.default.number,
  delay: Lt.default.number,
  isDynamic: Lt.default.bool,
  onClick: Lt.default.func,
  duration: Lt.default.oneOfType([Lt.default.number, Lt.default.func]),
  absolute: Lt.default.bool,
  onSetActive: Lt.default.func,
  onSetInactive: Lt.default.func,
  ignoreCancelEvents: Lt.default.bool,
  hashSpy: Lt.default.bool,
  saveHashHistory: Lt.default.bool,
  spyThrottle: Lt.default.number
};
si.default = function(e, t) {
  var n = t || mL.default, r = function(i) {
    EL(a, i);
    function a(s) {
      CL(this, a);
      var u = wL(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(u), u.state = {
        active: !1
      }, u;
    }
    return pL(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, u = this.props.container;
        return s && !u ? document.getElementById(s) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          Ni.default.isMounted(s) || Ni.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (dr.default.isMounted() || dr.default.mount(n), dr.default.mapContainer(this.props.to, s)), Ni.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Ni.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var u = {};
        this.state && this.state.active ? u = ji({}, this.props.style, this.props.activeStyle) : u = ji({}, this.props.style);
        var l = ji({}, this.props);
        for (var c in Gp)
          l.hasOwnProperty(c) && delete l[c];
        return l.className = s, l.style = u, l.onClick = this.handleClick, Zp.default.createElement(e, l);
      }
    }]), a;
  }(Zp.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, ji({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var u = i.getScrollSpyContainer();
      if (!(dr.default.isMounted() && !dr.default.isInitialized())) {
        var l = i.props.horizontal, c = i.props.to, f = null, p = void 0, g = void 0;
        if (l) {
          var v = 0, h = 0, d = 0;
          if (u.getBoundingClientRect) {
            var w = u.getBoundingClientRect();
            d = w.left;
          }
          if (!f || i.props.isDynamic) {
            if (f = n.get(c), !f)
              return;
            var L = f.getBoundingClientRect();
            v = L.left - d + a, h = v + L.width;
          }
          var D = a - i.props.offset;
          p = D >= Math.floor(v) && D < Math.floor(h), g = D < Math.floor(v) || D >= Math.floor(h);
        } else {
          var B = 0, b = 0, E = 0;
          if (u.getBoundingClientRect) {
            var O = u.getBoundingClientRect();
            E = O.top;
          }
          if (!f || i.props.isDynamic) {
            if (f = n.get(c), !f)
              return;
            var S = f.getBoundingClientRect();
            B = S.top - E + s, b = B + S.height;
          }
          var V = s - i.props.offset;
          p = V >= Math.floor(B) && V < Math.floor(b), g = V < Math.floor(B) || V >= Math.floor(b);
        }
        var M = n.getActiveLink();
        if (g) {
          if (c === M && n.setActiveLink(void 0), i.props.hashSpy && dr.default.getHash() === c) {
            var q = i.props.saveHashHistory, _ = q === void 0 ? !1 : q;
            dr.default.changeHash("", _);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, f));
        }
        if (p && (M !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var j = i.props.saveHashHistory, I = j === void 0 ? !1 : j;
          i.props.hashSpy && dr.default.changeHash(c, I), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, f));
        }
      }
    };
  };
  return r.propTypes = Gp, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(tc, "__esModule", {
  value: !0
});
var DL = Se, Kp = iy(DL), xL = si, LL = iy(xL);
function iy(e) {
  return e && e.__esModule ? e : { default: e };
}
function OL(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Yp(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function SL(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var kL = function(e) {
  SL(t, e);
  function t() {
    var n, r, o, i;
    OL(this, t);
    for (var a = arguments.length, s = Array(a), u = 0; u < a; u++)
      s[u] = arguments[u];
    return i = (r = (o = Yp(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return Kp.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), Yp(o, i);
  }
  return t;
}(Kp.default.Component);
tc.default = (0, LL.default)(kL);
var sc = {};
Object.defineProperty(sc, "__esModule", {
  value: !0
});
var ML = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), PL = Se, Xp = ay(PL), BL = si, TL = ay(BL);
function ay(e) {
  return e && e.__esModule ? e : { default: e };
}
function AL(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function FL(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function IL(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var RL = function(e) {
  IL(t, e);
  function t() {
    return AL(this, t), FL(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return ML(t, [{
    key: "render",
    value: function() {
      return Xp.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(Xp.default.Component);
sc.default = (0, TL.default)(RL);
var uc = {}, os = {};
Object.defineProperty(os, "__esModule", {
  value: !0
});
var _L = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, jL = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), NL = Se, Jp = is(NL), zL = Ol;
is(zL);
var $L = yo, Qp = is($L), UL = ns, eh = is(UL);
function is(e) {
  return e && e.__esModule ? e : { default: e };
}
function WL(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function HL(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function VL(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
os.default = function(e) {
  var t = function(n) {
    VL(r, n);
    function r(o) {
      WL(this, r);
      var i = HL(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return jL(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        Qp.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        Qp.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return Jp.default.createElement(e, _L({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(Jp.default.Component);
  return t.propTypes = {
    name: eh.default.string,
    id: eh.default.string
  }, t;
};
Object.defineProperty(uc, "__esModule", {
  value: !0
});
var th = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, qL = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ZL = Se, nh = lc(ZL), GL = os, KL = lc(GL), YL = ns, rh = lc(YL);
function lc(e) {
  return e && e.__esModule ? e : { default: e };
}
function XL(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function JL(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function QL(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var sy = function(e) {
  QL(t, e);
  function t() {
    return XL(this, t), JL(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return qL(t, [{
    key: "render",
    value: function() {
      var n = this, r = th({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, nh.default.createElement(
        "div",
        th({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(nh.default.Component);
sy.propTypes = {
  name: rh.default.string,
  id: rh.default.string
};
uc.default = (0, KL.default)(sy);
var nu = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, oh = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function ih(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ah(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function sh(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var zi = Se, zr = ui, ru = yo, Tt = ns, pr = rs, uh = {
  to: Tt.string.isRequired,
  containerId: Tt.string,
  container: Tt.object,
  activeClass: Tt.string,
  spy: Tt.bool,
  smooth: Tt.oneOfType([Tt.bool, Tt.string]),
  offset: Tt.number,
  delay: Tt.number,
  isDynamic: Tt.bool,
  onClick: Tt.func,
  duration: Tt.oneOfType([Tt.number, Tt.func]),
  absolute: Tt.bool,
  onSetActive: Tt.func,
  onSetInactive: Tt.func,
  ignoreCancelEvents: Tt.bool,
  hashSpy: Tt.bool,
  spyThrottle: Tt.number
}, eO = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || ru, r = function(i) {
      sh(a, i);
      function a(s) {
        ih(this, a);
        var u = ah(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(u), u.state = {
          active: !1
        }, u;
      }
      return oh(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, u = this.props.container;
          return s ? document.getElementById(s) : u && u.nodeType ? u : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            zr.isMounted(s) || zr.mount(s, this.props.spyThrottle), this.props.hashSpy && (pr.isMounted() || pr.mount(n), pr.mapContainer(this.props.to, s)), this.props.spy && zr.addStateHandler(this.stateHandler), zr.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          zr.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var u = nu({}, this.props);
          for (var l in uh)
            u.hasOwnProperty(l) && delete u[l];
          return u.className = s, u.onClick = this.handleClick, zi.createElement(e, u);
        }
      }]), a;
    }(zi.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, nu({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(pr.isMounted() && !pr.isInitialized())) {
          var u = i.props.to, l = null, c = 0, f = 0, p = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            p = g.top;
          }
          if (!l || i.props.isDynamic) {
            if (l = n.get(u), !l)
              return;
            var v = l.getBoundingClientRect();
            c = v.top - p + a, f = c + v.height;
          }
          var h = a - i.props.offset, d = h >= Math.floor(c) && h < Math.floor(f), w = h < Math.floor(c) || h >= Math.floor(f), L = n.getActiveLink();
          if (w)
            return u === L && n.setActiveLink(void 0), i.props.hashSpy && pr.getHash() === u && pr.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), zr.updateStates();
          if (d && L !== u)
            return n.setActiveLink(u), i.props.hashSpy && pr.changeHash(u), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(u)), zr.updateStates();
        }
      };
    };
    return r.propTypes = uh, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      sh(r, n);
      function r(o) {
        ih(this, r);
        var i = ah(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return oh(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          ru.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          ru.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return zi.createElement(e, nu({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(zi.Component);
    return t.propTypes = {
      name: Tt.string,
      id: Tt.string
    }, t;
  }
}, tO = eO;
Object.defineProperty(It, "__esModule", {
  value: !0
});
It.Helpers = It.ScrollElement = It.ScrollLink = It.animateScroll = It.scrollSpy = It.Events = It.scroller = It.Element = It.Button = It.Link = void 0;
var nO = tc, uy = Gn(nO), rO = sc, ly = Gn(rO), oO = uc, cy = Gn(oO), iO = yo, fy = Gn(iO), aO = fi, dy = Gn(aO), sO = ui, py = Gn(sO), uO = Qa, hy = Gn(uO), lO = si, gy = Gn(lO), cO = os, vy = Gn(cO), fO = tO, my = Gn(fO);
function Gn(e) {
  return e && e.__esModule ? e : { default: e };
}
It.Link = uy.default;
It.Button = ly.default;
It.Element = cy.default;
It.scroller = fy.default;
It.Events = dy.default;
It.scrollSpy = py.default;
It.animateScroll = hy.default;
It.ScrollLink = gy.default;
It.ScrollElement = vy.default;
It.Helpers = my.default;
It.default = { Link: uy.default, Button: ly.default, Element: cy.default, scroller: fy.default, Events: dy.default, scrollSpy: py.default, animateScroll: hy.default, ScrollLink: gy.default, ScrollElement: vy.default, Helpers: my.default };
ht({});
ht({});
ht({});
let dO = { data: "" }, pO = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || dO, hO = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, gO = /\/\*[^]*?\*\/|  +/g, lh = /\n+/g, Dr = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Dr(a, i) : i + "{" + Dr(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Dr(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (u) => /&/.test(u) ? u.replace(/&/g, s) : s ? s + " " + u : u)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Dr.p ? Dr.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, tr = {}, yy = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + yy(e[n]);
    return t;
  }
  return e;
}, vO = (e, t, n, r, o) => {
  let i = yy(e), a = tr[i] || (tr[i] = ((u) => {
    let l = 0, c = 11;
    for (; l < u.length; ) c = 101 * c + u.charCodeAt(l++) >>> 0;
    return "go" + c;
  })(i));
  if (!tr[a]) {
    let u = i !== e ? e : ((l) => {
      let c, f, p = [{}];
      for (; c = hO.exec(l.replace(gO, "")); ) c[4] ? p.shift() : c[3] ? (f = c[3].replace(lh, " ").trim(), p.unshift(p[0][f] = p[0][f] || {})) : p[0][c[1]] = c[2].replace(lh, " ").trim();
      return p[0];
    })(e);
    tr[a] = Dr(o ? { ["@keyframes " + a]: u } : u, n ? "" : "." + a);
  }
  let s = n && tr.g ? tr.g : null;
  return n && (tr.g = tr[a]), ((u, l, c, f) => {
    f ? l.data = l.data.replace(f, u) : l.data.indexOf(u) === -1 && (l.data = c ? u + l.data : l.data + u);
  })(tr[a], t, r, s), a;
}, mO = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), u = s && s.props && s.props.className || /^go/.test(s) && s;
    a = u ? "." + u : s && typeof s == "object" ? s.props ? "" : Dr(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function as(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return vO(n.unshift ? n.raw ? mO(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, pO(t.target), t.g, t.o, t.k);
}
let by, Qu, el;
as.bind({ g: 1 });
let ar = as.bind({ k: 1 });
function yO(e, t, n, r) {
  Dr.p = t, by = e, Qu = n, el = r;
}
function Ar(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), u = s.className || o.className;
      n.p = Object.assign({ theme: Qu && Qu() }, s), n.o = / *go\d+/.test(u), s.className = as.apply(n, r) + (u ? " " + u : ""), t && (s.ref = a);
      let l = e;
      return e[0] && (l = s.as || e, delete s.as), el && l[0] && el(s), by(l, s);
    }
    return t ? t(o) : o;
  };
}
var bO = (e) => typeof e == "function", CO = (e, t) => bO(e) ? e(t) : e, wO = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), EO = ar`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, DO = ar`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, xO = ar`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, LO = Ar("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${EO} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${DO} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${xO} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, OO = ar`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, SO = Ar("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${OO} 1s linear infinite;
`, kO = ar`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, MO = ar`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, PO = Ar("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${kO} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${MO} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, BO = Ar("div")`
  position: absolute;
`, TO = Ar("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, AO = ar`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, FO = Ar("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${AO} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, IO = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? ut.createElement(FO, null, t) : t : n === "blank" ? null : ut.createElement(TO, null, ut.createElement(SO, { ...r }), n !== "loading" && ut.createElement(BO, null, n === "error" ? ut.createElement(LO, { ...r }) : ut.createElement(PO, { ...r })));
}, RO = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, _O = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, jO = "0%{opacity:0;} 100%{opacity:1;}", NO = "0%{opacity:1;} 100%{opacity:0;}", zO = Ar("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, $O = Ar("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, UO = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = wO() ? [jO, NO] : [RO(n), _O(n)];
  return { animation: t ? `${ar(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ar(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
ut.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? UO(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = ut.createElement(IO, { toast: e }), a = ut.createElement($O, { ...e.ariaProps }, CO(e.message, e));
  return ut.createElement(zO, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : ut.createElement(ut.Fragment, null, i, a));
});
yO(ut.createElement);
as`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function WO(e) {
  const {
    filePath: t,
    isLoading: n,
    acceptImage: r,
    changeImageButtonText: o,
    handleSelectFile: i,
    reSendImage: a
  } = e;
  function s() {
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (l) => {
      var f;
      const c = (f = l.target.files) == null ? void 0 : f[0];
      c && i(c);
    }, u.click();
  }
  return /* @__PURE__ */ F.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url(${t})` },
      children: [
        a && /* @__PURE__ */ F.jsx(ox, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ F.jsx(
          zw,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: n,
            onClick: a,
            icon: yb
          }
        ) }),
        /* @__PURE__ */ F.jsx(
          gm,
          {
            isLoading: n,
            onClick: s,
            variant: "outline",
            size: "sm",
            type: "button",
            children: o
          }
        )
      ]
    }
  );
}
function HO(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ F.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ F.jsx(F.Fragment, {});
}
function VO(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ F.jsx("strong", { className: o.trim(), children: t });
}
function qO(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i
  } = e;
  function a(u) {
    u.preventDefault();
    const l = u.dataTransfer.files[0];
    l && o(l);
  }
  function s() {
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (l) => {
      var f;
      const c = (f = l.target.files) == null ? void 0 : f[0];
      c && o(c);
    }, u.click();
  }
  return /* @__PURE__ */ F.jsxs("div", { onDrop: a, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ F.jsx(
      gm,
      {
        isLoading: n,
        onClick: s,
        variant: "ghost",
        size: "sm",
        type: "button",
        children: i
      }
    ),
    /* @__PURE__ */ F.jsx("p", { children: t })
  ] });
}
function O_(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: a = "file",
    method: s = "POST",
    acceptImage: u = "image/*",
    fileResponseName: l = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: f = "Selecionar imagem",
    dropImageText: p = "Ou arraste e solte a imagem aqui",
    onUpload: g
  } = e, h = _w()[t], [d, w] = P(n), [L, D] = P(""), [B, b] = P(null), [E, O] = P(n), [S, V] = P(!1);
  async function M(X) {
    V(!0), b(X);
    const R = new FormData();
    R.append(a, X), await fetch(i, { method: s, body: R }).then(async (ee) => await ee.json()).then((ee) => {
      ee != null && ee.error ? D(ee.error) : w(ee == null ? void 0 : ee[l]), g && g(ee == null ? void 0 : ee[l]);
    }).catch((ee) => {
      console.error(ee), D("Erro ao enviar imagem");
    }).finally(() => V(!1));
  }
  function q(X) {
    O(URL.createObjectURL(X)), M(X);
  }
  const _ = h || L, z = `arkynImageUpload ${_ ? "hasError" : "noHasError"} ${E ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ F.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ F.jsx(VO, { label: r, showAsterisk: o }),
    /* @__PURE__ */ F.jsxs("div", { className: z, children: [
      /* @__PURE__ */ F.jsx("input", { type: "hidden", name: t, value: d || "" }),
      !E && /* @__PURE__ */ F.jsx(
        qO,
        {
          isLoading: S,
          acceptImage: u,
          dropImageText: p,
          handleSelectFile: q,
          selectImageButtonText: f
        }
      ),
      E && /* @__PURE__ */ F.jsx(
        WO,
        {
          isLoading: S,
          acceptImage: u,
          filePath: E,
          handleSelectFile: q,
          changeImageButtonText: c,
          reSendImage: _ && B ? () => M(B) : void 0
        }
      )
    ] }),
    _ && /* @__PURE__ */ F.jsx(HO, { error: _ })
  ] });
}
const Cy = ht({});
function ZO() {
  return Ae(Cy);
}
function S_(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: a = "",
    ...s
  } = e, [u, l] = P(t || ""), { inputRef: c, id: f } = Pn();
  function p(v) {
    l(v), o && o(v);
  }
  const g = `arkynRadioGroup ${i} ${a}`;
  return /* @__PURE__ */ F.jsxs(
    Cy.Provider,
    {
      value: { onChange: p, value: r || u, size: i },
      children: [
        /* @__PURE__ */ F.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: f,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || u
          }
        ),
        /* @__PURE__ */ F.jsx("div", { className: g.trim(), ...s })
      ]
    }
  );
}
function k_(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...a
  } = e, { onChange: s, size: u, value: l } = ZO(), { error: c } = Pn(), h = `arkynRadioBox ${n || u} ${l === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ F.jsxs("label", { className: h.trim(), children: [
    /* @__PURE__ */ F.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => s(t),
        onFocus: () => s(t),
        ...a
      }
    ),
    o
  ] });
}
var fr = {};
Object.defineProperty(fr, "__esModule", {
  value: !0
});
var GO = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), ou = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, wy = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: GO ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, cc = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var $i = 1; $i < 20; $i++)
  cc["f" + $i] = 111 + $i;
function ss(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Ey(a, t);
  }), o = function(s) {
    return r.some(function(u) {
      return Dy(u, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function KO(e, t) {
  return ss(e, t);
}
function YO(e, t) {
  return ss(e, { byKey: !0 }, t);
}
function Ey(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in ou)
    r[ou[a]] = !1;
  var s = !0, u = !1, l = void 0;
  try {
    for (var c = o[Symbol.iterator](), f; !(s = (f = c.next()).done); s = !0) {
      var p = f.value, g = p.endsWith("?") && p.length > 1;
      g && (p = p.slice(0, -1));
      var v = fc(p), h = ou[v];
      if (p.length > 1 && !h && !wy[p] && !cc[v])
        throw new TypeError('Unknown modifier: "' + p + '"');
      (i === 1 || !h) && (n ? r.key = v : r.which = xy(p)), h && (r[h] = g ? null : !0);
    }
  } catch (d) {
    u = !0, l = d;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (u)
        throw l;
    }
  }
  return r;
}
function Dy(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function xy(e) {
  e = fc(e);
  var t = cc[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function fc(e) {
  return e = e.toLowerCase(), e = wy[e] || e, e;
}
var XO = fr.default = ss, iu = fr.isHotkey = ss;
fr.isCodeHotkey = KO;
fr.isKeyHotkey = YO;
fr.parseHotkey = Ey;
fr.compareHotkey = Dy;
fr.toKeyCode = xy;
fr.toKeyName = fc;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function ch(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Xt(e) {
  var t, n;
  return ch(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(ch(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Ly = Symbol.for("immer-nothing"), fh = Symbol.for("immer-draftable"), kn = Symbol.for("immer-state"), JO = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ln(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = JO[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var ho = Object.getPrototypeOf;
function oo(e) {
  return !!e && !!e[kn];
}
function io(e) {
  var t;
  return e ? Oy(e) || Array.isArray(e) || !!e[fh] || !!((t = e.constructor) != null && t[fh]) || ls(e) || cs(e) : !1;
}
var QO = Object.prototype.constructor.toString();
function Oy(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = ho(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === QO;
}
function Oa(e, t) {
  us(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function us(e) {
  const t = e[kn];
  return t ? t.type_ : Array.isArray(e) ? 1 : ls(e) ? 2 : cs(e) ? 3 : 0;
}
function tl(e, t) {
  return us(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Sy(e, t, n) {
  const r = us(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function eS(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function ls(e) {
  return e instanceof Map;
}
function cs(e) {
  return e instanceof Set;
}
function Hr(e) {
  return e.copy_ || e.base_;
}
function nl(e, t) {
  if (ls(e))
    return new Map(e);
  if (cs(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Oy(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[kn];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(ho(e), r);
  } else {
    const r = ho(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function dc(e, t = !1) {
  return fs(e) || oo(e) || !io(e) || (us(e) > 1 && (e.set = e.add = e.clear = e.delete = tS), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => dc(r, !0))), e;
}
function tS() {
  ln(2);
}
function fs(e) {
  return Object.isFrozen(e);
}
var nS = {};
function ao(e) {
  const t = nS[e];
  return t || ln(0, e), t;
}
var ei;
function ky() {
  return ei;
}
function rS(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function dh(e, t) {
  t && (ao("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function rl(e) {
  ol(e), e.drafts_.forEach(oS), e.drafts_ = null;
}
function ol(e) {
  e === ei && (ei = e.parent_);
}
function ph(e) {
  return ei = rS(ei, e);
}
function oS(e) {
  const t = e[kn];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function hh(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[kn].modified_ && (rl(t), ln(4)), io(e) && (e = Sa(t, e), t.parent_ || ka(t, e)), t.patches_ && ao("Patches").generateReplacementPatches_(
    n[kn].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Sa(t, n, []), rl(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== Ly ? e : void 0;
}
function Sa(e, t, n) {
  if (fs(t))
    return t;
  const r = t[kn];
  if (!r)
    return Oa(
      t,
      (o, i) => gh(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return ka(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Oa(
      i,
      (s, u) => gh(e, r, o, s, u, n, a)
    ), ka(e, o, !1), n && e.patches_ && ao("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function gh(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ln(5), oo(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !tl(t.assigned_, r) ? i.concat(r) : void 0, u = Sa(e, o, s);
    if (Sy(n, r, u), oo(u))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (io(o) && !fs(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Sa(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && ka(e, o);
  }
}
function ka(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && dc(t, n);
}
function iS(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : ky(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = pc;
  n && (o = [r], i = ti);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var pc = {
  get(e, t) {
    if (t === kn)
      return e;
    const n = Hr(e);
    if (!tl(n, t))
      return aS(e, n, t);
    const r = n[t];
    return e.finalized_ || !io(r) ? r : r === au(e.base_, t) ? (su(e), e.copy_[t] = al(r, e)) : r;
  },
  has(e, t) {
    return t in Hr(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Hr(e));
  },
  set(e, t, n) {
    const r = My(Hr(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = au(Hr(e), t), i = o == null ? void 0 : o[kn];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (eS(n, o) && (n !== void 0 || tl(e.base_, t)))
        return !0;
      su(e), il(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return au(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, su(e), il(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Hr(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ln(11);
  },
  getPrototypeOf(e) {
    return ho(e.base_);
  },
  setPrototypeOf() {
    ln(12);
  }
}, ti = {};
Oa(pc, (e, t) => {
  ti[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
ti.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ln(13), ti.set.call(this, e, t, void 0);
};
ti.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ln(14), pc.set.call(this, e[0], t, n, e[0]);
};
function au(e, t) {
  const n = e[kn];
  return (n ? Hr(n) : e)[t];
}
function aS(e, t, n) {
  var o;
  const r = My(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function My(e, t) {
  if (!(t in e))
    return;
  let n = ho(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = ho(n);
  }
}
function il(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && il(e.parent_));
}
function su(e) {
  e.copy_ || (e.copy_ = nl(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var sS = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(u = i, ...l) {
          return a.produce(u, (c) => n.call(this, c, ...l));
        };
      }
      typeof n != "function" && ln(6), r !== void 0 && typeof r != "function" && ln(7);
      let o;
      if (io(t)) {
        const i = ph(this), a = al(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? rl(i) : ol(i);
        }
        return dh(i, r), hh(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === Ly && (o = void 0), this.autoFreeze_ && dc(o, !0), r) {
          const i = [], a = [];
          ao("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ln(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (a, ...s) => this.produceWithPatches(a, (u) => t(u, ...s));
      let r, o;
      return [this.produce(t, n, (a, s) => {
        r = a, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    io(e) || ln(8), oo(e) && (e = uS(e));
    const t = ph(this), n = al(e, void 0);
    return n[kn].isManual_ = !0, ol(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[kn];
    (!n || !n.isManual_) && ln(9);
    const { scope_: r } = n;
    return dh(r, t), hh(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = ao("Patches").applyPatches_;
    return oo(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function al(e, t) {
  const n = ls(e) ? ao("MapSet").proxyMap_(e, t) : cs(e) ? ao("MapSet").proxySet_(e, t) : iS(e, t);
  return (t ? t.scope_ : ky()).drafts_.push(n), n;
}
function uS(e) {
  return oo(e) || ln(10, e), Py(e);
}
function Py(e) {
  if (!io(e) || fs(e))
    return e;
  const t = e[kn];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = nl(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = nl(e, !0);
  return Oa(n, (r, o) => {
    Sy(n, r, Py(o));
  }), t && (t.finalized_ = !1), n;
}
var Mn = new sS(), hc = Mn.produce;
Mn.produceWithPatches.bind(
  Mn
);
Mn.setAutoFreeze.bind(Mn);
Mn.setUseStrictShallowCopy.bind(Mn);
Mn.applyPatches.bind(Mn);
var vh = Mn.createDraft.bind(Mn), mh = Mn.finishDraft.bind(Mn), lS = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = H.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, cS = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = qe.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, fS = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ne.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Ma = /* @__PURE__ */ new WeakMap(), Pa = /* @__PURE__ */ new WeakMap(), Uo = /* @__PURE__ */ new WeakMap(), By = /* @__PURE__ */ new WeakMap(), yh = /* @__PURE__ */ new WeakMap(), bh = /* @__PURE__ */ new WeakMap(), Ch = /* @__PURE__ */ new WeakMap(), H = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = H.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return H.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return H.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return H.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return H.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && H.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return H.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && H.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && H.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && H.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && H.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && H.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!H.isAncestor(t, e) && !H.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (H.equals(i, r) || H.endsBefore(i, r) || H.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (H.equals(a, r) || H.isAncestor(a, r))
          return null;
        H.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: u
        } = t;
        H.equals(s, r) || H.endsBefore(s, r) ? r[s.length - 1] -= 1 : H.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += u);
        break;
      }
      case "split_node": {
        var {
          path: l,
          position: c
        } = t;
        if (H.equals(l, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else H.endsBefore(l, r) ? r[l.length - 1] += 1 : H.isAncestor(l, r) && e[l.length] >= c && (r[l.length - 1] += 1, r[l.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: f,
          newPath: p
        } = t;
        if (H.equals(f, p))
          return r;
        if (H.isAncestor(f, r) || H.equals(f, r)) {
          var g = p.slice();
          return H.endsBefore(f, p) && f.length < p.length && (g[f.length - 1] -= 1), g.concat(r.slice(f.length));
        } else H.isSibling(f, p) && (H.isAncestor(p, r) || H.equals(p, r)) ? H.endsBefore(f, r) ? r[f.length - 1] -= 1 : r[f.length - 1] += 1 : H.endsBefore(p, r) || H.equals(p, r) || H.isAncestor(p, r) ? (H.endsBefore(f, r) && (r[f.length - 1] -= 1), r[p.length - 1] += 1) : H.endsBefore(f, r) && (H.equals(p, r) && (r[p.length - 1] += 1), r[f.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function ni(e) {
  "@babel/helpers - typeof";
  return ni = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ni(e);
}
function dS(e, t) {
  if (ni(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (ni(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function pS(e) {
  var t = dS(e, "string");
  return ni(t) === "symbol" ? t : String(t);
}
function on(e, t, n) {
  return t = pS(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function wh(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Bo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wh(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wh(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hS = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = ve.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, u] of ne.points(t))
          t[u] = qe.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: l,
        offset: c,
        text: f
      } = n;
      if (f.length === 0) break;
      var p = ve.leaf(e, l), g = p.text.slice(0, c), v = p.text.slice(c);
      if (p.text = g + f + v, t)
        for (var [h, d] of ne.points(t))
          t[d] = qe.transform(h, n);
      break;
    }
    case "merge_node": {
      var {
        path: w
      } = n, L = ve.get(e, w), D = H.previous(w), B = ve.get(e, D), b = ve.parent(e, w), E = w[w.length - 1];
      if (Oe.isText(L) && Oe.isText(B))
        B.text += L.text;
      else if (!Oe.isText(L) && !Oe.isText(B))
        B.children.push(...L.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(w, "] to nodes of different interfaces: ").concat(qt.stringify(L), " ").concat(qt.stringify(B)));
      if (b.children.splice(E, 1), t)
        for (var [O, S] of ne.points(t))
          t[S] = qe.transform(O, n);
      break;
    }
    case "move_node": {
      var {
        path: V,
        newPath: M
      } = n;
      if (H.isAncestor(V, M))
        throw new Error("Cannot move a path [".concat(V, "] to new path [").concat(M, "] because the destination is inside itself."));
      var q = ve.get(e, V), _ = ve.parent(e, V), j = V[V.length - 1];
      _.children.splice(j, 1);
      var I = H.transform(V, n), z = ve.get(e, H.parent(I)), X = I[I.length - 1];
      if (z.children.splice(X, 0, q), t)
        for (var [R, ee] of ne.points(t))
          t[ee] = qe.transform(R, n);
      break;
    }
    case "remove_node": {
      var {
        path: re
      } = n, k = re[re.length - 1], A = ve.parent(e, re);
      if (A.children.splice(k, 1), t)
        for (var [G, U] of ne.points(t)) {
          var Y = qe.transform(G, n);
          if (t != null && Y != null)
            t[U] = Y;
          else {
            var K = void 0, m = void 0;
            for (var [$, W] of ve.texts(e))
              if (H.compare(W, re) === -1)
                K = [$, W];
              else {
                m = [$, W];
                break;
              }
            var T = !1;
            K && m && (H.equals(m[1], re) ? T = !H.hasPrevious(m[1]) : T = H.common(K[1], re).length < H.common(m[1], re).length), K && !T ? (G.path = K[1], G.offset = K[0].text.length) : m ? (G.path = m[1], G.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: J,
        offset: te,
        text: N
      } = n;
      if (N.length === 0) break;
      var se = ve.leaf(e, J), ue = se.text.slice(0, te), de = se.text.slice(te + N.length);
      if (se.text = ue + de, t)
        for (var [ge, Ce] of ne.points(t))
          t[Ce] = qe.transform(ge, n);
      break;
    }
    case "set_node": {
      var {
        path: me,
        properties: ye,
        newProperties: ce
      } = n;
      if (me.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Me = ve.get(e, me);
      for (var ie in ce) {
        if (ie === "children" || ie === "text")
          throw new Error('Cannot set the "'.concat(ie, '" property of nodes!'));
        var Re = ce[ie];
        Re == null ? delete Me[ie] : Me[ie] = Re;
      }
      for (var ae in ye)
        ce.hasOwnProperty(ae) || delete Me[ae];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Le
      } = n;
      if (Le == null)
        t = Le;
      else {
        if (t == null) {
          if (!ne.isRange(Le))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(qt.stringify(Le), " when there is no current selection."));
          t = Bo({}, Le);
        }
        for (var Fe in Le) {
          var ze = Le[Fe];
          if (ze == null) {
            if (Fe === "anchor" || Fe === "focus")
              throw new Error('Cannot remove the "'.concat(Fe, '" selection property'));
            delete t[Fe];
          } else
            t[Fe] = ze;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ye,
        position: we,
        properties: Ct
      } = n;
      if (Ye.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ye, "] because the root node cannot be split."));
      var ot = ve.get(e, Ye), Jt = ve.parent(e, Ye), _t = Ye[Ye.length - 1], $t;
      if (Oe.isText(ot)) {
        var dn = ot.text.slice(0, we), pn = ot.text.slice(we);
        ot.text = dn, $t = Bo(Bo({}, Ct), {}, {
          text: pn
        });
      } else {
        var hn = ot.children.slice(0, we), gn = ot.children.slice(we);
        ot.children = hn, $t = Bo(Bo({}, Ct), {}, {
          children: gn
        });
      }
      if (Jt.children.splice(_t + 1, 0, $t), t)
        for (var [jt, Qt] of ne.points(t))
          t[Qt] = qe.transform(jt, n);
      break;
    }
  }
  return t;
}, gS = {
  transform(e, t) {
    e.children = vh(e.children);
    var n = e.selection && vh(e.selection);
    try {
      n = hS(e, n, t);
    } finally {
      e.children = mh(e.children), n ? e.selection = oo(n) ? mh(n) : n : e.selection = null;
    }
  }
}, vS = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, mS = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Ty = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Xt(r) && Xt(o)) {
      if (!Ty(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function yS(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function sr(e, t) {
  if (e == null) return {};
  var n = yS(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var bS = ["anchor", "focus"];
function Eh(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function CS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Eh(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Eh(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ne = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return ne.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = ne.edges(e);
    return t;
  },
  equals(e, t) {
    return qe.equals(e.anchor, t.anchor) && qe.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (ne.isRange(t)) {
      if (ne.includes(e, t.anchor) || ne.includes(e, t.focus))
        return !0;
      var [n, r] = ne.edges(e), [o, i] = ne.edges(t);
      return qe.isBefore(n, o) && qe.isAfter(r, i);
    }
    var [a, s] = ne.edges(e), u = !1, l = !1;
    return qe.isPoint(t) ? (u = qe.compare(t, a) >= 0, l = qe.compare(t, s) <= 0) : (u = H.compare(t, a.path) >= 0, l = H.compare(t, s.path) <= 0), u && l;
  },
  intersection(e, t) {
    var n = sr(e, bS), [r, o] = ne.edges(e), [i, a] = ne.edges(t), s = qe.isBefore(r, i) ? i : r, u = qe.isBefore(o, a) ? o : a;
    return qe.isBefore(u, s) ? null : CS({
      anchor: s,
      focus: u
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return qe.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return qe.equals(t, n);
  },
  isExpanded(e) {
    return !ne.isCollapsed(e);
  },
  isForward(e) {
    return !ne.isBackward(e);
  },
  isRange(e) {
    return Xt(e) && qe.isPoint(e.anchor) && qe.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = ne.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return hc(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = ne.isCollapsed(r);
        ne.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? ne.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var u = qe.transform(r.anchor, t, {
        affinity: i
      }), l = qe.transform(r.focus, t, {
        affinity: a
      });
      if (!u || !l)
        return null;
      r.anchor = u, r.focus = l;
    });
  }
}, Dh = (e) => Xt(e) && ve.isNodeList(e.children) && !x.isEditor(e), xe = {
  isAncestor(e) {
    return Xt(e) && ve.isNodeList(e.children);
  },
  isElement: Dh,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => xe.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return Dh(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, wS = ["children"], ES = ["text"], xh = /* @__PURE__ */ new WeakMap(), ve = {
  ancestor(e, t) {
    var n = ve.get(e, t);
    if (Oe.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(qt.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of H.ancestors(t, n)) {
        var o = ve.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Oe.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(qt.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(qt.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = ve.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = ve.child(o, a), u = t.concat(a);
        yield [s, u], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = H.common(t, n), o = ve.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = ve.get(e, t);
    if (x.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(qt.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ve.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ve.nodes(e, t))
        xe.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (xe.isAncestor(e)) {
      var t = sr(e, wS);
      return t;
    } else {
      var t = sr(e, ES);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = ve.get(e, n); r && !(Oe.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Oe.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(qt.stringify(e)));
    var n = hc({
      children: e.children
    }, (r) => {
      var [o, i] = ne.edges(t), a = ve.nodes(r, {
        reverse: !0,
        pass: (p) => {
          var [, g] = p;
          return !ne.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!ne.includes(t, s)) {
          var u = ve.parent(r, s), l = s[s.length - 1];
          u.children.splice(l, 1);
        }
        if (H.equals(s, i.path)) {
          var c = ve.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (H.equals(s, o.path)) {
          var f = ve.leaf(r, s);
          f.text = f.text.slice(o.offset);
        }
      }
      x.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Oe.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(qt.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Oe.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Oe.isText(e) || xe.isElement(e) || x.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = xh.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => ve.isNode(r));
    return xh.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = ve.get(e, n); r && !(Oe.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = ve.get(e, t);
    if (!Oe.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(qt.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of H.levels(t, n)) {
        var o = ve.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return xe.isElement(e) && xe.isElementProps(t) && xe.matches(e, t) || Oe.isText(e) && Oe.isTextProps(t) && Oe.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], u = e; !(i && (r ? H.isBefore(s, i) : H.isAfter(s, i))); ) {
        if (a.has(u) || (yield [u, s]), !a.has(u) && !Oe.isText(u) && u.children.length !== 0 && (n == null || n([u, s]) === !1)) {
          a.add(u);
          var l = r ? u.children.length - 1 : 0;
          H.isAncestor(s, o) && (l = o[s.length]), s = s.concat(l), u = ve.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = H.next(s);
          if (ve.has(e, c)) {
            s = c, u = ve.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var f = H.previous(s);
          s = f, u = ve.get(e, s);
          continue;
        }
        s = H.parent(s), u = ve.get(e, s), a.add(u);
      }
    }();
  },
  parent(e, t) {
    var n = H.parent(t), r = ve.get(e, n);
    if (Oe.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Oe.isText(e) ? e.text : e.children.map(ve.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ve.nodes(e, t))
        Oe.isText(n) && (yield [n, r]);
    }();
  }
};
function Lh(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ot(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Lh(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Lh(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Lr = {
  isNodeOperation(e) {
    return Lr.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Xt(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return H.isPath(e.path) && ve.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && H.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && H.isPath(e.path) && Xt(e.properties);
      case "move_node":
        return H.isPath(e.path) && H.isPath(e.newPath);
      case "remove_node":
        return H.isPath(e.path) && ve.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && H.isPath(e.path);
      case "set_node":
        return H.isPath(e.path) && Xt(e.properties) && Xt(e.newProperties);
      case "set_selection":
        return e.properties === null && ne.isRange(e.newProperties) || e.newProperties === null && ne.isRange(e.properties) || Xt(e.properties) && Xt(e.newProperties);
      case "split_node":
        return H.isPath(e.path) && typeof e.position == "number" && Xt(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Lr.isOperation(t));
  },
  isSelectionOperation(e) {
    return Lr.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Lr.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Ot(Ot({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Ot(Ot({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Ot(Ot({}, e), {}, {
          type: "split_node",
          path: H.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (H.equals(t, n))
          return e;
        if (H.isSibling(n, t))
          return Ot(Ot({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = H.transform(n, e), o = H.transform(H.next(n), e);
        return Ot(Ot({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Ot(Ot({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Ot(Ot({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Ot(Ot({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: u
        } = e;
        return s == null ? Ot(Ot({}, e), {}, {
          properties: u,
          newProperties: null
        }) : u == null ? Ot(Ot({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Ot(Ot({}, e), {}, {
          properties: u,
          newProperties: s
        });
      }
      case "split_node":
        return Ot(Ot({}, e), {}, {
          type: "merge_node",
          path: H.next(e.path)
        });
    }
  }
}, Oh = /* @__PURE__ */ new WeakMap(), DS = (e) => {
  var t = Oh.get(e);
  if (t !== void 0)
    return t;
  if (!Xt(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Xt(e.marks)) && (e.selection === null || ne.isRange(e.selection)) && ve.isNodeList(e.children) && Lr.isOperationList(e.operations);
  return Oh.set(e, n), n;
}, x = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return DS(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, xS = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(H.isPath);
  }
};
function Sh(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Sh(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sh(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qe = {
  compare(e, t) {
    var n = H.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return qe.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return qe.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && H.equals(e.path, t.path);
  },
  isPoint(e) {
    return Xt(e) && typeof e.offset == "number" && H.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return hc(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = H.transform(i, t, n);
          break;
        }
        case "insert_text": {
          H.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          H.equals(t.path, i) && (r.offset += t.position), r.path = H.transform(i, t, n);
          break;
        }
        case "remove_text": {
          H.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (H.equals(t.path, i) || H.isAncestor(t.path, i))
            return null;
          r.path = H.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (H.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = H.transform(i, t, kh(kh({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = H.transform(i, t, n);
          break;
        }
      }
    });
  }
}, Mh = void 0, qt = {
  setScrubber(e) {
    Mh = e;
  },
  stringify(e) {
    return JSON.stringify(e, Mh);
  }
}, LS = ["text"], OS = ["anchor", "focus"];
function Ph(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ph(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ph(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Oe = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = sr(i, LS);
      return a;
    }
    return Ty(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Xt(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Oe.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [nr({}, e)];
    for (var r of t) {
      var o = sr(r, OS), [i, a] = ne.edges(r), s = [], u = 0, l = i.offset, c = a.offset;
      for (var f of n) {
        var {
          length: p
        } = f.text, g = u;
        if (u += p, l <= g && u <= c) {
          Object.assign(f, o), s.push(f);
          continue;
        }
        if (l !== c && (l === u || c === g) || l > u || c < g || c === g && g !== 0) {
          s.push(f);
          continue;
        }
        var v = f, h = void 0, d = void 0;
        if (c < u) {
          var w = c - g;
          d = nr(nr({}, v), {}, {
            text: v.text.slice(w)
          }), v = nr(nr({}, v), {}, {
            text: v.text.slice(0, w)
          });
        }
        if (l > g) {
          var L = l - g;
          h = nr(nr({}, v), {}, {
            text: v.text.slice(0, L)
          }), v = nr(nr({}, v), {}, {
            text: v.text.slice(L)
          });
        }
        Object.assign(v, o), h && s.push(h), s.push(v), d && s.push(d);
      }
      n = s;
    }
    return n;
  }
}, gc = (e) => e.selection ? e.selection : e.children.length > 0 ? x.end(e, []) : [0], bo = (e, t) => {
  var [n] = x.node(e, t);
  return (r) => r === n;
}, vc = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? TS(t) : t, i = je.None, a = je.None, s = 0, u = null, l = null;
  for (var c of o) {
    var f = c.codePointAt(0);
    if (!f) break;
    var p = HS(c, f);
    if ([i, a] = r ? [a, p] : [p, i], lo(i, je.ZWJ) && lo(a, je.ExtPict) && (r ? u = Bh(t.substring(0, s)) : u = Bh(t.substring(0, t.length - s)), !u) || lo(i, je.RI) && lo(a, je.RI) && (l !== null ? l = !l : r ? l = !0 : l = KS(t.substring(0, t.length - s)), !l) || i !== je.None && a !== je.None && qS(i, a))
      break;
    s += c.length;
  }
  return s || 1;
}, SS = /\s/, kS = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, MS = /['\u2018\u2019]/, PS = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = vc(t, n), [a, s] = mc(t, i, n);
    if (BS(a, s, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = s;
  }
  return r;
}, mc = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, BS = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (SS.test(t))
    return !1;
  if (MS.test(t)) {
    var o = vc(n, r), [i, a] = mc(n, o, r);
    if (e(i, a, r))
      return !0;
  }
  return !kS.test(t);
}, TS = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (FS(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (AS(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, AS = (e) => e >= 55296 && e <= 56319, FS = (e) => e >= 56320 && e <= 57343, je;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(je || (je = {}));
var IS = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, RS = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, _S = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, jS = /^[\u1100-\u115F\uA960-\uA97C]$/, NS = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, zS = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, $S = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, US = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, WS = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, HS = (e, t) => {
  var n = je.Any;
  return e.search(IS) !== -1 && (n |= je.Extend), t === 8205 && (n |= je.ZWJ), t >= 127462 && t <= 127487 && (n |= je.RI), e.search(RS) !== -1 && (n |= je.Prepend), e.search(_S) !== -1 && (n |= je.SpacingMark), e.search(jS) !== -1 && (n |= je.L), e.search(NS) !== -1 && (n |= je.V), e.search(zS) !== -1 && (n |= je.T), e.search($S) !== -1 && (n |= je.LV), e.search(US) !== -1 && (n |= je.LVT), e.search(WS) !== -1 && (n |= je.ExtPict), n;
};
function lo(e, t) {
  return (e & t) !== 0;
}
var VS = [
  // GB6
  [je.L, je.L | je.V | je.LV | je.LVT],
  // GB7
  [je.LV | je.V, je.V | je.T],
  // GB8
  [je.LVT | je.T, je.T],
  // GB9
  [je.Any, je.Extend | je.ZWJ],
  // GB9a
  [je.Any, je.SpacingMark],
  // GB9b
  [je.Prepend, je.Any],
  // GB11
  [je.ZWJ, je.ExtPict],
  // GB12 and GB13
  [je.RI, je.RI]
];
function qS(e, t) {
  return VS.findIndex((n) => lo(e, n[0]) && lo(t, n[1])) === -1;
}
var ZS = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, Bh = (e) => e.search(ZS) !== -1, GS = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, KS = (e) => {
  var t = e.match(GS);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, YS = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    x.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = gc(e)
      } = n;
      if (H.isPath(o) && (o = x.range(e, o)), ne.isRange(o))
        if (ne.isCollapsed(o))
          o = o.anchor;
        else {
          var i = ne.end(o);
          if (!r && x.void(e, {
            at: i
          }))
            return;
          var a = ne.start(o), s = x.pointRef(e, a), u = x.pointRef(e, i);
          le.delete(e, {
            at: o,
            voids: r
          });
          var l = s.unref(), c = u.unref();
          o = l || c, le.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && x.void(e, {
        at: o
      }) || x.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: f,
          offset: p
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: f,
          offset: p,
          text: t
        });
      }
    });
  }
};
function Th(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ui(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Th(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Th(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var le = Ui(Ui(Ui(Ui({}, gS), vS), mS), YS), sa = /* @__PURE__ */ new WeakMap(), XS = (e) => sa.get(e) || !1, JS = (e, t, n) => {
  var r = sa.get(e) || !1;
  sa.set(e, !0);
  try {
    t(), n();
  } finally {
    sa.set(e, r);
  }
};
function Ay(e, t, n) {
  var r = Ma.get(e) || [], o = Pa.get(e) || /* @__PURE__ */ new Set(), i, a, s = (f) => {
    if (f) {
      var p = f.join(",");
      a.has(p) || (a.add(p), i.push(f));
    }
  };
  if (n) {
    i = [], a = /* @__PURE__ */ new Set();
    for (var u of r) {
      var l = n(u);
      s(l);
    }
  } else
    i = r, a = o;
  for (var c of t)
    s(c);
  Ma.set(e, i), Pa.set(e, a);
}
var QS = (e, t) => {
  for (var n of x.pathRefs(e))
    lS.transform(n, t);
  for (var r of x.pointRefs(e))
    cS.transform(r, t);
  for (var o of x.rangeRefs(e))
    fS.transform(o, t);
  if (!XS(e)) {
    var i = H.operationCanTransformPath(t) ? (a) => H.transform(a, t) : void 0;
    Ay(e, e.getDirtyPaths(t), i);
  }
  le.transform(e, t), e.operations.push(t), x.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), Uo.get(e) || (Uo.set(e, !0), Promise.resolve().then(() => {
    Uo.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, ek = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return H.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = H.levels(o), a = Oe.isText(r) ? [] : Array.from(ve.nodes(r), (M) => {
        var [, q] = M;
        return o.concat(q);
      });
      return [...i, ...a];
    }
    case "merge_node": {
      var {
        path: s
      } = t, u = H.ancestors(s), l = H.previous(s);
      return [...u, l];
    }
    case "move_node": {
      var {
        path: c,
        newPath: f
      } = t;
      if (H.equals(c, f))
        return [];
      var p = [], g = [];
      for (var v of H.ancestors(c)) {
        var h = H.transform(v, t);
        p.push(h);
      }
      for (var d of H.ancestors(f)) {
        var w = H.transform(d, t);
        g.push(w);
      }
      var L = g[g.length - 1], D = f[f.length - 1], B = L.concat(D);
      return [...p, ...g, B];
    }
    case "remove_node": {
      var {
        path: b
      } = t, E = H.ancestors(b);
      return [...E];
    }
    case "split_node": {
      var {
        path: O
      } = t, S = H.levels(O), V = H.next(O);
      return [...S, V];
    }
    default:
      return [];
  }
}, tk = (e) => {
  var {
    selection: t
  } = e;
  return t ? ve.fragment(e, t) : [];
}, nk = (e, t) => {
  var [n, r] = t;
  if (!Oe.isText(n)) {
    if (xe.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      le.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = x.isEditor(n) ? !1 : xe.isElement(n) && (e.isInline(n) || n.children.length === 0 || Oe.isText(n.children[0]) || e.isInline(n.children[0])), a = 0, s = 0; s < n.children.length; s++, a++) {
      var u = ve.get(e, r);
      if (!Oe.isText(u)) {
        var l = u.children[a], c = u.children[a - 1], f = s === n.children.length - 1, p = Oe.isText(l) || xe.isElement(l) && e.isInline(l);
        if (p !== i)
          le.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--;
        else if (xe.isElement(l)) {
          if (e.isInline(l)) {
            if (c == null || !Oe.isText(c)) {
              var g = {
                text: ""
              };
              le.insertNodes(e, g, {
                at: r.concat(a),
                voids: !0
              }), a++;
            } else if (f) {
              var v = {
                text: ""
              };
              le.insertNodes(e, v, {
                at: r.concat(a + 1),
                voids: !0
              }), a++;
            }
          }
        } else {
          if (!Oe.isText(l) && !("children" in l)) {
            var h = l;
            h.children = [];
          }
          c != null && Oe.isText(c) && (Oe.equals(l, c, {
            loose: !0
          }) ? (le.mergeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--) : c.text === "" ? (le.removeNodes(e, {
            at: r.concat(a - 1),
            voids: !0
          }), a--) : l.text === "" && (le.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--));
        }
      }
    }
  }
}, rk = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, ok = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: a
  } = n;
  if (i) {
    var s = x.path(t, i), u = o === "lowest";
    for (var [l, c] of x.levels(t, {
      at: s,
      voids: r,
      match: a,
      reverse: u
    }))
      if (!Oe.isText(l)) {
        if (ne.isRange(i)) {
          if (H.isAncestor(c, i.anchor.path) && H.isAncestor(c, i.focus.path))
            return [l, c];
        } else if (!H.equals(s, c))
          return [l, c];
      }
  }
};
function Ah(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ah(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ah(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ik = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (f, p) => {
      if (!Oe.isText(f))
        return !1;
      var [g, v] = x.parent(e, p);
      return !e.isVoid(g) || e.markableVoid(g);
    }, i = ne.isExpanded(r), a = !1;
    if (!i) {
      var [s, u] = x.node(e, r);
      if (s && o(s, u)) {
        var [l] = x.parent(e, u);
        a = l && e.markableVoid(l);
      }
    }
    if (i || a)
      le.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = Fh(Fh({}, x.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, Uo.get(e) || e.onChange();
    }
  }
};
function Ih(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ih(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ih(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ak = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = x.point(t, n, {
    edge: "end"
  }), i = x.end(t, []), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, u = 0, l;
  for (var c of x.positions(t, Rh(Rh({}, r), {}, {
    at: a
  }))) {
    if (u > s)
      break;
    u !== 0 && (l = c), u++;
  }
  return l;
};
function _h(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _h(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _h(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sk = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = x.start(t, []), i = x.point(t, n, {
    edge: "start"
  }), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, u = 0, l;
  for (var c of x.positions(t, jh(jh({}, r), {}, {
    at: a,
    reverse: !0
  }))) {
    if (u > s)
      break;
    u !== 0 && (l = c), u++;
  }
  return l;
}, uk = (e, t) => {
  var {
    selection: n
  } = e;
  n && ne.isCollapsed(n) && le.delete(e, {
    unit: t,
    reverse: !0
  });
}, lk = (e, t) => {
  var {
    selection: n
  } = e;
  n && ne.isCollapsed(n) && le.delete(e, {
    unit: t
  });
}, ck = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && ne.isExpanded(r) && le.delete(t, {
    reverse: n === "backward"
  });
}, fk = (e, t) => [x.start(e, t), x.end(e, t)];
function Nh(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Nh(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Nh(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dk = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return x.above(t, zh(zh({}, n), {}, {
    match: (r) => xe.isElement(r) && x.isElementReadOnly(t, r)
  }));
}, pk = (e, t) => x.point(e, t, {
  edge: "end"
}), hk = (e, t) => {
  var n = x.path(e, t, {
    edge: "start"
  });
  return x.node(e, n);
}, gk = (e, t) => {
  var n = x.range(e, t);
  return ve.fragment(e, n);
};
function $h(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $h(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $h(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vk = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return x.above(t, Uh(Uh({}, n), {}, {
    match: (r) => xe.isElement(r) && x.isVoid(t, r)
  }));
}, mk = (e, t) => t.children.some((n) => xe.isElement(n) && x.isBlock(e, n)), yk = (e, t) => t.children.some((n) => Oe.isText(n) || x.isInline(e, n)), bk = (e, t) => ve.has(e, t), Ck = (e, t) => t.children.every((n) => Oe.isText(n)), wk = (e) => {
  le.splitNodes(e, {
    always: !0
  });
}, Ek = (e, t, n) => {
  le.insertNodes(e, t, n);
}, Dk = (e) => {
  le.splitNodes(e, {
    always: !0
  });
};
function Wh(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xk(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Wh(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Wh(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Lk = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var a = xk({
        text: n
      }, i);
      le.insertNodes(t, a, {
        at: r.at,
        voids: r.voids
      });
    } else
      le.insertText(t, n, r);
    t.marks = null;
  }
}, Ok = (e, t) => !e.isInline(t), Sk = (e, t, n) => x.isStart(e, t, n) || x.isEnd(e, t, n), kk = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && Oe.isText(r) && r.text === "" && !e.isVoid(t);
}, Mk = (e, t, n) => {
  var r = x.end(e, n);
  return qe.equals(t, r);
}, Pk = (e) => {
  var t = By.get(e);
  return t === void 0 ? !0 : t;
}, Bk = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = x.start(e, n);
  return qe.equals(t, r);
}, Tk = (e, t) => {
  var n = x.path(e, t, {
    edge: "end"
  });
  return x.node(e, n);
}, Ak = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = x.path(t, n, r), i = ve.leaf(t, o);
  return [i, o];
};
function Fk(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var a = [], s = x.path(e, n);
      for (var [u, l] of ve.levels(e, s))
        if (i(u, l) && (a.push([u, l]), !o && xe.isElement(u) && x.isVoid(e, u)))
          break;
      r && a.reverse(), yield* a;
    }
  }();
}
var Ik = ["text"], Rk = ["text"], _k = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (ne.isExpanded(r)) {
    var a = x.isEnd(t, o, o.path);
    if (a) {
      var s = x.after(t, o);
      s && (o = s);
    }
    var [u] = x.nodes(t, {
      match: Oe.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (u) {
      var [l] = u, c = sr(l, Ik);
      return c;
    } else
      return {};
  }
  var {
    path: f
  } = o, [p] = x.leaf(t, f);
  if (o.offset === 0) {
    var g = x.previous(t, {
      at: f,
      match: Oe.isText
    }), v = x.above(t, {
      match: (B) => xe.isElement(B) && x.isVoid(t, B) && t.markableVoid(B)
    });
    if (!v) {
      var h = x.above(t, {
        match: (B) => xe.isElement(B) && x.isBlock(t, B)
      });
      if (g && h) {
        var [d, w] = g, [, L] = h;
        H.isAncestor(L, w) && (p = d);
      }
    }
  }
  var D = sr(p, Rk);
  return D;
}, jk = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = x.after(t, a, {
      voids: o
    });
    if (s) {
      var [, u] = x.last(t, []), l = [s.path, u];
      if (H.isPath(a) && a.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (H.isPath(a)) {
          var [c] = x.parent(t, a);
          i = (p) => c.children.includes(p);
        } else
          i = () => !0;
      var [f] = x.nodes(t, {
        at: l,
        match: i,
        mode: r,
        voids: o
      });
      return f;
    }
  }
}, Nk = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = x.path(t, n, r), i = ve.get(t, o);
  return [i, o];
};
function zk(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: a = !1,
      ignoreNonSelectable: s = !1
    } = t, {
      match: u
    } = t;
    if (u || (u = () => !0), !!n) {
      var l, c;
      if (xS.isSpan(n))
        l = n[0], c = n[1];
      else {
        var f = x.path(e, n, {
          edge: "start"
        }), p = x.path(e, n, {
          edge: "end"
        });
        l = i ? p : f, c = i ? f : p;
      }
      var g = ve.nodes(e, {
        reverse: i,
        from: l,
        to: c,
        pass: (B) => {
          var [b] = B;
          return xe.isElement(b) ? !!(!a && (x.isVoid(e, b) || x.isElementReadOnly(e, b)) || s && !x.isSelectable(e, b)) : !1;
        }
      }), v = [], h;
      for (var [d, w] of g)
        if (!(s && xe.isElement(d) && !x.isSelectable(e, d))) {
          var L = h && H.compare(w, h[1]) === 0;
          if (!(r === "highest" && L)) {
            if (!u(d, w)) {
              if (o && !L && Oe.isText(d))
                return;
              continue;
            }
            if (r === "lowest" && L) {
              h = [d, w];
              continue;
            }
            var D = r === "lowest" ? h : [d, w];
            D && (o ? v.push(D) : yield D), h = [d, w];
          }
        }
      r === "lowest" && h && (o ? v.push(h) : yield h), o && (yield* v);
    }
  }();
}
var $k = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => Ma.get(c) || [], a = (c) => Pa.get(c) || /* @__PURE__ */ new Set(), s = (c) => {
    var f = i(c).pop(), p = f.join(",");
    return a(c).delete(p), f;
  };
  if (x.isNormalizing(t)) {
    if (r) {
      var u = Array.from(ve.nodes(t), (c) => {
        var [, f] = c;
        return f;
      }), l = new Set(u.map((c) => c.join(",")));
      Ma.set(t, u), Pa.set(t, l);
    }
    i(t).length !== 0 && x.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (ve.has(t, c)) {
          var f = x.node(t, c), [p, g] = f;
          xe.isElement(p) && p.children.length === 0 && t.normalizeNode(f, {
            operation: o
          });
        }
      for (var v = i(t), h = v.length, d = 0; v.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: v,
          iteration: d,
          initialDirtyPathsLength: h,
          operation: o
        }))
          return;
        var w = s(t);
        if (ve.has(t, w)) {
          var L = x.node(t, w);
          t.normalizeNode(L, {
            operation: o
          });
        }
        d++, v = i(t);
      }
    });
  }
}, Uk = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = x.path(t, n, r), i = H.parent(o), a = x.node(t, i);
  return a;
}, Wk = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, u = x.pathRefs(t);
      return u.delete(i), i.current = null, s;
    }
  }, a = x.pathRefs(t);
  return a.add(i), i;
}, Hk = (e) => {
  var t = yh.get(e);
  return t || (t = /* @__PURE__ */ new Set(), yh.set(e, t)), t;
}, Vk = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (H.isPath(n)) {
    if (i === "start") {
      var [, a] = ve.first(t, n);
      n = a;
    } else if (i === "end") {
      var [, s] = ve.last(t, n);
      n = s;
    }
  }
  return ne.isRange(n) && (i === "start" ? n = ne.start(n) : i === "end" ? n = ne.end(n) : n = H.common(n.anchor.path, n.focus.path)), qe.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, qk = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, u = x.pointRefs(t);
      return u.delete(i), i.current = null, s;
    }
  }, a = x.pointRefs(t);
  return a.add(i), i;
}, Zk = (e) => {
  var t = bh.get(e);
  return t || (t = /* @__PURE__ */ new Set(), bh.set(e, t)), t;
}, Gk = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (H.isPath(n)) {
    var i;
    if (o === "end") {
      var [, a] = ve.last(t, n);
      i = a;
    } else {
      var [, s] = ve.first(t, n);
      i = s;
    }
    var u = ve.get(t, i);
    if (!Oe.isText(u))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? u.text.length : 0
    };
  }
  if (ne.isRange(n)) {
    var [l, c] = ne.edges(n);
    return o === "start" ? l : c;
  }
  return n;
};
function Kk(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: a = !1
    } = t;
    if (!n)
      return;
    var s = x.range(e, n), [u, l] = ne.edges(s), c = o ? l : u, f = !1, p = "", g = 0, v = 0, h = 0;
    for (var [d, w] of x.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: a
    })) {
      if (xe.isElement(d)) {
        if (!i && (e.isVoid(d) || e.isElementReadOnly(d))) {
          yield x.start(e, w);
          continue;
        }
        if (e.isInline(d)) continue;
        if (x.hasInlines(e, d)) {
          var L = H.isAncestor(w, l.path) ? l : x.end(e, w), D = H.isAncestor(w, u.path) ? u : x.start(e, w);
          p = x.string(e, {
            anchor: D,
            focus: L
          }, {
            voids: i
          }), f = !0;
        }
      }
      if (Oe.isText(d)) {
        var B = H.equals(w, c.path);
        for (B ? (v = o ? c.offset : d.text.length - c.offset, h = c.offset) : (v = d.text.length, h = o ? v : 0), (B || f || r === "offset") && (yield {
          path: w,
          offset: h
        }, f = !1); ; ) {
          if (g === 0) {
            if (p === "") break;
            g = b(p, r, o), p = mc(p, g, o)[1];
          }
          if (h = o ? h - g : h + g, v = v - g, v < 0) {
            g = -v;
            break;
          }
          g = 0, yield {
            path: w,
            offset: h
          };
        }
      }
    }
    function b(E, O, S) {
      return O === "character" ? vc(E, S) : O === "word" ? PS(E, S) : O === "line" || O === "block" ? E.length : 1;
    }
  }();
}
var Yk = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = x.before(t, a, {
      voids: o
    });
    if (s) {
      var [, u] = x.first(t, []), l = [s.path, u];
      if (H.isPath(a) && a.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (H.isPath(a)) {
          var [c] = x.parent(t, a);
          i = (p) => c.children.includes(p);
        } else
          i = () => !0;
      var [f] = x.nodes(t, {
        reverse: !0,
        at: l,
        match: i,
        mode: r,
        voids: o
      });
      return f;
    }
  }
}, Xk = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, u = x.rangeRefs(t);
      return u.delete(i), i.current = null, s;
    }
  }, a = x.rangeRefs(t);
  return a.add(i), i;
}, Jk = (e) => {
  var t = Ch.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Ch.set(e, t)), t;
}, Qk = (e, t, n) => {
  if (ne.isRange(t) && !n)
    return t;
  var r = x.start(e, t), o = x.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function Hh(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function eM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Hh(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Hh(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tM = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, f) => {
      if (!Oe.isText(c))
        return !1;
      var [p, g] = x.parent(e, f);
      return !e.isVoid(p) || e.markableVoid(p);
    }, o = ne.isExpanded(n), i = !1;
    if (!o) {
      var [a, s] = x.node(e, n);
      if (a && r(a, s)) {
        var [u] = x.parent(e, s);
        i = u && e.markableVoid(u);
      }
    }
    if (o || i)
      le.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var l = eM({}, x.marks(e) || {});
      delete l[t], e.marks = l, Uo.get(e) || e.onChange();
    }
  }
}, nM = (e, t) => {
  By.set(e, t);
}, rM = (e, t) => x.point(e, t, {
  edge: "start"
}), oM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = x.range(t, n), [a, s] = ne.edges(i), u = "";
  for (var [l, c] of x.nodes(t, {
    at: i,
    match: Oe.isText,
    voids: o
  })) {
    var f = l.text;
    H.equals(c, s.path) && (f = f.slice(0, s.offset)), H.equals(c, a.path) && (f = f.slice(a.offset)), u += f;
  }
  return u;
}, iM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, a] = ne.edges(n);
  if (i.offset !== 0 || a.offset !== 0 || ne.isCollapsed(n) || H.hasPrevious(a.path))
    return n;
  var s = x.above(t, {
    at: a,
    match: (v) => xe.isElement(v) && x.isBlock(t, v),
    voids: o
  }), u = s ? s[1] : [], l = x.start(t, i), c = {
    anchor: l,
    focus: a
  }, f = !0;
  for (var [p, g] of x.nodes(t, {
    at: c,
    match: Oe.isText,
    reverse: !0,
    voids: o
  })) {
    if (f) {
      f = !1;
      continue;
    }
    if (p.text !== "" || H.isBefore(g, u)) {
      a = {
        path: g,
        offset: p.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: a
  };
}, aM = (e, t) => {
  var n = x.isNormalizing(e);
  x.setNormalizing(e, !1);
  try {
    t();
  } finally {
    x.setNormalizing(e, n);
  }
  x.normalize(e);
}, sM = (e, t, n) => {
  var [r, o] = t;
  return xe.isElement(r) && x.isEmpty(e, r) || Oe.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, uM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  x.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: a = "character",
      distance: s = 1,
      voids: u = !1
    } = n, {
      at: l = t.selection,
      hanging: c = !1
    } = n;
    if (l) {
      var f = !1;
      if (ne.isRange(l) && ne.isCollapsed(l) && (f = !0, l = l.anchor), qe.isPoint(l)) {
        var p = x.void(t, {
          at: l,
          mode: "highest"
        });
        if (!u && p) {
          var [, g] = p;
          l = g;
        } else {
          var v = {
            unit: a,
            distance: s
          }, h = i ? x.before(t, l, v) || x.start(t, []) : x.after(t, l, v) || x.end(t, []);
          l = {
            anchor: l,
            focus: h
          }, c = !0;
        }
      }
      if (H.isPath(l)) {
        le.removeNodes(t, {
          at: l,
          voids: u
        });
        return;
      }
      if (!ne.isCollapsed(l)) {
        if (!c) {
          var [, d] = ne.edges(l), w = x.end(t, []);
          qe.equals(d, w) || (l = x.unhangRange(t, l, {
            voids: u
          }));
        }
        var [L, D] = ne.edges(l), B = x.above(t, {
          match: (ue) => xe.isElement(ue) && x.isBlock(t, ue),
          at: L,
          voids: u
        }), b = x.above(t, {
          match: (ue) => xe.isElement(ue) && x.isBlock(t, ue),
          at: D,
          voids: u
        }), E = B && b && !H.equals(B[1], b[1]), O = H.equals(L.path, D.path), S = u ? null : (r = x.void(t, {
          at: L,
          mode: "highest"
        })) !== null && r !== void 0 ? r : x.elementReadOnly(t, {
          at: L,
          mode: "highest"
        }), V = u ? null : (o = x.void(t, {
          at: D,
          mode: "highest"
        })) !== null && o !== void 0 ? o : x.elementReadOnly(t, {
          at: D,
          mode: "highest"
        });
        if (S) {
          var M = x.before(t, L);
          M && B && H.isAncestor(B[1], M.path) && (L = M);
        }
        if (V) {
          var q = x.after(t, D);
          q && b && H.isAncestor(b[1], q.path) && (D = q);
        }
        var _ = [], j;
        for (var I of x.nodes(t, {
          at: l,
          voids: u
        })) {
          var [z, X] = I;
          j && H.compare(X, j) === 0 || (!u && xe.isElement(z) && (x.isVoid(t, z) || x.isElementReadOnly(t, z)) || !H.isCommon(X, L.path) && !H.isCommon(X, D.path)) && (_.push(I), j = X);
        }
        var R = Array.from(_, (ue) => {
          var [, de] = ue;
          return x.pathRef(t, de);
        }), ee = x.pointRef(t, L), re = x.pointRef(t, D), k = "";
        if (!O && !S) {
          var A = ee.current, [G] = x.leaf(t, A), {
            path: U
          } = A, {
            offset: Y
          } = L, K = G.text.slice(Y);
          K.length > 0 && (t.apply({
            type: "remove_text",
            path: U,
            offset: Y,
            text: K
          }), k = K);
        }
        if (R.reverse().map((ue) => ue.unref()).filter((ue) => ue !== null).forEach((ue) => le.removeNodes(t, {
          at: ue,
          voids: u
        })), !V) {
          var m = re.current, [$] = x.leaf(t, m), {
            path: W
          } = m, T = O ? L.offset : 0, J = $.text.slice(T, D.offset);
          J.length > 0 && (t.apply({
            type: "remove_text",
            path: W,
            offset: T,
            text: J
          }), k = J);
        }
        !O && E && re.current && ee.current && le.mergeNodes(t, {
          at: re.current,
          hanging: !0,
          voids: u
        }), f && i && a === "character" && k.length > 1 && k.match(/[\u0E00-\u0E7F]+/) && le.insertText(t, k.slice(0, k.length - s));
        var te = ee.unref(), N = re.unref(), se = i ? te || N : N || te;
        n.at == null && se && le.select(t, se);
      }
    }
  });
}, lM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  x.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: a = gc(t),
      batchDirty: s = !0
    } = r;
    if (n.length) {
      if (ne.isRange(a))
        if (o || (a = x.unhangRange(t, a, {
          voids: i
        })), ne.isCollapsed(a))
          a = a.anchor;
        else {
          var [, u] = ne.edges(a);
          if (!i && x.void(t, {
            at: u
          }))
            return;
          var l = x.pointRef(t, u);
          le.delete(t, {
            at: a
          }), a = l.unref();
        }
      else H.isPath(a) && (a = x.start(t, a));
      if (!(!i && x.void(t, {
        at: a
      }))) {
        var c = x.above(t, {
          at: a,
          match: (K) => xe.isElement(K) && x.isInline(t, K),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, f] = c;
          if (x.isEnd(t, a, f)) {
            var p = x.after(t, f);
            a = p;
          } else if (x.isStart(t, a, f)) {
            var g = x.before(t, f);
            a = g;
          }
        }
        var v = x.above(t, {
          match: (K) => xe.isElement(K) && x.isBlock(t, K),
          at: a,
          voids: i
        }), [, h] = v, d = x.isStart(t, a, h), w = x.isEnd(t, a, h), L = d && w, D = !d || d && w, B = !w, [, b] = ve.first({
          children: n
        }, []), [, E] = ve.last({
          children: n
        }, []), O = [], S = (K) => {
          var [m, $] = K, W = $.length === 0;
          return W ? !1 : L ? !0 : !(D && H.isAncestor($, b) && xe.isElement(m) && !t.isVoid(m) && !t.isInline(m) || B && H.isAncestor($, E) && xe.isElement(m) && !t.isVoid(m) && !t.isInline(m));
        };
        for (var V of ve.nodes({
          children: n
        }, {
          pass: S
        }))
          S(V) && O.push(V);
        var M = [], q = [], _ = [], j = !0, I = !1;
        for (var [z] of O)
          xe.isElement(z) && !t.isInline(z) ? (j = !1, I = !0, q.push(z)) : j ? M.push(z) : _.push(z);
        var [X] = x.nodes(t, {
          at: a,
          match: (K) => Oe.isText(K) || x.isInline(t, K),
          mode: "highest",
          voids: i
        }), [, R] = X, ee = x.isStart(t, a, R), re = x.isEnd(t, a, R), k = x.pathRef(t, w && !_.length ? H.next(h) : h), A = x.pathRef(t, re ? H.next(R) : R);
        le.splitNodes(t, {
          at: a,
          match: (K) => I ? xe.isElement(K) && x.isBlock(t, K) : Oe.isText(K) || x.isInline(t, K),
          mode: I ? "lowest" : "highest",
          always: I && (!d || M.length > 0) && (!w || _.length > 0),
          voids: i
        });
        var G = x.pathRef(t, !ee || ee && re ? H.next(R) : R);
        if (le.insertNodes(t, M, {
          at: G.current,
          match: (K) => Oe.isText(K) || x.isInline(t, K),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), L && !M.length && q.length && !_.length && le.delete(t, {
          at: h,
          voids: i
        }), le.insertNodes(t, q, {
          at: k.current,
          match: (K) => xe.isElement(K) && x.isBlock(t, K),
          mode: "lowest",
          voids: i,
          batchDirty: s
        }), le.insertNodes(t, _, {
          at: A.current,
          match: (K) => Oe.isText(K) || x.isInline(t, K),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), !r.at) {
          var U;
          if (_.length > 0 && A.current ? U = H.previous(A.current) : q.length > 0 && k.current ? U = H.previous(k.current) : G.current && (U = H.previous(G.current)), U) {
            var Y = x.end(t, U);
            le.select(t, Y);
          }
        }
        G.unref(), k.unref(), A.unref();
      }
    }
  });
}, cM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      le.select(t, o.anchor);
    else if (r === "focus")
      le.select(t, o.focus);
    else if (r === "start") {
      var [i] = ne.edges(o);
      le.select(t, i);
    } else if (r === "end") {
      var [, a] = ne.edges(o);
      le.select(t, a);
    }
  } else return;
}, fM = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, dM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: a = !1
  } = n, {
    edge: s = null
  } = n;
  if (r) {
    s === "start" && (s = ne.isBackward(r) ? "focus" : "anchor"), s === "end" && (s = ne.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: u,
      focus: l
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, f = {};
    if (s == null || s === "anchor") {
      var p = a ? x.before(t, u, c) : x.after(t, u, c);
      p && (f.anchor = p);
    }
    if (s == null || s === "focus") {
      var g = a ? x.before(t, l, c) : x.after(t, l, c);
      g && (f.focus = g);
    }
    le.setSelection(t, f);
  }
}, pM = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = x.range(e, t), n) {
    le.setSelection(e, t);
    return;
  }
  if (!ne.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(qt.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function Vh(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Vh(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Vh(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = ne.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = ne.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: a,
      focus: s
    } = o, u = i === "anchor" ? a : s;
    le.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: qh(qh({}, u), n)
    });
  }
}, gM = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !qe.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !qe.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, vM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  x.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: a = "lowest",
      batchDirty: s = !0
    } = r, {
      at: u,
      match: l,
      select: c
    } = r;
    if (ve.isNode(n) && (n = [n]), n.length !== 0) {
      var [f] = n;
      if (u || (u = gc(t), c !== !1 && (c = !0)), c == null && (c = !1), ne.isRange(u))
        if (o || (u = x.unhangRange(t, u, {
          voids: i
        })), ne.isCollapsed(u))
          u = u.anchor;
        else {
          var [, p] = ne.edges(u), g = x.pointRef(t, p);
          le.delete(t, {
            at: u
          }), u = g.unref();
        }
      if (qe.isPoint(u)) {
        l == null && (Oe.isText(f) ? l = (M) => Oe.isText(M) : t.isInline(f) ? l = (M) => Oe.isText(M) || x.isInline(t, M) : l = (M) => xe.isElement(M) && x.isBlock(t, M));
        var [v] = x.nodes(t, {
          at: u.path,
          match: l,
          mode: a,
          voids: i
        });
        if (v) {
          var [, h] = v, d = x.pathRef(t, h), w = x.isEnd(t, u, h);
          le.splitNodes(t, {
            at: u,
            match: l,
            mode: a,
            voids: i
          });
          var L = d.unref();
          u = w ? H.next(L) : L;
        } else
          return;
      }
      var D = H.parent(u), B = u[u.length - 1];
      if (!(!i && x.void(t, {
        at: D
      }))) {
        if (s) {
          var b = [], E = H.levels(D);
          JS(t, () => {
            var M = function() {
              var j = D.concat(B);
              B++;
              var I = {
                type: "insert_node",
                path: j,
                node: q
              };
              t.apply(I), u = H.next(u), b.push(I), Oe.isText ? E.push(...Array.from(ve.nodes(q), (z) => {
                var [, X] = z;
                return j.concat(X);
              })) : E.push(j);
            };
            for (var q of n)
              M();
          }, () => {
            Ay(t, E, (M) => {
              var q = M;
              for (var _ of b)
                if (H.operationCanTransformPath(_) && (q = H.transform(q, _), !q))
                  return null;
              return q;
            });
          });
        } else
          for (var O of n) {
            var S = D.concat(B);
            B++, t.apply({
              type: "insert_node",
              path: S,
              node: O
            }), u = H.next(u);
          }
        if (u = H.previous(u), c) {
          var V = x.end(t, u);
          V && le.select(t, V);
        }
      }
    }
  });
}, mM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  x.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: a
    } = n;
    if (a == null && (a = H.isPath(r) ? bo(t, r) : (B) => xe.isElement(B) && x.isBlock(t, B)), !!r) {
      var s = x.nodes(t, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), u = Array.from(s, (B) => {
        var [, b] = B;
        return x.pathRef(t, b);
      });
      for (var l of u) {
        var c = l.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var f = x.node(t, H.parent(c)), [p, g] = f, v = c[c.length - 1], {
          length: h
        } = p.children;
        if (h === 1) {
          var d = H.next(g);
          le.moveNodes(t, {
            at: c,
            to: d,
            voids: i
          }), le.removeNodes(t, {
            at: g,
            voids: i
          });
        } else if (v === 0)
          le.moveNodes(t, {
            at: c,
            to: g,
            voids: i
          });
        else if (v === h - 1) {
          var w = H.next(g);
          le.moveNodes(t, {
            at: c,
            to: w,
            voids: i
          });
        } else {
          var L = H.next(c), D = H.next(g);
          le.splitNodes(t, {
            at: L,
            voids: i
          }), le.moveNodes(t, {
            at: c,
            to: D,
            voids: i
          });
        }
      }
    }
  });
}, yM = ["text"], bM = ["children"], Fy = (e, t) => {
  if (xe.isElement(t)) {
    var n = t;
    return x.isVoid(e, t) ? !0 : n.children.length === 1 ? Fy(e, n.children[0]) : !1;
  } else return !x.isEditor(t);
}, CM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  x.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: a = !1,
      mode: s = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (H.isPath(o)) {
          var [u] = x.parent(t, o);
          r = (M) => u.children.includes(M);
        } else
          r = (M) => xe.isElement(M) && x.isBlock(t, M);
      if (!i && ne.isRange(o) && (o = x.unhangRange(t, o, {
        voids: a
      })), ne.isRange(o))
        if (ne.isCollapsed(o))
          o = o.anchor;
        else {
          var [, l] = ne.edges(o), c = x.pointRef(t, l);
          le.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && le.select(t, o);
        }
      var [f] = x.nodes(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      }), p = x.previous(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      });
      if (!(!f || !p)) {
        var [g, v] = f, [h, d] = p;
        if (!(v.length === 0 || d.length === 0)) {
          var w = H.next(d), L = H.common(v, d), D = H.isSibling(v, d), B = Array.from(x.levels(t, {
            at: v
          }), (M) => {
            var [q] = M;
            return q;
          }).slice(L.length).slice(0, -1), b = x.above(t, {
            at: v,
            mode: "highest",
            match: (M) => B.includes(M) && Fy(t, M)
          }), E = b && x.pathRef(t, b[1]), O, S;
          if (Oe.isText(g) && Oe.isText(h)) {
            var V = sr(g, yM);
            S = h.text.length, O = V;
          } else if (xe.isElement(g) && xe.isElement(h)) {
            var V = sr(g, bM);
            S = h.children.length, O = V;
          } else
            throw new Error("Cannot merge the node at path [".concat(v, "] with the previous sibling because it is not the same kind: ").concat(qt.stringify(g), " ").concat(qt.stringify(h)));
          D || le.moveNodes(t, {
            at: v,
            to: w,
            voids: a
          }), E && le.removeNodes(t, {
            at: E.current,
            voids: a
          }), x.shouldMergeNodesRemovePrevNode(t, p, f) ? le.removeNodes(t, {
            at: d,
            voids: a
          }) : t.apply({
            type: "merge_node",
            path: w,
            position: S,
            properties: O
          }), E && E.unref();
        }
      }
    }
  });
}, wM = (e, t) => {
  x.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: a
    } = t;
    if (r) {
      a == null && (a = H.isPath(r) ? bo(e, r) : (g) => xe.isElement(g) && x.isBlock(e, g));
      var s = x.pathRef(e, n), u = x.nodes(e, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), l = Array.from(u, (g) => {
        var [, v] = g;
        return x.pathRef(e, v);
      });
      for (var c of l) {
        var f = c.unref(), p = s.current;
        f.length !== 0 && e.apply({
          type: "move_node",
          path: f,
          newPath: p
        }), s.current && H.isSibling(p, f) && H.isAfter(p, f) && (s.current = H.next(s.current));
      }
      s.unref();
    }
  });
}, EM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  x.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = H.isPath(a) ? bo(t, a) : (g) => xe.isElement(g) && x.isBlock(t, g)), !r && ne.isRange(a) && (a = x.unhangRange(t, a, {
        voids: o
      }));
      var u = x.nodes(t, {
        at: a,
        match: s,
        mode: i,
        voids: o
      }), l = Array.from(u, (g) => {
        var [, v] = g;
        return x.pathRef(t, v);
      });
      for (var c of l) {
        var f = c.unref();
        if (f) {
          var [p] = x.node(t, f);
          t.apply({
            type: "remove_node",
            path: f,
            node: p
          });
        }
      }
    }
  });
}, DM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  x.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: a,
      merge: s
    } = r, {
      hanging: u = !1,
      mode: l = "lowest",
      split: c = !1,
      voids: f = !1
    } = r;
    if (i) {
      if (o == null && (o = H.isPath(i) ? bo(t, i) : (S) => xe.isElement(S) && x.isBlock(t, S)), !u && ne.isRange(i) && (i = x.unhangRange(t, i, {
        voids: f
      })), c && ne.isRange(i)) {
        if (ne.isCollapsed(i) && x.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var p = x.rangeRef(t, i, {
          affinity: "inward"
        }), [g, v] = ne.edges(i), h = l === "lowest" ? "lowest" : "highest", d = x.isEnd(t, v, v.path);
        le.splitNodes(t, {
          at: v,
          match: o,
          mode: h,
          voids: f,
          always: !d
        });
        var w = x.isStart(t, g, g.path);
        le.splitNodes(t, {
          at: g,
          match: o,
          mode: h,
          voids: f,
          always: !w
        }), i = p.unref(), r.at == null && le.select(t, i);
      }
      a || (a = (S, V) => S !== V);
      for (var [L, D] of x.nodes(t, {
        at: i,
        match: o,
        mode: l,
        voids: f
      })) {
        var B = {}, b = {};
        if (D.length !== 0) {
          var E = !1;
          for (var O in n)
            O === "children" || O === "text" || a(n[O], L[O]) && (E = !0, L.hasOwnProperty(O) && (B[O] = L[O]), s ? n[O] != null && (b[O] = s(L[O], n[O])) : n[O] != null && (b[O] = n[O]));
          E && t.apply({
            type: "set_node",
            path: D,
            properties: B,
            newProperties: b
          });
        }
      }
    }
  });
}, xM = (e, t) => {
  if (ne.isCollapsed(t))
    return t.anchor;
  var [, n] = ne.edges(t), r = x.pointRef(e, n);
  return le.delete(e, {
    at: t
  }), r.unref();
}, LM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  x.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: a = t.selection,
      height: s = 0,
      always: u = !1
    } = n;
    if (i == null && (i = (re) => xe.isElement(re) && x.isBlock(t, re)), ne.isRange(a) && (a = xM(t, a)), H.isPath(a)) {
      var l = a, c = x.point(t, l), [f] = x.parent(t, l);
      i = (re) => re === f, s = c.path.length - l.length + 1, a = c, u = !0;
    }
    if (a) {
      var p = x.pointRef(t, a, {
        affinity: "backward"
      }), g;
      try {
        var [v] = x.nodes(t, {
          at: a,
          match: i,
          mode: r,
          voids: o
        });
        if (!v)
          return;
        var h = x.void(t, {
          at: a,
          mode: "highest"
        }), d = 0;
        if (!o && h) {
          var [w, L] = h;
          if (xe.isElement(w) && t.isInline(w)) {
            var D = x.after(t, L);
            if (!D) {
              var B = {
                text: ""
              }, b = H.next(L);
              le.insertNodes(t, B, {
                at: b,
                voids: o
              }), D = x.point(t, b);
            }
            a = D, u = !0;
          }
          var E = a.path.length - L.length;
          s = E + 1, u = !0;
        }
        g = x.pointRef(t, a);
        var O = a.path.length - s, [, S] = v, V = a.path.slice(0, O), M = s === 0 ? a.offset : a.path[O] + d;
        for (var [q, _] of x.levels(t, {
          at: V,
          reverse: !0,
          voids: o
        })) {
          var j = !1;
          if (_.length < S.length || _.length === 0 || !o && xe.isElement(q) && x.isVoid(t, q))
            break;
          var I = p.current, z = x.isEnd(t, I, _);
          if (u || !p || !x.isEdge(t, I, _)) {
            j = !0;
            var X = ve.extractProps(q);
            t.apply({
              type: "split_node",
              path: _,
              position: M,
              properties: X
            });
          }
          M = _[_.length - 1] + (j || z ? 1 : 0);
        }
        if (n.at == null) {
          var R = g.current || x.end(t, []);
          le.select(t, R);
        }
      } finally {
        var ee;
        p.unref(), (ee = g) === null || ee === void 0 || ee.unref();
      }
    }
  });
}, OM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  le.setNodes(t, o, r);
}, SM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  x.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = H.isPath(a) ? bo(t, a) : (g) => xe.isElement(g) && x.isBlock(t, g)), H.isPath(a) && (a = x.range(t, a));
      var u = ne.isRange(a) ? x.rangeRef(t, a) : null, l = x.nodes(t, {
        at: a,
        match: s,
        mode: r,
        voids: i
      }), c = Array.from(
        l,
        (g) => {
          var [, v] = g;
          return x.pathRef(t, v);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), f = function() {
        var v = p.unref(), [h] = x.node(t, v), d = x.range(t, v);
        o && u && (d = ne.intersection(u.current, d)), le.liftNodes(t, {
          at: d,
          match: (w) => xe.isAncestor(h) && h.children.includes(w),
          voids: i
        });
      };
      for (var p of c)
        f();
      u && u.unref();
    }
  });
};
function Zh(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Zh(Object(n), !0).forEach(function(r) {
      on(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Zh(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  x.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: a = !1
    } = r, {
      match: s,
      at: u = t.selection
    } = r;
    if (u) {
      if (s == null && (H.isPath(u) ? s = bo(t, u) : t.isInline(n) ? s = (d) => xe.isElement(d) && x.isInline(t, d) || Oe.isText(d) : s = (d) => xe.isElement(d) && x.isBlock(t, d)), i && ne.isRange(u)) {
        var [l, c] = ne.edges(u), f = x.rangeRef(t, u, {
          affinity: "inward"
        });
        le.splitNodes(t, {
          at: c,
          match: s,
          voids: a
        }), le.splitNodes(t, {
          at: l,
          match: s,
          voids: a
        }), u = f.unref(), r.at == null && le.select(t, u);
      }
      var p = Array.from(x.nodes(t, {
        at: u,
        match: t.isInline(n) ? (d) => xe.isElement(d) && x.isBlock(t, d) : (d) => x.isEditor(d),
        mode: "lowest",
        voids: a
      })), g = function() {
        var w = ne.isRange(u) ? ne.intersection(u, x.range(t, h)) : u;
        if (!w)
          return 0;
        var L = Array.from(x.nodes(t, {
          at: w,
          match: s,
          mode: o,
          voids: a
        }));
        if (L.length > 0) {
          var [D] = L, B = L[L.length - 1], [, b] = D, [, E] = B;
          if (b.length === 0 && E.length === 0)
            return 0;
          var O = H.equals(b, E) ? H.parent(b) : H.common(b, E), S = x.range(t, b, E), V = x.node(t, O), [M] = V, q = O.length + 1, _ = H.next(E.slice(0, q)), j = Gh(Gh({}, n), {}, {
            children: []
          });
          le.insertNodes(t, j, {
            at: _,
            voids: a
          }), le.moveNodes(t, {
            at: S,
            match: (I) => xe.isAncestor(M) && M.children.includes(I),
            to: _.concat(0),
            voids: a
          });
        }
      }, v;
      for (var [, h] of p)
        v = g();
    }
  });
}, MM = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return QS(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ik(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uk(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lk(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ck(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return tk(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wk(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dk(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lM(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ek(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Lk(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nk(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return tM(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ek(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rk(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ok(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ak(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sk(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cM(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uM(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fM(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fk(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dk(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pk(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hk(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gk(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _k(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mk(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yk(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bk(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ck(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vM(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ok(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Sk(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kk(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mk(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Pk(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Bk(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tk(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ak(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fk(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mM(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return CM(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dM(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wM(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jk(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nk(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zk(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $k(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Uk(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vk(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wk(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hk(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Gk(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qk(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zk(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Kk(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Yk(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qk(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Xk(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jk(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return EM(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pM(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return DM(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nM(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hM(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gM(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LM(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rM(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return oM(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return iM(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return OM(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return SM(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vk(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return aM(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kM(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sM(e, ...r);
    }
  };
  return e;
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Kh(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function PM(e) {
  var t, n;
  return Kh(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(Kh(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var BM = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return PM(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || Lr.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || Lr.isOperationList(e.undos[0].operations));
  }
}, uu = /* @__PURE__ */ new WeakMap(), To = /* @__PURE__ */ new WeakMap(), Yr = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return BM.isHistory(e.history) && x.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return To.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return uu.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = Yr.isMerging(e);
    To.set(e, !0), t(), To.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = Yr.isMerging(e);
    To.set(e, !1), t(), To.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = Yr.isSaving(e);
    uu.set(e, !1), t(), uu.set(e, n);
  }
}, TM = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && le.setSelection(t, i.selectionBefore), Yr.withoutSaving(t, () => {
        x.withoutNormalizing(t, () => {
          for (var a of i.operations)
            t.apply(a);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      Yr.withoutSaving(t, () => {
        x.withoutNormalizing(t, () => {
          var a = i.operations.map(Lr.inverse).reverse();
          for (var s of a)
            t.apply(s);
          i.selectionBefore && le.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: a
    } = i, s = a[a.length - 1], u = s && s.operations[s.operations.length - 1], l = Yr.isSaving(t), c = Yr.isMerging(t);
    if (l == null && (l = FM(r)), l) {
      if (c == null && (s == null ? c = !1 : o.length !== 0 ? c = !0 : c = AM(r, u)), s && c)
        s.operations.push(r);
      else {
        var f = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", f);
      }
      for (; a.length > 100; )
        a.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, AM = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && H.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && H.equals(e.path, t.path)), FM = (e, t) => e.type !== "set_selection", IM = jM, Iy = "֑-߿יִ-﷽ﹰ-ﻼ", Ry = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", RM = new RegExp("^[^" + Ry + "]*[" + Iy + "]"), _M = new RegExp("^[^" + Iy + "]*[" + Ry + "]");
function jM(e) {
  return e = String(e || ""), RM.test(e) ? "rtl" : _M.test(e) ? "ltr" : "neutral";
}
const _y = /* @__PURE__ */ Na(IM);
function NM(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var yc = NM, zM = typeof vt == "object" && vt && vt.Object === Object && vt, $M = zM, UM = $M, WM = typeof self == "object" && self && self.Object === Object && self, HM = UM || WM || Function("return this")(), jy = HM, VM = jy, qM = function() {
  return VM.Date.now();
}, ZM = qM, GM = /\s/;
function KM(e) {
  for (var t = e.length; t-- && GM.test(e.charAt(t)); )
    ;
  return t;
}
var YM = KM, XM = YM, JM = /^\s+/;
function QM(e) {
  return e && e.slice(0, XM(e) + 1).replace(JM, "");
}
var eP = QM, tP = jy, nP = tP.Symbol, Ny = nP, Yh = Ny, zy = Object.prototype, rP = zy.hasOwnProperty, oP = zy.toString, Ao = Yh ? Yh.toStringTag : void 0;
function iP(e) {
  var t = rP.call(e, Ao), n = e[Ao];
  try {
    e[Ao] = void 0;
    var r = !0;
  } catch {
  }
  var o = oP.call(e);
  return r && (t ? e[Ao] = n : delete e[Ao]), o;
}
var aP = iP, sP = Object.prototype, uP = sP.toString;
function lP(e) {
  return uP.call(e);
}
var cP = lP, Xh = Ny, fP = aP, dP = cP, pP = "[object Null]", hP = "[object Undefined]", Jh = Xh ? Xh.toStringTag : void 0;
function gP(e) {
  return e == null ? e === void 0 ? hP : pP : Jh && Jh in Object(e) ? fP(e) : dP(e);
}
var vP = gP;
function mP(e) {
  return e != null && typeof e == "object";
}
var yP = mP, bP = vP, CP = yP, wP = "[object Symbol]";
function EP(e) {
  return typeof e == "symbol" || CP(e) && bP(e) == wP;
}
var DP = EP, xP = eP, Qh = yc, LP = DP, eg = NaN, OP = /^[-+]0x[0-9a-f]+$/i, SP = /^0b[01]+$/i, kP = /^0o[0-7]+$/i, MP = parseInt;
function PP(e) {
  if (typeof e == "number")
    return e;
  if (LP(e))
    return eg;
  if (Qh(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Qh(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = xP(e);
  var n = SP.test(e);
  return n || kP.test(e) ? MP(e.slice(2), n ? 2 : 8) : OP.test(e) ? eg : +e;
}
var BP = PP, TP = yc, lu = ZM, tg = BP, AP = "Expected a function", FP = Math.max, IP = Math.min;
function RP(e, t, n) {
  var r, o, i, a, s, u, l = 0, c = !1, f = !1, p = !0;
  if (typeof e != "function")
    throw new TypeError(AP);
  t = tg(t) || 0, TP(n) && (c = !!n.leading, f = "maxWait" in n, i = f ? FP(tg(n.maxWait) || 0, t) : i, p = "trailing" in n ? !!n.trailing : p);
  function g(E) {
    var O = r, S = o;
    return r = o = void 0, l = E, a = e.apply(S, O), a;
  }
  function v(E) {
    return l = E, s = setTimeout(w, t), c ? g(E) : a;
  }
  function h(E) {
    var O = E - u, S = E - l, V = t - O;
    return f ? IP(V, i - S) : V;
  }
  function d(E) {
    var O = E - u, S = E - l;
    return u === void 0 || O >= t || O < 0 || f && S >= i;
  }
  function w() {
    var E = lu();
    if (d(E))
      return L(E);
    s = setTimeout(w, h(E));
  }
  function L(E) {
    return s = void 0, p && r ? g(E) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), l = 0, r = u = o = s = void 0;
  }
  function B() {
    return s === void 0 ? a : L(lu());
  }
  function b() {
    var E = lu(), O = d(E);
    if (r = arguments, o = this, u = E, O) {
      if (s === void 0)
        return v(u);
      if (f)
        return clearTimeout(s), s = setTimeout(w, t), g(u);
    }
    return s === void 0 && (s = setTimeout(w, t)), a;
  }
  return b.cancel = D, b.flush = B, b;
}
var $y = RP;
const _P = /* @__PURE__ */ Na($y);
var jP = $y, NP = yc, zP = "Expected a function";
function $P(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(zP);
  return NP(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), jP(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var UP = $P;
const WP = /* @__PURE__ */ Na(UP), ng = (e) => typeof e == "object" && e != null && e.nodeType === 1, rg = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", cu = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return rg(n.overflowY, t) || rg(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, Wi = (e, t, n, r, o, i, a, s) => i < e && a > t || i > e && a < t ? 0 : i <= e && s <= n || a >= t && s >= n ? i - e - r : a > t && s < n || i < e && s > n ? a - t + o : 0, HP = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, og = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: a, block: s, inline: u, boundary: l, skipOverflowHiddenElements: c } = t, f = typeof l == "function" ? l : (X) => X !== l;
  if (!ng(e)) throw new TypeError("Invalid target");
  const p = document.scrollingElement || document.documentElement, g = [];
  let v = e;
  for (; ng(v) && f(v); ) {
    if (v = HP(v), v === p) {
      g.push(v);
      break;
    }
    v != null && v === document.body && cu(v) && !cu(document.documentElement) || v != null && cu(v, c) && g.push(v);
  }
  const h = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, d = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: w, scrollY: L } = window, { height: D, width: B, top: b, right: E, bottom: O, left: S } = e.getBoundingClientRect(), { top: V, right: M, bottom: q, left: _ } = ((X) => {
    const R = window.getComputedStyle(X);
    return { top: parseFloat(R.scrollMarginTop) || 0, right: parseFloat(R.scrollMarginRight) || 0, bottom: parseFloat(R.scrollMarginBottom) || 0, left: parseFloat(R.scrollMarginLeft) || 0 };
  })(e);
  let j = s === "start" || s === "nearest" ? b - V : s === "end" ? O + q : b + D / 2 - V + q, I = u === "center" ? S + B / 2 - _ + M : u === "end" ? E + M : S - _;
  const z = [];
  for (let X = 0; X < g.length; X++) {
    const R = g[X], { height: ee, width: re, top: k, right: A, bottom: G, left: U } = R.getBoundingClientRect();
    if (a === "if-needed" && b >= 0 && S >= 0 && O <= d && E <= h && b >= k && O <= G && S >= U && E <= A) return z;
    const Y = getComputedStyle(R), K = parseInt(Y.borderLeftWidth, 10), m = parseInt(Y.borderTopWidth, 10), $ = parseInt(Y.borderRightWidth, 10), W = parseInt(Y.borderBottomWidth, 10);
    let T = 0, J = 0;
    const te = "offsetWidth" in R ? R.offsetWidth - R.clientWidth - K - $ : 0, N = "offsetHeight" in R ? R.offsetHeight - R.clientHeight - m - W : 0, se = "offsetWidth" in R ? R.offsetWidth === 0 ? 0 : re / R.offsetWidth : 0, ue = "offsetHeight" in R ? R.offsetHeight === 0 ? 0 : ee / R.offsetHeight : 0;
    if (p === R) T = s === "start" ? j : s === "end" ? j - d : s === "nearest" ? Wi(L, L + d, d, m, W, L + j, L + j + D, D) : j - d / 2, J = u === "start" ? I : u === "center" ? I - h / 2 : u === "end" ? I - h : Wi(w, w + h, h, K, $, w + I, w + I + B, B), T = Math.max(0, T + L), J = Math.max(0, J + w);
    else {
      T = s === "start" ? j - k - m : s === "end" ? j - G + W + N : s === "nearest" ? Wi(k, G, ee, m, W + N, j, j + D, D) : j - (k + ee / 2) + N / 2, J = u === "start" ? I - U - K : u === "center" ? I - (U + re / 2) + te / 2 : u === "end" ? I - A + $ + te : Wi(U, A, re, K, $ + te, I, I + B, B);
      const { scrollLeft: de, scrollTop: ge } = R;
      T = ue === 0 ? 0 : Math.max(0, Math.min(ge + T / ue, R.scrollHeight - ee / ue + N)), J = se === 0 ? 0 : Math.max(0, Math.min(de + J / se, R.scrollWidth - re / se + te)), j += ge - T, I += de - J;
    }
    z.push({ el: R, top: T, left: J });
  }
  return z;
}, VP = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function qP(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(og(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: a } of og(e, VP(t))) {
    const s = i - n.top + n.bottom, u = a - n.left + n.right;
    o.scroll({ top: s, left: u, behavior: r });
  }
}
var Jr = [], ZP = function() {
  return Jr.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, GP = function() {
  return Jr.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, ig = "ResizeObserver loop completed with undelivered notifications.", KP = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: ig
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = ig), window.dispatchEvent(e);
}, ri;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(ri || (ri = {}));
var Qr = function(e) {
  return Object.freeze(e);
}, YP = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Qr(this);
  }
  return e;
}(), Uy = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Qr(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, u = t.width, l = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: u, height: l };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), bc = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, Wy = function(e) {
  if (bc(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, a = o.offsetHeight;
  return !(i || a || e.getClientRects().length);
}, ag = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, XP = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, Wo = typeof window < "u" ? window : {}, Hi = /* @__PURE__ */ new WeakMap(), sg = /auto|scroll/, JP = /^tb|vertical/, QP = /msie|trident/i.test(Wo.navigator && Wo.navigator.userAgent), Wn = function(e) {
  return parseFloat(e || "0");
}, fo = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new YP((n ? t : e) || 0, (n ? e : t) || 0);
}, ug = Qr({
  devicePixelContentBoxSize: fo(),
  borderBoxSize: fo(),
  contentBoxSize: fo(),
  contentRect: new Uy(0, 0, 0, 0)
}), Hy = function(e, t) {
  if (t === void 0 && (t = !1), Hi.has(e) && !t)
    return Hi.get(e);
  if (Wy(e))
    return Hi.set(e, ug), ug;
  var n = getComputedStyle(e), r = bc(e) && e.ownerSVGElement && e.getBBox(), o = !QP && n.boxSizing === "border-box", i = JP.test(n.writingMode || ""), a = !r && sg.test(n.overflowY || ""), s = !r && sg.test(n.overflowX || ""), u = r ? 0 : Wn(n.paddingTop), l = r ? 0 : Wn(n.paddingRight), c = r ? 0 : Wn(n.paddingBottom), f = r ? 0 : Wn(n.paddingLeft), p = r ? 0 : Wn(n.borderTopWidth), g = r ? 0 : Wn(n.borderRightWidth), v = r ? 0 : Wn(n.borderBottomWidth), h = r ? 0 : Wn(n.borderLeftWidth), d = f + l, w = u + c, L = h + g, D = p + v, B = s ? e.offsetHeight - D - e.clientHeight : 0, b = a ? e.offsetWidth - L - e.clientWidth : 0, E = o ? d + L : 0, O = o ? w + D : 0, S = r ? r.width : Wn(n.width) - E - b, V = r ? r.height : Wn(n.height) - O - B, M = S + d + b + L, q = V + w + B + D, _ = Qr({
    devicePixelContentBoxSize: fo(Math.round(S * devicePixelRatio), Math.round(V * devicePixelRatio), i),
    borderBoxSize: fo(M, q, i),
    contentBoxSize: fo(S, V, i),
    contentRect: new Uy(f, u, S, V)
  });
  return Hi.set(e, _), _;
}, Vy = function(e, t, n) {
  var r = Hy(e, n), o = r.borderBoxSize, i = r.contentBoxSize, a = r.devicePixelContentBoxSize;
  switch (t) {
    case ri.DEVICE_PIXEL_CONTENT_BOX:
      return a;
    case ri.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, eB = /* @__PURE__ */ function() {
  function e(t) {
    var n = Hy(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = Qr([n.borderBoxSize]), this.contentBoxSize = Qr([n.contentBoxSize]), this.devicePixelContentBoxSize = Qr([n.devicePixelContentBoxSize]);
  }
  return e;
}(), qy = function(e) {
  if (Wy(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, tB = function() {
  var e = 1 / 0, t = [];
  Jr.forEach(function(a) {
    if (a.activeTargets.length !== 0) {
      var s = [];
      a.activeTargets.forEach(function(l) {
        var c = new eB(l.target), f = qy(l.target);
        s.push(c), l.lastReportedSize = Vy(l.target, l.observedBox), f < e && (e = f);
      }), t.push(function() {
        a.callback.call(a.observer, s, a.observer);
      }), a.activeTargets.splice(0, a.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, lg = function(e) {
  Jr.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (qy(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, nB = function() {
  var e = 0;
  for (lg(e); ZP(); )
    e = tB(), lg(e);
  return GP() && KP(), e > 0;
}, fu, Zy = [], rB = function() {
  return Zy.splice(0).forEach(function(e) {
    return e();
  });
}, oB = function(e) {
  if (!fu) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return rB();
    }).observe(n, r), fu = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  Zy.push(e), fu();
}, iB = function(e) {
  oB(function() {
    requestAnimationFrame(e);
  });
}, ua = 0, aB = function() {
  return !!ua;
}, sB = 250, uB = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, cg = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], fg = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, du = !1, lB = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = sB), !du) {
      du = !0;
      var r = fg(t);
      iB(function() {
        var o = !1;
        try {
          o = nB();
        } finally {
          if (du = !1, t = r - fg(), !aB())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, uB);
    };
    document.body ? n() : Wo.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), cg.forEach(function(n) {
      return Wo.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), cg.forEach(function(n) {
      return Wo.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), sl = new lB(), dg = function(e) {
  !ua && e > 0 && sl.start(), ua += e, !ua && sl.stop();
}, cB = function(e) {
  return !bc(e) && !XP(e) && getComputedStyle(e).display === "inline";
}, fB = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || ri.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = Vy(this.target, this.observedBox, !0);
    return cB(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), dB = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Vi = /* @__PURE__ */ new WeakMap(), pg = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, qi = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new dB(t, n);
    Vi.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = Vi.get(t), i = o.observationTargets.length === 0;
    pg(o.observationTargets, n) < 0 && (i && Jr.push(o), o.observationTargets.push(new fB(n, r && r.box)), dg(1), sl.schedule());
  }, e.unobserve = function(t, n) {
    var r = Vi.get(t), o = pg(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && Jr.splice(Jr.indexOf(r), 1), r.observationTargets.splice(o, 1), dg(-1));
  }, e.disconnect = function(t) {
    var n = this, r = Vi.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), pB = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    qi.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!ag(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    qi.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!ag(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    qi.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    qi.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function hB(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function go(e, t) {
  if (e == null) return {};
  var n = hB(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function oi(e) {
  "@babel/helpers - typeof";
  return oi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, oi(e);
}
function gB(e, t) {
  if (oi(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (oi(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function vB(e) {
  var t = gB(e, "string");
  return oi(t) === "symbol" ? t : String(t);
}
function Fn(e, t, n) {
  return t = vB(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Cc = /* @__PURE__ */ ht(null), Fr = () => {
  var e = Ae(Cc);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, pu, hu, Gy = parseInt(Se.version.split(".")[0], 10), Ky = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, hg = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), nn = typeof navigator < "u" && /Android/.test(navigator.userAgent), co = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Vr = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), mB = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), Yy = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), yB = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), bB = nn && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), CB = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), wB = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), EB = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), la = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((pu = navigator.userAgent.match(/Version\/(\d+)/)) !== null && pu !== void 0 && pu[1] && parseInt((hu = navigator.userAgent.match(/Version\/(\d+)/)) === null || hu === void 0 ? void 0 : hu[1], 10) < 17);
var hr = (!yB || !bB) && !mB && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", wc = /* @__PURE__ */ new WeakMap(), Ec = /* @__PURE__ */ new WeakMap(), Xy = /* @__PURE__ */ new WeakMap(), ca = /* @__PURE__ */ new WeakMap(), ul = /* @__PURE__ */ new WeakMap(), ii = /* @__PURE__ */ new WeakMap(), eo = /* @__PURE__ */ new WeakMap(), Ba = /* @__PURE__ */ new WeakMap(), ds = /* @__PURE__ */ new WeakMap(), ll = /* @__PURE__ */ new WeakMap(), Or = /* @__PURE__ */ new WeakMap(), Xr = /* @__PURE__ */ new WeakMap(), Ho = /* @__PURE__ */ new WeakMap(), cl = /* @__PURE__ */ new WeakMap(), Dc = /* @__PURE__ */ new WeakMap(), zn = /* @__PURE__ */ new WeakMap(), ir = /* @__PURE__ */ new WeakMap(), sn = /* @__PURE__ */ new WeakMap(), wr = /* @__PURE__ */ new WeakMap(), Er = /* @__PURE__ */ new WeakMap(), Jy = /* @__PURE__ */ new WeakMap(), vo = Symbol("placeholder"), Qy = Symbol("mark-placeholder"), e0 = globalThis.Node, DB = globalThis.Text, xc = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, xB = (e) => kr(e) && e.nodeType === 8, An = (e) => kr(e) && e.nodeType === 1, kr = (e) => {
  var t = xc(e);
  return !!t && e instanceof t.Node;
}, fl = (e) => {
  var t = e && e.anchorNode && xc(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, t0 = (e) => kr(e) && e.nodeType === 3, LB = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, OB = (e) => {
  var [t, n] = e;
  if (An(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = n0(t, o, r ? "backward" : "forward"), r = o < n; An(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = kB(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, SB = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, n0 = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (xB(o) || An(o) && o.childNodes.length === 0 || An(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, kB = (e, t, n) => {
  var [r] = n0(e, t, n);
  return r;
}, r0 = (e) => {
  var t = "";
  if (t0(e) && e.nodeValue)
    return e.nodeValue;
  if (An(e)) {
    for (var n of Array.from(e.childNodes))
      t += r0(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, MB = /data-slate-fragment="(.+?)"/m, PB = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(MB) || [];
  return n;
}, Vo = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Lc = (e, t, n) => {
  var {
    target: r
  } = t;
  if (An(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = oe.getWindow(e);
  if (o.contains(r))
    return oe.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: u
    } = a;
    for (var l of s)
      if (l === r || l.contains(r))
        return !0;
    for (var c of u)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Lc(e, i, n);
}, BB = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, gg = (e, t) => !!(e.compareDocumentPosition(t) & e0.DOCUMENT_POSITION_PRECEDING), TB = (e, t) => !!(e.compareDocumentPosition(t) & e0.DOCUMENT_POSITION_FOLLOWING), AB = 0;
class FB {
  constructor() {
    Fn(this, "id", void 0), this.id = "".concat(AB++);
  }
}
var oe = {
  androidPendingDiffs: (e) => sn.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = Dc.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = oe.toDOMNode(e, e), n = oe.findDocumentOrShadowRoot(e);
    Or.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = oe.findDocumentOrShadowRoot(e), r = Vo(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && le.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = oe.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = oe.toSlateNode(e, t.target), a = oe.findPath(e, i);
    if (xe.isElement(i) && x.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), u = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, l = x.point(e, a, {
        edge: u ? "start" : "end"
      }), c = u ? x.before(e, l) : x.after(e, l);
      if (c) {
        var f = x.range(e, c);
        return f;
      }
    }
    var p, {
      document: g
    } = oe.getWindow(e);
    if (g.caretRangeFromPoint)
      p = g.caretRangeFromPoint(n, r);
    else {
      var v = g.caretPositionFromPoint(n, r);
      v && (p = g.createRange(), p.setStart(v.offsetNode, v.offset), p.setEnd(v.offsetNode, v.offset));
    }
    if (!p)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var h = oe.toSlateRange(e, p, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return h;
  },
  findKey: (e, t) => {
    var n = Ba.get(t);
    return n || (n = new FB(), Ba.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = Ec.get(r);
      if (o == null) {
        if (x.isEditor(r))
          return n;
        break;
      }
      var i = wc.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(qt.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Or.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          oe.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = oe.toDOMNode(t, t), o = oe.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = Vo(o), a = oe.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(a);
        }
        t.selection || le.select(t, x.start(t, [])), Or.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Xy.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = oe.toDOMNode(t, t), a;
    try {
      a = An(n) ? n : n.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return a ? a.closest("[data-slate-editor]") === i && (!o || a.isContentEditable ? !0 : typeof a.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    a.closest('[contenteditable="false"]') === i || !!a.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => kr(t) && oe.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return x.hasPath(e, n.path) && x.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => oe.hasEditableTarget(e, t) || oe.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => kr(t) && oe.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Xr.get(e),
  isFocused: (e) => !!Or.get(e),
  isReadOnly: (e) => !!ll.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (ll.get(e)) return !1;
    var n = oe.hasTarget(e, t) && oe.toSlateNode(e, t);
    return xe.isElement(n) && x.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = ds.get(e), r = x.isEditor(t) ? ca.get(e) : n == null ? void 0 : n.get(oe.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(qt.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = x.node(e, t.path), r = oe.toDOMNode(e, n), o;
    x.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, u = 0; u < a.length; u++) {
      var l = a[u], c = l.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: f
        } = c.textContent, p = l.getAttribute("data-slate-length"), g = p == null ? f : parseInt(p, 10), v = s + g, h = a[u + 1];
        if (t.offset === v && h !== null && h !== void 0 && h.hasAttribute("data-slate-mark-placeholder")) {
          var d, w = h.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            w instanceof DB ? w : h,
            (d = h.textContent) !== null && d !== void 0 && d.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= v) {
          var L = Math.min(f, Math.max(0, t.offset - s));
          o = [c, L];
          break;
        }
        s = v;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(qt.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = ne.isBackward(t), i = oe.toDOMPoint(e, n), a = ne.isCollapsed(t) ? i : oe.toDOMPoint(e, r), s = oe.getWindow(e), u = s.document.createRange(), [l, c] = o ? a : i, [f, p] = o ? i : a, g = An(l) ? l : l.parentElement, v = !!g.getAttribute("data-slate-zero-width"), h = An(f) ? f : f.parentElement, d = !!h.getAttribute("data-slate-zero-width");
    return u.setStart(l, v ? 1 : c), u.setEnd(f, d ? 1 : p), u;
  },
  toSlateNode: (e, t) => {
    var n = An(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? ii.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : OB(t), u = a.parentNode, l = null, c = 0;
    if (u) {
      var f, p, g = oe.toDOMNode(e, e), v = u.closest('[data-slate-void="true"]'), h = v && g.contains(v) ? v : null, d = u.closest('[contenteditable="false"]'), w = d && g.contains(d) ? d : null, L = u.closest("[data-slate-leaf]"), D = null;
      if (L) {
        if (l = L.closest('[data-slate-node="text"]'), l) {
          var B = oe.getWindow(e), b = B.document.createRange();
          b.setStart(l, 0), b.setEnd(a, s);
          var E = b.cloneContents(), O = [...Array.prototype.slice.call(E.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(E.querySelectorAll("[contenteditable=false]"))];
          O.forEach((U) => {
            if (nn && !r && U.hasAttribute("data-slate-zero-width") && U.textContent.length > 0 && U.textContext !== "\uFEFF") {
              U.textContent.startsWith("\uFEFF") && (U.textContent = U.textContent.slice(1));
              return;
            }
            U.parentNode.removeChild(U);
          }), c = E.textContent.length, D = l;
        }
      } else if (h) {
        for (var S = h.querySelectorAll("[data-slate-leaf]"), V = 0; V < S.length; V++) {
          var M = S[V];
          if (oe.hasDOMNode(e, M)) {
            L = M;
            break;
          }
        }
        L ? (l = L.closest('[data-slate-node="text"]'), D = L, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((U) => {
          c -= U.textContent.length;
        })) : c = 1;
      } else if (w) {
        var q = (U) => U ? U.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], _ = w.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var j, I = [...q(_), ...q(_ == null ? void 0 : _.nextElementSibling)];
          L = (j = I.find((U) => TB(w, U))) !== null && j !== void 0 ? j : null;
        } else {
          var z, X = [...q(_ == null ? void 0 : _.previousElementSibling), ...q(_)];
          L = (z = X.findLast((U) => gg(w, U))) !== null && z !== void 0 ? z : null;
        }
        L && (l = L.closest('[data-slate-node="text"]'), D = L, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((U) => {
          c -= U.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      nn && D.getAttribute("data-slate-zero-width") === "z" && (f = D.textContent) !== null && f !== void 0 && f.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (u.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      co && (p = D.textContent) !== null && p !== void 0 && p.endsWith(`

`)) && c--;
    }
    if (nn && !l && !r) {
      var R = u.hasAttribute("data-slate-node") ? u : u.closest("[data-slate-node]");
      if (R && oe.hasDOMNode(e, R, {
        editable: !0
      })) {
        var ee = oe.toSlateNode(e, R), {
          path: re,
          offset: k
        } = x.start(e, oe.findPath(e, ee));
        return R.querySelector("[data-slate-leaf]") || (k = s), {
          path: re,
          offset: k
        };
      }
    }
    if (!l) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var A = oe.toSlateNode(e, l), G = oe.findPath(e, A);
    return {
      path: G,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = fl(t) ? t.anchorNode : t.startContainer, s, u, l, c, f;
    if (a)
      if (fl(t)) {
        if (co && t.rangeCount > 1) {
          l = t.focusNode;
          var p = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (l instanceof HTMLTableRowElement && p.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let E = function(O) {
              return O.childElementCount > 0 ? E(O.children[0]) : O;
            };
            var v = p.startContainer, h = g.startContainer, d = E(v.children[p.startOffset]), w = E(h.children[g.startOffset]);
            c = 0, w.childNodes.length > 0 ? s = w.childNodes[0] : s = w, d.childNodes.length > 0 ? l = d.childNodes[0] : l = d, w instanceof HTMLElement ? u = w.innerHTML.length : u = 0;
          } else
            p.startContainer === l ? (s = g.endContainer, u = g.endOffset, c = p.startOffset) : (s = p.startContainer, u = p.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, u = t.anchorOffset, l = t.focusNode, c = t.focusOffset;
        Yy && SB(s) || co ? f = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : f = t.isCollapsed;
      } else
        s = t.startContainer, u = t.startOffset, l = t.endContainer, c = t.endOffset, f = t.collapsed;
    if (s == null || l == null || u == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    co && (r = l.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === l.textContent.length && c--;
    var L = oe.toSlatePoint(e, [s, u], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!L)
      return null;
    var D = gg(s, l) || s === l && c < u, B = f ? L : oe.toSlatePoint(e, [l, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!B)
      return null;
    var b = {
      anchor: L,
      focus: B
    };
    return ne.isExpanded(b) && ne.isForward(b) && An(l) && x.void(e, {
      at: b.focus,
      mode: "highest"
    }) && (b = x.unhangRange(e, b, {
      voids: !0
    })), b;
  }
};
function IB(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!x.hasPath(e, n))
    return !1;
  var o = ve.get(e, n);
  if (!Oe.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = H.next(n);
  if (!x.hasPath(e, i))
    return !1;
  var a = ve.get(e, i);
  return Oe.isText(a) && a.text.startsWith(r.text);
}
function o0(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function RB(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function _B(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function i0(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), a = RB(i, o), s = Math.min(i.length - a, o.length - a), u = _B(i, o, s), l = {
    start: n + a,
    end: r - u,
    text: o.slice(a, o.length - u)
  };
  return l.start === l.end && l.text.length === 0 ? null : l;
}
function jB(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = o0(e, t, n), a = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), s = i.slice(r, a), u = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return i0(e, {
    start: r,
    end: u,
    text: s
  });
}
function NB(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function dl(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!x.hasPath(e, n))
    return null;
  var o = ve.get(e, n);
  if (!Oe.isText(o))
    return null;
  var i = x.above(e, {
    match: (s) => xe.isElement(s) && x.isBlock(e, s),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var a = x.next(e, {
      at: n,
      match: Oe.isText
    });
    if (!a || !H.isDescendant(a[1], i[1]))
      return null;
    r -= o.text.length, o = a[0], n = a[1];
  }
  return {
    path: n,
    offset: r
  };
}
function vg(e, t) {
  var n = dl(e, t.anchor);
  if (!n)
    return null;
  if (ne.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = dl(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function pl(e, t, n) {
  var r = sn.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: f
    } = c;
    return H.equals(f, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return qe.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var a = {
      path: t.path,
      offset: i.start
    }, s = qe.transform(a, n, {
      affinity: "backward"
    });
    return s ? {
      path: s.path,
      offset: s.offset + t.offset - i.start
    } : null;
  }
  var u = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, l = qe.transform(u, n, {
    affinity: "backward"
  });
  return l ? n.type === "split_node" && H.equals(n.path, t.path) && u.offset < n.position && i.start < n.position ? l : {
    path: l.path,
    offset: l.offset + i.text.length - i.end + i.start
  } : null;
}
function mg(e, t, n) {
  var r = pl(e, t.anchor, n);
  if (!r)
    return null;
  if (ne.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = pl(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function zB(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !H.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !H.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !H.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: H.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: H.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return H.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: H.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: H.transform(n, t)
      };
  }
  var i = H.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function yg(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yg(Object(n), !0).forEach(function(r) {
      Fn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yg(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $B = 25, UB = 200, WB = function() {
}, HB = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function VB(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, a = null, s = null, u = 0, l = !1, c = () => {
    var _ = Er.get(t);
    if (Er.delete(t), _) {
      var {
        selection: j
      } = t, I = vg(t, _);
      I && (!j || !ne.equals(I, j)) && le.select(t, I);
    }
  }, f = () => {
    var _ = wr.get(t);
    if (wr.delete(t), !!_) {
      if (_.at) {
        var j = qe.isPoint(_.at) ? dl(t, _.at) : vg(t, _.at);
        if (!j)
          return;
        var I = x.range(t, j);
        (!t.selection || !ne.equals(t.selection, I)) && le.select(t, j);
      }
      _.run();
    }
  }, p = () => {
    if (a && (clearTimeout(a), a = null), s && (clearTimeout(s), s = null), !B() && !D()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), D() && (o = "action");
    var _ = t.selection && x.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    ir.set(t, t.marks), WB("flush", wr.get(t), sn.get(t));
    for (var j = B(), I; I = (z = sn.get(t)) === null || z === void 0 ? void 0 : z[0]; ) {
      var z, X, R = zn.get(t);
      R !== void 0 && (zn.delete(t), t.marks = R), R && l === !1 && (l = null);
      var ee = NB(I);
      (!t.selection || !ne.equals(t.selection, ee)) && le.select(t, ee), I.diff.text ? x.insertText(t, I.diff.text) : x.deleteFragment(t), sn.set(t, (X = sn.get(t)) === null || X === void 0 ? void 0 : X.filter((A) => {
        var {
          id: G
        } = A;
        return G !== I.id;
      })), IB(t, I) || (j = !1, wr.delete(t), ir.delete(t), o = "action", Er.delete(t), n.cancel(), r.cancel(), _ == null || _.unref());
    }
    var re = _ == null ? void 0 : _.unref();
    if (re && !Er.get(t) && (!t.selection || !ne.equals(re, t.selection)) && le.select(t, re), D()) {
      f();
      return;
    }
    j && n(), n.flush(), r.flush(), c();
    var k = ir.get(t);
    ir.delete(t), k !== void 0 && (t.marks = k, t.onChange());
  }, g = (_) => {
    i && clearTimeout(i), i = setTimeout(() => {
      Xr.set(t, !1), p();
    }, $B);
  }, v = (_) => {
    Xr.set(t, !0), i && (clearTimeout(i), i = null);
  }, h = function() {
    var j = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, I = ul.get(t);
    if (I) {
      if (B() || j) {
        I.style.display = "none";
        return;
      }
      I.style.removeProperty("display");
    }
  }, d = (_, j) => {
    var I, z = (I = sn.get(t)) !== null && I !== void 0 ? I : [];
    sn.set(t, z);
    var X = ve.leaf(t, _), R = z.findIndex((k) => H.equals(k.path, _));
    if (R < 0) {
      var ee = i0(X.text, j);
      ee && z.push({
        path: _,
        diff: j,
        id: u++
      }), h();
      return;
    }
    var re = jB(X.text, z[R].diff, j);
    if (!re) {
      z.splice(R, 1), h();
      return;
    }
    z[R] = Zi(Zi({}, z[R]), {}, {
      diff: re
    });
  }, w = function(j) {
    var {
      at: I
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    l = !1, Er.delete(t), n.cancel(), r.cancel(), D() && p(), wr.set(t, {
      at: I,
      run: j
    }), s = setTimeout(p);
  }, L = (_) => {
    var j;
    a && (clearTimeout(a), a = null);
    var {
      inputType: I
    } = _, z = null, X = _.dataTransfer || _.data || void 0;
    l !== !1 && I !== "insertText" && I !== "insertCompositionText" && (l = !1);
    var [R] = _.getTargetRanges();
    R && (z = oe.toSlateRange(t, R, {
      exactMatch: !1,
      suppressThrow: !0
    }));
    var ee = oe.getWindow(t), re = ee.getSelection();
    if (!z && re && (R = re, z = oe.toSlateRange(t, re, {
      exactMatch: !1,
      suppressThrow: !0
    })), z = (j = z) !== null && j !== void 0 ? j : t.selection, !!z) {
      var k = !0;
      if (I.startsWith("delete")) {
        if (ne.isExpanded(z)) {
          var [A, G] = ne.edges(z), U = ve.leaf(t, A.path);
          if (U.text.length === A.offset && G.offset === 0) {
            var Y = x.next(t, {
              at: A.path,
              match: Oe.isText
            });
            Y && H.equals(Y[1], G.path) && (z = {
              anchor: G,
              focus: G
            });
          }
        }
        var K = I.endsWith("Backward") ? "backward" : "forward", [m, $] = ne.edges(z), [W, T] = x.leaf(t, m.path), J = {
          text: "",
          start: m.offset,
          end: $.offset
        }, te = sn.get(t), N = te == null ? void 0 : te.find((Ye) => H.equals(Ye.path, T)), se = N ? [N.diff, J] : [J], ue = o0(W.text, ...se);
        if (ue.length === 0 && (k = !1), ne.isExpanded(z)) {
          if (k && H.equals(z.anchor.path, z.focus.path)) {
            var de = {
              path: z.anchor.path,
              offset: m.offset
            }, ge = x.range(t, de, de);
            return O(ge), d(z.anchor.path, {
              text: "",
              end: $.offset,
              start: m.offset
            });
          }
          return w(() => x.deleteFragment(t, {
            direction: K
          }), {
            at: z
          });
        }
      }
      switch (I) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag":
          return w(() => x.deleteFragment(t), {
            at: z
          });
        case "deleteContent":
        case "deleteContentForward": {
          var {
            anchor: Ce
          } = z;
          if (k && ne.isCollapsed(z)) {
            var me = ve.leaf(t, Ce.path);
            if (Ce.offset < me.text.length)
              return d(Ce.path, {
                text: "",
                start: Ce.offset,
                end: Ce.offset + 1
              });
          }
          return w(() => x.deleteForward(t), {
            at: z
          });
        }
        case "deleteContentBackward": {
          var ye, {
            anchor: ce
          } = z, Me = fl(R) ? R.isCollapsed : !!((ye = R) !== null && ye !== void 0 && ye.collapsed);
          return k && Me && ne.isCollapsed(z) && ce.offset > 0 ? d(ce.path, {
            text: "",
            start: ce.offset - 1,
            end: ce.offset
          }) : w(() => x.deleteBackward(t), {
            at: z
          });
        }
        case "deleteEntireSoftLine":
          return w(() => {
            x.deleteBackward(t, {
              unit: "line"
            }), x.deleteForward(t, {
              unit: "line"
            });
          }, {
            at: z
          });
        case "deleteHardLineBackward":
          return w(() => x.deleteBackward(t, {
            unit: "block"
          }), {
            at: z
          });
        case "deleteSoftLineBackward":
          return w(() => x.deleteBackward(t, {
            unit: "line"
          }), {
            at: z
          });
        case "deleteHardLineForward":
          return w(() => x.deleteForward(t, {
            unit: "block"
          }), {
            at: z
          });
        case "deleteSoftLineForward":
          return w(() => x.deleteForward(t, {
            unit: "line"
          }), {
            at: z
          });
        case "deleteWordBackward":
          return w(() => x.deleteBackward(t, {
            unit: "word"
          }), {
            at: z
          });
        case "deleteWordForward":
          return w(() => x.deleteForward(t, {
            unit: "word"
          }), {
            at: z
          });
        case "insertLineBreak":
          return w(() => x.insertSoftBreak(t), {
            at: z
          });
        case "insertParagraph":
          return w(() => x.insertBreak(t), {
            at: z
          });
        case "insertCompositionText":
        case "deleteCompositionText":
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          if (HB(X))
            return w(() => oe.insertData(t, X), {
              at: z
            });
          var ie = X ?? "";
          if (zn.get(t) && (ie = ie.replace("\uFEFF", "")), I === "insertText" && /.*\n.*\n$/.test(ie) && (ie = ie.slice(0, -1)), ie.includes(`
`))
            return w(() => {
              var Ye = ie.split(`
`);
              Ye.forEach((we, Ct) => {
                we && x.insertText(t, we), Ct !== Ye.length - 1 && x.insertSoftBreak(t);
              });
            }, {
              at: z
            });
          if (H.equals(z.anchor.path, z.focus.path)) {
            var [Re, ae] = ne.edges(z), Le = {
              start: Re.offset,
              end: ae.offset,
              text: ie
            };
            if (ie && l && I === "insertCompositionText") {
              var Fe = l.start + l.text.search(/\S|$/), ze = Le.start + Le.text.search(/\S|$/);
              ze === Fe + 1 && Le.end === l.start + l.text.length ? (Le.start -= 1, l = null, M()) : l = !1;
            } else I === "insertText" ? l === null ? l = Le : l && ne.isCollapsed(z) && l.end + l.text.length === Re.offset ? l = Zi(Zi({}, l), {}, {
              text: l.text + ie
            }) : l = !1 : l = !1;
            if (k) {
              d(Re.path, Le);
              return;
            }
          }
          return w(() => x.insertText(t, ie), {
            at: z
          });
        }
      }
    }
  }, D = () => !!wr.get(t), B = () => {
    var _;
    return !!((_ = sn.get(t)) !== null && _ !== void 0 && _.length);
  }, b = () => D() || B(), E = () => o, O = (_) => {
    Er.set(t, _), a && (clearTimeout(a), a = null);
    var {
      selection: j
    } = t;
    if (_) {
      var I = !j || !H.equals(j.anchor.path, _.anchor.path), z = !j || !H.equals(j.anchor.path.slice(0, -1), _.anchor.path.slice(0, -1));
      (I && l || z) && (l = !1), (I || B()) && (a = setTimeout(p, UB));
    }
  }, S = () => {
    (D() || !B()) && p();
  }, V = (_) => {
    B() || (h(!0), setTimeout(h));
  }, M = () => {
    D() || (s = setTimeout(p));
  }, q = (_) => {
    if (!(B() || D()) && _.some((I) => Lc(t, I, _))) {
      var j;
      (j = Jy.get(t)) === null || j === void 0 || j();
    }
  };
  return {
    flush: p,
    scheduleFlush: M,
    hasPendingDiffs: B,
    hasPendingAction: D,
    hasPendingChanges: b,
    isFlushing: E,
    handleUserSelect: O,
    handleCompositionEnd: g,
    handleCompositionStart: v,
    handleDOMBeforeInput: L,
    handleKeyDown: V,
    handleDomMutations: q,
    handleInput: S
  };
}
function qB() {
  var e = rt(!1);
  return y(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var ai = la ? gb : y;
function ZB(e, t, n) {
  var [r] = P(() => new MutationObserver(t));
  ai(() => {
    r.takeRecords();
  }), y(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var GB = ["node"];
function bg(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function KB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bg(Object(n), !0).forEach(function(r) {
      Fn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bg(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YB = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, XB = nn ? (e) => {
  var {
    node: t
  } = e, n = go(e, GB);
  if (!nn)
    return null;
  var r = Fr(), o = qB(), [i] = P(() => VB(KB({
    editor: r
  }, n)));
  return ZB(t, i.handleDomMutations, YB), Dc.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, JB = ["anchor", "focus"], QB = ["anchor", "focus"], eT = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), a0 = (e, t) => {
  var n = go(e, JB), r = go(t, QB);
  return e[vo] === t[vo] && eT(n, r);
}, tT = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!ne.equals(r, o) || !a0(r, o))
      return !1;
  }
  return !0;
}, nT = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !a0(r, o))
      return !1;
  }
  return !0;
};
function Cg(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Cg(Object(n), !0).forEach(function(r) {
      Fn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Cg(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oT = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = Fr(), a = oe.findPath(i, o), s = H.parent(a), u = !!n[Qy];
  return i.isVoid(r) ? /* @__PURE__ */ Se.createElement(gu, {
    length: ve.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && x.string(i, s) === "" ? /* @__PURE__ */ Se.createElement(gu, {
    isLineBreak: !0,
    isMarkPlaceholder: u
  }) : n.text === "" ? /* @__PURE__ */ Se.createElement(gu, {
    isMarkPlaceholder: u
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ Se.createElement(wg, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ Se.createElement(wg, {
    text: n.text
  });
}, wg = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = rt(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = P(o);
  return ai(() => {
    var a = o();
    r.current && r.current.textContent !== a && (r.current.textContent = a);
  }), /* @__PURE__ */ Se.createElement(iT, {
    ref: r
  }, i);
}, iT = /* @__PURE__ */ Ze(/* @__PURE__ */ _a((e, t) => /* @__PURE__ */ Se.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), gu = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ Se.createElement("span", rT({}, o), !(nn || Ky) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ Se.createElement("br", null) : null);
};
function Eg(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function s0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Eg(Object(n), !0).forEach(function(r) {
      Fn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Eg(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aT = nn ? 300 : 0;
function sT(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function Dg(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var uT = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: a = (L) => /* @__PURE__ */ Se.createElement(cT, s0({}, L))
  } = e, s = Fr(), u = rt(null), l = rt(null), [c, f] = P(!1), p = rt(null), g = dt((L) => {
    if (sT(u, L == null), L == null) {
      var D;
      ul.delete(s), (D = t.onPlaceholderResize) === null || D === void 0 || D.call(t, null);
    } else {
      if (ul.set(s, L), !u.current) {
        var B = window.ResizeObserver || pB;
        u.current = new B(() => {
          var b;
          (b = t.onPlaceholderResize) === null || b === void 0 || b.call(t, L);
        });
      }
      u.current.observe(L), l.current = L;
    }
  }, [l, t, s]), v = /* @__PURE__ */ Se.createElement(oT, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), h = !!t[vo];
  if (y(() => (h ? p.current || (p.current = setTimeout(() => {
    f(!0), p.current = null;
  }, aT)) : (Dg(p), f(!1)), () => Dg(p)), [h, f]), h && c) {
    var d = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: Vr ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: g
      }
    };
    v = /* @__PURE__ */ Se.createElement(Se.Fragment, null, i(d), v);
  }
  var w = {
    "data-slate-leaf": !0
  };
  return a({
    attributes: w,
    children: v,
    leaf: t,
    text: r
  });
}, lT = /* @__PURE__ */ Se.memo(uT, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && Oe.equals(t.leaf, e.leaf) && t.leaf[vo] === e.leaf[vo]), cT = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ Se.createElement("span", s0({}, t), n);
}, fT = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: a
  } = e, s = Fr(), u = rt(null), l = Oe.decorations(a, t), c = oe.findKey(s, a), f = [], p = 0; p < l.length; p++) {
    var g = l[p];
    f.push(/* @__PURE__ */ Se.createElement(lT, {
      isLast: n && p === l.length - 1,
      key: "".concat(c.id, "-").concat(p),
      renderPlaceholder: o,
      leaf: g,
      text: a,
      parent: r,
      renderLeaf: i
    }));
  }
  var v = dt((h) => {
    var d = ds.get(s);
    h ? (d == null || d.set(c, h), eo.set(a, h), ii.set(h, a)) : (d == null || d.delete(c), eo.delete(a), u.current && ii.delete(u.current)), u.current = h;
  }, [u, s, c, a]);
  return /* @__PURE__ */ Se.createElement("span", {
    "data-slate-node": "text",
    ref: v
  }, f);
}, u0 = /* @__PURE__ */ Se.memo(fT, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && nT(t.decorations, e.decorations));
function xg(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xg(Object(n), !0).forEach(function(r) {
      Fn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xg(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dT = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (L) => /* @__PURE__ */ Se.createElement(hT, hl({}, L)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = Fr(), u = mT(), l = s.isInline(n), c = oe.findKey(s, n), f = dt((L) => {
    var D = ds.get(s);
    L ? (D == null || D.set(c, L), eo.set(n, L), ii.set(L, n)) : (D == null || D.delete(c), eo.delete(n));
  }, [s, c, n]), p = c0({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  }), g = {
    "data-slate-node": "element",
    ref: f
  };
  if (l && (g["data-slate-inline"] = !0), !l && x.hasInlines(s, n)) {
    var v = ve.string(n), h = _y(v);
    h === "rtl" && (g.dir = h);
  }
  if (x.isVoid(s, n)) {
    g["data-slate-void"] = !0, !u && l && (g.contentEditable = !1);
    var d = l ? "span" : "div", [[w]] = ve.texts(n);
    p = /* @__PURE__ */ Se.createElement(d, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ Se.createElement(u0, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: w
    })), wc.set(w, 0), Ec.set(w, n);
  }
  return r({
    attributes: g,
    children: p,
    element: n
  });
}, pT = /* @__PURE__ */ Se.memo(dT, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && tT(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && ne.equals(e.selection, t.selection))), hT = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = Fr(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ Se.createElement(i, hl(hl({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, l0 = /* @__PURE__ */ ht(() => []), gT = () => Ae(l0), vT = /* @__PURE__ */ ht(!1), c0 = (e) => {
  for (var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = gT(), u = Fr(), l = oe.findPath(u, n), c = [], f = xe.isElement(n) && !u.isInline(n) && x.hasInlines(u, n), p = 0; p < n.children.length; p++) {
    var g = l.concat(p), v = n.children[p], h = oe.findKey(u, v), d = x.range(u, g), w = a && ne.intersection(d, a), L = s([v, g]);
    for (var D of t) {
      var B = ne.intersection(D, d);
      B && L.push(B);
    }
    xe.isElement(v) ? c.push(/* @__PURE__ */ Se.createElement(vT.Provider, {
      key: "provider-".concat(h.id),
      value: !!w
    }, /* @__PURE__ */ Se.createElement(pT, {
      decorations: L,
      element: v,
      key: h.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: w
    }))) : c.push(/* @__PURE__ */ Se.createElement(u0, {
      decorations: L,
      key: h.id,
      isLast: f && p === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: v
    })), wc.set(v, p), Ec.set(v, n);
  }
  return c;
}, f0 = /* @__PURE__ */ ht(!1), mT = () => Ae(f0), d0 = /* @__PURE__ */ ht(null), Oc = () => {
  var e = Ae(d0);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function yT() {
  var e = Fr(), t = rt(!1), n = rt(0), r = dt(() => {
    if (!t.current) {
      t.current = !0;
      var o = oe.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return y(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var bT = 3, CT = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, wT = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, ET = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, St = (e) => {
  var t = CT[e], n = wT[e], r = ET[e], o = t && iu(t), i = n && iu(n), a = r && iu(r);
  return (s) => !!(o && o(s) || hg && i && i(s) || !hg && a && a(s));
}, Mt = {
  isBold: St("bold"),
  isCompose: St("compose"),
  isMoveBackward: St("moveBackward"),
  isMoveForward: St("moveForward"),
  isDeleteBackward: St("deleteBackward"),
  isDeleteForward: St("deleteForward"),
  isDeleteLineBackward: St("deleteLineBackward"),
  isDeleteLineForward: St("deleteLineForward"),
  isDeleteWordBackward: St("deleteWordBackward"),
  isDeleteWordForward: St("deleteWordForward"),
  isExtendBackward: St("extendBackward"),
  isExtendForward: St("extendForward"),
  isExtendLineBackward: St("extendLineBackward"),
  isExtendLineForward: St("extendLineForward"),
  isItalic: St("italic"),
  isMoveLineBackward: St("moveLineBackward"),
  isMoveLineForward: St("moveLineForward"),
  isMoveWordBackward: St("moveWordBackward"),
  isMoveWordForward: St("moveWordForward"),
  isRedo: St("redo"),
  isSoftBreak: St("insertSoftBreak"),
  isSplitBlock: St("splitBlock"),
  isTransposeCharacter: St("transposeCharacter"),
  isUndo: St("undo")
}, DT = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((u) => Lc(e, u, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, xT = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class p0 extends Mv {
  constructor() {
    super(...arguments), Fn(this, "context", null), Fn(this, "manager", null), Fn(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, xT);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = DT(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Fn(p0, "contextType", Cc);
var LT = nn ? p0 : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ Se.createElement(Se.Fragment, null, t);
}, OT = /* @__PURE__ */ ht(!1), ST = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], kT = ["text"];
function Lg(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Lg(Object(n), !0).forEach(function(r) {
      Fn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Lg(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var MT = (e) => /* @__PURE__ */ Se.createElement(Se.Fragment, null, c0(e)), PT = /* @__PURE__ */ _a((e, t) => {
  var n = dt((m) => /* @__PURE__ */ Se.createElement(BT, Hn({}, m)), []), {
    autoFocus: r,
    decorate: o = TT,
    onDOMBeforeInput: i,
    placeholder: a,
    readOnly: s = !1,
    renderElement: u,
    renderLeaf: l,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: f = AT,
    style: p = {},
    as: g = "div",
    disableDefaultStyles: v = !1
  } = e, h = go(e, ST), d = Oc(), [w, L] = P(!1), D = rt(null), B = rt([]), [b, E] = P(), O = rt(!1), {
    onUserInput: S,
    receivedUserInput: V
  } = yT(), [, M] = hb((m) => m + 1, 0);
  Jy.set(d, M), ll.set(d, s);
  var q = Ln(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  y(() => {
    D.current && r && D.current.focus();
  }, [r]);
  var _ = rt(), j = Ln(() => WP(() => {
    var m = oe.toDOMNode(d, d), $ = m.getRootNode();
    if (!O.current && Vr && $ instanceof ShadowRoot) {
      O.current = !0;
      var W = BB();
      W ? document.execCommand("indent") : le.deselect(d), O.current = !1;
      return;
    }
    var T = _.current;
    if ((nn || !oe.isComposing(d)) && (!q.isUpdatingSelection || T != null && T.isFlushing()) && !q.isDraggingInternally) {
      var J = oe.findDocumentOrShadowRoot(d), {
        activeElement: te
      } = J, N = oe.toDOMNode(d, d), se = Vo(J);
      if (te === N ? (q.latestElement = te, Or.set(d, !0)) : Or.delete(d), !se)
        return le.deselect(d);
      var {
        anchorNode: ue,
        focusNode: de
      } = se, ge = oe.hasEditableTarget(d, ue) || oe.isTargetInsideNonReadonlyVoid(d, ue), Ce = oe.hasTarget(d, de);
      if (ge && Ce) {
        var me = oe.toSlateRange(d, se, {
          exactMatch: !1,
          suppressThrow: !0
        });
        me && (!oe.isComposing(d) && !(T != null && T.hasPendingChanges()) && !(T != null && T.isFlushing()) ? le.select(d, me) : T == null || T.handleUserSelect(me));
      }
      s && (!ge || !Ce) && le.deselect(d);
    }
  }, 100), [d, s, q]), I = Ln(() => _P(j, 0), [j]);
  _.current = XB({
    node: D,
    onDOMSelectionChange: j,
    scheduleOnDOMSelectionChange: I
  }), ai(() => {
    var m, $, W;
    D.current && (W = xc(D.current)) ? (Xy.set(d, W), ca.set(d, D.current), eo.set(d, D.current), ii.set(D.current, d)) : eo.delete(d);
    var {
      selection: T
    } = d, J = oe.findDocumentOrShadowRoot(d), te = Vo(J);
    if (!(!te || !oe.isFocused(d) || (m = _.current) !== null && m !== void 0 && m.hasPendingAction())) {
      var N = (ge) => {
        var Ce = te.type !== "None";
        if (!(!T && !Ce)) {
          var me = te.focusNode, ye;
          if (co && te.rangeCount > 1) {
            var ce = te.getRangeAt(0), Me = te.getRangeAt(te.rangeCount - 1);
            ce.startContainer === me ? ye = Me.endContainer : ye = ce.startContainer;
          } else
            ye = te.anchorNode;
          var ie = ca.get(d), Re = !1;
          if (ie.contains(ye) && ie.contains(me) && (Re = !0), Ce && Re && T && !ge) {
            var ae = oe.toSlateRange(d, te, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (ae && ne.equals(ae, T)) {
              var Le;
              if (!q.hasMarkPlaceholder || (Le = ye) !== null && Le !== void 0 && (Le = Le.parentElement) !== null && Le !== void 0 && Le.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (T && !oe.hasRange(d, T)) {
            d.selection = oe.toSlateRange(d, te, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          q.isUpdatingSelection = !0;
          var Fe = T && oe.toDOMRange(d, T);
          return Fe ? (oe.isComposing(d) && !nn ? te.collapseToEnd() : ne.isBackward(T) ? te.setBaseAndExtent(Fe.endContainer, Fe.endOffset, Fe.startContainer, Fe.startOffset) : te.setBaseAndExtent(Fe.startContainer, Fe.startOffset, Fe.endContainer, Fe.endOffset), f(d, Fe)) : te.removeAllRanges(), Fe;
        }
      };
      te.rangeCount <= 1 && N();
      var se = (($ = _.current) === null || $ === void 0 ? void 0 : $.isFlushing()) === "action";
      if (!nn || !se) {
        setTimeout(() => {
          q.isUpdatingSelection = !1;
        });
        return;
      }
      var ue = null, de = requestAnimationFrame(() => {
        if (se) {
          var ge = (Ce) => {
            try {
              var me = oe.toDOMNode(d, d);
              me.focus(), N(Ce);
            } catch {
            }
          };
          ge(), ue = setTimeout(() => {
            ge(!0), q.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(de), ue && clearTimeout(ue);
      };
    }
  });
  var z = dt((m) => {
    var $ = oe.toDOMNode(d, d), W = $.getRootNode();
    if (O != null && O.current && Vr && W instanceof ShadowRoot) {
      var T = m.getTargetRanges(), J = T[0], te = new window.Range();
      te.setStart(J.startContainer, J.startOffset), te.setEnd(J.endContainer, J.endOffset);
      var N = oe.toSlateRange(d, te, {
        exactMatch: !1,
        suppressThrow: !1
      });
      le.select(d, N), m.preventDefault(), m.stopImmediatePropagation();
      return;
    }
    if (S(), !s && oe.hasEditableTarget(d, m.target) && !FT(m, i)) {
      var se;
      if (_.current)
        return _.current.handleDOMBeforeInput(m);
      I.flush(), j.flush();
      var {
        selection: ue
      } = d, {
        inputType: de
      } = m, ge = m.dataTransfer || m.data || void 0, Ce = de === "insertCompositionText" || de === "deleteCompositionText";
      if (Ce && oe.isComposing(d))
        return;
      var me = !1;
      if (de === "insertText" && ue && ne.isCollapsed(ue) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      m.data && m.data.length === 1 && /[a-z ]/i.test(m.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      ue.anchor.offset !== 0) {
        var ye, ce;
        me = !0, d.marks && (me = !1);
        var {
          anchor: Me
        } = ue, [ie, Re] = oe.toDOMPoint(d, Me), ae = (ye = ie.parentElement) === null || ye === void 0 ? void 0 : ye.closest("a"), Le = oe.getWindow(d);
        if (me && ae && oe.hasDOMNode(d, ae)) {
          var Fe, ze = Le == null ? void 0 : Le.document.createTreeWalker(ae, NodeFilter.SHOW_TEXT).lastChild();
          ze === ie && ((Fe = ze.textContent) === null || Fe === void 0 ? void 0 : Fe.length) === Re && (me = !1);
        }
        if (me && ie.parentElement && (Le == null || (ce = Le.getComputedStyle(ie.parentElement)) === null || ce === void 0 ? void 0 : ce.whiteSpace) === "pre") {
          var Ye = x.above(d, {
            at: Me.path,
            match: ($t) => xe.isElement($t) && x.isBlock(d, $t)
          });
          Ye && ve.string(Ye[0]).includes("	") && (me = !1);
        }
      }
      if (!de.startsWith("delete") || de.startsWith("deleteBy")) {
        var [we] = m.getTargetRanges();
        if (we) {
          var Ct = oe.toSlateRange(d, we, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!ue || !ne.equals(ue, Ct)) {
            me = !1;
            var ot = !Ce && d.selection && x.rangeRef(d, d.selection);
            le.select(d, Ct), ot && Ho.set(d, ot);
          }
        }
      }
      if (Ce)
        return;
      if (me || m.preventDefault(), ue && ne.isExpanded(ue) && de.startsWith("delete")) {
        var Jt = de.endsWith("Backward") ? "backward" : "forward";
        x.deleteFragment(d, {
          direction: Jt
        });
        return;
      }
      switch (de) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          x.deleteFragment(d);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          x.deleteForward(d);
          break;
        }
        case "deleteContentBackward": {
          x.deleteBackward(d);
          break;
        }
        case "deleteEntireSoftLine": {
          x.deleteBackward(d, {
            unit: "line"
          }), x.deleteForward(d, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          x.deleteBackward(d, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          x.deleteBackward(d, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          x.deleteForward(d, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          x.deleteForward(d, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          x.deleteBackward(d, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          x.deleteForward(d, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          x.insertSoftBreak(d);
          break;
        case "insertParagraph": {
          x.insertBreak(d);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          de === "insertFromComposition" && oe.isComposing(d) && (L(!1), Xr.set(d, !1)), (ge == null ? void 0 : ge.constructor.name) === "DataTransfer" ? oe.insertData(d, ge) : typeof ge == "string" && (me ? B.current.push(() => x.insertText(d, ge)) : x.insertText(d, ge));
          break;
        }
      }
      var _t = (se = Ho.get(d)) === null || se === void 0 ? void 0 : se.unref();
      Ho.delete(d), _t && (!d.selection || !ne.equals(d.selection, _t)) && le.select(d, _t);
    }
  }, [d, j, S, i, s, I]), X = dt((m) => {
    m == null ? (j.cancel(), I.cancel(), ca.delete(d), eo.delete(d), D.current && hr && D.current.removeEventListener("beforeinput", z)) : hr && m.addEventListener("beforeinput", z), D.current = m, typeof t == "function" ? t(m) : t && (t.current = m);
  }, [j, I, d, z, t]);
  ai(() => {
    var m = oe.getWindow(d);
    m.document.addEventListener("selectionchange", I);
    var $ = () => {
      q.isDraggingInternally = !1;
    };
    return m.document.addEventListener("dragend", $), m.document.addEventListener("drop", $), () => {
      m.document.removeEventListener("selectionchange", I), m.document.removeEventListener("dragend", $), m.document.removeEventListener("drop", $);
    };
  }, [I, q]);
  var R = o([d, []]), ee = a && d.children.length === 1 && Array.from(ve.texts(d)).length === 1 && ve.string(d) === "" && !w, re = dt((m) => {
    if (m && ee) {
      var $;
      E(($ = m.getBoundingClientRect()) === null || $ === void 0 ? void 0 : $.height);
    } else
      E(void 0);
  }, [ee]);
  if (ee) {
    var k = x.start(d, []);
    R.push({
      [vo]: !0,
      placeholder: a,
      onPlaceholderResize: re,
      anchor: k,
      focus: k
    });
  }
  var {
    marks: A
  } = d;
  if (q.hasMarkPlaceholder = !1, d.selection && ne.isCollapsed(d.selection) && A) {
    var {
      anchor: G
    } = d.selection, U = ve.leaf(d, G.path), Y = go(U, kT);
    if (!Oe.equals(U, A, {
      loose: !0
    })) {
      q.hasMarkPlaceholder = !0;
      var K = Object.fromEntries(Object.keys(Y).map((m) => [m, null]));
      R.push(Hn(Hn(Hn({
        [Qy]: !0
      }, K), A), {}, {
        anchor: G,
        focus: G
      }));
    }
  }
  return y(() => {
    setTimeout(() => {
      var {
        selection: m
      } = d;
      if (m) {
        var {
          anchor: $
        } = m, W = ve.leaf(d, $.path);
        if (A && !Oe.equals(W, A, {
          loose: !0
        })) {
          zn.set(d, A);
          return;
        }
      }
      zn.delete(d);
    });
  }), /* @__PURE__ */ Se.createElement(f0.Provider, {
    value: s
  }, /* @__PURE__ */ Se.createElement(OT.Provider, {
    value: w
  }, /* @__PURE__ */ Se.createElement(l0.Provider, {
    value: o
  }, /* @__PURE__ */ Se.createElement(LT, {
    node: D,
    receivedUserInput: V
  }, /* @__PURE__ */ Se.createElement(g, Hn(Hn({
    role: s ? void 0 : "textbox",
    "aria-multiline": s ? void 0 : !0
  }, h), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: hr || !la ? h.spellCheck : !1,
    autoCorrect: hr || !la ? h.autoCorrect : "false",
    autoCapitalize: hr || !la ? h.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !s,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: X,
    style: Hn(Hn({}, v ? {} : Hn({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, b ? {
      minHeight: b
    } : {})), p),
    onBeforeInput: dt((m) => {
      if (!hr && !s && !tn(m, h.onBeforeInput) && oe.hasSelectableTarget(d, m.target) && (m.preventDefault(), !oe.isComposing(d))) {
        var $ = m.data;
        x.insertText(d, $);
      }
    }, [h.onBeforeInput, d, s]),
    onInput: dt((m) => {
      if (!tn(m, h.onInput)) {
        if (_.current) {
          _.current.handleInput();
          return;
        }
        for (var $ of B.current)
          $();
        B.current = [];
      }
    }, [h.onInput]),
    onBlur: dt((m) => {
      if (!(s || q.isUpdatingSelection || !oe.hasSelectableTarget(d, m.target) || tn(m, h.onBlur))) {
        var $ = oe.findDocumentOrShadowRoot(d);
        if (q.latestElement !== $.activeElement) {
          var {
            relatedTarget: W
          } = m, T = oe.toDOMNode(d, d);
          if (W !== T && !(An(W) && W.hasAttribute("data-slate-spacer"))) {
            if (W != null && kr(W) && oe.hasDOMNode(d, W)) {
              var J = oe.toSlateNode(d, W);
              if (xe.isElement(J) && !d.isVoid(J))
                return;
            }
            if (Vr) {
              var te = Vo($);
              te == null || te.removeAllRanges();
            }
            Or.delete(d);
          }
        }
      }
    }, [s, q.isUpdatingSelection, q.latestElement, d, h.onBlur]),
    onClick: dt((m) => {
      if (oe.hasTarget(d, m.target) && !tn(m, h.onClick) && kr(m.target)) {
        var $ = oe.toSlateNode(d, m.target), W = oe.findPath(d, $);
        if (!x.hasPath(d, W) || ve.get(d, W) !== $)
          return;
        if (m.detail === bT && W.length >= 1) {
          var T = W;
          if (!(xe.isElement($) && x.isBlock(d, $))) {
            var J, te = x.above(d, {
              match: (me) => xe.isElement(me) && x.isBlock(d, me),
              at: W
            });
            T = (J = te == null ? void 0 : te[1]) !== null && J !== void 0 ? J : W.slice(0, 1);
          }
          var N = x.range(d, T);
          le.select(d, N);
          return;
        }
        if (s)
          return;
        var se = x.start(d, W), ue = x.end(d, W), de = x.void(d, {
          at: se
        }), ge = x.void(d, {
          at: ue
        });
        if (de && ge && H.equals(de[1], ge[1])) {
          var Ce = x.range(d, se);
          le.select(d, Ce);
        }
      }
    }, [d, h.onClick, s]),
    onCompositionEnd: dt((m) => {
      if (oe.hasSelectableTarget(d, m.target)) {
        var $;
        if (oe.isComposing(d) && Promise.resolve().then(() => {
          L(!1), Xr.set(d, !1);
        }), ($ = _.current) === null || $ === void 0 || $.handleCompositionEnd(m), tn(m, h.onCompositionEnd) || nn)
          return;
        if (!Vr && !CB && !Ky && !EB && !wB && m.data) {
          var W = zn.get(d);
          zn.delete(d), W !== void 0 && (ir.set(d, d.marks), d.marks = W), x.insertText(d, m.data);
          var T = ir.get(d);
          ir.delete(d), T !== void 0 && (d.marks = T);
        }
      }
    }, [h.onCompositionEnd, d]),
    onCompositionUpdate: dt((m) => {
      oe.hasSelectableTarget(d, m.target) && !tn(m, h.onCompositionUpdate) && (oe.isComposing(d) || (L(!0), Xr.set(d, !0)));
    }, [h.onCompositionUpdate, d]),
    onCompositionStart: dt((m) => {
      if (oe.hasSelectableTarget(d, m.target)) {
        var $;
        if (($ = _.current) === null || $ === void 0 || $.handleCompositionStart(m), tn(m, h.onCompositionStart) || nn)
          return;
        L(!0);
        var {
          selection: W
        } = d;
        if (W && ne.isExpanded(W)) {
          x.deleteFragment(d);
          return;
        }
      }
    }, [h.onCompositionStart, d]),
    onCopy: dt((m) => {
      oe.hasSelectableTarget(d, m.target) && !tn(m, h.onCopy) && !Og(m) && (m.preventDefault(), oe.setFragmentData(d, m.clipboardData, "copy"));
    }, [h.onCopy, d]),
    onCut: dt((m) => {
      if (!s && oe.hasSelectableTarget(d, m.target) && !tn(m, h.onCut) && !Og(m)) {
        m.preventDefault(), oe.setFragmentData(d, m.clipboardData, "cut");
        var {
          selection: $
        } = d;
        if ($)
          if (ne.isExpanded($))
            x.deleteFragment(d);
          else {
            var W = ve.parent(d, $.anchor.path);
            x.isVoid(d, W) && le.delete(d);
          }
      }
    }, [s, d, h.onCut]),
    onDragOver: dt((m) => {
      if (oe.hasTarget(d, m.target) && !tn(m, h.onDragOver)) {
        var $ = oe.toSlateNode(d, m.target);
        xe.isElement($) && x.isVoid(d, $) && m.preventDefault();
      }
    }, [h.onDragOver, d]),
    onDragStart: dt((m) => {
      if (!s && oe.hasTarget(d, m.target) && !tn(m, h.onDragStart)) {
        var $ = oe.toSlateNode(d, m.target), W = oe.findPath(d, $), T = xe.isElement($) && x.isVoid(d, $) || x.void(d, {
          at: W,
          voids: !0
        });
        if (T) {
          var J = x.range(d, W);
          le.select(d, J);
        }
        q.isDraggingInternally = !0, oe.setFragmentData(d, m.dataTransfer, "drag");
      }
    }, [s, d, h.onDragStart, q]),
    onDrop: dt((m) => {
      if (!s && oe.hasTarget(d, m.target) && !tn(m, h.onDrop)) {
        m.preventDefault();
        var $ = d.selection, W = oe.findEventRange(d, m), T = m.dataTransfer;
        le.select(d, W), q.isDraggingInternally && $ && !ne.equals($, W) && !x.void(d, {
          at: W,
          voids: !0
        }) && le.delete(d, {
          at: $
        }), oe.insertData(d, T), oe.isFocused(d) || oe.focus(d);
      }
    }, [s, d, h.onDrop, q]),
    onDragEnd: dt((m) => {
      !s && q.isDraggingInternally && h.onDragEnd && oe.hasTarget(d, m.target) && h.onDragEnd(m);
    }, [s, q, h, d]),
    onFocus: dt((m) => {
      if (!s && !q.isUpdatingSelection && oe.hasEditableTarget(d, m.target) && !tn(m, h.onFocus)) {
        var $ = oe.toDOMNode(d, d), W = oe.findDocumentOrShadowRoot(d);
        if (q.latestElement = W.activeElement, co && m.target !== $) {
          $.focus();
          return;
        }
        Or.set(d, !0);
      }
    }, [s, q, d, h.onFocus]),
    onKeyDown: dt((m) => {
      if (!s && oe.hasEditableTarget(d, m.target)) {
        var $;
        ($ = _.current) === null || $ === void 0 || $.handleKeyDown(m);
        var {
          nativeEvent: W
        } = m;
        if (oe.isComposing(d) && W.isComposing === !1 && (Xr.set(d, !1), L(!1)), tn(m, h.onKeyDown) || oe.isComposing(d))
          return;
        var {
          selection: T
        } = d, J = d.children[T !== null ? T.focus.path[0] : 0], te = _y(ve.string(J)) === "rtl";
        if (Mt.isRedo(W)) {
          m.preventDefault();
          var N = d;
          typeof N.redo == "function" && N.redo();
          return;
        }
        if (Mt.isUndo(W)) {
          m.preventDefault();
          var se = d;
          typeof se.undo == "function" && se.undo();
          return;
        }
        if (Mt.isMoveLineBackward(W)) {
          m.preventDefault(), le.move(d, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (Mt.isMoveLineForward(W)) {
          m.preventDefault(), le.move(d, {
            unit: "line"
          });
          return;
        }
        if (Mt.isExtendLineBackward(W)) {
          m.preventDefault(), le.move(d, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (Mt.isExtendLineForward(W)) {
          m.preventDefault(), le.move(d, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (Mt.isMoveBackward(W)) {
          m.preventDefault(), T && ne.isCollapsed(T) ? le.move(d, {
            reverse: !te
          }) : le.collapse(d, {
            edge: te ? "end" : "start"
          });
          return;
        }
        if (Mt.isMoveForward(W)) {
          m.preventDefault(), T && ne.isCollapsed(T) ? le.move(d, {
            reverse: te
          }) : le.collapse(d, {
            edge: te ? "start" : "end"
          });
          return;
        }
        if (Mt.isMoveWordBackward(W)) {
          m.preventDefault(), T && ne.isExpanded(T) && le.collapse(d, {
            edge: "focus"
          }), le.move(d, {
            unit: "word",
            reverse: !te
          });
          return;
        }
        if (Mt.isMoveWordForward(W)) {
          m.preventDefault(), T && ne.isExpanded(T) && le.collapse(d, {
            edge: "focus"
          }), le.move(d, {
            unit: "word",
            reverse: te
          });
          return;
        }
        if (hr) {
          if ((Yy || Vr) && T && (Mt.isDeleteBackward(W) || Mt.isDeleteForward(W)) && ne.isCollapsed(T)) {
            var ue = ve.parent(d, T.anchor.path);
            if (xe.isElement(ue) && x.isVoid(d, ue) && (x.isInline(d, ue) || x.isBlock(d, ue))) {
              m.preventDefault(), x.deleteBackward(d, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (Mt.isBold(W) || Mt.isItalic(W) || Mt.isTransposeCharacter(W)) {
            m.preventDefault();
            return;
          }
          if (Mt.isSoftBreak(W)) {
            m.preventDefault(), x.insertSoftBreak(d);
            return;
          }
          if (Mt.isSplitBlock(W)) {
            m.preventDefault(), x.insertBreak(d);
            return;
          }
          if (Mt.isDeleteBackward(W)) {
            m.preventDefault(), T && ne.isExpanded(T) ? x.deleteFragment(d, {
              direction: "backward"
            }) : x.deleteBackward(d);
            return;
          }
          if (Mt.isDeleteForward(W)) {
            m.preventDefault(), T && ne.isExpanded(T) ? x.deleteFragment(d, {
              direction: "forward"
            }) : x.deleteForward(d);
            return;
          }
          if (Mt.isDeleteLineBackward(W)) {
            m.preventDefault(), T && ne.isExpanded(T) ? x.deleteFragment(d, {
              direction: "backward"
            }) : x.deleteBackward(d, {
              unit: "line"
            });
            return;
          }
          if (Mt.isDeleteLineForward(W)) {
            m.preventDefault(), T && ne.isExpanded(T) ? x.deleteFragment(d, {
              direction: "forward"
            }) : x.deleteForward(d, {
              unit: "line"
            });
            return;
          }
          if (Mt.isDeleteWordBackward(W)) {
            m.preventDefault(), T && ne.isExpanded(T) ? x.deleteFragment(d, {
              direction: "backward"
            }) : x.deleteBackward(d, {
              unit: "word"
            });
            return;
          }
          if (Mt.isDeleteWordForward(W)) {
            m.preventDefault(), T && ne.isExpanded(T) ? x.deleteFragment(d, {
              direction: "forward"
            }) : x.deleteForward(d, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [s, d, h.onKeyDown]),
    onPaste: dt((m) => {
      !s && oe.hasEditableTarget(d, m.target) && !tn(m, h.onPaste) && (!hr || LB(m.nativeEvent) || Vr) && (m.preventDefault(), oe.insertData(d, m.clipboardData));
    }, [s, d, h.onPaste])
  }), /* @__PURE__ */ Se.createElement(MT, {
    decorations: R,
    node: d,
    renderElement: u,
    renderPlaceholder: c,
    renderLeaf: l,
    selection: d.selection
  }))))));
}), BT = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ Se.createElement("span", Hn({}, t), n, nn && /* @__PURE__ */ Se.createElement("br", null))
  );
}, TT = () => [], AT = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && ne.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), qP(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, tn = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, Og = (e) => kr(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), FT = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, IT = /* @__PURE__ */ ht(!1), RT = /* @__PURE__ */ ht({});
function _T(e) {
  var t = rt([]).current, n = rt({
    editor: e
  }).current, r = dt((i) => {
    n.editor = i, t.forEach((a) => a(i));
  }, [t, n]), o = Ln(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var jT = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], NT = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: a
  } = e, s = go(e, jT), [u, l] = Se.useState(() => {
    if (!ve.isNodeList(a))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(qt.stringify(a)));
    if (!x.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(qt.stringify(t)));
    return t.children = a, Object.assign(t, s), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: f
  } = _T(t), p = dt((h) => {
    var d;
    switch (r && r(t.children), h == null || (d = h.operation) === null || d === void 0 ? void 0 : d.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    l((w) => ({
      v: w.v + 1,
      editor: t
    })), f(t);
  }, [t, f, r, o, i]);
  y(() => (cl.set(t, p), () => {
    cl.set(t, () => {
    });
  }), [t, p]);
  var [g, v] = P(oe.isFocused(t));
  return y(() => {
    v(oe.isFocused(t));
  }, [t]), ai(() => {
    var h = () => v(oe.isFocused(t));
    return Gy >= 17 ? (document.addEventListener("focusin", h), document.addEventListener("focusout", h), () => {
      document.removeEventListener("focusin", h), document.removeEventListener("focusout", h);
    }) : (document.addEventListener("focus", h, !0), document.addEventListener("blur", h, !0), () => {
      document.removeEventListener("focus", h, !0), document.removeEventListener("blur", h, !0);
    });
  }, []), /* @__PURE__ */ Se.createElement(RT.Provider, {
    value: c
  }, /* @__PURE__ */ Se.createElement(d0.Provider, {
    value: u
  }, /* @__PURE__ */ Se.createElement(Cc.Provider, {
    value: u.editor
  }, /* @__PURE__ */ Se.createElement(IT.Provider, {
    value: g
  }, n))));
}, Sg = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, kg = (e, t, n) => {
  var r = oe.toDOMRange(e, t).getBoundingClientRect(), o = oe.toDOMRange(e, n).getBoundingClientRect();
  return Sg(r, o) && Sg(o, r);
}, zT = (e, t) => {
  var n = x.range(e, ne.end(t)), r = Array.from(x.positions(e, {
    at: t
  })), o = 0, i = r.length, a = Math.floor(i / 2);
  if (kg(e, x.range(e, r[o]), n))
    return x.range(e, r[o], n);
  if (r.length < 2)
    return x.range(e, r[r.length - 1], n);
  for (; a !== r.length && a !== o; )
    kg(e, x.range(e, r[a]), n) ? i = a : o = a, a = Math.floor((o + i) / 2);
  return x.range(e, r[i], n);
};
function Mg(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Mg(Object(n), !0).forEach(function(r) {
      Fn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Mg(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $T = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: a,
    addMark: s,
    removeMark: u
  } = r;
  return ds.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (l, c) => {
    var f, p;
    (f = Dc.get(r)) === null || f === void 0 || f(), !zn.get(r) && (p = sn.get(r)) !== null && p !== void 0 && p.length && zn.set(r, null), ir.delete(r), s(l, c);
  }, r.removeMark = (l) => {
    var c;
    !zn.get(r) && (c = sn.get(r)) !== null && c !== void 0 && c.length && zn.set(r, null), ir.delete(r), u(l);
  }, r.deleteBackward = (l) => {
    if (l !== "line")
      return a(l);
    if (r.selection && ne.isCollapsed(r.selection)) {
      var c = x.above(r, {
        match: (v) => xe.isElement(v) && x.isBlock(r, v),
        at: r.selection
      });
      if (c) {
        var [, f] = c, p = x.range(r, f, r.selection.anchor), g = zT(r, p);
        ne.isCollapsed(g) || le.delete(r, {
          at: g
        });
      }
    }
  }, r.apply = (l) => {
    var c = [], f = [], p = sn.get(r);
    if (p != null && p.length) {
      var g = p.map((I) => zB(I, l)).filter(Boolean);
      sn.set(r, g);
    }
    var v = Er.get(r);
    v && Er.set(r, mg(r, v, l));
    var h = wr.get(r);
    if (h != null && h.at) {
      var d = qe.isPoint(h == null ? void 0 : h.at) ? pl(r, h.at, l) : mg(r, h.at, l);
      wr.set(r, d ? Pg(Pg({}, h), {}, {
        at: d
      }) : null);
    }
    switch (l.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...uo(r, l.path));
        break;
      }
      case "set_selection": {
        var w;
        (w = Ho.get(r)) === null || w === void 0 || w.unref(), Ho.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...uo(r, H.parent(l.path)));
        break;
      }
      case "merge_node": {
        var L = H.previous(l.path);
        c.push(...uo(r, L));
        break;
      }
      case "move_node": {
        var D = H.common(H.parent(l.path), H.parent(l.newPath));
        c.push(...uo(r, D));
        var B;
        H.isBefore(l.path, l.newPath) ? (c.push(...uo(r, H.parent(l.path))), B = l.newPath) : (c.push(...uo(r, H.parent(l.newPath))), B = l.path);
        var b = ve.get(t, H.parent(B)), E = oe.findKey(r, b), O = x.pathRef(r, H.parent(B));
        f.push([O, E]);
        break;
      }
    }
    o(l);
    for (var [S, V] of c) {
      var [M] = x.node(r, S);
      Ba.set(M, V);
    }
    for (var [q, _] of f)
      if (q.current) {
        var [j] = x.node(r, q.current);
        Ba.set(j, _);
      }
  }, r.setFragmentData = (l) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [f, p] = ne.edges(c), g = x.void(r, {
        at: f.path
      }), v = x.void(r, {
        at: p.path
      });
      if (!(ne.isCollapsed(c) && !g)) {
        var h = oe.toDOMRange(r, c), d = h.cloneContents(), w = d.childNodes[0];
        if (d.childNodes.forEach((M) => {
          M.textContent && M.textContent.trim() !== "" && (w = M);
        }), v) {
          var [L] = v, D = h.cloneRange(), B = oe.toDOMNode(r, L);
          D.setEndAfter(B), d = D.cloneContents();
        }
        if (g && (w = d.querySelector("[data-slate-spacer]")), Array.from(d.querySelectorAll("[data-slate-zero-width]")).forEach((M) => {
          var q = M.getAttribute("data-slate-zero-width") === "n";
          M.textContent = q ? `
` : "";
        }), t0(w)) {
          var b = w.ownerDocument.createElement("span");
          b.style.whiteSpace = "pre", b.appendChild(w), d.appendChild(b), w = b;
        }
        var E = r.getFragment(), O = JSON.stringify(E), S = window.btoa(encodeURIComponent(O));
        w.setAttribute("data-slate-fragment", S), l.setData("application/".concat(n), S);
        var V = d.ownerDocument.createElement("div");
        return V.appendChild(d), V.setAttribute("hidden", "true"), d.ownerDocument.body.appendChild(V), l.setData("text/html", V.innerHTML), l.setData("text/plain", r0(V)), d.ownerDocument.body.removeChild(V), l;
      }
    }
  }, r.insertData = (l) => {
    r.insertFragmentData(l) || r.insertTextData(l);
  }, r.insertFragmentData = (l) => {
    var c = l.getData("application/".concat(n)) || PB(l);
    if (c) {
      var f = decodeURIComponent(window.atob(c)), p = JSON.parse(f);
      return r.insertFragment(p), !0;
    }
    return !1;
  }, r.insertTextData = (l) => {
    var c = l.getData("text/plain");
    if (c) {
      var f = c.split(/\r\n|\r|\n/), p = !1;
      for (var g of f)
        p && le.splitNodes(r, {
          always: !0
        }), r.insertText(g), p = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (l) => {
    var c = Gy < 18 ? Ol.unstable_batchedUpdates : (f) => f();
    c(() => {
      var f = cl.get(r);
      f && f(l), i(l);
    });
  }, r;
}, uo = (e, t) => {
  var n = [];
  for (var [r, o] of x.levels(e, {
    at: t
  })) {
    var i = oe.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function h0(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    x.nodes(e, {
      at: x.unhangRange(e, r),
      match: (i) => !x.isEditor(i) && xe.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const Bg = ["listItem", "numberedList"], fa = ["left", "center", "right", "justify"];
function UT(e, t) {
  const n = fa.includes(t) ? "align" : "type", r = h0(e, t, n), o = Bg.includes(t);
  le.unwrapNodes(e, {
    match: (a) => !x.isEditor(a) && xe.isElement(a) && Bg.includes(a.type) && !fa.includes(t),
    split: !0
  });
  let i;
  if (fa.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, le.setNodes(e, i), !r && o) {
    const a = { type: t, children: [] };
    le.wrapNodes(e, a);
  }
}
function $r({ format: e, icon: t }) {
  const n = Oc(), r = fa.includes(e) ? "align" : "type", i = h0(n, e, r) ? "activeTrue" : "activeFalse";
  function a(s) {
    s.preventDefault(), UT(n, e);
  }
  return /* @__PURE__ */ F.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: a,
      children: /* @__PURE__ */ F.jsx(t, {})
    }
  );
}
function WT({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ F.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ F.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ F.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ F.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ F.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ F.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    default:
      return /* @__PURE__ */ F.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
function HT({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ F.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ F.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ F.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ F.jsx("u", { children: t })), /* @__PURE__ */ F.jsx("span", { ...e, children: t });
}
function g0(e, t) {
  const n = x.marks(e);
  return n ? n[t] === !0 : !1;
}
function v0(e, t) {
  g0(e, t) ? x.removeMark(e, t) : x.addMark(e, t, !0);
}
function Gi({ format: e, icon: t }) {
  const n = Oc(), o = g0(n, e) ? "activeTrue" : "activeFalse";
  function i(a) {
    a.preventDefault(), v0(n, e);
  }
  return /* @__PURE__ */ F.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ F.jsx(t, {})
    }
  );
}
function VT({ children: e }) {
  return /* @__PURE__ */ F.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
const Tg = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, qT = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
var m0 = {}, Sc = {}, kc = {};
Object.defineProperty(kc, "__esModule", { value: !0 });
kc.default = YT;
var Ag = "html", Fg = "head", Ki = "body", ZT = /<([a-zA-Z]+[0-9]?)/, Ig = /<head[^]*>/i, Rg = /<body[^]*>/i, Ta = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, gl = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, _g = typeof window == "object" && window.DOMParser;
if (typeof _g == "function") {
  var GT = new _g(), KT = "text/html";
  gl = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), GT.parseFromString(e, KT);
  }, Ta = gl;
}
if (typeof document == "object" && document.implementation) {
  var Yi = document.implementation.createHTMLDocument();
  Ta = function(e, t) {
    if (t) {
      var n = Yi.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Yi;
    }
    return Yi.documentElement.innerHTML = e, Yi;
  };
}
var Xi = typeof document == "object" && document.createElement("template"), vl;
Xi && Xi.content && (vl = function(e) {
  return Xi.innerHTML = e, Xi.content.childNodes;
});
function YT(e) {
  var t, n, r = e.match(ZT), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case Ag: {
      var i = gl(e);
      if (!Ig.test(e)) {
        var a = i.querySelector(Fg);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!Rg.test(e)) {
        var a = i.querySelector(Ki);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(Ag);
    }
    case Fg:
    case Ki: {
      var s = Ta(e).querySelectorAll(o);
      return Rg.test(e) && Ig.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (vl)
        return vl(e);
      var a = Ta(e, Ki).querySelector(Ki);
      return a.childNodes;
    }
  }
}
var ps = {}, Mc = {}, Pc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Pc);
var Je = {}, Ir = vt && vt.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), qo = vt && vt.__assign || function() {
  return qo = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, qo.apply(this, arguments);
};
Object.defineProperty(Je, "__esModule", { value: !0 });
Je.cloneNode = Je.hasChildren = Je.isDocument = Je.isDirective = Je.isComment = Je.isText = Je.isCDATA = Je.isTag = Je.Element = Je.Document = Je.CDATA = Je.NodeWithChildren = Je.ProcessingInstruction = Je.Comment = Je.Text = Je.DataNode = Je.Node = void 0;
var fn = Pc, Bc = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Tc(this, t);
    }, e;
  }()
);
Je.Node = Bc;
var hs = (
  /** @class */
  function(e) {
    Ir(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Bc)
);
Je.DataNode = hs;
var y0 = (
  /** @class */
  function(e) {
    Ir(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = fn.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(hs)
);
Je.Text = y0;
var b0 = (
  /** @class */
  function(e) {
    Ir(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = fn.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(hs)
);
Je.Comment = b0;
var C0 = (
  /** @class */
  function(e) {
    Ir(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = fn.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(hs)
);
Je.ProcessingInstruction = C0;
var gs = (
  /** @class */
  function(e) {
    Ir(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Bc)
);
Je.NodeWithChildren = gs;
var w0 = (
  /** @class */
  function(e) {
    Ir(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = fn.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gs)
);
Je.CDATA = w0;
var E0 = (
  /** @class */
  function(e) {
    Ir(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = fn.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gs)
);
Je.Document = E0;
var D0 = (
  /** @class */
  function(e) {
    Ir(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? fn.ElementType.Script : n === "style" ? fn.ElementType.Style : fn.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gs)
);
Je.Element = D0;
function x0(e) {
  return (0, fn.isTag)(e);
}
Je.isTag = x0;
function L0(e) {
  return e.type === fn.ElementType.CDATA;
}
Je.isCDATA = L0;
function O0(e) {
  return e.type === fn.ElementType.Text;
}
Je.isText = O0;
function S0(e) {
  return e.type === fn.ElementType.Comment;
}
Je.isComment = S0;
function k0(e) {
  return e.type === fn.ElementType.Directive;
}
Je.isDirective = k0;
function M0(e) {
  return e.type === fn.ElementType.Root;
}
Je.isDocument = M0;
function XT(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Je.hasChildren = XT;
function Tc(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (O0(e))
    n = new y0(e.data);
  else if (S0(e))
    n = new b0(e.data);
  else if (x0(e)) {
    var r = t ? vu(e.children) : [], o = new D0(e.name, qo({}, e.attribs), r);
    r.forEach(function(u) {
      return u.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = qo({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = qo({}, e["x-attribsPrefix"])), n = o;
  } else if (L0(e)) {
    var r = t ? vu(e.children) : [], i = new w0(r);
    r.forEach(function(l) {
      return l.parent = i;
    }), n = i;
  } else if (M0(e)) {
    var r = t ? vu(e.children) : [], a = new E0(r);
    r.forEach(function(l) {
      return l.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (k0(e)) {
    var s = new C0(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Je.cloneNode = Tc;
function vu(e) {
  for (var t = e.map(function(r) {
    return Tc(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = vt && vt.__createBinding || (Object.create ? function(s, u, l, c) {
    c === void 0 && (c = l);
    var f = Object.getOwnPropertyDescriptor(u, l);
    (!f || ("get" in f ? !u.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return u[l];
    } }), Object.defineProperty(s, c, f);
  } : function(s, u, l, c) {
    c === void 0 && (c = l), s[c] = u[l];
  }), n = vt && vt.__exportStar || function(s, u) {
    for (var l in s) l !== "default" && !Object.prototype.hasOwnProperty.call(u, l) && t(u, s, l);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Pc, o = Je;
  n(Je, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(u, l, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof l == "function" && (c = l, l = i), typeof u == "object" && (l = u, u = void 0), this.callback = u ?? null, this.options = l ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(u) {
        this.parser = u;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(u) {
        this.handleCallback(u);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var u = this.tagStack.pop();
        this.options.withEndIndices && (u.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(u);
      }, s.prototype.onopentag = function(u, l) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, f = new o.Element(u, l, void 0, c);
        this.addNode(f), this.tagStack.push(f);
      }, s.prototype.ontext = function(u) {
        var l = this.lastNode;
        if (l && l.type === r.ElementType.Text)
          l.data += u, this.options.withEndIndices && (l.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(u);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(u) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += u;
          return;
        }
        var l = new o.Comment(u);
        this.addNode(l), this.lastNode = l;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var u = new o.Text(""), l = new o.CDATA([u]);
        this.addNode(l), u.parent = l, this.lastNode = u;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(u, l) {
        var c = new o.ProcessingInstruction(u, l);
        this.addNode(c);
      }, s.prototype.handleCallback = function(u) {
        if (typeof this.callback == "function")
          this.callback(u, this.dom);
        else if (u)
          throw u;
      }, s.prototype.addNode = function(u) {
        var l = this.tagStack[this.tagStack.length - 1], c = l.children[l.children.length - 1];
        this.options.withStartIndices && (u.startIndex = this.parser.startIndex), this.options.withEndIndices && (u.endIndex = this.parser.endIndex), l.children.push(u), c && (u.prev = c, c.next = u), u.parent = l, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(Mc);
var P0 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(P0);
Object.defineProperty(ps, "__esModule", { value: !0 });
ps.formatAttributes = B0;
ps.formatDOM = T0;
var Ji = Mc, JT = P0;
function QT(e) {
  return JT.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function B0(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function eA(e) {
  e = e.toLowerCase();
  var t = QT(e);
  return t || e;
}
function T0(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var u = eA(s.nodeName);
        o = new Ji.Element(u, B0(s.attributes)), o.children = T0(
          // template children are on content
          u === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Ji.Text(s.nodeValue);
        break;
      case 8:
        o = new Ji.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var l = r[i - 1] || null;
    l && (l.next = o), o.parent = t, o.prev = l, o.next = null, r.push(o);
  }
  return n && (o = new Ji.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var tA = vt && vt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Sc, "__esModule", { value: !0 });
Sc.default = iA;
var nA = tA(kc), rA = ps, oA = /<(![a-zA-Z\s]+)>/;
function iA(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(oA), n = t ? t[1] : void 0;
  return (0, rA.formatDOM)((0, nA.default)(e), null, n);
}
var vs = {}, Un = {}, ms = {}, aA = 0;
ms.SAME = aA;
var sA = 1;
ms.CAMELCASE = sA;
ms.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const A0 = 0, Rr = 1, ys = 2, bs = 3, Ac = 4, F0 = 5, I0 = 6;
function uA(e) {
  return Kt.hasOwnProperty(e) ? Kt[e] : null;
}
function an(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === ys || t === bs || t === Ac, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Kt = {}, lA = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
lA.forEach((e) => {
  Kt[e] = new an(
    e,
    A0,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Kt[e] = new an(
    e,
    Rr,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Kt[e] = new an(
    e,
    ys,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Kt[e] = new an(
    e,
    ys,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Kt[e] = new an(
    e,
    bs,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Kt[e] = new an(
    e,
    bs,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Kt[e] = new an(
    e,
    Ac,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Kt[e] = new an(
    e,
    I0,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Kt[e] = new an(
    e,
    F0,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Fc = /[\-\:]([a-z])/g, Ic = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Fc, Ic);
  Kt[t] = new an(
    t,
    Rr,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Fc, Ic);
  Kt[t] = new an(
    t,
    Rr,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Fc, Ic);
  Kt[t] = new an(
    t,
    Rr,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Kt[e] = new an(
    e,
    Rr,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const cA = "xlinkHref";
Kt[cA] = new an(
  "xlinkHref",
  Rr,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Kt[e] = new an(
    e,
    Rr,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: fA,
  SAME: dA,
  possibleStandardNames: jg
} = ms, pA = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", hA = pA + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", gA = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + hA + "]*$")
), vA = Object.keys(
  jg
).reduce((e, t) => {
  const n = jg[t];
  return n === dA ? e[t] = t : n === fA ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Un.BOOLEAN = bs;
Un.BOOLEANISH_STRING = ys;
Un.NUMERIC = F0;
Un.OVERLOADED_BOOLEAN = Ac;
Un.POSITIVE_NUMERIC = I0;
Un.RESERVED = A0;
Un.STRING = Rr;
Un.getPropertyInfo = uA;
Un.isCustomAttribute = gA;
Un.possibleStandardNames = vA;
var Rc = {}, _c = {}, Ng = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, mA = /\n/g, yA = /^\s*/, bA = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, CA = /^:\s*/, wA = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, EA = /^[;\s]*/, DA = /^\s+|\s+$/g, xA = `
`, zg = "/", $g = "*", Zr = "", LA = "comment", OA = "declaration", SA = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(v) {
    var h = v.match(mA);
    h && (n += h.length);
    var d = v.lastIndexOf(xA);
    r = ~d ? v.length - d : r + v.length;
  }
  function i() {
    var v = { line: n, column: r };
    return function(h) {
      return h.position = new a(v), l(), h;
    };
  }
  function a(v) {
    this.start = v, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(v) {
    var h = new Error(
      t.source + ":" + n + ":" + r + ": " + v
    );
    if (h.reason = v, h.filename = t.source, h.line = n, h.column = r, h.source = e, !t.silent) throw h;
  }
  function u(v) {
    var h = v.exec(e);
    if (h) {
      var d = h[0];
      return o(d), e = e.slice(d.length), h;
    }
  }
  function l() {
    u(yA);
  }
  function c(v) {
    var h;
    for (v = v || []; h = f(); )
      h !== !1 && v.push(h);
    return v;
  }
  function f() {
    var v = i();
    if (!(zg != e.charAt(0) || $g != e.charAt(1))) {
      for (var h = 2; Zr != e.charAt(h) && ($g != e.charAt(h) || zg != e.charAt(h + 1)); )
        ++h;
      if (h += 2, Zr === e.charAt(h - 1))
        return s("End of comment missing");
      var d = e.slice(2, h - 2);
      return r += 2, o(d), e = e.slice(h), r += 2, v({
        type: LA,
        comment: d
      });
    }
  }
  function p() {
    var v = i(), h = u(bA);
    if (h) {
      if (f(), !u(CA)) return s("property missing ':'");
      var d = u(wA), w = v({
        type: OA,
        property: Ug(h[0].replace(Ng, Zr)),
        value: d ? Ug(d[0].replace(Ng, Zr)) : Zr
      });
      return u(EA), w;
    }
  }
  function g() {
    var v = [];
    c(v);
    for (var h; h = p(); )
      h !== !1 && (v.push(h), c(v));
    return v;
  }
  return l(), g();
};
function Ug(e) {
  return e ? e.replace(DA, Zr) : Zr;
}
var kA = vt && vt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(_c, "__esModule", { value: !0 });
_c.default = PA;
var MA = kA(SA);
function PA(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, MA.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Cs = {};
Object.defineProperty(Cs, "__esModule", { value: !0 });
Cs.camelCase = void 0;
var BA = /^--[a-zA-Z0-9-]+$/, TA = /-([a-z])/g, AA = /^[^-]+$/, FA = /^-(webkit|moz|ms|o|khtml)-/, IA = /^-(ms)-/, RA = function(e) {
  return !e || AA.test(e) || BA.test(e);
}, _A = function(e, t) {
  return t.toUpperCase();
}, Wg = function(e, t) {
  return "".concat(t, "-");
}, jA = function(e, t) {
  return t === void 0 && (t = {}), RA(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(IA, Wg) : e = e.replace(FA, Wg), e.replace(TA, _A));
};
Cs.camelCase = jA;
var NA = vt && vt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, zA = NA(_c), $A = Cs;
function ml(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, zA.default)(e, function(r, o) {
    r && o && (n[(0, $A.camelCase)(r, t)] = o);
  }), n;
}
ml.default = ml;
var UA = ml;
(function(e) {
  var t = vt && vt.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Se, r = t(UA), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, f) {
    return c.includes("-") ? !o.has(c) : !!(f && typeof f.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, f) {
    if (typeof c == "string") {
      if (!c.trim()) {
        f.style = {};
        return;
      }
      try {
        f.style = (0, r.default)(c, a);
      } catch {
        f.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var u = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = u;
  var l = function(c) {
    return c;
  };
  e.returnFirstArg = l;
})(Rc);
Object.defineProperty(vs, "__esModule", { value: !0 });
vs.default = qA;
var Ro = Un, Hg = Rc, WA = ["checked", "value"], HA = ["input", "select", "textarea"], VA = {
  reset: !0,
  submit: !0
};
function qA(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && VA[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Ro.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = Vg(a);
    if (s) {
      var u = (0, Ro.getPropertyInfo)(s);
      switch (WA.includes(s) && HA.includes(t) && !r && (s = Vg("default" + a)), n[s] = i, u && u.type) {
        case Ro.BOOLEAN:
          n[s] = !0;
          break;
        case Ro.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    Hg.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, Hg.setStyleProp)(e.style, n), n;
}
function Vg(e) {
  return Ro.possibleStandardNames[e];
}
var jc = {}, ZA = vt && vt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(jc, "__esModule", { value: !0 });
jc.default = R0;
var mu = Se, GA = ZA(vs), Zo = Rc, KA = {
  cloneElement: mu.cloneElement,
  createElement: mu.createElement,
  isValidElement: mu.isValidElement
};
function R0(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Zo.returnFirstArg, i = t.library || KA, a = i.cloneElement, s = i.createElement, u = i.isValidElement, l = e.length, c = 0; c < l; c++) {
    var f = e[c];
    if (r) {
      var p = t.replace(f, c);
      if (u(p)) {
        l > 1 && (p = a(p, {
          key: p.key || c
        })), n.push(o(p, f, c));
        continue;
      }
    }
    if (f.type === "text") {
      var g = !f.data.trim().length;
      if (g && f.parent && !(0, Zo.canTextBeChildOfNode)(f.parent) || t.trim && g)
        continue;
      n.push(o(f.data, f, c));
      continue;
    }
    var v = f, h = {};
    YA(v) ? ((0, Zo.setStyleProp)(v.attribs.style, v.attribs), h = v.attribs) : v.attribs && (h = (0, GA.default)(v.attribs, v.name));
    var d = void 0;
    switch (f.type) {
      case "script":
      case "style":
        f.children[0] && (h.dangerouslySetInnerHTML = {
          __html: f.children[0].data
        });
        break;
      case "tag":
        f.name === "textarea" && f.children[0] ? h.defaultValue = f.children[0].data : f.children && f.children.length && (d = R0(f.children, t));
        break;
      default:
        continue;
    }
    l > 1 && (h.key = c), n.push(o(s(f.name, h, d), f, c));
  }
  return n.length === 1 ? n[0] : n;
}
function YA(e) {
  return Zo.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Zo.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = vt && vt.__importDefault || function(u) {
    return u && u.__esModule ? u : { default: u };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(Sc);
  e.htmlToDOM = n.default;
  var r = t(vs);
  e.attributesToProps = r.default;
  var o = t(jc);
  e.domToReact = o.default;
  var i = Mc;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(u, l) {
    if (typeof u != "string")
      throw new TypeError("First argument must be a string");
    return u ? (0, o.default)((0, n.default)(u, (l == null ? void 0 : l.htmlparser2) || a), l) : [];
  }
})(m0);
const qg = /* @__PURE__ */ Na(m0), XA = qg.default || qg, yl = (e) => {
  if (typeof e == "string") return { text: e || "" };
  function t(o) {
    return o.map((i) => yl(i));
  }
  const n = Array.isArray(e.props.children) ? t(e.props.children) : [{ text: e.props.children }], r = typeof e.props.children == "string" ? e.props.children : "";
  switch (e.type) {
    case "p":
      return { type: "paragraph", children: n };
    case "blockquote":
      return { type: "blockQuote", children: n };
    case "ul":
      return { type: "bulletedList", children: n };
    case "h1":
      return { type: "headingOne", children: n };
    case "h2":
      return { type: "headingTwo", children: n };
    case "li":
      return { type: "listItem", children: n };
    case "ol":
      return { type: "numberedList", children: n };
    case "strong":
      return { type: "paragraph", text: r, bold: !0 };
    case "code":
      return { text: r, code: !0 };
    case "em":
      return { text: r, italic: !0 };
    case "u":
      return { text: r, underline: !0 };
    default:
      return { text: r };
  }
}, JA = (e) => {
  const t = XA(e);
  return Array.isArray(t) ? t.flatMap((n) => typeof n == "string" ? { text: n } : yl(n)) : typeof t == "string" ? [{ text: t }] : [yl(t)];
};
function Zg(e) {
  return e.map((t) => ve.string(t)).join("");
}
const _0 = (e) => {
  if (Oe.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (xe.isElement(e)) {
    const t = e.children.map((n) => _0(n)).join("");
    switch (e.type) {
      case "paragraph":
        return `<p>${t}</p>`;
      case "blockQuote":
        return `<blockquote>${t}</blockquote>`;
      case "bulletedList":
        return `<ul>${t}</ul>`;
      case "headingOne":
        return `<h1>${t}</h1>`;
      case "headingTwo":
        return `<h2>${t}</h2>`;
      case "listItem":
        return `<li>${t}</li>`;
      case "numberedList":
        return `<ol>${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, Gg = (e) => e.children.map((t) => _0(t)).join(""), Kg = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function M_({
  name: e,
  defaultValue: t,
  enforceCharacterLimit: n = !1,
  onChangeCharactersCount: r,
  maxLimit: o = 2e3,
  onValueChange: i,
  onChange: a,
  isError: s
}) {
  const u = Ln(() => TM($T(MM())), []), { id: l, inputRef: c, error: f } = Pn(), p = rt(null), g = Kg(t) ? JA(t) : qT, v = Zg(g), [h, d] = P(v.length), [w, L] = P(
    Kg(t) ? t : ""
  ), [D, B] = P(!1), b = c || p, E = s || !!f, O = dt(HT, []), S = dt(WT, []);
  function V(I) {
    const z = Zg(I);
    d(z.length), r && r(z.length), !(n && z.length >= o) && (L(Gg(u)), a && a(I), i && i(Gg(u)), u.children = I, le.setNodes(u, { children: I }));
  }
  const M = D ? "focusTrue" : "focusFalse", _ = `arkynRichText ${E || o < h ? "errorTrue" : "errorFalse"} ${M}`, j = o - h;
  return /* @__PURE__ */ F.jsxs(
    NT,
    {
      editor: u,
      initialValue: g,
      onChange: V,
      onValueChange: V,
      children: [
        /* @__PURE__ */ F.jsxs("div", { className: _, children: [
          /* @__PURE__ */ F.jsxs(VT, { children: [
            /* @__PURE__ */ F.jsx($r, { format: "headingOne", icon: bb }),
            /* @__PURE__ */ F.jsx($r, { format: "headingTwo", icon: Cb }),
            /* @__PURE__ */ F.jsx($r, { format: "blockQuote", icon: wb }),
            /* @__PURE__ */ F.jsx(Gi, { format: "bold", icon: Eb }),
            /* @__PURE__ */ F.jsx(Gi, { format: "italic", icon: Db }),
            /* @__PURE__ */ F.jsx(Gi, { format: "underline", icon: xb }),
            /* @__PURE__ */ F.jsx(Gi, { format: "code", icon: Lb }),
            /* @__PURE__ */ F.jsx($r, { format: "left", icon: Ob }),
            /* @__PURE__ */ F.jsx($r, { format: "right", icon: Sb }),
            /* @__PURE__ */ F.jsx($r, { format: "center", icon: kb }),
            /* @__PURE__ */ F.jsx($r, { format: "justify", icon: Mb })
          ] }),
          /* @__PURE__ */ F.jsx(
            PT,
            {
              className: "editorContainer",
              renderElement: S,
              renderLeaf: O,
              spellCheck: !0,
              id: l,
              onFocus: () => B(!0),
              onBlur: () => B(!1),
              onKeyDown: (I) => {
                for (const z in Tg)
                  if (XO(z, I)) {
                    I.preventDefault();
                    const X = Tg[z];
                    v0(u, X);
                  }
              }
            }
          ),
          j < 0 && /* @__PURE__ */ F.jsx("div", { className: "restatesCharacters", children: j })
        ] }),
        /* @__PURE__ */ F.jsx("input", { ref: b, type: "hidden", name: e, value: w }),
        /* @__PURE__ */ F.jsx("input", { type: "hidden", name: `${e}Count`, value: h })
      ]
    }
  );
}
function QA(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    leftIcon: u,
    disabled: l,
    readOnly: c,
    onFocus: f,
    onBlur: p,
    title: g,
    style: v,
    closeOnSelect: h = !0,
    ...d
  } = e, b = `arkyn_select ${s ? "hasPrefix" : ""} ${a} ${o} ${l || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, O = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: b,
    prefix: zb(s, O, "prefix"),
    LeftIcon: u,
    disabled: l || n || c,
    onFocus: f,
    onBlur: p,
    title: g,
    closeOnSelect: h,
    style: v,
    iconSize: O,
    Spinner: /* @__PURE__ */ F.jsx(lr, { className: "spinner", size: O, strokeWidth: 2.5 }),
    ...d
  };
}
function P_(e) {
  var G;
  const [t, n] = P(!1), { inputRef: r, id: o, error: i } = Pn(), a = rt(null), s = r || a, u = e.isError || !!i, {
    disabled: l,
    title: c,
    style: f,
    className: p,
    prefix: g,
    iconSize: v,
    isLoading: h,
    LeftIcon: d,
    value: w = null,
    defaultValue: L = "",
    onFocus: D,
    onBlur: B,
    Spinner: b,
    name: E,
    placeholder: O,
    onSelect: S,
    options: V,
    optionMaxHeight: M,
    closeOnSelect: q,
    ..._
  } = QA({ ...e, id: o, isError: u }, t), [j, I] = P(L);
  function z() {
    l || !(s != null && s.current) || t || (n(!0), s.current.focus());
  }
  function X(U) {
    t || (n(!0), D && D(U));
  }
  function R() {
    n(!1), B && s.current && s.current.blur();
  }
  function ee(U) {
    const { label: Y, value: K } = U;
    I(j !== K ? K : ""), S && S({ label: Y, value: K }), q && R();
  }
  const re = typeof w == "string" ? w : j, k = ((G = V.find((U) => U.value === re)) == null ? void 0 : G.label) || "", A = () => {
    if (!t && k) return !0;
    if (!t && !k) return !1;
    if (t && k) return !0;
    if (t && !k) return !1;
  };
  return /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
    /* @__PURE__ */ F.jsxs(
      "section",
      {
        title: c,
        style: f,
        onClick: z,
        className: `${p} placeholder_dark_${A()}`,
        children: [
          g,
          d && /* @__PURE__ */ F.jsx(d, { size: v, strokeWidth: 2.5 }),
          /* @__PURE__ */ F.jsx(
            "input",
            {
              disabled: l,
              readOnly: !0,
              placeholder: k || O,
              onFocus: X,
              ..._
            }
          ),
          /* @__PURE__ */ F.jsx(
            "input",
            {
              type: "hidden",
              ref: s,
              name: E,
              value: re || "",
              readOnly: !0
            }
          ),
          t && /* @__PURE__ */ F.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: M },
              children: [
                V.map(({ label: U, value: Y }) => /* @__PURE__ */ F.jsxs(
                  "div",
                  {
                    onClick: () => ee({ label: U, value: Y }),
                    className: re === Y ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      U,
                      " ",
                      /* @__PURE__ */ F.jsx(Av, {})
                    ]
                  },
                  Y
                )),
                V.length <= 0 && /* @__PURE__ */ F.jsx("p", { children: "Sem opções disponíveis" })
              ]
            }
          ),
          !h && /* @__PURE__ */ F.jsx(
            Pb,
            {
              className: "arkyn_select_arrow",
              size: v,
              strokeWidth: 2.5
            }
          ),
          h && b
        ]
      }
    ),
    t && /* @__PURE__ */ F.jsx("aside", { className: "arkyn_select_overlay", onClick: R })
  ] });
}
function B_(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: a,
    className: s = "",
    onCheck: u,
    ...l
  } = e, [c, f] = P(n), { id: p, inputRef: g } = Pn(), v = typeof r == "boolean" ? r : c;
  function h() {
    f(!c), u && u(v ? i : o || "checked");
  }
  const w = `arkynSwitch ${v ? "checkedTrue" : "checkedFalse"} ${t} ${s}`;
  return /* @__PURE__ */ F.jsx("button", { type: "button", onClick: h, className: w, ...l, children: /* @__PURE__ */ F.jsx(
    "input",
    {
      id: p,
      type: "hidden",
      name: a,
      ref: g,
      onClick: h,
      value: v ? o || "checked" : i
    }
  ) });
}
function T_(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: a,
    onBlur: s,
    title: u,
    style: l,
    ...c
  } = e, [f, p] = P(!1), { inputRef: g, id: v, error: h } = Pn(), d = rt(null), w = g || d, D = e.isError || !!h ? "errorTrue" : "errorFalse", E = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${D} ${f ? "focusedTrue" : "focusedFalse"} ${r}`;
  function O() {
    o || !(w != null && w.current) || (p(!0), w.current.focus());
  }
  function S(M) {
    p(!0), a && a(M);
  }
  function V(M) {
    p(!1), s && s(M);
  }
  return /* @__PURE__ */ F.jsx(
    "section",
    {
      title: u,
      style: l,
      onClick: O,
      className: E,
      children: /* @__PURE__ */ F.jsx(
        "textarea",
        {
          id: v,
          disabled: o,
          readOnly: i,
          ref: w,
          onFocus: S,
          onBlur: V,
          ...c
        }
      )
    }
  );
}
function A_(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ F.jsx("nav", { className: r, ...n });
}
function F_(e) {
  const { pathname: t } = kl(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...a
  } = e, u = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ F.jsxs("p", { className: u, children: [
    /* @__PURE__ */ F.jsx(Mu, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ F.jsxs(Tb, { to: i, className: u, ...a, children: [
    /* @__PURE__ */ F.jsx(Mu, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function j0(e = "") {
  const t = kl(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([a, s]) => {
      s === void 0 ? n.delete(`${r}${a}`) : n.set(`${r}${a}`, String(s));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let a = n.toString();
      return a && (a = "?" + a), a;
    }
  };
}
function I_(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    ...a
  } = e, s = _v(), { getParam: u, getScopedSearch: l } = j0(t), c = Number(u(o)) || 1, f = Number(u(r)) || 20, p = Math.ceil(n / f), g = Nb(c, i), v = jb(c, i, p);
  function h(d) {
    s(l({ page: d }));
  }
  return /* @__PURE__ */ F.jsxs("div", { className: "arkynPagination", ...a, children: [
    /* @__PURE__ */ F.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: c <= 1,
        onClick: () => h(c - 1),
        children: /* @__PURE__ */ F.jsx(Bb, {})
      }
    ),
    c > 1 + i && /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
      /* @__PURE__ */ F.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => h(1),
          children: "1"
        }
      ),
      c > 2 + i && /* @__PURE__ */ F.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ F.jsx(Kc, {}) })
    ] }),
    g.map((d, w) => /* @__PURE__ */ F.jsx(
      "button",
      {
        onClick: () => h(d),
        className: "arkynPaginationPageButton",
        children: d
      },
      w
    )),
    /* @__PURE__ */ F.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: c }),
    v.map((d, w) => /* @__PURE__ */ F.jsx(
      "button",
      {
        onClick: () => h(d),
        className: "arkynPaginationPageButton",
        children: d
      },
      w
    )),
    c + i < p && /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
      c + 1 + i < p && /* @__PURE__ */ F.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ F.jsx(Kc, {}) }),
      /* @__PURE__ */ F.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => h(p),
          children: p
        }
      )
    ] }),
    /* @__PURE__ */ F.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: c >= p,
        onClick: () => h(c + 1),
        children: /* @__PURE__ */ F.jsx(Mu, {})
      }
    )
  ] });
}
const bl = ht({});
function eF() {
  if (!bl)
    throw new Error("useTabContext must be used within a TabProvider");
  return Ae(bl);
}
function R_(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [a, s] = P(r || ""), [u, l] = P(!0), c = rt(null), f = `arkynTabContainer ${o || ""}`, [p, g] = P({
    width: "0px",
    left: "0px",
    transition: "none"
  }), v = (d, w) => {
    const L = d.getBoundingClientRect(), D = c.current.getBoundingClientRect(), B = w ? void 0 : "none";
    l(!1), g({
      transition: B,
      width: `${L.width}px`,
      left: `${L.left - D.left}px`
    });
  };
  y(() => {
    const d = c.current;
    if (!d) return;
    let w = null;
    w = d.querySelector("button.activeTrue"), w && v(w);
  }, []);
  const h = (d) => {
    const w = d.target;
    w && (s(w.value), w.classList.add("activeTrue"), v(w, !0), n && n(w.value));
  };
  return /* @__PURE__ */ F.jsxs("nav", { ref: c, className: f.trim(), ...i, children: [
    /* @__PURE__ */ F.jsx(bl.Provider, { value: { handleTabClick: h, showInitialTab: u, value: a }, children: t }),
    /* @__PURE__ */ F.jsx("div", { className: "activeLine", style: p })
  ] });
}
function __(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: a, handleTabClick: s } = eF(), u = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && a ? "showBorderBottom" : ""} ${u} ${n}`;
  function f(p) {
    s(p), r && r(p);
  }
  return /* @__PURE__ */ F.jsx("button", { onClick: f, className: c.trim(), ...o, children: t });
}
const N0 = ht({});
function j_(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...a
  } = e, s = r === "left" ? "-100%" : "100%", l = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ F.jsx(N0.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ F.jsx(jv, { children: t && /* @__PURE__ */ F.jsxs("aside", { className: l.trim(), ...a, children: [
    /* @__PURE__ */ F.jsx(
      Go.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ F.jsx(
      Go.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${s})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${s})` },
        children: o
      }
    )
  ] }) }) });
}
function N_(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = Ae(N0), a = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ F.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ F.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ F.jsx(Fv, { size: 24 })
      }
    )
  ] });
}
const z0 = ht({});
function z_(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, s = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ F.jsx(z0.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ F.jsx(jv, { children: t && /* @__PURE__ */ F.jsxs("aside", { className: s.trim(), ...i, children: [
    /* @__PURE__ */ F.jsx(
      Go.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ F.jsx(
      Go.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function $_(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ F.jsx("footer", { className: o.trim(), ...r });
}
function U_(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = Ae(z0), a = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ F.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ F.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ F.jsx(Fv, { size: 24 })
      }
    )
  ] });
}
function W_(e) {
  const { children: t, button: n, closeOnClick: r, orientation: o = "bottomLeft" } = e, [i, a] = P(!1), u = `arkynPopover ${o} ${i ? "visibleTrue" : "visibleFalse"}`;
  function l() {
    i || a(!0);
  }
  return /* @__PURE__ */ F.jsxs("div", { className: u, onClick: l, children: [
    n,
    /* @__PURE__ */ F.jsx(
      Go.div,
      {
        style: { visibility: i ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: i ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && a(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    i && /* @__PURE__ */ F.jsx("div", { onClick: () => a(!1), className: "arkynPopoverOverlay" })
  ] });
}
function H_(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ F.jsx(Tv, {});
      case "danger":
        return /* @__PURE__ */ F.jsx(Bv, {});
      default:
        return /* @__PURE__ */ F.jsx(Pv, {});
    }
  }
  return /* @__PURE__ */ F.jsxs("div", { className: r, children: [
    /* @__PURE__ */ F.jsxs("div", { children: [
      /* @__PURE__ */ F.jsx("div", { className: "bg" }),
      /* @__PURE__ */ F.jsx(o, {})
    ] }),
    /* @__PURE__ */ F.jsx("p", { children: /* @__PURE__ */ F.jsx("span", { children: t }) })
  ] });
}
function V_(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ F.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ F.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
var Rt = {}, Nc = {}, hi = {}, gi = {}, $0 = "Expected a function", Yg = NaN, tF = "[object Symbol]", nF = /^\s+|\s+$/g, rF = /^[-+]0x[0-9a-f]+$/i, oF = /^0b[01]+$/i, iF = /^0o[0-7]+$/i, aF = parseInt, sF = typeof vt == "object" && vt && vt.Object === Object && vt, uF = typeof self == "object" && self && self.Object === Object && self, lF = sF || uF || Function("return this")(), cF = Object.prototype, fF = cF.toString, dF = Math.max, pF = Math.min, yu = function() {
  return lF.Date.now();
};
function hF(e, t, n) {
  var r, o, i, a, s, u, l = 0, c = !1, f = !1, p = !0;
  if (typeof e != "function")
    throw new TypeError($0);
  t = Xg(t) || 0, Aa(n) && (c = !!n.leading, f = "maxWait" in n, i = f ? dF(Xg(n.maxWait) || 0, t) : i, p = "trailing" in n ? !!n.trailing : p);
  function g(E) {
    var O = r, S = o;
    return r = o = void 0, l = E, a = e.apply(S, O), a;
  }
  function v(E) {
    return l = E, s = setTimeout(w, t), c ? g(E) : a;
  }
  function h(E) {
    var O = E - u, S = E - l, V = t - O;
    return f ? pF(V, i - S) : V;
  }
  function d(E) {
    var O = E - u, S = E - l;
    return u === void 0 || O >= t || O < 0 || f && S >= i;
  }
  function w() {
    var E = yu();
    if (d(E))
      return L(E);
    s = setTimeout(w, h(E));
  }
  function L(E) {
    return s = void 0, p && r ? g(E) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), l = 0, r = u = o = s = void 0;
  }
  function B() {
    return s === void 0 ? a : L(yu());
  }
  function b() {
    var E = yu(), O = d(E);
    if (r = arguments, o = this, u = E, O) {
      if (s === void 0)
        return v(u);
      if (f)
        return s = setTimeout(w, t), g(u);
    }
    return s === void 0 && (s = setTimeout(w, t)), a;
  }
  return b.cancel = D, b.flush = B, b;
}
function gF(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError($0);
  return Aa(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), hF(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Aa(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function vF(e) {
  return !!e && typeof e == "object";
}
function mF(e) {
  return typeof e == "symbol" || vF(e) && fF.call(e) == tF;
}
function Xg(e) {
  if (typeof e == "number")
    return e;
  if (mF(e))
    return Yg;
  if (Aa(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Aa(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(nF, "");
  var n = oF.test(e);
  return n || iF.test(e) ? aF(e.slice(2), n ? 2 : 8) : rF.test(e) ? Yg : +e;
}
var yF = gF, vi = {};
Object.defineProperty(vi, "__esModule", {
  value: !0
});
vi.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), da.has(n) || da.set(n, /* @__PURE__ */ new Set());
  var i = da.get(n);
  if (!i.has(o)) {
    var a = function() {
      var s = !1;
      try {
        var u = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, u);
      } catch {
      }
      return s;
    }();
    t.addEventListener(n, r, a ? { passive: !0 } : !1), i.add(o);
  }
};
vi.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), da.get(n).delete(r.name || n);
};
var da = /* @__PURE__ */ new Map();
Object.defineProperty(gi, "__esModule", {
  value: !0
});
var bF = yF, CF = EF(bF), wF = vi;
function EF(e) {
  return e && e.__esModule ? e : { default: e };
}
var DF = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, CF.default)(t, n);
}, Bt = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = DF(function(o) {
        Bt.scrollHandler(t);
      }, n);
      Bt.scrollSpyContainers.push(t), (0, wF.addPassiveEventListener)(t, "scroll", r);
    }
  },
  isMounted: function(t) {
    return Bt.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.pageYOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = Bt.scrollSpyContainers[Bt.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(Bt.currentPositionX(t), Bt.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    Bt.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = Bt.scrollSpyContainers[Bt.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t), t(Bt.currentPositionX(n), Bt.currentPositionY(n));
  },
  updateStates: function() {
    Bt.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    Bt.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), Bt.spySetState && Bt.spySetState.length && Bt.spySetState.indexOf(t) > -1 && Bt.spySetState.splice(Bt.spySetState.indexOf(t), 1), document.removeEventListener("scroll", Bt.scrollHandler);
  },
  update: function() {
    return Bt.scrollSpyContainers.forEach(function(t) {
      return Bt.scrollHandler(t);
    });
  }
};
gi.default = Bt;
var Co = {}, mi = {};
Object.defineProperty(mi, "__esModule", {
  value: !0
});
var xF = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, a = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", a) : history.replaceState(history.state, "", a);
}, LF = function() {
  return window.location.hash.replace(/^#/, "");
}, OF = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, SF = function(t) {
  return getComputedStyle(t).position !== "static";
}, bu = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, kF = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (SF(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = bu(n, o), a = i.offsetTop, s = i.offsetParent;
      if (s !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return a;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var u = function(c) {
    return c === document;
  };
  return bu(n, u).offsetTop - bu(t, u).offsetTop;
};
mi.default = {
  updateHash: xF,
  getHash: LF,
  filterElementInContainer: OF,
  scrollOffset: kF
};
var ws = {}, zc = {};
Object.defineProperty(zc, "__esModule", {
  value: !0
});
zc.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var $c = {};
Object.defineProperty($c, "__esModule", {
  value: !0
});
var MF = vi, PF = ["mousedown", "mousewheel", "touchmove", "keydown"];
$c.default = {
  subscribe: function(t) {
    return typeof document < "u" && PF.forEach(function(n) {
      return (0, MF.addPassiveEventListener)(document, n, t);
    });
  }
};
var yi = {};
Object.defineProperty(yi, "__esModule", {
  value: !0
});
var Cl = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      Cl.registered[t] = n;
    },
    remove: function(t) {
      Cl.registered[t] = null;
    }
  }
};
yi.default = Cl;
Object.defineProperty(ws, "__esModule", {
  value: !0
});
var BF = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, TF = mi;
Es(TF);
var AF = zc, Jg = Es(AF), FF = $c, IF = Es(FF), RF = yi, qn = Es(RF);
function Es(e) {
  return e && e.__esModule ? e : { default: e };
}
var U0 = function(t) {
  return Jg.default[t.smooth] || Jg.default.defaultEasing;
}, _F = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, jF = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, wl = function() {
  return jF() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), W0 = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, H0 = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, V0 = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, NF = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, zF = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, $F = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    qn.default.registered.end && qn.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    wl.call(window, i);
    return;
  }
  qn.default.registered.end && qn.default.registered.end(o.to, o.target, o.currentPosition);
}, Uc = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, bi = function(t, n, r, o) {
  n.data = n.data || W0(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (IF.default.subscribe(i), Uc(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? H0(n) : V0(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    qn.default.registered.end && qn.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = _F(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var a = U0(n), s = $F.bind(null, a, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      qn.default.registered.begin && qn.default.registered.begin(n.data.to, n.data.target), wl.call(window, s);
    }, n.delay);
    return;
  }
  qn.default.registered.begin && qn.default.registered.begin(n.data.to, n.data.target), wl.call(window, s);
}, Ds = function(t) {
  return t = BF({}, t), t.data = t.data || W0(), t.absolute = !0, t;
}, UF = function(t) {
  bi(0, Ds(t));
}, WF = function(t, n) {
  bi(t, Ds(n));
}, HF = function(t) {
  t = Ds(t), Uc(t), bi(t.horizontal ? NF(t) : zF(t), t);
}, VF = function(t, n) {
  n = Ds(n), Uc(n);
  var r = n.horizontal ? H0(n) : V0(n);
  bi(t + r, n);
};
ws.default = {
  animateTopScroll: bi,
  getAnimationType: U0,
  scrollToTop: UF,
  scrollToBottom: HF,
  scrollTo: WF,
  scrollMore: VF
};
Object.defineProperty(Co, "__esModule", {
  value: !0
});
var qF = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ZF = mi, GF = Wc(ZF), KF = ws, YF = Wc(KF), XF = yi, Qi = Wc(XF);
function Wc(e) {
  return e && e.__esModule ? e : { default: e };
}
var ea = {}, Qg = void 0;
Co.default = {
  unmount: function() {
    ea = {};
  },
  register: function(t, n) {
    ea[t] = n;
  },
  unregister: function(t) {
    delete ea[t];
  },
  get: function(t) {
    return ea[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return Qg = t;
  },
  getActiveLink: function() {
    return Qg;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = qF({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, a = void 0;
    o ? a = document.getElementById(o) : i && i.nodeType ? a = i : a = document, n.absolute = !0;
    var s = n.horizontal, u = GF.default.scrollOffset(a, r, s) + (n.offset || 0);
    if (!n.smooth) {
      Qi.default.registered.begin && Qi.default.registered.begin(t, r), a === document ? n.horizontal ? window.scrollTo(u, 0) : window.scrollTo(0, u) : a.scrollTop = u, Qi.default.registered.end && Qi.default.registered.end(t, r);
      return;
    }
    YF.default.animateTopScroll(u, n, t, r);
  }
};
var El = { exports: {} }, ta = { exports: {} }, ct = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ev;
function JF() {
  if (ev) return ct;
  ev = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, u = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, v = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, d = e ? Symbol.for("react.fundamental") : 60117, w = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
  function D(b) {
    if (typeof b == "object" && b !== null) {
      var E = b.$$typeof;
      switch (E) {
        case t:
          switch (b = b.type, b) {
            case u:
            case l:
            case r:
            case i:
            case o:
            case f:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case s:
                case c:
                case v:
                case g:
                case a:
                  return b;
                default:
                  return E;
              }
          }
        case n:
          return E;
      }
    }
  }
  function B(b) {
    return D(b) === l;
  }
  return ct.AsyncMode = u, ct.ConcurrentMode = l, ct.ContextConsumer = s, ct.ContextProvider = a, ct.Element = t, ct.ForwardRef = c, ct.Fragment = r, ct.Lazy = v, ct.Memo = g, ct.Portal = n, ct.Profiler = i, ct.StrictMode = o, ct.Suspense = f, ct.isAsyncMode = function(b) {
    return B(b) || D(b) === u;
  }, ct.isConcurrentMode = B, ct.isContextConsumer = function(b) {
    return D(b) === s;
  }, ct.isContextProvider = function(b) {
    return D(b) === a;
  }, ct.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === t;
  }, ct.isForwardRef = function(b) {
    return D(b) === c;
  }, ct.isFragment = function(b) {
    return D(b) === r;
  }, ct.isLazy = function(b) {
    return D(b) === v;
  }, ct.isMemo = function(b) {
    return D(b) === g;
  }, ct.isPortal = function(b) {
    return D(b) === n;
  }, ct.isProfiler = function(b) {
    return D(b) === i;
  }, ct.isStrictMode = function(b) {
    return D(b) === o;
  }, ct.isSuspense = function(b) {
    return D(b) === f;
  }, ct.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === r || b === l || b === i || b === o || b === f || b === p || typeof b == "object" && b !== null && (b.$$typeof === v || b.$$typeof === g || b.$$typeof === a || b.$$typeof === s || b.$$typeof === c || b.$$typeof === d || b.$$typeof === w || b.$$typeof === L || b.$$typeof === h);
  }, ct.typeOf = D, ct;
}
var ft = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tv;
function QF() {
  return tv || (tv = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, u = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, v = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, d = e ? Symbol.for("react.fundamental") : 60117, w = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === l || N === i || N === o || N === f || N === p || typeof N == "object" && N !== null && (N.$$typeof === v || N.$$typeof === g || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === d || N.$$typeof === w || N.$$typeof === L || N.$$typeof === h);
    }
    function B(N) {
      if (typeof N == "object" && N !== null) {
        var se = N.$$typeof;
        switch (se) {
          case t:
            var ue = N.type;
            switch (ue) {
              case u:
              case l:
              case r:
              case i:
              case o:
              case f:
                return ue;
              default:
                var de = ue && ue.$$typeof;
                switch (de) {
                  case s:
                  case c:
                  case v:
                  case g:
                  case a:
                    return de;
                  default:
                    return se;
                }
            }
          case n:
            return se;
        }
      }
    }
    var b = u, E = l, O = s, S = a, V = t, M = c, q = r, _ = v, j = g, I = n, z = i, X = o, R = f, ee = !1;
    function re(N) {
      return ee || (ee = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || B(N) === u;
    }
    function k(N) {
      return B(N) === l;
    }
    function A(N) {
      return B(N) === s;
    }
    function G(N) {
      return B(N) === a;
    }
    function U(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function Y(N) {
      return B(N) === c;
    }
    function K(N) {
      return B(N) === r;
    }
    function m(N) {
      return B(N) === v;
    }
    function $(N) {
      return B(N) === g;
    }
    function W(N) {
      return B(N) === n;
    }
    function T(N) {
      return B(N) === i;
    }
    function J(N) {
      return B(N) === o;
    }
    function te(N) {
      return B(N) === f;
    }
    ft.AsyncMode = b, ft.ConcurrentMode = E, ft.ContextConsumer = O, ft.ContextProvider = S, ft.Element = V, ft.ForwardRef = M, ft.Fragment = q, ft.Lazy = _, ft.Memo = j, ft.Portal = I, ft.Profiler = z, ft.StrictMode = X, ft.Suspense = R, ft.isAsyncMode = re, ft.isConcurrentMode = k, ft.isContextConsumer = A, ft.isContextProvider = G, ft.isElement = U, ft.isForwardRef = Y, ft.isFragment = K, ft.isLazy = m, ft.isMemo = $, ft.isPortal = W, ft.isProfiler = T, ft.isStrictMode = J, ft.isSuspense = te, ft.isValidElementType = D, ft.typeOf = B;
  }()), ft;
}
var nv;
function q0() {
  return nv || (nv = 1, process.env.NODE_ENV === "production" ? ta.exports = JF() : ta.exports = QF()), ta.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Cu, rv;
function eI() {
  if (rv) return Cu;
  rv = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var u = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (u.join("") !== "0123456789")
        return !1;
      var l = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        l[c] = c;
      }), Object.keys(Object.assign({}, l)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Cu = o() ? Object.assign : function(i, a) {
    for (var s, u = r(i), l, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var f in s)
        t.call(s, f) && (u[f] = s[f]);
      if (e) {
        l = e(s);
        for (var p = 0; p < l.length; p++)
          n.call(s, l[p]) && (u[l[p]] = s[l[p]]);
      }
    }
    return u;
  }, Cu;
}
var wu, ov;
function Hc() {
  if (ov) return wu;
  ov = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return wu = e, wu;
}
var Eu, iv;
function Z0() {
  return iv || (iv = 1, Eu = Function.call.bind(Object.prototype.hasOwnProperty)), Eu;
}
var Du, av;
function tI() {
  if (av) return Du;
  av = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Hc(), n = {}, r = Z0();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, u, l) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var f;
          try {
            if (typeof i[c] != "function") {
              var p = Error(
                (u || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            f = i[c](a, c, u, s, null, t);
          } catch (v) {
            f = v;
          }
          if (f && !(f instanceof Error) && e(
            (u || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in n)) {
            n[f.message] = !0;
            var g = l ? l() : "";
            e(
              "Failed " + s + " type: " + f.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Du = o, Du;
}
var xu, sv;
function nI() {
  if (sv) return xu;
  sv = 1;
  var e = q0(), t = eI(), n = Hc(), r = Z0(), o = tI(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var u = "Warning: " + s;
    typeof console < "u" && console.error(u);
    try {
      throw new Error(u);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return xu = function(s, u) {
    var l = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function f(k) {
      var A = k && (l && k[l] || k[c]);
      if (typeof A == "function")
        return A;
    }
    var p = "<<anonymous>>", g = {
      array: w("array"),
      bigint: w("bigint"),
      bool: w("boolean"),
      func: w("function"),
      number: w("number"),
      object: w("object"),
      string: w("string"),
      symbol: w("symbol"),
      any: L(),
      arrayOf: D,
      element: B(),
      elementType: b(),
      instanceOf: E,
      node: M(),
      objectOf: S,
      oneOf: O,
      oneOfType: V,
      shape: _,
      exact: j
    };
    function v(k, A) {
      return k === A ? k !== 0 || 1 / k === 1 / A : k !== k && A !== A;
    }
    function h(k, A) {
      this.message = k, this.data = A && typeof A == "object" ? A : {}, this.stack = "";
    }
    h.prototype = Error.prototype;
    function d(k) {
      if (process.env.NODE_ENV !== "production")
        var A = {}, G = 0;
      function U(K, m, $, W, T, J, te) {
        if (W = W || p, J = J || $, te !== n) {
          if (u) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var se = W + ":" + $;
            !A[se] && // Avoid spamming the console because they are often not actionable except for lib authors
            G < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + J + "` prop on `" + W + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), A[se] = !0, G++);
          }
        }
        return m[$] == null ? K ? m[$] === null ? new h("The " + T + " `" + J + "` is marked as required " + ("in `" + W + "`, but its value is `null`.")) : new h("The " + T + " `" + J + "` is marked as required in " + ("`" + W + "`, but its value is `undefined`.")) : null : k(m, $, W, T, J);
      }
      var Y = U.bind(null, !1);
      return Y.isRequired = U.bind(null, !0), Y;
    }
    function w(k) {
      function A(G, U, Y, K, m, $) {
        var W = G[U], T = X(W);
        if (T !== k) {
          var J = R(W);
          return new h(
            "Invalid " + K + " `" + m + "` of type " + ("`" + J + "` supplied to `" + Y + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return d(A);
    }
    function L() {
      return d(a);
    }
    function D(k) {
      function A(G, U, Y, K, m) {
        if (typeof k != "function")
          return new h("Property `" + m + "` of component `" + Y + "` has invalid PropType notation inside arrayOf.");
        var $ = G[U];
        if (!Array.isArray($)) {
          var W = X($);
          return new h("Invalid " + K + " `" + m + "` of type " + ("`" + W + "` supplied to `" + Y + "`, expected an array."));
        }
        for (var T = 0; T < $.length; T++) {
          var J = k($, T, Y, K, m + "[" + T + "]", n);
          if (J instanceof Error)
            return J;
        }
        return null;
      }
      return d(A);
    }
    function B() {
      function k(A, G, U, Y, K) {
        var m = A[G];
        if (!s(m)) {
          var $ = X(m);
          return new h("Invalid " + Y + " `" + K + "` of type " + ("`" + $ + "` supplied to `" + U + "`, expected a single ReactElement."));
        }
        return null;
      }
      return d(k);
    }
    function b() {
      function k(A, G, U, Y, K) {
        var m = A[G];
        if (!e.isValidElementType(m)) {
          var $ = X(m);
          return new h("Invalid " + Y + " `" + K + "` of type " + ("`" + $ + "` supplied to `" + U + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return d(k);
    }
    function E(k) {
      function A(G, U, Y, K, m) {
        if (!(G[U] instanceof k)) {
          var $ = k.name || p, W = re(G[U]);
          return new h("Invalid " + K + " `" + m + "` of type " + ("`" + W + "` supplied to `" + Y + "`, expected ") + ("instance of `" + $ + "`."));
        }
        return null;
      }
      return d(A);
    }
    function O(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function A(G, U, Y, K, m) {
        for (var $ = G[U], W = 0; W < k.length; W++)
          if (v($, k[W]))
            return null;
        var T = JSON.stringify(k, function(te, N) {
          var se = R(N);
          return se === "symbol" ? String(N) : N;
        });
        return new h("Invalid " + K + " `" + m + "` of value `" + String($) + "` " + ("supplied to `" + Y + "`, expected one of " + T + "."));
      }
      return d(A);
    }
    function S(k) {
      function A(G, U, Y, K, m) {
        if (typeof k != "function")
          return new h("Property `" + m + "` of component `" + Y + "` has invalid PropType notation inside objectOf.");
        var $ = G[U], W = X($);
        if (W !== "object")
          return new h("Invalid " + K + " `" + m + "` of type " + ("`" + W + "` supplied to `" + Y + "`, expected an object."));
        for (var T in $)
          if (r($, T)) {
            var J = k($, T, Y, K, m + "." + T, n);
            if (J instanceof Error)
              return J;
          }
        return null;
      }
      return d(A);
    }
    function V(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var A = 0; A < k.length; A++) {
        var G = k[A];
        if (typeof G != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ee(G) + " at index " + A + "."
          ), a;
      }
      function U(Y, K, m, $, W) {
        for (var T = [], J = 0; J < k.length; J++) {
          var te = k[J], N = te(Y, K, m, $, W, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && T.push(N.data.expectedType);
        }
        var se = T.length > 0 ? ", expected one of type [" + T.join(", ") + "]" : "";
        return new h("Invalid " + $ + " `" + W + "` supplied to " + ("`" + m + "`" + se + "."));
      }
      return d(U);
    }
    function M() {
      function k(A, G, U, Y, K) {
        return I(A[G]) ? null : new h("Invalid " + Y + " `" + K + "` supplied to " + ("`" + U + "`, expected a ReactNode."));
      }
      return d(k);
    }
    function q(k, A, G, U, Y) {
      return new h(
        (k || "React class") + ": " + A + " type `" + G + "." + U + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Y + "`."
      );
    }
    function _(k) {
      function A(G, U, Y, K, m) {
        var $ = G[U], W = X($);
        if (W !== "object")
          return new h("Invalid " + K + " `" + m + "` of type `" + W + "` " + ("supplied to `" + Y + "`, expected `object`."));
        for (var T in k) {
          var J = k[T];
          if (typeof J != "function")
            return q(Y, K, m, T, R(J));
          var te = J($, T, Y, K, m + "." + T, n);
          if (te)
            return te;
        }
        return null;
      }
      return d(A);
    }
    function j(k) {
      function A(G, U, Y, K, m) {
        var $ = G[U], W = X($);
        if (W !== "object")
          return new h("Invalid " + K + " `" + m + "` of type `" + W + "` " + ("supplied to `" + Y + "`, expected `object`."));
        var T = t({}, G[U], k);
        for (var J in T) {
          var te = k[J];
          if (r(k, J) && typeof te != "function")
            return q(Y, K, m, J, R(te));
          if (!te)
            return new h(
              "Invalid " + K + " `" + m + "` key `" + J + "` supplied to `" + Y + "`.\nBad object: " + JSON.stringify(G[U], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = te($, J, Y, K, m + "." + J, n);
          if (N)
            return N;
        }
        return null;
      }
      return d(A);
    }
    function I(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(I);
          if (k === null || s(k))
            return !0;
          var A = f(k);
          if (A) {
            var G = A.call(k), U;
            if (A !== k.entries) {
              for (; !(U = G.next()).done; )
                if (!I(U.value))
                  return !1;
            } else
              for (; !(U = G.next()).done; ) {
                var Y = U.value;
                if (Y && !I(Y[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function z(k, A) {
      return k === "symbol" ? !0 : A ? A["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && A instanceof Symbol : !1;
    }
    function X(k) {
      var A = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : z(A, k) ? "symbol" : A;
    }
    function R(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var A = X(k);
      if (A === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return A;
    }
    function ee(k) {
      var A = R(k);
      switch (A) {
        case "array":
        case "object":
          return "an " + A;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + A;
        default:
          return A;
      }
    }
    function re(k) {
      return !k.constructor || !k.constructor.name ? p : k.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, xu;
}
var Lu, uv;
function rI() {
  if (uv) return Lu;
  uv = 1;
  var e = Hc();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Lu = function() {
    function r(a, s, u, l, c, f) {
      if (f !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Lu;
}
if (process.env.NODE_ENV !== "production") {
  var oI = q0(), iI = !0;
  El.exports = nI()(oI.isElement, iI);
} else
  El.exports = rI()();
var xs = El.exports, Ls = {};
Object.defineProperty(Ls, "__esModule", {
  value: !0
});
var aI = mi, Ou = sI(aI);
function sI(e) {
  return e && e.__esModule ? e : { default: e };
}
var uI = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return Ou.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && Ou.default.getHash() !== t && Ou.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Ls.default = uI;
Object.defineProperty(hi, "__esModule", {
  value: !0
});
var na = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, lI = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), cI = Se, lv = Ci(cI), fI = gi, ra = Ci(fI), dI = Co, pI = Ci(dI), hI = xs, kt = Ci(hI), gI = Ls, gr = Ci(gI);
function Ci(e) {
  return e && e.__esModule ? e : { default: e };
}
function vI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function mI(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function yI(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var cv = {
  to: kt.default.string.isRequired,
  containerId: kt.default.string,
  container: kt.default.object,
  activeClass: kt.default.string,
  activeStyle: kt.default.object,
  spy: kt.default.bool,
  horizontal: kt.default.bool,
  smooth: kt.default.oneOfType([kt.default.bool, kt.default.string]),
  offset: kt.default.number,
  delay: kt.default.number,
  isDynamic: kt.default.bool,
  onClick: kt.default.func,
  duration: kt.default.oneOfType([kt.default.number, kt.default.func]),
  absolute: kt.default.bool,
  onSetActive: kt.default.func,
  onSetInactive: kt.default.func,
  ignoreCancelEvents: kt.default.bool,
  hashSpy: kt.default.bool,
  saveHashHistory: kt.default.bool,
  spyThrottle: kt.default.number
};
hi.default = function(e, t) {
  var n = t || pI.default, r = function(i) {
    yI(a, i);
    function a(s) {
      vI(this, a);
      var u = mI(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(u), u.state = {
        active: !1
      }, u;
    }
    return lI(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var u = this.props.containerId, l = this.props.container;
        return u && !l ? document.getElementById(u) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var u = this.getScrollSpyContainer();
          ra.default.isMounted(u) || ra.default.mount(u, this.props.spyThrottle), this.props.hashSpy && (gr.default.isMounted() || gr.default.mount(n), gr.default.mapContainer(this.props.to, u)), ra.default.addSpyHandler(this.spyHandler, u), this.setState({
            container: u
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        ra.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var u = "";
        this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
        var l = {};
        this.state && this.state.active ? l = na({}, this.props.style, this.props.activeStyle) : l = na({}, this.props.style);
        var c = na({}, this.props);
        for (var f in cv)
          c.hasOwnProperty(f) && delete c[f];
        return c.className = u, c.style = l, c.onClick = this.handleClick, lv.default.createElement(e, c);
      }
    }]), a;
  }(lv.default.PureComponent), o = function() {
    var a = this;
    this.scrollTo = function(s, u) {
      n.scrollTo(s, na({}, a.state, u));
    }, this.handleClick = function(s) {
      a.props.onClick && a.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), a.scrollTo(a.props.to, a.props);
    }, this.spyHandler = function(s, u) {
      var l = a.getScrollSpyContainer();
      if (!(gr.default.isMounted() && !gr.default.isInitialized())) {
        var c = a.props.horizontal, f = a.props.to, p = null, g = void 0, v = void 0;
        if (c) {
          var h = 0, d = 0, w = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            w = L.left;
          }
          if (!p || a.props.isDynamic) {
            if (p = n.get(f), !p)
              return;
            var D = p.getBoundingClientRect();
            h = D.left - w + s, d = h + D.width;
          }
          var B = s - a.props.offset;
          g = B >= Math.floor(h) && B < Math.floor(d), v = B < Math.floor(h) || B >= Math.floor(d);
        } else {
          var b = 0, E = 0, O = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            O = S.top;
          }
          if (!p || a.props.isDynamic) {
            if (p = n.get(f), !p)
              return;
            var V = p.getBoundingClientRect();
            b = V.top - O + u, E = b + V.height;
          }
          var M = u - a.props.offset;
          g = M >= Math.floor(b) && M < Math.floor(E), v = M < Math.floor(b) || M >= Math.floor(E);
        }
        var q = n.getActiveLink();
        if (v) {
          if (f === q && n.setActiveLink(void 0), a.props.hashSpy && gr.default.getHash() === f) {
            var _ = a.props.saveHashHistory, j = _ === void 0 ? !1 : _;
            gr.default.changeHash("", j);
          }
          a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive(f, p));
        }
        if (g && (q !== f || a.state.active === !1)) {
          n.setActiveLink(f);
          var I = a.props.saveHashHistory, z = I === void 0 ? !1 : I;
          a.props.hashSpy && gr.default.changeHash(f, z), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(f, p));
        }
      }
    };
  };
  return r.propTypes = cv, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Nc, "__esModule", {
  value: !0
});
var bI = Se, fv = G0(bI), CI = hi, wI = G0(CI);
function G0(e) {
  return e && e.__esModule ? e : { default: e };
}
function EI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function dv(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function DI(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var xI = function(e) {
  DI(t, e);
  function t() {
    var n, r, o, i;
    EI(this, t);
    for (var a = arguments.length, s = Array(a), u = 0; u < a; u++)
      s[u] = arguments[u];
    return i = (r = (o = dv(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return fv.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), dv(o, i);
  }
  return t;
}(fv.default.Component);
Nc.default = (0, wI.default)(xI);
var Vc = {};
Object.defineProperty(Vc, "__esModule", {
  value: !0
});
var LI = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), OI = Se, pv = K0(OI), SI = hi, kI = K0(SI);
function K0(e) {
  return e && e.__esModule ? e : { default: e };
}
function MI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function PI(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function BI(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var TI = function(e) {
  BI(t, e);
  function t() {
    return MI(this, t), PI(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return LI(t, [{
    key: "render",
    value: function() {
      return pv.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(pv.default.Component);
Vc.default = (0, kI.default)(TI);
var qc = {}, Os = {};
Object.defineProperty(Os, "__esModule", {
  value: !0
});
var AI = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, FI = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), II = Se, hv = Ss(II), RI = Ol;
Ss(RI);
var _I = Co, gv = Ss(_I), jI = xs, vv = Ss(jI);
function Ss(e) {
  return e && e.__esModule ? e : { default: e };
}
function NI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function zI(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function $I(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Os.default = function(e) {
  var t = function(n) {
    $I(r, n);
    function r(o) {
      NI(this, r);
      var i = zI(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return FI(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        gv.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        gv.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return hv.default.createElement(e, AI({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(hv.default.Component);
  return t.propTypes = {
    name: vv.default.string,
    id: vv.default.string
  }, t;
};
Object.defineProperty(qc, "__esModule", {
  value: !0
});
var mv = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, UI = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), WI = Se, yv = Zc(WI), HI = Os, VI = Zc(HI), qI = xs, bv = Zc(qI);
function Zc(e) {
  return e && e.__esModule ? e : { default: e };
}
function ZI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function GI(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function KI(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Y0 = function(e) {
  KI(t, e);
  function t() {
    return ZI(this, t), GI(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return UI(t, [{
    key: "render",
    value: function() {
      var r = this, o = mv({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, yv.default.createElement(
        "div",
        mv({}, o, { ref: function(a) {
          r.props.parentBindings.domNode = a;
        } }),
        this.props.children
      );
    }
  }]), t;
}(yv.default.Component);
Y0.propTypes = {
  name: bv.default.string,
  id: bv.default.string
};
qc.default = (0, VI.default)(Y0);
var Su = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Cv = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function wv(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ev(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Dv(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var oa = Se, Ur = gi, ku = Co, At = xs, vr = Ls, xv = {
  to: At.string.isRequired,
  containerId: At.string,
  container: At.object,
  activeClass: At.string,
  spy: At.bool,
  smooth: At.oneOfType([At.bool, At.string]),
  offset: At.number,
  delay: At.number,
  isDynamic: At.bool,
  onClick: At.func,
  duration: At.oneOfType([At.number, At.func]),
  absolute: At.bool,
  onSetActive: At.func,
  onSetInactive: At.func,
  ignoreCancelEvents: At.bool,
  hashSpy: At.bool,
  spyThrottle: At.number
}, YI = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || ku, o = function(a) {
      Dv(s, a);
      function s(u) {
        wv(this, s);
        var l = Ev(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, u));
        return i.call(l), l.state = {
          active: !1
        }, l;
      }
      return Cv(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var l = this.props.containerId, c = this.props.container;
          return l ? document.getElementById(l) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var l = this.getScrollSpyContainer();
            Ur.isMounted(l) || Ur.mount(l, this.props.spyThrottle), this.props.hashSpy && (vr.isMounted() || vr.mount(r), vr.mapContainer(this.props.to, l)), this.props.spy && Ur.addStateHandler(this.stateHandler), Ur.addSpyHandler(this.spyHandler, l), this.setState({
              container: l
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ur.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var l = "";
          this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
          var c = Su({}, this.props);
          for (var f in xv)
            c.hasOwnProperty(f) && delete c[f];
          return c.className = l, c.onClick = this.handleClick, oa.createElement(t, c);
        }
      }]), s;
    }(oa.Component), i = function() {
      var s = this;
      this.scrollTo = function(u, l) {
        r.scrollTo(u, Su({}, s.state, l));
      }, this.handleClick = function(u) {
        s.props.onClick && s.props.onClick(u), u.stopPropagation && u.stopPropagation(), u.preventDefault && u.preventDefault(), s.scrollTo(s.props.to, s.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== s.props.to && (s.state !== null && s.state.active && s.props.onSetInactive && s.props.onSetInactive(), s.setState({ active: !1 }));
      }, this.spyHandler = function(u) {
        var l = s.getScrollSpyContainer();
        if (!(vr.isMounted() && !vr.isInitialized())) {
          var c = s.props.to, f = null, p = 0, g = 0, v = 0;
          if (l.getBoundingClientRect) {
            var h = l.getBoundingClientRect();
            v = h.top;
          }
          if (!f || s.props.isDynamic) {
            if (f = r.get(c), !f)
              return;
            var d = f.getBoundingClientRect();
            p = d.top - v + u, g = p + d.height;
          }
          var w = u - s.props.offset, L = w >= Math.floor(p) && w < Math.floor(g), D = w < Math.floor(p) || w >= Math.floor(g), B = r.getActiveLink();
          if (D)
            return c === B && r.setActiveLink(void 0), s.props.hashSpy && vr.getHash() === c && vr.changeHash(), s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive()), Ur.updateStates();
          if (L && B !== c)
            return r.setActiveLink(c), s.props.hashSpy && vr.changeHash(c), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(c)), Ur.updateStates();
        }
      };
    };
    return o.propTypes = xv, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      Dv(o, r);
      function o(i) {
        wv(this, o);
        var a = Ev(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return a.childBindings = {
          domNode: null
        }, a;
      }
      return Cv(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(a) {
          this.props.name !== a.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          ku.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(a) {
          ku.register(a, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return oa.createElement(t, Su({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(oa.Component);
    return n.propTypes = {
      name: At.string,
      id: At.string
    }, n;
  }
}, XI = YI;
Object.defineProperty(Rt, "__esModule", {
  value: !0
});
Rt.Helpers = Rt.ScrollElement = Rt.ScrollLink = sb = Rt.animateScroll = Rt.scrollSpy = Rt.Events = Rt.scroller = Rt.Element = Rt.Button = Rt.Link = void 0;
var JI = Nc, X0 = Kn(JI), QI = Vc, J0 = Kn(QI), eR = qc, Q0 = Kn(eR), tR = Co, eb = Kn(tR), nR = yi, tb = Kn(nR), rR = gi, nb = Kn(rR), oR = ws, rb = Kn(oR), iR = hi, ob = Kn(iR), aR = Os, ib = Kn(aR), sR = XI, ab = Kn(sR);
function Kn(e) {
  return e && e.__esModule ? e : { default: e };
}
Rt.Link = X0.default;
Rt.Button = J0.default;
Rt.Element = Q0.default;
Rt.scroller = eb.default;
Rt.Events = tb.default;
Rt.scrollSpy = nb.default;
var sb = Rt.animateScroll = rb.default;
Rt.ScrollLink = ob.default;
Rt.ScrollElement = ib.default;
Rt.Helpers = ab.default;
Rt.default = { Link: X0.default, Button: J0.default, Element: Q0.default, scroller: eb.default, Events: tb.default, scrollSpy: nb.default, animateScroll: rb.default, ScrollLink: ob.default, ScrollElement: ib.default, Helpers: ab.default };
const Gc = ht({}), ub = ht({});
function uR() {
  const e = Ae(ub);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function Lv(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function q_() {
  const e = Sl(), { closeModal: t, closeAll: n } = Ae(Gc), { showToast: r } = uR(), { getParam: o } = j0(), { pathname: i } = kl(), a = _v(), s = o("closeAllModals");
  y(() => {
    s === "true" && (n(), a(i));
  }, [s]), y(() => {
    const u = e == null ? void 0 : e.closeModalKey;
    u && t(u);
  }, [e]), y(() => {
    const u = e == null ? void 0 : e.toast, l = e == null ? void 0 : e.message;
    Lv(u) && r(u), !Lv(u) && l && r({ message: l, type: "danger" });
  }, [e]), y(() => {
    var u, l;
    if (typeof ((u = e == null ? void 0 : e.data) == null ? void 0 : u.scrollTo) == "string") {
      const c = document.getElementById((l = e == null ? void 0 : e.data) == null ? void 0 : l.scrollTo);
      c && sb.scrollTo(c.offsetTop - 200);
    }
  }, [e]);
}
const lb = ht({});
function Z_(e) {
  const t = Ae(lb);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, a = r(e), s = n(e);
    return { drawerIsOpen: a, drawerData: s, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function G_(e) {
  const t = Ae(Gc);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, a = r(e), s = n(e);
    return { modalIsOpen: a, modalData: s, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function K_(e) {
  const { children: t = !1 } = e, [n, r] = P([]);
  function o(u) {
    return !!n.some((l) => l.key === u);
  }
  function i(u) {
    var l;
    return (l = n.find((c) => c.key === u)) == null ? void 0 : l.data;
  }
  function a(u, l) {
    const c = o(u);
    r(c ? (f) => [...f.filter((g) => g.key !== u), { key: u, data: l }] : [...n, { key: u, data: l }]);
  }
  function s(u) {
    r(n.filter((l) => l.key !== u));
  }
  return /* @__PURE__ */ F.jsx(
    lb.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: a, closeDrawer: s },
      children: t
    }
  );
}
function Y_({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ F.jsx(
    eC,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function X_(e) {
  const { children: t = !1 } = e, [n, r] = P([]);
  function o(l) {
    return !!n.some((c) => c.key === l);
  }
  function i(l) {
    var c;
    return (c = n.find((f) => f.key === l)) == null ? void 0 : c.data;
  }
  function a(l, c) {
    const f = o(l);
    r(f ? (p) => [...p.filter((v) => v.key !== l), { key: l, data: c }] : [...n, { key: l, data: c }]);
  }
  function s(l) {
    r(n.filter((c) => c.key !== l));
  }
  function u() {
    r([]);
  }
  return /* @__PURE__ */ F.jsx(
    Gc.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: a, closeModal: s, closeAll: u },
      children: t
    }
  );
}
let lR = { data: "" }, cR = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || lR, fR = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, dR = /\/\*[^]*?\*\/|  +/g, Ov = /\n+/g, xr = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? xr(a, i) : i + "{" + xr(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += xr(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (u) => /&/.test(u) ? u.replace(/&/g, s) : s ? s + " " + u : u)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += xr.p ? xr.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, rr = {}, cb = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + cb(e[n]);
    return t;
  }
  return e;
}, pR = (e, t, n, r, o) => {
  let i = cb(e), a = rr[i] || (rr[i] = ((u) => {
    let l = 0, c = 11;
    for (; l < u.length; ) c = 101 * c + u.charCodeAt(l++) >>> 0;
    return "go" + c;
  })(i));
  if (!rr[a]) {
    let u = i !== e ? e : ((l) => {
      let c, f, p = [{}];
      for (; c = fR.exec(l.replace(dR, "")); ) c[4] ? p.shift() : c[3] ? (f = c[3].replace(Ov, " ").trim(), p.unshift(p[0][f] = p[0][f] || {})) : p[0][c[1]] = c[2].replace(Ov, " ").trim();
      return p[0];
    })(e);
    rr[a] = xr(o ? { ["@keyframes " + a]: u } : u, n ? "" : "." + a);
  }
  let s = n && rr.g ? rr.g : null;
  return n && (rr.g = rr[a]), ((u, l, c, f) => {
    f ? l.data = l.data.replace(f, u) : l.data.indexOf(u) === -1 && (l.data = c ? u + l.data : l.data + u);
  })(rr[a], t, r, s), a;
}, hR = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), u = s && s.props && s.props.className || /^go/.test(s) && s;
    a = u ? "." + u : s && typeof s == "object" ? s.props ? "" : xr(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function ks(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return pR(n.unshift ? n.raw ? hR(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, cR(t.target), t.g, t.o, t.k);
}
let fb, Dl, xl;
ks.bind({ g: 1 });
let ur = ks.bind({ k: 1 });
function gR(e, t, n, r) {
  xr.p = t, fb = e, Dl = n, xl = r;
}
function _r(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), u = s.className || o.className;
      n.p = Object.assign({ theme: Dl && Dl() }, s), n.o = / *go\d+/.test(u), s.className = ks.apply(n, r) + (u ? " " + u : ""), t && (s.ref = a);
      let l = e;
      return e[0] && (l = s.as || e, delete s.as), xl && l[0] && xl(s), fb(l, s);
    }
    return t ? t(o) : o;
  };
}
var vR = (e) => typeof e == "function", Fa = (e, t) => vR(e) ? e(t) : e, mR = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), db = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), yR = 20, pa = /* @__PURE__ */ new Map(), bR = 1e3, Sv = (e) => {
  if (pa.has(e)) return;
  let t = setTimeout(() => {
    pa.delete(e), so({ type: 4, toastId: e });
  }, bR);
  pa.set(e, t);
}, CR = (e) => {
  let t = pa.get(e);
  t && clearTimeout(t);
}, Ll = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, yR) };
    case 1:
      return t.toast.id && CR(t.toast.id), { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return e.toasts.find((i) => i.id === n.id) ? Ll(e, { type: 1, toast: n }) : Ll(e, { type: 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return r ? Sv(r) : e.toasts.forEach((i) => {
        Sv(i.id);
      }), { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, ha = [], ga = { toasts: [], pausedAt: void 0 }, so = (e) => {
  ga = Ll(ga, e), ha.forEach((t) => {
    t(ga);
  });
}, wR = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, ER = (e = {}) => {
  let [t, n] = P(ga);
  y(() => (ha.push(n), () => {
    let o = ha.indexOf(n);
    o > -1 && ha.splice(o, 1);
  }), [t]);
  let r = t.toasts.map((o) => {
    var i, a;
    return { ...e, ...e[o.type], ...o, duration: o.duration || ((i = e[o.type]) == null ? void 0 : i.duration) || (e == null ? void 0 : e.duration) || wR[o.type], style: { ...e.style, ...(a = e[o.type]) == null ? void 0 : a.style, ...o.style } };
  });
  return { ...t, toasts: r };
}, DR = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || mR() }), wi = (e) => (t, n) => {
  let r = DR(t, e, n);
  return so({ type: 2, toast: r }), r.id;
}, xn = (e, t) => wi("blank")(e, t);
xn.error = wi("error");
xn.success = wi("success");
xn.loading = wi("loading");
xn.custom = wi("custom");
xn.dismiss = (e) => {
  so({ type: 3, toastId: e });
};
xn.remove = (e) => so({ type: 4, toastId: e });
xn.promise = (e, t, n) => {
  let r = xn.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return e.then((o) => (xn.success(Fa(t.success, o), { id: r, ...n, ...n == null ? void 0 : n.success }), o)).catch((o) => {
    xn.error(Fa(t.error, o), { id: r, ...n, ...n == null ? void 0 : n.error });
  }), e;
};
var xR = (e, t) => {
  so({ type: 1, toast: { id: e, height: t } });
}, LR = () => {
  so({ type: 5, time: Date.now() });
}, OR = (e) => {
  let { toasts: t, pausedAt: n } = ER(e);
  y(() => {
    if (n) return;
    let i = Date.now(), a = t.map((s) => {
      if (s.duration === 1 / 0) return;
      let u = (s.duration || 0) + s.pauseDuration - (i - s.createdAt);
      if (u < 0) {
        s.visible && xn.dismiss(s.id);
        return;
      }
      return setTimeout(() => xn.dismiss(s.id), u);
    });
    return () => {
      a.forEach((s) => s && clearTimeout(s));
    };
  }, [t, n]);
  let r = dt(() => {
    n && so({ type: 6, time: Date.now() });
  }, [n]), o = dt((i, a) => {
    let { reverseOrder: s = !1, gutter: u = 8, defaultPosition: l } = a || {}, c = t.filter((g) => (g.position || l) === (i.position || l) && g.height), f = c.findIndex((g) => g.id === i.id), p = c.filter((g, v) => v < f && g.visible).length;
    return c.filter((g) => g.visible).slice(...s ? [p + 1] : [0, p]).reduce((g, v) => g + (v.height || 0) + u, 0);
  }, [t]);
  return { toasts: t, handlers: { updateHeight: xR, startPause: LR, endPause: r, calculateOffset: o } };
}, SR = ur`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, kR = ur`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, MR = ur`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, PR = _r("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${SR} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${kR} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${MR} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, BR = ur`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, TR = _r("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${BR} 1s linear infinite;
`, AR = ur`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, FR = ur`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, IR = _r("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${AR} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${FR} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, RR = _r("div")`
  position: absolute;
`, _R = _r("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, jR = ur`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, NR = _r("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${jR} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, zR = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? ut.createElement(NR, null, t) : t : n === "blank" ? null : ut.createElement(_R, null, ut.createElement(TR, { ...r }), n !== "loading" && ut.createElement(RR, null, n === "error" ? ut.createElement(PR, { ...r }) : ut.createElement(IR, { ...r })));
}, $R = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, UR = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, WR = "0%{opacity:0;} 100%{opacity:1;}", HR = "0%{opacity:1;} 100%{opacity:0;}", VR = _r("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, qR = _r("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, ZR = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = db() ? [WR, HR] : [$R(n), UR(n)];
  return { animation: t ? `${ur(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ur(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, GR = ut.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? ZR(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = ut.createElement(zR, { toast: e }), a = ut.createElement(qR, { ...e.ariaProps }, Fa(e.message, e));
  return ut.createElement(VR, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : ut.createElement(ut.Fragment, null, i, a));
});
gR(ut.createElement);
var KR = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = ut.useCallback((a) => {
    if (a) {
      let s = () => {
        let u = a.getBoundingClientRect().height;
        r(e, u);
      };
      s(), new MutationObserver(s).observe(a, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return ut.createElement("div", { ref: i, className: t, style: n }, o);
}, YR = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: db() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, XR = ks`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, ia = 16, JR = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: a }) => {
  let { toasts: s, handlers: u } = OR(n);
  return ut.createElement("div", { style: { position: "fixed", zIndex: 9999, top: ia, left: ia, right: ia, bottom: ia, pointerEvents: "none", ...i }, className: a, onMouseEnter: u.startPause, onMouseLeave: u.endPause }, s.map((l) => {
    let c = l.position || t, f = u.calculateOffset(l, { reverseOrder: e, gutter: r, defaultPosition: t }), p = YR(c, f);
    return ut.createElement(KR, { id: l.id, key: l.id, onHeightUpdate: u.updateHeight, className: l.visible ? XR : "", style: p }, l.type === "custom" ? Fa(l.message, l) : o ? o(l) : ut.createElement(GR, { toast: l, position: c }));
  }));
}, kv = xn;
function J_({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return kv.success(n.message);
      case "danger":
        return kv.error(n.message);
    }
  }
  return /* @__PURE__ */ F.jsxs(ub.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ F.jsx(
      JR,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
export {
  i_ as AlertContainer,
  a_ as AlertContent,
  s_ as AlertDescription,
  u_ as AlertIcon,
  Rb as AlertTitle,
  l_ as Badge,
  A_ as BreadcrumbContainer,
  F_ as BreadcrumbLink,
  b_ as Button,
  c_ as Card,
  w_ as Checkbox,
  f_ as Divider,
  j_ as DrawerContainer,
  N_ as DrawerHeader,
  K_ as DrawerProvider,
  C_ as FormController,
  E_ as FormError,
  D_ as FormLabel,
  d_ as GoogleMap,
  Y_ as GoogleProvider,
  x_ as GoogleSearchPlaces,
  L_ as IconButton,
  O_ as ImageUpload,
  y1 as Input,
  z_ as ModalContainer,
  $_ as ModalFooter,
  U_ as ModalHeader,
  X_ as ModalProvider,
  I_ as Pagination,
  W_ as Popover,
  k_ as RadioBox,
  S_ as RadioGroup,
  M_ as RichText,
  P_ as Select,
  p_ as Skeleton,
  B_ as Switch,
  __ as TabButton,
  R_ as TabContainer,
  h_ as TableBody,
  g_ as TableCaption,
  v_ as TableContainer,
  m_ as TableFooter,
  y_ as TableHeader,
  T_ as Textarea,
  H_ as Toast,
  J_ as ToastProvider,
  V_ as Tooltip,
  q_ as useAutomation,
  Z_ as useDrawer,
  a1 as useFieldErrors,
  G_ as useModal,
  j0 as useScopedParams,
  uR as useToast
};
