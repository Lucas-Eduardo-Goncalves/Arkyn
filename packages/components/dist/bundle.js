var Xhe = Object.defineProperty;
var Jhe = (e, t, n) => t in e ? Xhe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var jv = (e, t, n) => Jhe(e, typeof t != "symbol" ? t + "" : t, n);
import * as Me from "react";
import we, { createContext as We, useContext as ge, Children as ut, forwardRef as yr, useState as k, useEffect as h, memo as me, useRef as ht, useMemo as Ft, isValidElement as wi, cloneElement as Ci, Component as Kl, PureComponent as pe, createRef as Br, useId as Qhe, useCallback as ur, useLayoutEffect as ege, useReducer as tge, useSyncExternalStore as nge } from "react";
import { Info as rte, AlertTriangle as rge, XCircle as ote, CheckCircle2 as ite, Loader2 as el, Pause as oge, Play as ige, RefreshCw as yT, Check as Ex, FileImage as sge, FileAudio as age, FileArchive as lge, File as uge, ChevronDown as bT, X as wT, Search as ste, Image as cge, Heading1 as pge, Heading2 as dge, Quote as fge, Bold as hge, Italic as gge, Underline as mge, Code as vge, AlignLeft as yge, AlignRight as bge, AlignCenter as wge, AlignJustify as Cge, ChevronRight as sS, ChevronLeft as xge, Ellipsis as UR, MapPinned as Oge } from "lucide-react";
import { useActionData as CT, useNavigation as ate, useFetchers as xT, useLocation as OT, Link as Ege, useNavigate as lte } from "@remix-run/react";
import { InputMask as tl } from "@react-input/mask";
import { AnimatePresence as ute, motion as cg } from "framer-motion";
import * as xi from "react-dom";
import nl, { createPortal as Tn } from "react-dom";
var Pr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function kx(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var aS = { exports: {} }, ff = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var HR;
function kge() {
  if (HR) return ff;
  HR = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return ff.Fragment = n, ff.jsx = a, ff.jsxs = a, ff;
}
var hf = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WR;
function Lge() {
  return WR || (WR = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, y = "@@iterator";
    function b(m) {
      if (m === null || typeof m != "object")
        return null;
      var A = f && m[f] || m[y];
      return typeof A == "function" ? A : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(m) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), ee = 1; ee < A; ee++)
          G[ee - 1] = arguments[ee];
        M("error", m, G);
      }
    }
    function M(m, A, G) {
      {
        var ee = E.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[m], console, ue);
      }
    }
    var O = !1, v = !1, x = !1, _ = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function N(m) {
      return !!(typeof m == "string" || typeof m == "function" || m === r || m === i || z || m === o || m === u || m === c || _ || m === g || O || v || x || typeof m == "object" && m !== null && (m.$$typeof === d || m.$$typeof === p || m.$$typeof === a || m.$$typeof === s || m.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      m.$$typeof === L || m.getModuleId !== void 0));
    }
    function R(m, A, G) {
      var ee = m.displayName;
      if (ee)
        return ee;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(m) {
      return m.displayName || "Context";
    }
    function Z(m) {
      if (m == null)
        return null;
      if (typeof m.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof m == "function")
        return m.displayName || m.name || null;
      if (typeof m == "string")
        return m;
      switch (m) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case s:
            var A = m;
            return V(A) + ".Consumer";
          case a:
            var G = m;
            return V(G._context) + ".Provider";
          case l:
            return R(m, m.render, "ForwardRef");
          case p:
            var ee = m.displayName || null;
            return ee !== null ? ee : Z(m.type) || "Memo";
          case d: {
            var ae = m, ue = ae._payload, se = ae._init;
            try {
              return Z(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, $ = 0, K, X, Q, J, P, D, F;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if ($ === 0) {
          K = console.log, X = console.info, Q = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, F = console.groupEnd;
          var m = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: m,
            log: m,
            warn: m,
            error: m,
            group: m,
            groupCollapsed: m,
            groupEnd: m
          });
        }
        $++;
      }
    }
    function C() {
      {
        if ($--, $ === 0) {
          var m = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, m, {
              value: K
            }),
            info: H({}, m, {
              value: X
            }),
            warn: H({}, m, {
              value: Q
            }),
            error: H({}, m, {
              value: J
            }),
            group: H({}, m, {
              value: P
            }),
            groupCollapsed: H({}, m, {
              value: D
            }),
            groupEnd: H({}, m, {
              value: F
            })
          });
        }
        $ < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = E.ReactCurrentDispatcher, U;
    function T(m, A, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            U = ee && ee[1] || "";
          }
        return `
` + U + m;
      }
    }
    var q = !1, j;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      j = new Y();
    }
    function B(m, A) {
      if (!m || q)
        return "";
      {
        var G = j.get(m);
        if (G !== void 0)
          return G;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Ee) {
              ee = Ee;
            }
            Reflect.construct(m, [], se);
          } else {
            try {
              se.call();
            } catch (Ee) {
              ee = Ee;
            }
            m.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ee) {
            ee = Ee;
          }
          m();
        }
      } catch (Ee) {
        if (Ee && ee && typeof Ee.stack == "string") {
          for (var ie = Ee.stack.split(`
`), be = ee.stack.split(`
`), de = ie.length - 1, fe = be.length - 1; de >= 1 && fe >= 0 && ie[de] !== be[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== be[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== be[fe]) {
                    var Fe = `
` + ie[de].replace(" at new ", " at ");
                    return m.displayName && Fe.includes("<anonymous>") && (Fe = Fe.replace("<anonymous>", m.displayName)), typeof m == "function" && j.set(m, Fe), Fe;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, C(), Error.prepareStackTrace = ae;
      }
      var Lt = m ? m.displayName || m.name : "", bt = Lt ? T(Lt) : "";
      return typeof m == "function" && j.set(m, bt), bt;
    }
    function le(m, A, G) {
      return B(m, !1);
    }
    function he(m) {
      var A = m.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(m, A, G) {
      if (m == null)
        return "";
      if (typeof m == "function")
        return B(m, he(m));
      if (typeof m == "string")
        return T(m);
      switch (m) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case l:
            return le(m.render);
          case p:
            return oe(m.type, A, G);
          case d: {
            var ee = m, ae = ee._payload, ue = ee._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Pe = Object.prototype.hasOwnProperty, Ue = {}, Ze = E.ReactDebugCurrentFrame;
    function _e(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        Ze.setExtraStackFrame(G);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(m, A, G, ee, ae) {
      {
        var ue = Function.call.bind(Pe);
        for (var se in m)
          if (ue(m, se)) {
            var ie = void 0;
            try {
              if (typeof m[se] != "function") {
                var be = Error((ee || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof m[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw be.name = "Invariant Violation", be;
              }
              ie = m[se](A, se, ee, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (_e(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", G, se, typeof ie), _e(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, _e(ae), w("Failed %s type: %s", G, ie.message), _e(null));
          }
      }
    }
    var Ve = Array.isArray;
    function ye(m) {
      return Ve(m);
    }
    function Ge(m) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && m[Symbol.toStringTag] || m.constructor.name || "Object";
        return G;
      }
    }
    function ct(m) {
      try {
        return ve(m), !1;
      } catch {
        return !0;
      }
    }
    function ve(m) {
      return "" + m;
    }
    function Oe(m) {
      if (ct(m))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ge(m)), ve(m);
    }
    var qe = E.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Se, st;
    function xe(m) {
      if (Pe.call(m, "ref")) {
        var A = Object.getOwnPropertyDescriptor(m, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.ref !== void 0;
    }
    function xt(m) {
      if (Pe.call(m, "key")) {
        var A = Object.getOwnPropertyDescriptor(m, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.key !== void 0;
    }
    function at(m, A) {
      typeof m.ref == "string" && qe.current;
    }
    function lt(m, A) {
      {
        var G = function() {
          Se || (Se = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function pt(m, A) {
      {
        var G = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(m, A, G, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: m,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function dt(m, A, G, ee, ae) {
      {
        var ue, se = {}, ie = null, be = null;
        G !== void 0 && (Oe(G), ie = "" + G), xt(A) && (Oe(A.key), ie = "" + A.key), xe(A) && (be = A.ref, at(A, ae));
        for (ue in A)
          Pe.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (m && m.defaultProps) {
          var de = m.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || be) {
          var fe = typeof m == "function" ? m.displayName || m.name || "Unknown" : m;
          ie && lt(se, fe), be && pt(se, fe);
        }
        return Ot(m, ie, be, ae, ee, qe.current, se);
      }
    }
    var ft = E.ReactCurrentOwner, ot = E.ReactDebugCurrentFrame;
    function He(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        ot.setExtraStackFrame(G);
      } else
        ot.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(m) {
      return typeof m == "object" && m !== null && m.$$typeof === t;
    }
    function gt() {
      {
        if (ft.current) {
          var m = Z(ft.current.type);
          if (m)
            return `

Check the render method of \`` + m + "`.";
        }
        return "";
      }
    }
    function St(m) {
      return "";
    }
    var mt = {};
    function Mt(m) {
      {
        var A = gt();
        if (!A) {
          var G = typeof m == "string" ? m : m.displayName || m.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function vt(m, A) {
      {
        if (!m._store || m._store.validated || m.key != null)
          return;
        m._store.validated = !0;
        var G = Mt(A);
        if (mt[G])
          return;
        mt[G] = !0;
        var ee = "";
        m && m._owner && m._owner !== ft.current && (ee = " It was passed a child from " + Z(m._owner.type) + "."), He(m), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ee), He(null);
      }
    }
    function Pt(m, A) {
      {
        if (typeof m != "object")
          return;
        if (ye(m))
          for (var G = 0; G < m.length; G++) {
            var ee = m[G];
            kt(ee) && vt(ee, A);
          }
        else if (kt(m))
          m._store && (m._store.validated = !0);
        else if (m) {
          var ae = b(m);
          if (typeof ae == "function" && ae !== m.entries)
            for (var ue = ae.call(m), se; !(se = ue.next()).done; )
              kt(se.value) && vt(se.value, A);
        }
      }
    }
    function jn(m) {
      {
        var A = m.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var ee = Z(A);
          rt(G, m.props, "prop", ee, m);
        } else if (A.PropTypes !== void 0 && !Et) {
          Et = !0;
          var ae = Z(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(m) {
      {
        for (var A = Object.keys(m.props), G = 0; G < A.length; G++) {
          var ee = A[G];
          if (ee !== "children" && ee !== "key") {
            He(m), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), He(null);
            break;
          }
        }
        m.ref !== null && (He(m), w("Invalid attribute `ref` supplied to `React.Fragment`."), He(null));
      }
    }
    var te = {};
    function Rr(m, A, G, ee, ae, ue) {
      {
        var se = N(m);
        if (!se) {
          var ie = "";
          (m === void 0 || typeof m == "object" && m !== null && Object.keys(m).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var be = St();
          be ? ie += be : ie += gt();
          var de;
          m === null ? de = "null" : ye(m) ? de = "array" : m !== void 0 && m.$$typeof === t ? (de = "<" + (Z(m.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof m, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = dt(m, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Fe = A.children;
          if (Fe !== void 0)
            if (ee)
              if (ye(Fe)) {
                for (var Lt = 0; Lt < Fe.length; Lt++)
                  Pt(Fe[Lt], m);
                Object.freeze && Object.freeze(Fe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Pt(Fe, m);
        }
        if (Pe.call(A, "key")) {
          var bt = Z(m), Ee = Object.keys(A).filter(function(_i) {
            return _i !== "key";
          }), An = Ee.length > 0 ? "{key: someKey, " + Ee.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!te[bt + An]) {
            var Pi = Ee.length > 0 ? "{" + Ee.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, An, bt, Pi, bt), te[bt + An] = !0;
          }
        }
        return m === r ? yt(fe) : jn(fe), fe;
      }
    }
    function Oi(m, A, G) {
      return Rr(m, A, G, !0);
    }
    function Ei(m, A, G) {
      return Rr(m, A, G, !1);
    }
    var ki = Ei, Li = Oi;
    hf.Fragment = r, hf.jsx = ki, hf.jsxs = Li;
  }()), hf;
}
process.env.NODE_ENV === "production" ? aS.exports = kge() : aS.exports = Lge();
var ne = aS.exports;
function Pge(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ ne.jsx("div", { className: r.trim(), ...n });
}
const cte = We({});
function _ge() {
  return ge(cte);
}
function Owt(e) {
  const { schema: t, children: n, className: r, ...o } = e, s = !((u) => {
    let c = !1;
    const p = (d) => {
      Array.isArray(d) ? d.forEach(p) : d && typeof d == "object" && "type" in d && (d.type === Pge ? c = !0 : d.props && d.props.children && p(d.props.children));
    };
    return p(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${s} ${r}`;
  return /* @__PURE__ */ ne.jsx(cte.Provider, { value: e, children: /* @__PURE__ */ ne.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function Ewt(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ ne.jsx("div", { className: r.trim(), ...n });
}
function kwt(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ ne.jsx("div", { className: r.trim(), ...n });
}
function Lwt(e) {
  const { className: t, ...n } = e, { schema: r } = _ge(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ ne.jsx(ite, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ ne.jsx(ote, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ ne.jsx(rge, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ ne.jsx(rte, { className: o, ...n });
  }
}
function Fw(e, t) {
  return t ? /* @__PURE__ */ ne.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ ne.jsx(ne.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function VR(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Si(e) {
  var t, n;
  return VR(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(VR(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var pte = Symbol.for("immer-nothing"), $R = Symbol.for("immer-draftable"), Ys = Symbol.for("immer-state"), Sge = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function gs(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Sge[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var _d = Object.getPrototypeOf;
function Mp(e) {
  return !!e && !!e[Ys];
}
function Dp(e) {
  var t;
  return e ? dte(e) || Array.isArray(e) || !!e[$R] || !!((t = e.constructor) != null && t[$R]) || Px(e) || _x(e) : !1;
}
var Mge = Object.prototype.constructor.toString();
function dte(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = _d(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Mge;
}
function zw(e, t) {
  Lx(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Lx(e) {
  const t = e[Ys];
  return t ? t.type_ : Array.isArray(e) ? 1 : Px(e) ? 2 : _x(e) ? 3 : 0;
}
function lS(e, t) {
  return Lx(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function fte(e, t, n) {
  const r = Lx(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Dge(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Px(e) {
  return e instanceof Map;
}
function _x(e) {
  return e instanceof Set;
}
function Yc(e) {
  return e.copy_ || e.base_;
}
function uS(e, t) {
  if (Px(e))
    return new Map(e);
  if (_x(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = dte(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ys];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(_d(e), r);
  } else {
    const r = _d(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function ET(e, t = !1) {
  return Sx(e) || Mp(e) || !Dp(e) || (Lx(e) > 1 && (e.set = e.add = e.clear = e.delete = Tge), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => ET(r, !0))), e;
}
function Tge() {
  gs(2);
}
function Sx(e) {
  return Object.isFrozen(e);
}
var jge = {};
function Tp(e) {
  const t = jge[e];
  return t || gs(0, e), t;
}
var pg;
function hte() {
  return pg;
}
function Age(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function ZR(e, t) {
  t && (Tp("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function cS(e) {
  pS(e), e.drafts_.forEach(Ige), e.drafts_ = null;
}
function pS(e) {
  e === pg && (pg = e.parent_);
}
function qR(e) {
  return pg = Age(pg, e);
}
function Ige(e) {
  const t = e[Ys];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function GR(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ys].modified_ && (cS(t), gs(4)), Dp(e) && (e = Uw(t, e), t.parent_ || Hw(t, e)), t.patches_ && Tp("Patches").generateReplacementPatches_(
    n[Ys].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Uw(t, n, []), cS(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== pte ? e : void 0;
}
function Uw(e, t, n) {
  if (Sx(t))
    return t;
  const r = t[Ys];
  if (!r)
    return zw(
      t,
      (o, i) => KR(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Hw(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), zw(
      i,
      (s, l) => KR(e, r, o, s, l, n, a)
    ), Hw(e, o, !1), n && e.patches_ && Tp("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function KR(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && gs(5), Mp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !lS(t.assigned_, r) ? i.concat(r) : void 0, l = Uw(e, o, s);
    if (fte(n, r, l), Mp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Dp(o) && !Sx(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Uw(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Hw(e, o);
  }
}
function Hw(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && ET(t, n);
}
function Bge(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : hte(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = kT;
  n && (o = [r], i = dg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var kT = {
  get(e, t) {
    if (t === Ys)
      return e;
    const n = Yc(e);
    if (!lS(n, t))
      return Rge(e, n, t);
    const r = n[t];
    return e.finalized_ || !Dp(r) ? r : r === qk(e.base_, t) ? (Gk(e), e.copy_[t] = fS(r, e)) : r;
  },
  has(e, t) {
    return t in Yc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Yc(e));
  },
  set(e, t, n) {
    const r = gte(Yc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = qk(Yc(e), t), i = o == null ? void 0 : o[Ys];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Dge(n, o) && (n !== void 0 || lS(e.base_, t)))
        return !0;
      Gk(e), dS(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return qk(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Gk(e), dS(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Yc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    gs(11);
  },
  getPrototypeOf(e) {
    return _d(e.base_);
  },
  setPrototypeOf() {
    gs(12);
  }
}, dg = {};
zw(kT, (e, t) => {
  dg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
dg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && gs(13), dg.set.call(this, e, t, void 0);
};
dg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && gs(14), kT.set.call(this, e[0], t, n, e[0]);
};
function qk(e, t) {
  const n = e[Ys];
  return (n ? Yc(n) : e)[t];
}
function Rge(e, t, n) {
  var o;
  const r = gte(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function gte(e, t) {
  if (!(t in e))
    return;
  let n = _d(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = _d(n);
  }
}
function dS(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && dS(e.parent_));
}
function Gk(e) {
  e.copy_ || (e.copy_ = uS(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Nge = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(l = i, ...u) {
          return a.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && gs(6), r !== void 0 && typeof r != "function" && gs(7);
      let o;
      if (Dp(t)) {
        const i = qR(this), a = fS(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? cS(i) : pS(i);
        }
        return ZR(i, r), GR(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === pte && (o = void 0), this.autoFreeze_ && ET(o, !0), r) {
          const i = [], a = [];
          Tp("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        gs(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (a, ...s) => this.produceWithPatches(a, (l) => t(l, ...s));
      let r, o;
      return [this.produce(t, n, (a, s) => {
        r = a, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Dp(e) || gs(8), Mp(e) && (e = Fge(e));
    const t = qR(this), n = fS(e, void 0);
    return n[Ys].isManual_ = !0, pS(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ys];
    (!n || !n.isManual_) && gs(9);
    const { scope_: r } = n;
    return ZR(r, t), GR(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Tp("Patches").applyPatches_;
    return Mp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function fS(e, t) {
  const n = Px(e) ? Tp("MapSet").proxyMap_(e, t) : _x(e) ? Tp("MapSet").proxySet_(e, t) : Bge(e, t);
  return (t ? t.scope_ : hte()).drafts_.push(n), n;
}
function Fge(e) {
  return Mp(e) || gs(10, e), mte(e);
}
function mte(e) {
  if (!Dp(e) || Sx(e))
    return e;
  const t = e[Ys];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = uS(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = uS(e, !0);
  return zw(n, (r, o) => {
    fte(n, r, mte(o));
  }), t && (t.finalized_ = !1), n;
}
var Xs = new Nge(), LT = Xs.produce;
Xs.produceWithPatches.bind(
  Xs
);
Xs.setAutoFreeze.bind(Xs);
Xs.setUseStrictShallowCopy.bind(Xs);
Xs.applyPatches.bind(Xs);
var YR = Xs.createDraft.bind(Xs), XR = Xs.finishDraft.bind(Xs), zge = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ce.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Uge = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = Kt.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Hge = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = Ce.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Ww = /* @__PURE__ */ new WeakMap(), Vw = /* @__PURE__ */ new WeakMap(), Eh = /* @__PURE__ */ new WeakMap(), vte = /* @__PURE__ */ new WeakMap(), JR = /* @__PURE__ */ new WeakMap(), QR = /* @__PURE__ */ new WeakMap(), eN = /* @__PURE__ */ new WeakMap(), ce = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = ce.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ce.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return ce.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ce.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return ce.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && ce.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return ce.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && ce.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && ce.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && ce.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && ce.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && ce.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!ce.isAncestor(t, e) && !ce.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (ce.equals(i, r) || ce.endsBefore(i, r) || ce.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (ce.equals(a, r) || ce.isAncestor(a, r))
          return null;
        ce.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        ce.equals(s, r) || ce.endsBefore(s, r) ? r[s.length - 1] -= 1 : ce.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (ce.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ce.endsBefore(u, r) ? r[u.length - 1] += 1 : ce.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (ce.equals(p, d))
          return r;
        if (ce.isAncestor(p, r) || ce.equals(p, r)) {
          var g = d.slice();
          return ce.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else ce.isSibling(p, d) && (ce.isAncestor(d, r) || ce.equals(d, r)) ? ce.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : ce.endsBefore(d, r) || ce.equals(d, r) || ce.isAncestor(d, r) ? (ce.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : ce.endsBefore(p, r) && (ce.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function fg(e) {
  "@babel/helpers - typeof";
  return fg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, fg(e);
}
function Wge(e, t) {
  if (fg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (fg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Vge(e) {
  var t = Wge(e, "string");
  return fg(t) === "symbol" ? t : String(t);
}
function rs(e, t, n) {
  return t = Vge(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function tN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $ge = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = it.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Ce.points(t))
          t[l] = Kt.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = it.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [y, b] of Ce.points(t))
          t[b] = Kt.transform(y, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = it.get(e, E), M = ce.previous(E), O = it.get(e, M), v = it.parent(e, E), x = E[E.length - 1];
      if (Ct.isText(w) && Ct.isText(O))
        O.text += w.text;
      else if (!Ct.isText(w) && !Ct.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(bi.stringify(w), " ").concat(bi.stringify(O)));
      if (v.children.splice(x, 1), t)
        for (var [_, z] of Ce.points(t))
          t[z] = Kt.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (ce.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = it.get(e, L), V = it.parent(e, L), Z = L[L.length - 1];
      V.children.splice(Z, 1);
      var H = ce.transform(L, n), $ = it.get(e, ce.parent(H)), K = H[H.length - 1];
      if ($.children.splice(K, 0, R), t)
        for (var [X, Q] of Ce.points(t))
          t[Q] = Kt.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = it.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [F, S] of Ce.points(t)) {
          var W = Kt.transform(F, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var C = void 0, I = void 0;
            for (var [U, T] of it.texts(e))
              if (ce.compare(T, J) === -1)
                C = [U, T];
              else {
                I = [U, T];
                break;
              }
            var q = !1;
            C && I && (ce.equals(I[1], J) ? q = !ce.hasPrevious(I[1]) : q = ce.common(C[1], J).length < ce.common(I[1], J).length), C && !q ? (F.path = C[1], F.offset = C[0].text.length) : I ? (F.path = I[1], F.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: j,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = it.leaf(e, j), he = le.text.slice(0, Y), oe = le.text.slice(Y + B.length);
      if (le.text = he + oe, t)
        for (var [Pe, Ue] of Ce.points(t))
          t[Ue] = Kt.transform(Pe, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: _e,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = it.get(e, Ze);
      for (var ye in rt) {
        if (ye === "children" || ye === "text")
          throw new Error('Cannot set the "'.concat(ye, '" property of nodes!'));
        var Ge = rt[ye];
        Ge == null ? delete Ve[ye] : Ve[ye] = Ge;
      }
      for (var ct in _e)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ve
      } = n;
      if (ve == null)
        t = ve;
      else {
        if (t == null) {
          if (!Ce.isRange(ve))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(bi.stringify(ve), " when there is no current selection."));
          t = gf({}, ve);
        }
        for (var Oe in ve) {
          var qe = ve[Oe];
          if (qe == null) {
            if (Oe === "anchor" || Oe === "focus")
              throw new Error('Cannot remove the "'.concat(Oe, '" selection property'));
            delete t[Oe];
          } else
            t[Oe] = qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Se,
        properties: st
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var xe = it.get(e, ze), xt = it.parent(e, ze), at = ze[ze.length - 1], lt;
      if (Ct.isText(xe)) {
        var pt = xe.text.slice(0, Se), Ot = xe.text.slice(Se);
        xe.text = pt, lt = gf(gf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = xe.children.slice(0, Se), ft = xe.children.slice(Se);
        xe.children = dt, lt = gf(gf({}, st), {}, {
          children: ft
        });
      }
      if (xt.children.splice(at + 1, 0, lt), t)
        for (var [ot, He] of Ce.points(t))
          t[He] = Kt.transform(ot, n);
      break;
    }
  }
  return t;
}, Zge = {
  transform(e, t) {
    e.children = YR(e.children);
    var n = e.selection && YR(e.selection);
    try {
      n = $ge(e, n, t);
    } finally {
      e.children = XR(e.children), n ? e.selection = Mp(n) ? XR(n) : n : e.selection = null;
    }
  }
}, qge = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Gge = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, yte = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Si(r) && Si(o)) {
      if (!yte(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Kge(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Fl(e, t) {
  if (e == null) return {};
  var n = Kge(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Yge = ["anchor", "focus"];
function nN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xge(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ce = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Ce.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Ce.edges(e);
    return t;
  },
  equals(e, t) {
    return Kt.equals(e.anchor, t.anchor) && Kt.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Ce.isRange(t)) {
      if (Ce.includes(e, t.anchor) || Ce.includes(e, t.focus))
        return !0;
      var [n, r] = Ce.edges(e), [o, i] = Ce.edges(t);
      return Kt.isBefore(n, o) && Kt.isAfter(r, i);
    }
    var [a, s] = Ce.edges(e), l = !1, u = !1;
    return Kt.isPoint(t) ? (l = Kt.compare(t, a) >= 0, u = Kt.compare(t, s) <= 0) : (l = ce.compare(t, a.path) >= 0, u = ce.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Fl(e, Yge), [r, o] = Ce.edges(e), [i, a] = Ce.edges(t), s = Kt.isBefore(r, i) ? i : r, l = Kt.isBefore(o, a) ? o : a;
    return Kt.isBefore(l, s) ? null : Xge({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Kt.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Kt.equals(t, n);
  },
  isExpanded(e) {
    return !Ce.isCollapsed(e);
  },
  isForward(e) {
    return !Ce.isBackward(e);
  },
  isRange(e) {
    return Si(e) && Kt.isPoint(e.anchor) && Kt.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Ce.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return LT(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Ce.isCollapsed(r);
        Ce.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Ce.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Kt.transform(r.anchor, t, {
        affinity: i
      }), u = Kt.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, rN = (e) => Si(e) && it.isNodeList(e.children) && !re.isEditor(e), wt = {
  isAncestor(e) {
    return Si(e) && it.isNodeList(e.children);
  },
  isElement: rN,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => wt.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return rN(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Jge = ["children"], Qge = ["text"], oN = /* @__PURE__ */ new WeakMap(), it = {
  ancestor(e, t) {
    var n = it.get(e, t);
    if (Ct.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(bi.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ce.ancestors(t, n)) {
        var o = it.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Ct.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(bi.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(bi.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = it.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = it.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = ce.common(t, n), o = it.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = it.get(e, t);
    if (re.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(bi.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of it.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of it.nodes(e, t))
        wt.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (wt.isAncestor(e)) {
      var t = Fl(e, Jge);
      return t;
    } else {
      var t = Fl(e, Qge);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = it.get(e, n); r && !(Ct.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Ct.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(bi.stringify(e)));
    var n = LT({
      children: e.children
    }, (r) => {
      var [o, i] = Ce.edges(t), a = it.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Ce.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Ce.includes(t, s)) {
          var l = it.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (ce.equals(s, i.path)) {
          var c = it.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (ce.equals(s, o.path)) {
          var p = it.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      re.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ct.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(bi.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ct.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Ct.isText(e) || wt.isElement(e) || re.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = oN.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => it.isNode(r));
    return oN.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = it.get(e, n); r && !(Ct.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = it.get(e, t);
    if (!Ct.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(bi.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ce.levels(t, n)) {
        var o = it.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return wt.isElement(e) && wt.isElementProps(t) && wt.matches(e, t) || Ct.isText(e) && Ct.isTextProps(t) && Ct.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? ce.isBefore(s, i) : ce.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Ct.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          ce.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = it.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = ce.next(s);
          if (it.has(e, c)) {
            s = c, l = it.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = ce.previous(s);
          s = p, l = it.get(e, s);
          continue;
        }
        s = ce.parent(s), l = it.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = ce.parent(t), r = it.get(e, n);
    if (Ct.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Ct.isText(e) ? e.text : e.children.map(it.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of it.nodes(e, t))
        Ct.isText(n) && (yield [n, r]);
    }();
  }
};
function iN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function eo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qu = {
  isNodeOperation(e) {
    return Qu.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Si(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return ce.isPath(e.path) && it.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ce.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && ce.isPath(e.path) && Si(e.properties);
      case "move_node":
        return ce.isPath(e.path) && ce.isPath(e.newPath);
      case "remove_node":
        return ce.isPath(e.path) && it.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ce.isPath(e.path);
      case "set_node":
        return ce.isPath(e.path) && Si(e.properties) && Si(e.newProperties);
      case "set_selection":
        return e.properties === null && Ce.isRange(e.newProperties) || e.newProperties === null && Ce.isRange(e.properties) || Si(e.properties) && Si(e.newProperties);
      case "split_node":
        return ce.isPath(e.path) && typeof e.position == "number" && Si(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Qu.isOperation(t));
  },
  isSelectionOperation(e) {
    return Qu.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Qu.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return eo(eo({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return eo(eo({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return eo(eo({}, e), {}, {
          type: "split_node",
          path: ce.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (ce.equals(t, n))
          return e;
        if (ce.isSibling(n, t))
          return eo(eo({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = ce.transform(n, e), o = ce.transform(ce.next(n), e);
        return eo(eo({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return eo(eo({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return eo(eo({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return eo(eo({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? eo(eo({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? eo(eo({}, e), {}, {
          properties: null,
          newProperties: s
        }) : eo(eo({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return eo(eo({}, e), {}, {
          type: "merge_node",
          path: ce.next(e.path)
        });
    }
  }
}, sN = /* @__PURE__ */ new WeakMap(), eme = (e) => {
  var t = sN.get(e);
  if (t !== void 0)
    return t;
  if (!Si(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Si(e.marks)) && (e.selection === null || Ce.isRange(e.selection)) && it.isNodeList(e.children) && Qu.isOperationList(e.operations);
  return sN.set(e, n), n;
}, re = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return eme(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, tme = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(ce.isPath);
  }
};
function aN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Kt = {
  compare(e, t) {
    var n = ce.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Kt.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Kt.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && ce.equals(e.path, t.path);
  },
  isPoint(e) {
    return Si(e) && typeof e.offset == "number" && ce.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return LT(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = ce.transform(i, t, n);
          break;
        }
        case "insert_text": {
          ce.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          ce.equals(t.path, i) && (r.offset += t.position), r.path = ce.transform(i, t, n);
          break;
        }
        case "remove_text": {
          ce.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (ce.equals(t.path, i) || ce.isAncestor(t.path, i))
            return null;
          r.path = ce.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (ce.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = ce.transform(i, t, lN(lN({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ce.transform(i, t, n);
          break;
        }
      }
    });
  }
}, uN = void 0, bi = {
  setScrubber(e) {
    uN = e;
  },
  stringify(e) {
    return JSON.stringify(e, uN);
  }
}, nme = ["text"], rme = ["anchor", "focus"];
function cN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ct = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Fl(i, nme);
      return a;
    }
    return yte(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Si(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Ct.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [dl({}, e)];
    for (var r of t) {
      var o = Fl(r, rme), [i, a] = Ce.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, y = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = dl(dl({}, f), {}, {
            text: f.text.slice(E)
          }), f = dl(dl({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          y = dl(dl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = dl(dl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), y && s.push(y), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, PT = (e) => e.selection ? e.selection : e.children.length > 0 ? re.end(e, []) : [0], Fd = (e, t) => {
  var [n] = re.node(e, t);
  return (r) => r === n;
}, _T = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? ume(t) : t, i = _t.None, a = _t.None, s = 0, l = null, u = null;
  for (var c of o) {
    var p = c.codePointAt(0);
    if (!p) break;
    var d = Cme(c, p);
    if ([i, a] = r ? [a, d] : [d, i], hd(i, _t.ZWJ) && hd(a, _t.ExtPict) && (r ? l = pN(t.substring(0, s)) : l = pN(t.substring(0, t.length - s)), !l) || hd(i, _t.RI) && hd(a, _t.RI) && (u !== null ? u = !u : r ? u = !0 : u = Lme(t.substring(0, t.length - s)), !u) || i !== _t.None && a !== _t.None && Ome(i, a))
      break;
    s += c.length;
  }
  return s || 1;
}, ome = /\s/, ime = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, sme = /['\u2018\u2019]/, ame = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = _T(t, n), [a, s] = ST(t, i, n);
    if (lme(a, s, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = s;
  }
  return r;
}, ST = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, lme = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (ome.test(t))
    return !1;
  if (sme.test(t)) {
    var o = _T(n, r), [i, a] = ST(n, o, r);
    if (e(i, a, r))
      return !0;
  }
  return !ime.test(t);
}, ume = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (pme(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (cme(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, cme = (e) => e >= 55296 && e <= 56319, pme = (e) => e >= 56320 && e <= 57343, _t;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(_t || (_t = {}));
var dme = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, fme = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, hme = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, gme = /^[\u1100-\u115F\uA960-\uA97C]$/, mme = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, vme = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, yme = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, bme = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, wme = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, Cme = (e, t) => {
  var n = _t.Any;
  return e.search(dme) !== -1 && (n |= _t.Extend), t === 8205 && (n |= _t.ZWJ), t >= 127462 && t <= 127487 && (n |= _t.RI), e.search(fme) !== -1 && (n |= _t.Prepend), e.search(hme) !== -1 && (n |= _t.SpacingMark), e.search(gme) !== -1 && (n |= _t.L), e.search(mme) !== -1 && (n |= _t.V), e.search(vme) !== -1 && (n |= _t.T), e.search(yme) !== -1 && (n |= _t.LV), e.search(bme) !== -1 && (n |= _t.LVT), e.search(wme) !== -1 && (n |= _t.ExtPict), n;
};
function hd(e, t) {
  return (e & t) !== 0;
}
var xme = [
  // GB6
  [_t.L, _t.L | _t.V | _t.LV | _t.LVT],
  // GB7
  [_t.LV | _t.V, _t.V | _t.T],
  // GB8
  [_t.LVT | _t.T, _t.T],
  // GB9
  [_t.Any, _t.Extend | _t.ZWJ],
  // GB9a
  [_t.Any, _t.SpacingMark],
  // GB9b
  [_t.Prepend, _t.Any],
  // GB11
  [_t.ZWJ, _t.ExtPict],
  // GB12 and GB13
  [_t.RI, _t.RI]
];
function Ome(e, t) {
  return xme.findIndex((n) => hd(e, n[0]) && hd(t, n[1])) === -1;
}
var Eme = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, pN = (e) => e.search(Eme) !== -1, kme = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, Lme = (e) => {
  var t = e.match(kme);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, Pme = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    re.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = PT(e)
      } = n;
      if (ce.isPath(o) && (o = re.range(e, o)), Ce.isRange(o))
        if (Ce.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Ce.end(o);
          if (!r && re.void(e, {
            at: i
          }))
            return;
          var a = Ce.start(o), s = re.pointRef(e, a), l = re.pointRef(e, i);
          $e.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, $e.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && re.void(e, {
        at: o
      }) || re.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function dN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Av(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $e = Av(Av(Av(Av({}, Zge), qge), Gge), Pme), Ew = /* @__PURE__ */ new WeakMap(), _me = (e) => Ew.get(e) || !1, Sme = (e, t, n) => {
  var r = Ew.get(e) || !1;
  Ew.set(e, !0);
  try {
    t(), n();
  } finally {
    Ew.set(e, r);
  }
};
function bte(e, t, n) {
  var r = Ww.get(e) || [], o = Vw.get(e) || /* @__PURE__ */ new Set(), i, a, s = (p) => {
    if (p) {
      var d = p.join(",");
      a.has(d) || (a.add(d), i.push(p));
    }
  };
  if (n) {
    i = [], a = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      s(u);
    }
  } else
    i = r, a = o;
  for (var c of t)
    s(c);
  Ww.set(e, i), Vw.set(e, a);
}
var Mme = (e, t) => {
  for (var n of re.pathRefs(e))
    zge.transform(n, t);
  for (var r of re.pointRefs(e))
    Uge.transform(r, t);
  for (var o of re.rangeRefs(e))
    Hge.transform(o, t);
  if (!_me(e)) {
    var i = ce.operationCanTransformPath(t) ? (a) => ce.transform(a, t) : void 0;
    bte(e, e.getDirtyPaths(t), i);
  }
  $e.transform(e, t), e.operations.push(t), re.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), Eh.get(e) || (Eh.set(e, !0), Promise.resolve().then(() => {
    Eh.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, Dme = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return ce.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = ce.levels(o), a = Ct.isText(r) ? [] : Array.from(it.nodes(r), (N) => {
        var [, R] = N;
        return o.concat(R);
      });
      return [...i, ...a];
    }
    case "merge_node": {
      var {
        path: s
      } = t, l = ce.ancestors(s), u = ce.previous(s);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: p
      } = t;
      if (ce.equals(c, p))
        return [];
      var d = [], g = [];
      for (var f of ce.ancestors(c)) {
        var y = ce.transform(f, t);
        d.push(y);
      }
      for (var b of ce.ancestors(p)) {
        var E = ce.transform(b, t);
        g.push(E);
      }
      var w = g[g.length - 1], M = p[p.length - 1], O = w.concat(M);
      return [...d, ...g, O];
    }
    case "remove_node": {
      var {
        path: v
      } = t, x = ce.ancestors(v);
      return [...x];
    }
    case "split_node": {
      var {
        path: _
      } = t, z = ce.levels(_), L = ce.next(_);
      return [...z, L];
    }
    default:
      return [];
  }
}, Tme = (e) => {
  var {
    selection: t
  } = e;
  return t ? it.fragment(e, t) : [];
}, jme = (e, t) => {
  var [n, r] = t;
  if (!Ct.isText(n)) {
    if (wt.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      $e.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = re.isEditor(n) ? !1 : wt.isElement(n) && (e.isInline(n) || n.children.length === 0 || Ct.isText(n.children[0]) || e.isInline(n.children[0])), a = 0, s = 0; s < n.children.length; s++, a++) {
      var l = it.get(e, r);
      if (!Ct.isText(l)) {
        var u = l.children[a], c = l.children[a - 1], p = s === n.children.length - 1, d = Ct.isText(u) || wt.isElement(u) && e.isInline(u);
        if (d !== i)
          $e.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--;
        else if (wt.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !Ct.isText(c)) {
              var g = {
                text: ""
              };
              $e.insertNodes(e, g, {
                at: r.concat(a),
                voids: !0
              }), a++;
            } else if (p) {
              var f = {
                text: ""
              };
              $e.insertNodes(e, f, {
                at: r.concat(a + 1),
                voids: !0
              }), a++;
            }
          }
        } else {
          if (!Ct.isText(u) && !("children" in u)) {
            var y = u;
            y.children = [];
          }
          c != null && Ct.isText(c) && (Ct.equals(u, c, {
            loose: !0
          }) ? ($e.mergeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--) : c.text === "" ? ($e.removeNodes(e, {
            at: r.concat(a - 1),
            voids: !0
          }), a--) : u.text === "" && ($e.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--));
        }
      }
    }
  }
}, Ame = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, Ime = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: a
  } = n;
  if (i) {
    var s = re.path(t, i), l = o === "lowest";
    for (var [u, c] of re.levels(t, {
      at: s,
      voids: r,
      match: a,
      reverse: l
    }))
      if (!Ct.isText(u)) {
        if (Ce.isRange(i)) {
          if (ce.isAncestor(c, i.anchor.path) && ce.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!ce.equals(s, c))
          return [u, c];
      }
  }
};
function fN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bme = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (p, d) => {
      if (!Ct.isText(p))
        return !1;
      var [g, f] = re.parent(e, d);
      return !e.isVoid(g) || e.markableVoid(g);
    }, i = Ce.isExpanded(r), a = !1;
    if (!i) {
      var [s, l] = re.node(e, r);
      if (s && o(s, l)) {
        var [u] = re.parent(e, l);
        a = u && e.markableVoid(u);
      }
    }
    if (i || a)
      $e.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = hN(hN({}, re.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, Eh.get(e) || e.onChange();
    }
  }
};
function gN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = re.point(t, n, {
    edge: "end"
  }), i = re.end(t, []), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of re.positions(t, mN(mN({}, r), {}, {
    at: a
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function vN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nme = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = re.start(t, []), i = re.point(t, n, {
    edge: "start"
  }), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of re.positions(t, yN(yN({}, r), {}, {
    at: a,
    reverse: !0
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, Fme = (e, t) => {
  var {
    selection: n
  } = e;
  n && Ce.isCollapsed(n) && $e.delete(e, {
    unit: t,
    reverse: !0
  });
}, zme = (e, t) => {
  var {
    selection: n
  } = e;
  n && Ce.isCollapsed(n) && $e.delete(e, {
    unit: t
  });
}, Ume = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && Ce.isExpanded(r) && $e.delete(t, {
    reverse: n === "backward"
  });
}, Hme = (e, t) => [re.start(e, t), re.end(e, t)];
function bN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wme = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return re.above(t, wN(wN({}, n), {}, {
    match: (r) => wt.isElement(r) && re.isElementReadOnly(t, r)
  }));
}, Vme = (e, t) => re.point(e, t, {
  edge: "end"
}), $me = (e, t) => {
  var n = re.path(e, t, {
    edge: "start"
  });
  return re.node(e, n);
}, Zme = (e, t) => {
  var n = re.range(e, t);
  return it.fragment(e, n);
};
function CN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qme = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return re.above(t, xN(xN({}, n), {}, {
    match: (r) => wt.isElement(r) && re.isVoid(t, r)
  }));
}, Gme = (e, t) => t.children.some((n) => wt.isElement(n) && re.isBlock(e, n)), Kme = (e, t) => t.children.some((n) => Ct.isText(n) || re.isInline(e, n)), Yme = (e, t) => it.has(e, t), Xme = (e, t) => t.children.every((n) => Ct.isText(n)), Jme = (e) => {
  $e.splitNodes(e, {
    always: !0
  });
}, Qme = (e, t, n) => {
  $e.insertNodes(e, t, n);
}, eve = (e) => {
  $e.splitNodes(e, {
    always: !0
  });
};
function ON(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tve(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ON(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ON(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nve = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var a = tve({
        text: n
      }, i);
      $e.insertNodes(t, a, {
        at: r.at,
        voids: r.voids
      });
    } else
      $e.insertText(t, n, r);
    t.marks = null;
  }
}, rve = (e, t) => !e.isInline(t), ove = (e, t, n) => re.isStart(e, t, n) || re.isEnd(e, t, n), ive = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && Ct.isText(r) && r.text === "" && !e.isVoid(t);
}, sve = (e, t, n) => {
  var r = re.end(e, n);
  return Kt.equals(t, r);
}, ave = (e) => {
  var t = vte.get(e);
  return t === void 0 ? !0 : t;
}, lve = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = re.start(e, n);
  return Kt.equals(t, r);
}, uve = (e, t) => {
  var n = re.path(e, t, {
    edge: "end"
  });
  return re.node(e, n);
}, cve = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = re.path(t, n, r), i = it.leaf(t, o);
  return [i, o];
};
function pve(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var a = [], s = re.path(e, n);
      for (var [l, u] of it.levels(e, s))
        if (i(l, u) && (a.push([l, u]), !o && wt.isElement(l) && re.isVoid(e, l)))
          break;
      r && a.reverse(), yield* a;
    }
  }();
}
var dve = ["text"], fve = ["text"], hve = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (Ce.isExpanded(r)) {
    var a = re.isEnd(t, o, o.path);
    if (a) {
      var s = re.after(t, o);
      s && (o = s);
    }
    var [l] = re.nodes(t, {
      match: Ct.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = Fl(u, dve);
      return c;
    } else
      return {};
  }
  var {
    path: p
  } = o, [d] = re.leaf(t, p);
  if (o.offset === 0) {
    var g = re.previous(t, {
      at: p,
      match: Ct.isText
    }), f = re.above(t, {
      match: (O) => wt.isElement(O) && re.isVoid(t, O) && t.markableVoid(O)
    });
    if (!f) {
      var y = re.above(t, {
        match: (O) => wt.isElement(O) && re.isBlock(t, O)
      });
      if (g && y) {
        var [b, E] = g, [, w] = y;
        ce.isAncestor(w, E) && (d = b);
      }
    }
  }
  var M = Fl(d, fve);
  return M;
}, gve = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = re.after(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = re.last(t, []), u = [s.path, l];
      if (ce.isPath(a) && a.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (ce.isPath(a)) {
          var [c] = re.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = re.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, mve = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = re.path(t, n, r), i = it.get(t, o);
  return [i, o];
};
function vve(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: a = !1,
      ignoreNonSelectable: s = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (tme.isSpan(n))
        u = n[0], c = n[1];
      else {
        var p = re.path(e, n, {
          edge: "start"
        }), d = re.path(e, n, {
          edge: "end"
        });
        u = i ? d : p, c = i ? p : d;
      }
      var g = it.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (O) => {
          var [v] = O;
          return wt.isElement(v) ? !!(!a && (re.isVoid(e, v) || re.isElementReadOnly(e, v)) || s && !re.isSelectable(e, v)) : !1;
        }
      }), f = [], y;
      for (var [b, E] of g)
        if (!(s && wt.isElement(b) && !re.isSelectable(e, b))) {
          var w = y && ce.compare(E, y[1]) === 0;
          if (!(r === "highest" && w)) {
            if (!l(b, E)) {
              if (o && !w && Ct.isText(b))
                return;
              continue;
            }
            if (r === "lowest" && w) {
              y = [b, E];
              continue;
            }
            var M = r === "lowest" ? y : [b, E];
            M && (o ? f.push(M) : yield M), y = [b, E];
          }
        }
      r === "lowest" && y && (o ? f.push(y) : yield y), o && (yield* f);
    }
  }();
}
var yve = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => Ww.get(c) || [], a = (c) => Vw.get(c) || /* @__PURE__ */ new Set(), s = (c) => {
    var p = i(c).pop(), d = p.join(",");
    return a(c).delete(d), p;
  };
  if (re.isNormalizing(t)) {
    if (r) {
      var l = Array.from(it.nodes(t), (c) => {
        var [, p] = c;
        return p;
      }), u = new Set(l.map((c) => c.join(",")));
      Ww.set(t, l), Vw.set(t, u);
    }
    i(t).length !== 0 && re.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (it.has(t, c)) {
          var p = re.node(t, c), [d, g] = p;
          wt.isElement(d) && d.children.length === 0 && t.normalizeNode(p, {
            operation: o
          });
        }
      for (var f = i(t), y = f.length, b = 0; f.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: f,
          iteration: b,
          initialDirtyPathsLength: y,
          operation: o
        }))
          return;
        var E = s(t);
        if (it.has(t, E)) {
          var w = re.node(t, E);
          t.normalizeNode(w, {
            operation: o
          });
        }
        b++, f = i(t);
      }
    });
  }
}, bve = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = re.path(t, n, r), i = ce.parent(o), a = re.node(t, i);
  return a;
}, wve = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = re.pathRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = re.pathRefs(t);
  return a.add(i), i;
}, Cve = (e) => {
  var t = JR.get(e);
  return t || (t = /* @__PURE__ */ new Set(), JR.set(e, t)), t;
}, xve = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (ce.isPath(n)) {
    if (i === "start") {
      var [, a] = it.first(t, n);
      n = a;
    } else if (i === "end") {
      var [, s] = it.last(t, n);
      n = s;
    }
  }
  return Ce.isRange(n) && (i === "start" ? n = Ce.start(n) : i === "end" ? n = Ce.end(n) : n = ce.common(n.anchor.path, n.focus.path)), Kt.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, Ove = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = re.pointRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = re.pointRefs(t);
  return a.add(i), i;
}, Eve = (e) => {
  var t = QR.get(e);
  return t || (t = /* @__PURE__ */ new Set(), QR.set(e, t)), t;
}, kve = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (ce.isPath(n)) {
    var i;
    if (o === "end") {
      var [, a] = it.last(t, n);
      i = a;
    } else {
      var [, s] = it.first(t, n);
      i = s;
    }
    var l = it.get(t, i);
    if (!Ct.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (Ce.isRange(n)) {
    var [u, c] = Ce.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function Lve(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: a = !1
    } = t;
    if (!n)
      return;
    var s = re.range(e, n), [l, u] = Ce.edges(s), c = o ? u : l, p = !1, d = "", g = 0, f = 0, y = 0;
    for (var [b, E] of re.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: a
    })) {
      if (wt.isElement(b)) {
        if (!i && (e.isVoid(b) || e.isElementReadOnly(b))) {
          yield re.start(e, E);
          continue;
        }
        if (e.isInline(b)) continue;
        if (re.hasInlines(e, b)) {
          var w = ce.isAncestor(E, u.path) ? u : re.end(e, E), M = ce.isAncestor(E, l.path) ? l : re.start(e, E);
          d = re.string(e, {
            anchor: M,
            focus: w
          }, {
            voids: i
          }), p = !0;
        }
      }
      if (Ct.isText(b)) {
        var O = ce.equals(E, c.path);
        for (O ? (f = o ? c.offset : b.text.length - c.offset, y = c.offset) : (f = b.text.length, y = o ? f : 0), (O || p || r === "offset") && (yield {
          path: E,
          offset: y
        }, p = !1); ; ) {
          if (g === 0) {
            if (d === "") break;
            g = v(d, r, o), d = ST(d, g, o)[1];
          }
          if (y = o ? y - g : y + g, f = f - g, f < 0) {
            g = -f;
            break;
          }
          g = 0, yield {
            path: E,
            offset: y
          };
        }
      }
    }
    function v(x, _, z) {
      return _ === "character" ? _T(x, z) : _ === "word" ? ame(x, z) : _ === "line" || _ === "block" ? x.length : 1;
    }
  }();
}
var Pve = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = re.before(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = re.first(t, []), u = [s.path, l];
      if (ce.isPath(a) && a.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (ce.isPath(a)) {
          var [c] = re.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = re.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, _ve = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = re.rangeRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = re.rangeRefs(t);
  return a.add(i), i;
}, Sve = (e) => {
  var t = eN.get(e);
  return t || (t = /* @__PURE__ */ new Set(), eN.set(e, t)), t;
}, Mve = (e, t, n) => {
  if (Ce.isRange(t) && !n)
    return t;
  var r = re.start(e, t), o = re.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function EN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dve(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Tve = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, p) => {
      if (!Ct.isText(c))
        return !1;
      var [d, g] = re.parent(e, p);
      return !e.isVoid(d) || e.markableVoid(d);
    }, o = Ce.isExpanded(n), i = !1;
    if (!o) {
      var [a, s] = re.node(e, n);
      if (a && r(a, s)) {
        var [l] = re.parent(e, s);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      $e.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = Dve({}, re.marks(e) || {});
      delete u[t], e.marks = u, Eh.get(e) || e.onChange();
    }
  }
}, jve = (e, t) => {
  vte.set(e, t);
}, Ave = (e, t) => re.point(e, t, {
  edge: "start"
}), Ive = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = re.range(t, n), [a, s] = Ce.edges(i), l = "";
  for (var [u, c] of re.nodes(t, {
    at: i,
    match: Ct.isText,
    voids: o
  })) {
    var p = u.text;
    ce.equals(c, s.path) && (p = p.slice(0, s.offset)), ce.equals(c, a.path) && (p = p.slice(a.offset)), l += p;
  }
  return l;
}, Bve = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, a] = Ce.edges(n);
  if (i.offset !== 0 || a.offset !== 0 || Ce.isCollapsed(n) || ce.hasPrevious(a.path))
    return n;
  var s = re.above(t, {
    at: a,
    match: (f) => wt.isElement(f) && re.isBlock(t, f),
    voids: o
  }), l = s ? s[1] : [], u = re.start(t, i), c = {
    anchor: u,
    focus: a
  }, p = !0;
  for (var [d, g] of re.nodes(t, {
    at: c,
    match: Ct.isText,
    reverse: !0,
    voids: o
  })) {
    if (p) {
      p = !1;
      continue;
    }
    if (d.text !== "" || ce.isBefore(g, l)) {
      a = {
        path: g,
        offset: d.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: a
  };
}, Rve = (e, t) => {
  var n = re.isNormalizing(e);
  re.setNormalizing(e, !1);
  try {
    t();
  } finally {
    re.setNormalizing(e, n);
  }
  re.normalize(e);
}, Nve = (e, t, n) => {
  var [r, o] = t;
  return wt.isElement(r) && re.isEmpty(e, r) || Ct.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, Fve = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  re.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: a = "character",
      distance: s = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var p = !1;
      if (Ce.isRange(u) && Ce.isCollapsed(u) && (p = !0, u = u.anchor), Kt.isPoint(u)) {
        var d = re.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && d) {
          var [, g] = d;
          u = g;
        } else {
          var f = {
            unit: a,
            distance: s
          }, y = i ? re.before(t, u, f) || re.start(t, []) : re.after(t, u, f) || re.end(t, []);
          u = {
            anchor: u,
            focus: y
          }, c = !0;
        }
      }
      if (ce.isPath(u)) {
        $e.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!Ce.isCollapsed(u)) {
        if (!c) {
          var [, b] = Ce.edges(u), E = re.end(t, []);
          Kt.equals(b, E) || (u = re.unhangRange(t, u, {
            voids: l
          }));
        }
        var [w, M] = Ce.edges(u), O = re.above(t, {
          match: (he) => wt.isElement(he) && re.isBlock(t, he),
          at: w,
          voids: l
        }), v = re.above(t, {
          match: (he) => wt.isElement(he) && re.isBlock(t, he),
          at: M,
          voids: l
        }), x = O && v && !ce.equals(O[1], v[1]), _ = ce.equals(w.path, M.path), z = l ? null : (r = re.void(t, {
          at: w,
          mode: "highest"
        })) !== null && r !== void 0 ? r : re.elementReadOnly(t, {
          at: w,
          mode: "highest"
        }), L = l ? null : (o = re.void(t, {
          at: M,
          mode: "highest"
        })) !== null && o !== void 0 ? o : re.elementReadOnly(t, {
          at: M,
          mode: "highest"
        });
        if (z) {
          var N = re.before(t, w);
          N && O && ce.isAncestor(O[1], N.path) && (w = N);
        }
        if (L) {
          var R = re.after(t, M);
          R && v && ce.isAncestor(v[1], R.path) && (M = R);
        }
        var V = [], Z;
        for (var H of re.nodes(t, {
          at: u,
          voids: l
        })) {
          var [$, K] = H;
          Z && ce.compare(K, Z) === 0 || (!l && wt.isElement($) && (re.isVoid(t, $) || re.isElementReadOnly(t, $)) || !ce.isCommon(K, w.path) && !ce.isCommon(K, M.path)) && (V.push(H), Z = K);
        }
        var X = Array.from(V, (he) => {
          var [, oe] = he;
          return re.pathRef(t, oe);
        }), Q = re.pointRef(t, w), J = re.pointRef(t, M), P = "";
        if (!_ && !z) {
          var D = Q.current, [F] = re.leaf(t, D), {
            path: S
          } = D, {
            offset: W
          } = w, C = F.text.slice(W);
          C.length > 0 && (t.apply({
            type: "remove_text",
            path: S,
            offset: W,
            text: C
          }), P = C);
        }
        if (X.reverse().map((he) => he.unref()).filter((he) => he !== null).forEach((he) => $e.removeNodes(t, {
          at: he,
          voids: l
        })), !L) {
          var I = J.current, [U] = re.leaf(t, I), {
            path: T
          } = I, q = _ ? w.offset : 0, j = U.text.slice(q, M.offset);
          j.length > 0 && (t.apply({
            type: "remove_text",
            path: T,
            offset: q,
            text: j
          }), P = j);
        }
        !_ && x && J.current && Q.current && $e.mergeNodes(t, {
          at: J.current,
          hanging: !0,
          voids: l
        }), p && i && a === "character" && P.length > 1 && P.match(/[\u0E00-\u0E7F]+/) && $e.insertText(t, P.slice(0, P.length - s));
        var Y = Q.unref(), B = J.unref(), le = i ? Y || B : B || Y;
        n.at == null && le && $e.select(t, le);
      }
    }
  });
}, zve = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  re.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: a = PT(t),
      batchDirty: s = !0
    } = r;
    if (n.length) {
      if (Ce.isRange(a))
        if (o || (a = re.unhangRange(t, a, {
          voids: i
        })), Ce.isCollapsed(a))
          a = a.anchor;
        else {
          var [, l] = Ce.edges(a);
          if (!i && re.void(t, {
            at: l
          }))
            return;
          var u = re.pointRef(t, l);
          $e.delete(t, {
            at: a
          }), a = u.unref();
        }
      else ce.isPath(a) && (a = re.start(t, a));
      if (!(!i && re.void(t, {
        at: a
      }))) {
        var c = re.above(t, {
          at: a,
          match: (C) => wt.isElement(C) && re.isInline(t, C),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, p] = c;
          if (re.isEnd(t, a, p)) {
            var d = re.after(t, p);
            a = d;
          } else if (re.isStart(t, a, p)) {
            var g = re.before(t, p);
            a = g;
          }
        }
        var f = re.above(t, {
          match: (C) => wt.isElement(C) && re.isBlock(t, C),
          at: a,
          voids: i
        }), [, y] = f, b = re.isStart(t, a, y), E = re.isEnd(t, a, y), w = b && E, M = !b || b && E, O = !E, [, v] = it.first({
          children: n
        }, []), [, x] = it.last({
          children: n
        }, []), _ = [], z = (C) => {
          var [I, U] = C, T = U.length === 0;
          return T ? !1 : w ? !0 : !(M && ce.isAncestor(U, v) && wt.isElement(I) && !t.isVoid(I) && !t.isInline(I) || O && ce.isAncestor(U, x) && wt.isElement(I) && !t.isVoid(I) && !t.isInline(I));
        };
        for (var L of it.nodes({
          children: n
        }, {
          pass: z
        }))
          z(L) && _.push(L);
        var N = [], R = [], V = [], Z = !0, H = !1;
        for (var [$] of _)
          wt.isElement($) && !t.isInline($) ? (Z = !1, H = !0, R.push($)) : Z ? N.push($) : V.push($);
        var [K] = re.nodes(t, {
          at: a,
          match: (C) => Ct.isText(C) || re.isInline(t, C),
          mode: "highest",
          voids: i
        }), [, X] = K, Q = re.isStart(t, a, X), J = re.isEnd(t, a, X), P = re.pathRef(t, E && !V.length ? ce.next(y) : y), D = re.pathRef(t, J ? ce.next(X) : X);
        $e.splitNodes(t, {
          at: a,
          match: (C) => H ? wt.isElement(C) && re.isBlock(t, C) : Ct.isText(C) || re.isInline(t, C),
          mode: H ? "lowest" : "highest",
          always: H && (!b || N.length > 0) && (!E || V.length > 0),
          voids: i
        });
        var F = re.pathRef(t, !Q || Q && J ? ce.next(X) : X);
        if ($e.insertNodes(t, N, {
          at: F.current,
          match: (C) => Ct.isText(C) || re.isInline(t, C),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), w && !N.length && R.length && !V.length && $e.delete(t, {
          at: y,
          voids: i
        }), $e.insertNodes(t, R, {
          at: P.current,
          match: (C) => wt.isElement(C) && re.isBlock(t, C),
          mode: "lowest",
          voids: i,
          batchDirty: s
        }), $e.insertNodes(t, V, {
          at: D.current,
          match: (C) => Ct.isText(C) || re.isInline(t, C),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), !r.at) {
          var S;
          if (V.length > 0 && D.current ? S = ce.previous(D.current) : R.length > 0 && P.current ? S = ce.previous(P.current) : F.current && (S = ce.previous(F.current)), S) {
            var W = re.end(t, S);
            $e.select(t, W);
          }
        }
        F.unref(), P.unref(), D.unref();
      }
    }
  });
}, Uve = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      $e.select(t, o.anchor);
    else if (r === "focus")
      $e.select(t, o.focus);
    else if (r === "start") {
      var [i] = Ce.edges(o);
      $e.select(t, i);
    } else if (r === "end") {
      var [, a] = Ce.edges(o);
      $e.select(t, a);
    }
  } else return;
}, Hve = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, Wve = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: a = !1
  } = n, {
    edge: s = null
  } = n;
  if (r) {
    s === "start" && (s = Ce.isBackward(r) ? "focus" : "anchor"), s === "end" && (s = Ce.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, p = {};
    if (s == null || s === "anchor") {
      var d = a ? re.before(t, l, c) : re.after(t, l, c);
      d && (p.anchor = d);
    }
    if (s == null || s === "focus") {
      var g = a ? re.before(t, u, c) : re.after(t, u, c);
      g && (p.focus = g);
    }
    $e.setSelection(t, p);
  }
}, Vve = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = re.range(e, t), n) {
    $e.setSelection(e, t);
    return;
  }
  if (!Ce.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(bi.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function kN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function LN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $ve = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = Ce.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = Ce.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: a,
      focus: s
    } = o, l = i === "anchor" ? a : s;
    $e.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: LN(LN({}, l), n)
    });
  }
}, Zve = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !Kt.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !Kt.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, qve = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  re.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: a = "lowest",
      batchDirty: s = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (it.isNode(n) && (n = [n]), n.length !== 0) {
      var [p] = n;
      if (l || (l = PT(t), c !== !1 && (c = !0)), c == null && (c = !1), Ce.isRange(l))
        if (o || (l = re.unhangRange(t, l, {
          voids: i
        })), Ce.isCollapsed(l))
          l = l.anchor;
        else {
          var [, d] = Ce.edges(l), g = re.pointRef(t, d);
          $e.delete(t, {
            at: l
          }), l = g.unref();
        }
      if (Kt.isPoint(l)) {
        u == null && (Ct.isText(p) ? u = (N) => Ct.isText(N) : t.isInline(p) ? u = (N) => Ct.isText(N) || re.isInline(t, N) : u = (N) => wt.isElement(N) && re.isBlock(t, N));
        var [f] = re.nodes(t, {
          at: l.path,
          match: u,
          mode: a,
          voids: i
        });
        if (f) {
          var [, y] = f, b = re.pathRef(t, y), E = re.isEnd(t, l, y);
          $e.splitNodes(t, {
            at: l,
            match: u,
            mode: a,
            voids: i
          });
          var w = b.unref();
          l = E ? ce.next(w) : w;
        } else
          return;
      }
      var M = ce.parent(l), O = l[l.length - 1];
      if (!(!i && re.void(t, {
        at: M
      }))) {
        if (s) {
          var v = [], x = ce.levels(M);
          Sme(t, () => {
            var N = function() {
              var Z = M.concat(O);
              O++;
              var H = {
                type: "insert_node",
                path: Z,
                node: R
              };
              t.apply(H), l = ce.next(l), v.push(H), Ct.isText ? x.push(...Array.from(it.nodes(R), ($) => {
                var [, K] = $;
                return Z.concat(K);
              })) : x.push(Z);
            };
            for (var R of n)
              N();
          }, () => {
            bte(t, x, (N) => {
              var R = N;
              for (var V of v)
                if (ce.operationCanTransformPath(V) && (R = ce.transform(R, V), !R))
                  return null;
              return R;
            });
          });
        } else
          for (var _ of n) {
            var z = M.concat(O);
            O++, t.apply({
              type: "insert_node",
              path: z,
              node: _
            }), l = ce.next(l);
          }
        if (l = ce.previous(l), c) {
          var L = re.end(t, l);
          L && $e.select(t, L);
        }
      }
    }
  });
}, Gve = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  re.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: a
    } = n;
    if (a == null && (a = ce.isPath(r) ? Fd(t, r) : (O) => wt.isElement(O) && re.isBlock(t, O)), !!r) {
      var s = re.nodes(t, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), l = Array.from(s, (O) => {
        var [, v] = O;
        return re.pathRef(t, v);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var p = re.node(t, ce.parent(c)), [d, g] = p, f = c[c.length - 1], {
          length: y
        } = d.children;
        if (y === 1) {
          var b = ce.next(g);
          $e.moveNodes(t, {
            at: c,
            to: b,
            voids: i
          }), $e.removeNodes(t, {
            at: g,
            voids: i
          });
        } else if (f === 0)
          $e.moveNodes(t, {
            at: c,
            to: g,
            voids: i
          });
        else if (f === y - 1) {
          var E = ce.next(g);
          $e.moveNodes(t, {
            at: c,
            to: E,
            voids: i
          });
        } else {
          var w = ce.next(c), M = ce.next(g);
          $e.splitNodes(t, {
            at: w,
            voids: i
          }), $e.moveNodes(t, {
            at: c,
            to: M,
            voids: i
          });
        }
      }
    }
  });
}, Kve = ["text"], Yve = ["children"], wte = (e, t) => {
  if (wt.isElement(t)) {
    var n = t;
    return re.isVoid(e, t) ? !0 : n.children.length === 1 ? wte(e, n.children[0]) : !1;
  } else return !re.isEditor(t);
}, Xve = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  re.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: a = !1,
      mode: s = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (ce.isPath(o)) {
          var [l] = re.parent(t, o);
          r = (N) => l.children.includes(N);
        } else
          r = (N) => wt.isElement(N) && re.isBlock(t, N);
      if (!i && Ce.isRange(o) && (o = re.unhangRange(t, o, {
        voids: a
      })), Ce.isRange(o))
        if (Ce.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = Ce.edges(o), c = re.pointRef(t, u);
          $e.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && $e.select(t, o);
        }
      var [p] = re.nodes(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      }), d = re.previous(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      });
      if (!(!p || !d)) {
        var [g, f] = p, [y, b] = d;
        if (!(f.length === 0 || b.length === 0)) {
          var E = ce.next(b), w = ce.common(f, b), M = ce.isSibling(f, b), O = Array.from(re.levels(t, {
            at: f
          }), (N) => {
            var [R] = N;
            return R;
          }).slice(w.length).slice(0, -1), v = re.above(t, {
            at: f,
            mode: "highest",
            match: (N) => O.includes(N) && wte(t, N)
          }), x = v && re.pathRef(t, v[1]), _, z;
          if (Ct.isText(g) && Ct.isText(y)) {
            var L = Fl(g, Kve);
            z = y.text.length, _ = L;
          } else if (wt.isElement(g) && wt.isElement(y)) {
            var L = Fl(g, Yve);
            z = y.children.length, _ = L;
          } else
            throw new Error("Cannot merge the node at path [".concat(f, "] with the previous sibling because it is not the same kind: ").concat(bi.stringify(g), " ").concat(bi.stringify(y)));
          M || $e.moveNodes(t, {
            at: f,
            to: E,
            voids: a
          }), x && $e.removeNodes(t, {
            at: x.current,
            voids: a
          }), re.shouldMergeNodesRemovePrevNode(t, d, p) ? $e.removeNodes(t, {
            at: b,
            voids: a
          }) : t.apply({
            type: "merge_node",
            path: E,
            position: z,
            properties: _
          }), x && x.unref();
        }
      }
    }
  });
}, Jve = (e, t) => {
  re.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: a
    } = t;
    if (r) {
      a == null && (a = ce.isPath(r) ? Fd(e, r) : (g) => wt.isElement(g) && re.isBlock(e, g));
      var s = re.pathRef(e, n), l = re.nodes(e, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), u = Array.from(l, (g) => {
        var [, f] = g;
        return re.pathRef(e, f);
      });
      for (var c of u) {
        var p = c.unref(), d = s.current;
        p.length !== 0 && e.apply({
          type: "move_node",
          path: p,
          newPath: d
        }), s.current && ce.isSibling(d, p) && ce.isAfter(d, p) && (s.current = ce.next(s.current));
      }
      s.unref();
    }
  });
}, Qve = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  re.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = ce.isPath(a) ? Fd(t, a) : (g) => wt.isElement(g) && re.isBlock(t, g)), !r && Ce.isRange(a) && (a = re.unhangRange(t, a, {
        voids: o
      }));
      var l = re.nodes(t, {
        at: a,
        match: s,
        mode: i,
        voids: o
      }), u = Array.from(l, (g) => {
        var [, f] = g;
        return re.pathRef(t, f);
      });
      for (var c of u) {
        var p = c.unref();
        if (p) {
          var [d] = re.node(t, p);
          t.apply({
            type: "remove_node",
            path: p,
            node: d
          });
        }
      }
    }
  });
}, eye = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  re.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: a,
      merge: s
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: p = !1
    } = r;
    if (i) {
      if (o == null && (o = ce.isPath(i) ? Fd(t, i) : (z) => wt.isElement(z) && re.isBlock(t, z)), !l && Ce.isRange(i) && (i = re.unhangRange(t, i, {
        voids: p
      })), c && Ce.isRange(i)) {
        if (Ce.isCollapsed(i) && re.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var d = re.rangeRef(t, i, {
          affinity: "inward"
        }), [g, f] = Ce.edges(i), y = u === "lowest" ? "lowest" : "highest", b = re.isEnd(t, f, f.path);
        $e.splitNodes(t, {
          at: f,
          match: o,
          mode: y,
          voids: p,
          always: !b
        });
        var E = re.isStart(t, g, g.path);
        $e.splitNodes(t, {
          at: g,
          match: o,
          mode: y,
          voids: p,
          always: !E
        }), i = d.unref(), r.at == null && $e.select(t, i);
      }
      a || (a = (z, L) => z !== L);
      for (var [w, M] of re.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: p
      })) {
        var O = {}, v = {};
        if (M.length !== 0) {
          var x = !1;
          for (var _ in n)
            _ === "children" || _ === "text" || a(n[_], w[_]) && (x = !0, w.hasOwnProperty(_) && (O[_] = w[_]), s ? n[_] != null && (v[_] = s(w[_], n[_])) : n[_] != null && (v[_] = n[_]));
          x && t.apply({
            type: "set_node",
            path: M,
            properties: O,
            newProperties: v
          });
        }
      }
    }
  });
}, tye = (e, t) => {
  if (Ce.isCollapsed(t))
    return t.anchor;
  var [, n] = Ce.edges(t), r = re.pointRef(e, n);
  return $e.delete(e, {
    at: t
  }), r.unref();
}, nye = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  re.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: a = t.selection,
      height: s = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (J) => wt.isElement(J) && re.isBlock(t, J)), Ce.isRange(a) && (a = tye(t, a)), ce.isPath(a)) {
      var u = a, c = re.point(t, u), [p] = re.parent(t, u);
      i = (J) => J === p, s = c.path.length - u.length + 1, a = c, l = !0;
    }
    if (a) {
      var d = re.pointRef(t, a, {
        affinity: "backward"
      }), g;
      try {
        var [f] = re.nodes(t, {
          at: a,
          match: i,
          mode: r,
          voids: o
        });
        if (!f)
          return;
        var y = re.void(t, {
          at: a,
          mode: "highest"
        }), b = 0;
        if (!o && y) {
          var [E, w] = y;
          if (wt.isElement(E) && t.isInline(E)) {
            var M = re.after(t, w);
            if (!M) {
              var O = {
                text: ""
              }, v = ce.next(w);
              $e.insertNodes(t, O, {
                at: v,
                voids: o
              }), M = re.point(t, v);
            }
            a = M, l = !0;
          }
          var x = a.path.length - w.length;
          s = x + 1, l = !0;
        }
        g = re.pointRef(t, a);
        var _ = a.path.length - s, [, z] = f, L = a.path.slice(0, _), N = s === 0 ? a.offset : a.path[_] + b;
        for (var [R, V] of re.levels(t, {
          at: L,
          reverse: !0,
          voids: o
        })) {
          var Z = !1;
          if (V.length < z.length || V.length === 0 || !o && wt.isElement(R) && re.isVoid(t, R))
            break;
          var H = d.current, $ = re.isEnd(t, H, V);
          if (l || !d || !re.isEdge(t, H, V)) {
            Z = !0;
            var K = it.extractProps(R);
            t.apply({
              type: "split_node",
              path: V,
              position: N,
              properties: K
            });
          }
          N = V[V.length - 1] + (Z || $ ? 1 : 0);
        }
        if (n.at == null) {
          var X = g.current || re.end(t, []);
          $e.select(t, X);
        }
      } finally {
        var Q;
        d.unref(), (Q = g) === null || Q === void 0 || Q.unref();
      }
    }
  });
}, rye = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  $e.setNodes(t, o, r);
}, oye = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  re.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = ce.isPath(a) ? Fd(t, a) : (g) => wt.isElement(g) && re.isBlock(t, g)), ce.isPath(a) && (a = re.range(t, a));
      var l = Ce.isRange(a) ? re.rangeRef(t, a) : null, u = re.nodes(t, {
        at: a,
        match: s,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (g) => {
          var [, f] = g;
          return re.pathRef(t, f);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), p = function() {
        var f = d.unref(), [y] = re.node(t, f), b = re.range(t, f);
        o && l && (b = Ce.intersection(l.current, b)), $e.liftNodes(t, {
          at: b,
          match: (E) => wt.isAncestor(y) && y.children.includes(E),
          voids: i
        });
      };
      for (var d of c)
        p();
      l && l.unref();
    }
  });
};
function PN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _N(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PN(Object(n), !0).forEach(function(r) {
      rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var iye = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  re.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: a = !1
    } = r, {
      match: s,
      at: l = t.selection
    } = r;
    if (l) {
      if (s == null && (ce.isPath(l) ? s = Fd(t, l) : t.isInline(n) ? s = (b) => wt.isElement(b) && re.isInline(t, b) || Ct.isText(b) : s = (b) => wt.isElement(b) && re.isBlock(t, b)), i && Ce.isRange(l)) {
        var [u, c] = Ce.edges(l), p = re.rangeRef(t, l, {
          affinity: "inward"
        });
        $e.splitNodes(t, {
          at: c,
          match: s,
          voids: a
        }), $e.splitNodes(t, {
          at: u,
          match: s,
          voids: a
        }), l = p.unref(), r.at == null && $e.select(t, l);
      }
      var d = Array.from(re.nodes(t, {
        at: l,
        match: t.isInline(n) ? (b) => wt.isElement(b) && re.isBlock(t, b) : (b) => re.isEditor(b),
        mode: "lowest",
        voids: a
      })), g = function() {
        var E = Ce.isRange(l) ? Ce.intersection(l, re.range(t, y)) : l;
        if (!E)
          return 0;
        var w = Array.from(re.nodes(t, {
          at: E,
          match: s,
          mode: o,
          voids: a
        }));
        if (w.length > 0) {
          var [M] = w, O = w[w.length - 1], [, v] = M, [, x] = O;
          if (v.length === 0 && x.length === 0)
            return 0;
          var _ = ce.equals(v, x) ? ce.parent(v) : ce.common(v, x), z = re.range(t, v, x), L = re.node(t, _), [N] = L, R = _.length + 1, V = ce.next(x.slice(0, R)), Z = _N(_N({}, n), {}, {
            children: []
          });
          $e.insertNodes(t, Z, {
            at: V,
            voids: a
          }), $e.moveNodes(t, {
            at: z,
            match: (H) => wt.isAncestor(N) && N.children.includes(H),
            to: V.concat(0),
            voids: a
          });
        }
      }, f;
      for (var [, y] of d)
        f = g();
    }
  });
}, sye = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mme(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Bme(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fme(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zme(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ume(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tme(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jme(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eve(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zve(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qme(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nve(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jme(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tve(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dme(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ame(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ime(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Rme(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nme(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Uve(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fve(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hve(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hme(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wme(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vme(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $me(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zme(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hve(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Gme(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Kme(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Yme(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Xme(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qve(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rve(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ove(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ive(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sve(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ave(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lve(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uve(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cve(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pve(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Gve(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Xve(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wve(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jve(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gve(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mve(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vve(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yve(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bve(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xve(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wve(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Cve(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kve(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ove(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Eve(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Lve(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Pve(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mve(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _ve(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Sve(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qve(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vve(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eye(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jve(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $ve(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zve(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nye(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ave(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ive(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Bve(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rye(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return oye(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qme(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Rve(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return iye(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nve(e, ...r);
    }
  };
  return e;
};
const Cte = (e) => {
  if (Ct.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (wt.isElement(e)) {
    const t = e.children.map((r) => Cte(r)).join(""), n = e.align || "left";
    switch (e.type) {
      case "image":
        return `<img src="${e.src}" class="align_${n}" />`;
      case "paragraph":
        return `<p class="align_${n}">${t}</p>`;
      case "blockQuote":
        return `<blockquote class="align_${n}">${t}</blockquote>`;
      case "bulletedList":
        return `<ul class="align_${n}">${t}</ul>`;
      case "headingOne":
        return `<h1 class="align_${n}">${t}</h1>`;
      case "headingTwo":
        return `<h2 class="align_${n}">${t}</h2>`;
      case "listItem":
        return `<li class="align_${n}">${t}</li>`;
      case "numberedList":
        return `<ol class="align_${n}">${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, Pwt = (e) => e.map((t) => Cte(t)).join("");
var xte = {}, MT = {}, DT = {}, rd = {}, TT = {}, jT = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(jT);
var sn = {}, rc = Pr && Pr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), kh = Pr && Pr.__assign || function() {
  return kh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, kh.apply(this, arguments);
};
Object.defineProperty(sn, "__esModule", { value: !0 });
sn.cloneNode = sn.hasChildren = sn.isDocument = sn.isDirective = sn.isComment = sn.isText = sn.isCDATA = sn.isTag = sn.Element = sn.Document = sn.CDATA = sn.NodeWithChildren = sn.ProcessingInstruction = sn.Comment = sn.Text = sn.DataNode = sn.Node = void 0;
var Es = jT, AT = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), IT(this, t);
    }, e;
  }()
);
sn.Node = AT;
var Mx = (
  /** @class */
  function(e) {
    rc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(AT)
);
sn.DataNode = Mx;
var Ote = (
  /** @class */
  function(e) {
    rc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Es.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Mx)
);
sn.Text = Ote;
var Ete = (
  /** @class */
  function(e) {
    rc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Es.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Mx)
);
sn.Comment = Ete;
var kte = (
  /** @class */
  function(e) {
    rc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Es.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Mx)
);
sn.ProcessingInstruction = kte;
var Dx = (
  /** @class */
  function(e) {
    rc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(AT)
);
sn.NodeWithChildren = Dx;
var Lte = (
  /** @class */
  function(e) {
    rc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Es.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Dx)
);
sn.CDATA = Lte;
var Pte = (
  /** @class */
  function(e) {
    rc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Es.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Dx)
);
sn.Document = Pte;
var _te = (
  /** @class */
  function(e) {
    rc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Es.ElementType.Script : n === "style" ? Es.ElementType.Style : Es.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Dx)
);
sn.Element = _te;
function Ste(e) {
  return (0, Es.isTag)(e);
}
sn.isTag = Ste;
function Mte(e) {
  return e.type === Es.ElementType.CDATA;
}
sn.isCDATA = Mte;
function Dte(e) {
  return e.type === Es.ElementType.Text;
}
sn.isText = Dte;
function Tte(e) {
  return e.type === Es.ElementType.Comment;
}
sn.isComment = Tte;
function jte(e) {
  return e.type === Es.ElementType.Directive;
}
sn.isDirective = jte;
function Ate(e) {
  return e.type === Es.ElementType.Root;
}
sn.isDocument = Ate;
function aye(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
sn.hasChildren = aye;
function IT(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (Dte(e))
    n = new Ote(e.data);
  else if (Tte(e))
    n = new Ete(e.data);
  else if (Ste(e)) {
    var r = t ? Kk(e.children) : [], o = new _te(e.name, kh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = kh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = kh({}, e["x-attribsPrefix"])), n = o;
  } else if (Mte(e)) {
    var r = t ? Kk(e.children) : [], i = new Lte(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (Ate(e)) {
    var r = t ? Kk(e.children) : [], a = new Pte(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (jte(e)) {
    var s = new kte(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
sn.cloneNode = IT;
function Kk(e) {
  for (var t = e.map(function(r) {
    return IT(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Pr && Pr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Pr && Pr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = jT, o = sn;
  n(sn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(TT);
var Ite = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(Ite);
Object.defineProperty(rd, "__esModule", { value: !0 });
rd.formatAttributes = Bte;
rd.escapeSpecialCharacters = cye;
rd.revertEscapedCharacters = Rte;
rd.formatDOM = Nte;
var Iv = TT, hg = Ite;
function lye(e) {
  return hg.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function Bte(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function uye(e) {
  e = e.toLowerCase();
  var t = lye(e);
  return t || e;
}
function cye(e) {
  return e.replace(hg.CARRIAGE_RETURN_REGEX, hg.CARRIAGE_RETURN_PLACEHOLDER);
}
function Rte(e) {
  return e.replace(hg.CARRIAGE_RETURN_PLACEHOLDER_REGEX, hg.CARRIAGE_RETURN);
}
function Nte(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = uye(s.nodeName);
        o = new Iv.Element(l, Bte(s.attributes)), o.children = Nte(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Iv.Text(Rte(s.nodeValue));
        break;
      case 8:
        o = new Iv.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Iv.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(DT, "__esModule", { value: !0 });
DT.default = gye;
var pye = rd, SN = "html", MN = "head", Bv = "body", dye = /<([a-zA-Z]+[0-9]?)/, DN = /<head[^]*>/i, TN = /<body[^]*>/i, $w = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, hS = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, jN = typeof window == "object" && window.DOMParser;
if (typeof jN == "function") {
  var fye = new jN(), hye = "text/html";
  hS = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), fye.parseFromString(e, hye);
  }, $w = hS;
}
if (typeof document == "object" && document.implementation) {
  var Rv = document.implementation.createHTMLDocument();
  $w = function(e, t) {
    if (t) {
      var n = Rv.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Rv;
    }
    return Rv.documentElement.innerHTML = e, Rv;
  };
}
var Nv = typeof document == "object" && document.createElement("template"), gS;
Nv && Nv.content && (gS = function(e) {
  return Nv.innerHTML = e, Nv.content.childNodes;
});
function gye(e) {
  var t, n;
  e = (0, pye.escapeSpecialCharacters)(e);
  var r = e.match(dye), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case SN: {
      var i = hS(e);
      if (!DN.test(e)) {
        var a = i.querySelector(MN);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!TN.test(e)) {
        var a = i.querySelector(Bv);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(SN);
    }
    case MN:
    case Bv: {
      var s = $w(e).querySelectorAll(o);
      return TN.test(e) && DN.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (gS)
        return gS(e);
      var a = $w(e, Bv).querySelector(Bv);
      return a.childNodes;
    }
  }
}
var mye = Pr && Pr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(MT, "__esModule", { value: !0 });
MT.default = wye;
var vye = mye(DT), yye = rd, bye = /<(![a-zA-Z\s]+)>/;
function wye(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(bye), n = t ? t[1] : void 0;
  return (0, yye.formatDOM)((0, vye.default)(e), null, n);
}
var Tx = {}, La = {}, jx = {}, Cye = 0;
jx.SAME = Cye;
var xye = 1;
jx.CAMELCASE = xye;
jx.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const Fte = 0, oc = 1, Ax = 2, Ix = 3, BT = 4, zte = 5, Ute = 6;
function Oye(e) {
  return Ri.hasOwnProperty(e) ? Ri[e] : null;
}
function os(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Ax || t === Ix || t === BT, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Ri = {}, Eye = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Eye.forEach((e) => {
  Ri[e] = new os(
    e,
    Fte,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Ri[e] = new os(
    e,
    oc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Ri[e] = new os(
    e,
    Ax,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Ri[e] = new os(
    e,
    Ax,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Ri[e] = new os(
    e,
    Ix,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ri[e] = new os(
    e,
    Ix,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ri[e] = new os(
    e,
    BT,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ri[e] = new os(
    e,
    Ute,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Ri[e] = new os(
    e,
    zte,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const RT = /[\-\:]([a-z])/g, NT = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(RT, NT);
  Ri[t] = new os(
    t,
    oc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(RT, NT);
  Ri[t] = new os(
    t,
    oc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(RT, NT);
  Ri[t] = new os(
    t,
    oc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Ri[e] = new os(
    e,
    oc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const kye = "xlinkHref";
Ri[kye] = new os(
  "xlinkHref",
  oc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Ri[e] = new os(
    e,
    oc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Lye,
  SAME: Pye,
  possibleStandardNames: AN
} = jx, _ye = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Sye = _ye + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Mye = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Sye + "]*$")
), Dye = Object.keys(
  AN
).reduce((e, t) => {
  const n = AN[t];
  return n === Pye ? e[t] = t : n === Lye ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
La.BOOLEAN = Ix;
La.BOOLEANISH_STRING = Ax;
La.NUMERIC = zte;
La.OVERLOADED_BOOLEAN = BT;
La.POSITIVE_NUMERIC = Ute;
La.RESERVED = Fte;
La.STRING = oc;
La.getPropertyInfo = Oye;
La.isCustomAttribute = Mye;
La.possibleStandardNames = Dye;
var FT = {}, zT = {}, IN = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Tye = /\n/g, jye = /^\s*/, Aye = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Iye = /^:\s*/, Bye = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Rye = /^[;\s]*/, Nye = /^\s+|\s+$/g, Fye = `
`, BN = "/", RN = "*", sp = "", zye = "comment", Uye = "declaration", Hye = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var y = f.match(Tye);
    y && (n += y.length);
    var b = f.lastIndexOf(Fye);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(y) {
      return y.position = new a(f), u(), y;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var y = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (y.reason = f, y.filename = t.source, y.line = n, y.column = r, y.source = e, !t.silent) throw y;
  }
  function l(f) {
    var y = f.exec(e);
    if (y) {
      var b = y[0];
      return o(b), e = e.slice(b.length), y;
    }
  }
  function u() {
    l(jye);
  }
  function c(f) {
    var y;
    for (f = f || []; y = p(); )
      y !== !1 && f.push(y);
    return f;
  }
  function p() {
    var f = i();
    if (!(BN != e.charAt(0) || RN != e.charAt(1))) {
      for (var y = 2; sp != e.charAt(y) && (RN != e.charAt(y) || BN != e.charAt(y + 1)); )
        ++y;
      if (y += 2, sp === e.charAt(y - 1))
        return s("End of comment missing");
      var b = e.slice(2, y - 2);
      return r += 2, o(b), e = e.slice(y), r += 2, f({
        type: zye,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), y = l(Aye);
    if (y) {
      if (p(), !l(Iye)) return s("property missing ':'");
      var b = l(Bye), E = f({
        type: Uye,
        property: NN(y[0].replace(IN, sp)),
        value: b ? NN(b[0].replace(IN, sp)) : sp
      });
      return l(Rye), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var y; y = d(); )
      y !== !1 && (f.push(y), c(f));
    return f;
  }
  return u(), g();
};
function NN(e) {
  return e ? e.replace(Nye, sp) : sp;
}
var Wye = Pr && Pr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(zT, "__esModule", { value: !0 });
zT.default = $ye;
var Vye = Wye(Hye);
function $ye(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Vye.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Bx = {};
Object.defineProperty(Bx, "__esModule", { value: !0 });
Bx.camelCase = void 0;
var Zye = /^--[a-zA-Z0-9_-]+$/, qye = /-([a-z])/g, Gye = /^[^-]+$/, Kye = /^-(webkit|moz|ms|o|khtml)-/, Yye = /^-(ms)-/, Xye = function(e) {
  return !e || Gye.test(e) || Zye.test(e);
}, Jye = function(e, t) {
  return t.toUpperCase();
}, FN = function(e, t) {
  return "".concat(t, "-");
}, Qye = function(e, t) {
  return t === void 0 && (t = {}), Xye(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Yye, FN) : e = e.replace(Kye, FN), e.replace(qye, Jye));
};
Bx.camelCase = Qye;
var ebe = Pr && Pr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, tbe = ebe(zT), nbe = Bx;
function mS(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, tbe.default)(e, function(r, o) {
    r && o && (n[(0, nbe.camelCase)(r, t)] = o);
  }), n;
}
mS.default = mS;
var rbe = mS;
(function(e) {
  var t = Pr && Pr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(rbe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(FT);
Object.defineProperty(Tx, "__esModule", { value: !0 });
Tx.default = abe;
var ah = La, zN = FT, obe = ["checked", "value"], ibe = ["input", "select", "textarea"], sbe = {
  reset: !0,
  submit: !0
};
function abe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && sbe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, ah.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = UN(a);
    if (s) {
      var l = (0, ah.getPropertyInfo)(s);
      switch (obe.includes(s) && ibe.includes(t) && !r && (s = UN("default" + a)), n[s] = i, l && l.type) {
        case ah.BOOLEAN:
          n[s] = !0;
          break;
        case ah.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    zN.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, zN.setStyleProp)(e.style, n), n;
}
function UN(e) {
  return ah.possibleStandardNames[e];
}
var UT = {}, lbe = Pr && Pr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(UT, "__esModule", { value: !0 });
UT.default = Hte;
var Yk = we, ube = lbe(Tx), Lh = FT, cbe = {
  cloneElement: Yk.cloneElement,
  createElement: Yk.createElement,
  isValidElement: Yk.isValidElement
};
function Hte(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Lh.returnFirstArg, i = t.library || cbe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Lh.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, y = {};
    pbe(f) ? ((0, Lh.setStyleProp)(f.attribs.style, f.attribs), y = f.attribs) : f.attribs && (y = (0, ube.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (y.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? y.defaultValue = p.children[0].data : p.children && p.children.length && (b = Hte(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (y.key = c), n.push(o(s(p.name, y, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function pbe(e) {
  return Lh.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Lh.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Pr && Pr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(MT);
  e.htmlToDOM = n.default;
  var r = t(Tx);
  e.attributesToProps = r.default;
  var o = t(UT);
  e.domToReact = o.default;
  var i = TT;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(xte);
const HN = /* @__PURE__ */ kx(xte), dbe = HN.default || HN, vS = (e) => {
  var r;
  if (typeof e == "string")
    return { text: e };
  const t = Array.isArray(e.props.children) ? e.props.children.map((o) => vS(o)) : [{ text: e.props.children || "" }], n = (r = e.props.className) == null ? void 0 : r.replace("align_", "");
  switch (e.type) {
    case "img":
      return {
        type: "image",
        align: n,
        src: e.props.src,
        children: [{ text: "" }]
      };
    case "p":
      return { type: "paragraph", align: n, children: t };
    case "blockquote":
      return { type: "blockQuote", align: n, children: t };
    case "ul":
      return { type: "bulletedList", align: n, children: t };
    case "ol":
      return { type: "numberedList", align: n, children: t };
    case "li":
      return { type: "listItem", align: n, children: t };
    case "h1":
      return { type: "headingOne", align: n, children: t };
    case "h2":
      return { type: "headingTwo", align: n, children: t };
    case "strong":
      return { text: e.props.children, bold: !0 };
    case "code":
      return { text: e.props.children, code: !0 };
    case "em":
      return { text: e.props.children, italic: !0 };
    case "u":
      return { text: e.props.children, underline: !0 };
    default:
      return { text: e.props.children || "" };
  }
}, _wt = (e) => {
  const t = dbe(e);
  return Array.isArray(t) ? t.map((n) => typeof n == "string" ? { text: n } : vS(n)) : typeof t == "string" ? [{ text: t }] : [vS(t)];
}, Swt = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function Wte(e, t, n) {
  if (!e) return /* @__PURE__ */ ne.jsx(ne.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ ne.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ ne.jsx("p", { className: n, children: /* @__PURE__ */ ne.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function Mwt(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: a = "",
    children: s,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], p = `arkynBadge ${t} ${n} ${r} ${a}`;
  return /* @__PURE__ */ ne.jsxs("div", { className: p.trim(), ...l, children: [
    Fw(c, o),
    s,
    Fw(c, i)
  ] });
}
function Dwt(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ ne.jsx("div", { className: r.trim(), ...n });
}
function Vte(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ ne.jsx("div", { className: o.trim(), ...r });
}
function Twt(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ ne.jsx("aside", { className: r.trim(), ...n });
}
function jwt(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, a = ut.count(r) === 0;
  return /* @__PURE__ */ ne.jsx("tbody", { className: i.trim(), ...o, children: a ? /* @__PURE__ */ ne.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ ne.jsx("td", { colSpan: 100, children: /* @__PURE__ */ ne.jsx("div", { children: t }) }) }) : r });
}
function Awt(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ ne.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ ne.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function Iwt(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ ne.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ ne.jsx("table", { children: t }) });
}
function Bwt(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ ne.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ ne.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ ne.jsx("tr", { children: /* @__PURE__ */ ne.jsx("th", { colSpan: 100, children: /* @__PURE__ */ ne.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function Rwt(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ ne.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ ne.jsx("tr", { children: n }),
    /* @__PURE__ */ ne.jsx("tr", { className: "spacingRow" })
  ] });
}
var _r = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function fbe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var yS = { exports: {} }, mf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WN;
function hbe() {
  if (WN) return mf;
  WN = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return mf.Fragment = n, mf.jsx = a, mf.jsxs = a, mf;
}
var Fv = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VN;
function gbe() {
  return VN || (VN = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, y = "@@iterator";
    function b(m) {
      if (m === null || typeof m != "object")
        return null;
      var A = f && m[f] || m[y];
      return typeof A == "function" ? A : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(m) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), ee = 1; ee < A; ee++)
          G[ee - 1] = arguments[ee];
        M("error", m, G);
      }
    }
    function M(m, A, G) {
      {
        var ee = E.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[m], console, ue);
      }
    }
    var O = !1, v = !1, x = !1, _ = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function N(m) {
      return !!(typeof m == "string" || typeof m == "function" || m === r || m === i || z || m === o || m === u || m === c || _ || m === g || O || v || x || typeof m == "object" && m !== null && (m.$$typeof === d || m.$$typeof === p || m.$$typeof === a || m.$$typeof === s || m.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      m.$$typeof === L || m.getModuleId !== void 0));
    }
    function R(m, A, G) {
      var ee = m.displayName;
      if (ee)
        return ee;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(m) {
      return m.displayName || "Context";
    }
    function Z(m) {
      if (m == null)
        return null;
      if (typeof m.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof m == "function")
        return m.displayName || m.name || null;
      if (typeof m == "string")
        return m;
      switch (m) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case s:
            var A = m;
            return V(A) + ".Consumer";
          case a:
            var G = m;
            return V(G._context) + ".Provider";
          case l:
            return R(m, m.render, "ForwardRef");
          case p:
            var ee = m.displayName || null;
            return ee !== null ? ee : Z(m.type) || "Memo";
          case d: {
            var ae = m, ue = ae._payload, se = ae._init;
            try {
              return Z(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, $ = 0, K, X, Q, J, P, D, F;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if ($ === 0) {
          K = console.log, X = console.info, Q = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, F = console.groupEnd;
          var m = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: m,
            log: m,
            warn: m,
            error: m,
            group: m,
            groupCollapsed: m,
            groupEnd: m
          });
        }
        $++;
      }
    }
    function C() {
      {
        if ($--, $ === 0) {
          var m = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, m, {
              value: K
            }),
            info: H({}, m, {
              value: X
            }),
            warn: H({}, m, {
              value: Q
            }),
            error: H({}, m, {
              value: J
            }),
            group: H({}, m, {
              value: P
            }),
            groupCollapsed: H({}, m, {
              value: D
            }),
            groupEnd: H({}, m, {
              value: F
            })
          });
        }
        $ < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = E.ReactCurrentDispatcher, U;
    function T(m, A, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            U = ee && ee[1] || "";
          }
        return `
` + U + m;
      }
    }
    var q = !1, j;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      j = new Y();
    }
    function B(m, A) {
      if (!m || q)
        return "";
      {
        var G = j.get(m);
        if (G !== void 0)
          return G;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Ee) {
              ee = Ee;
            }
            Reflect.construct(m, [], se);
          } else {
            try {
              se.call();
            } catch (Ee) {
              ee = Ee;
            }
            m.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ee) {
            ee = Ee;
          }
          m();
        }
      } catch (Ee) {
        if (Ee && ee && typeof Ee.stack == "string") {
          for (var ie = Ee.stack.split(`
`), be = ee.stack.split(`
`), de = ie.length - 1, fe = be.length - 1; de >= 1 && fe >= 0 && ie[de] !== be[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== be[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== be[fe]) {
                    var Fe = `
` + ie[de].replace(" at new ", " at ");
                    return m.displayName && Fe.includes("<anonymous>") && (Fe = Fe.replace("<anonymous>", m.displayName)), typeof m == "function" && j.set(m, Fe), Fe;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, C(), Error.prepareStackTrace = ae;
      }
      var Lt = m ? m.displayName || m.name : "", bt = Lt ? T(Lt) : "";
      return typeof m == "function" && j.set(m, bt), bt;
    }
    function le(m, A, G) {
      return B(m, !1);
    }
    function he(m) {
      var A = m.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(m, A, G) {
      if (m == null)
        return "";
      if (typeof m == "function")
        return B(m, he(m));
      if (typeof m == "string")
        return T(m);
      switch (m) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case l:
            return le(m.render);
          case p:
            return oe(m.type, A, G);
          case d: {
            var ee = m, ae = ee._payload, ue = ee._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Pe = Object.prototype.hasOwnProperty, Ue = {}, Ze = E.ReactDebugCurrentFrame;
    function _e(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        Ze.setExtraStackFrame(G);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(m, A, G, ee, ae) {
      {
        var ue = Function.call.bind(Pe);
        for (var se in m)
          if (ue(m, se)) {
            var ie = void 0;
            try {
              if (typeof m[se] != "function") {
                var be = Error((ee || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof m[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw be.name = "Invariant Violation", be;
              }
              ie = m[se](A, se, ee, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (_e(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", G, se, typeof ie), _e(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, _e(ae), w("Failed %s type: %s", G, ie.message), _e(null));
          }
      }
    }
    var Ve = Array.isArray;
    function ye(m) {
      return Ve(m);
    }
    function Ge(m) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && m[Symbol.toStringTag] || m.constructor.name || "Object";
        return G;
      }
    }
    function ct(m) {
      try {
        return ve(m), !1;
      } catch {
        return !0;
      }
    }
    function ve(m) {
      return "" + m;
    }
    function Oe(m) {
      if (ct(m))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ge(m)), ve(m);
    }
    var qe = E.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Se, st;
    function xe(m) {
      if (Pe.call(m, "ref")) {
        var A = Object.getOwnPropertyDescriptor(m, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.ref !== void 0;
    }
    function xt(m) {
      if (Pe.call(m, "key")) {
        var A = Object.getOwnPropertyDescriptor(m, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.key !== void 0;
    }
    function at(m, A) {
      typeof m.ref == "string" && qe.current;
    }
    function lt(m, A) {
      {
        var G = function() {
          Se || (Se = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function pt(m, A) {
      {
        var G = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(m, A, G, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: m,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function dt(m, A, G, ee, ae) {
      {
        var ue, se = {}, ie = null, be = null;
        G !== void 0 && (Oe(G), ie = "" + G), xt(A) && (Oe(A.key), ie = "" + A.key), xe(A) && (be = A.ref, at(A));
        for (ue in A)
          Pe.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (m && m.defaultProps) {
          var de = m.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || be) {
          var fe = typeof m == "function" ? m.displayName || m.name || "Unknown" : m;
          ie && lt(se, fe), be && pt(se, fe);
        }
        return Ot(m, ie, be, ae, ee, qe.current, se);
      }
    }
    var ft = E.ReactCurrentOwner, ot = E.ReactDebugCurrentFrame;
    function He(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        ot.setExtraStackFrame(G);
      } else
        ot.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(m) {
      return typeof m == "object" && m !== null && m.$$typeof === t;
    }
    function gt() {
      {
        if (ft.current) {
          var m = Z(ft.current.type);
          if (m)
            return `

Check the render method of \`` + m + "`.";
        }
        return "";
      }
    }
    function St(m) {
      return "";
    }
    var mt = {};
    function Mt(m) {
      {
        var A = gt();
        if (!A) {
          var G = typeof m == "string" ? m : m.displayName || m.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function vt(m, A) {
      {
        if (!m._store || m._store.validated || m.key != null)
          return;
        m._store.validated = !0;
        var G = Mt(A);
        if (mt[G])
          return;
        mt[G] = !0;
        var ee = "";
        m && m._owner && m._owner !== ft.current && (ee = " It was passed a child from " + Z(m._owner.type) + "."), He(m), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ee), He(null);
      }
    }
    function Pt(m, A) {
      {
        if (typeof m != "object")
          return;
        if (ye(m))
          for (var G = 0; G < m.length; G++) {
            var ee = m[G];
            kt(ee) && vt(ee, A);
          }
        else if (kt(m))
          m._store && (m._store.validated = !0);
        else if (m) {
          var ae = b(m);
          if (typeof ae == "function" && ae !== m.entries)
            for (var ue = ae.call(m), se; !(se = ue.next()).done; )
              kt(se.value) && vt(se.value, A);
        }
      }
    }
    function jn(m) {
      {
        var A = m.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var ee = Z(A);
          rt(G, m.props, "prop", ee, m);
        } else if (A.PropTypes !== void 0 && !Et) {
          Et = !0;
          var ae = Z(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(m) {
      {
        for (var A = Object.keys(m.props), G = 0; G < A.length; G++) {
          var ee = A[G];
          if (ee !== "children" && ee !== "key") {
            He(m), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), He(null);
            break;
          }
        }
        m.ref !== null && (He(m), w("Invalid attribute `ref` supplied to `React.Fragment`."), He(null));
      }
    }
    var te = {};
    function Rr(m, A, G, ee, ae, ue) {
      {
        var se = N(m);
        if (!se) {
          var ie = "";
          (m === void 0 || typeof m == "object" && m !== null && Object.keys(m).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var be = St();
          be ? ie += be : ie += gt();
          var de;
          m === null ? de = "null" : ye(m) ? de = "array" : m !== void 0 && m.$$typeof === t ? (de = "<" + (Z(m.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof m, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = dt(m, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Fe = A.children;
          if (Fe !== void 0)
            if (ee)
              if (ye(Fe)) {
                for (var Lt = 0; Lt < Fe.length; Lt++)
                  Pt(Fe[Lt], m);
                Object.freeze && Object.freeze(Fe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Pt(Fe, m);
        }
        if (Pe.call(A, "key")) {
          var bt = Z(m), Ee = Object.keys(A).filter(function(_i) {
            return _i !== "key";
          }), An = Ee.length > 0 ? "{key: someKey, " + Ee.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!te[bt + An]) {
            var Pi = Ee.length > 0 ? "{" + Ee.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, An, bt, Pi, bt), te[bt + An] = !0;
          }
        }
        return m === r ? yt(fe) : jn(fe), fe;
      }
    }
    function Oi(m, A, G) {
      return Rr(m, A, G, !0);
    }
    function Ei(m, A, G) {
      return Rr(m, A, G, !1);
    }
    var ki = Ei, Li = Oi;
    Fv.Fragment = r, Fv.jsx = ki, Fv.jsxs = Li;
  }()), Fv;
}
process.env.NODE_ENV === "production" ? yS.exports = hbe() : yS.exports = gbe();
var Jn = yS.exports;
We({});
function $N(e, t) {
  return t ? /* @__PURE__ */ Jn.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ Jn.jsx(Jn.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function ZN(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Zi(e) {
  var t, n;
  return ZN(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(ZN(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var $te = Symbol.for("immer-nothing"), qN = Symbol.for("immer-draftable"), Js = Symbol.for("immer-state"), mbe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ms(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = mbe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Sd = Object.getPrototypeOf;
function jp(e) {
  return !!e && !!e[Js];
}
function Ap(e) {
  var t;
  return e ? Zte(e) || Array.isArray(e) || !!e[qN] || !!((t = e.constructor) != null && t[qN]) || Nx(e) || Fx(e) : !1;
}
var vbe = Object.prototype.constructor.toString();
function Zte(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Sd(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === vbe;
}
function Zw(e, t) {
  Rx(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Rx(e) {
  const t = e[Js];
  return t ? t.type_ : Array.isArray(e) ? 1 : Nx(e) ? 2 : Fx(e) ? 3 : 0;
}
function bS(e, t) {
  return Rx(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function qte(e, t, n) {
  const r = Rx(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function ybe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Nx(e) {
  return e instanceof Map;
}
function Fx(e) {
  return e instanceof Set;
}
function Xc(e) {
  return e.copy_ || e.base_;
}
function wS(e, t) {
  if (Nx(e))
    return new Map(e);
  if (Fx(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Zte(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Js];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Sd(e), r);
  } else {
    const r = Sd(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function HT(e, t = !1) {
  return zx(e) || jp(e) || !Ap(e) || (Rx(e) > 1 && (e.set = e.add = e.clear = e.delete = bbe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => HT(r, !0))), e;
}
function bbe() {
  ms(2);
}
function zx(e) {
  return Object.isFrozen(e);
}
var wbe = {};
function Ip(e) {
  const t = wbe[e];
  return t || ms(0, e), t;
}
var gg;
function Gte() {
  return gg;
}
function Cbe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function GN(e, t) {
  t && (Ip("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function CS(e) {
  xS(e), e.drafts_.forEach(xbe), e.drafts_ = null;
}
function xS(e) {
  e === gg && (gg = e.parent_);
}
function KN(e) {
  return gg = Cbe(gg, e);
}
function xbe(e) {
  const t = e[Js];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function YN(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Js].modified_ && (CS(t), ms(4)), Ap(e) && (e = qw(t, e), t.parent_ || Gw(t, e)), t.patches_ && Ip("Patches").generateReplacementPatches_(
    n[Js].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = qw(t, n, []), CS(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== $te ? e : void 0;
}
function qw(e, t, n) {
  if (zx(t))
    return t;
  const r = t[Js];
  if (!r)
    return Zw(
      t,
      (o, i) => XN(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Gw(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Zw(
      i,
      (s, l) => XN(e, r, o, s, l, n, a)
    ), Gw(e, o, !1), n && e.patches_ && Ip("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function XN(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ms(5), jp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !bS(t.assigned_, r) ? i.concat(r) : void 0, l = qw(e, o, s);
    if (qte(n, r, l), jp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Ap(o) && !zx(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    qw(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Gw(e, o);
  }
}
function Gw(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && HT(t, n);
}
function Obe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Gte(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = WT;
  n && (o = [r], i = mg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var WT = {
  get(e, t) {
    if (t === Js)
      return e;
    const n = Xc(e);
    if (!bS(n, t))
      return Ebe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Ap(r) ? r : r === Xk(e.base_, t) ? (Jk(e), e.copy_[t] = ES(r, e)) : r;
  },
  has(e, t) {
    return t in Xc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Xc(e));
  },
  set(e, t, n) {
    const r = Kte(Xc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Xk(Xc(e), t), i = o == null ? void 0 : o[Js];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (ybe(n, o) && (n !== void 0 || bS(e.base_, t)))
        return !0;
      Jk(e), OS(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Xk(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Jk(e), OS(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Xc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ms(11);
  },
  getPrototypeOf(e) {
    return Sd(e.base_);
  },
  setPrototypeOf() {
    ms(12);
  }
}, mg = {};
Zw(WT, (e, t) => {
  mg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
mg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ms(13), mg.set.call(this, e, t, void 0);
};
mg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ms(14), WT.set.call(this, e[0], t, n, e[0]);
};
function Xk(e, t) {
  const n = e[Js];
  return (n ? Xc(n) : e)[t];
}
function Ebe(e, t, n) {
  var r;
  const o = Kte(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Kte(e, t) {
  if (!(t in e))
    return;
  let n = Sd(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Sd(n);
  }
}
function OS(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && OS(e.parent_));
}
function Jk(e) {
  e.copy_ || (e.copy_ = wS(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var kbe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ms(6), r !== void 0 && typeof r != "function" && ms(7);
      let o;
      if (Ap(t)) {
        const i = KN(this), a = ES(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? CS(i) : xS(i);
        }
        return GN(i, r), YN(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === $te && (o = void 0), this.autoFreeze_ && HT(o, !0), r) {
          const i = [], a = [];
          Ip("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ms(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Ap(e) || ms(8), jp(e) && (e = Lbe(e));
    const t = KN(this), n = ES(e, void 0);
    return n[Js].isManual_ = !0, xS(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Js];
    (!n || !n.isManual_) && ms(9);
    const { scope_: r } = n;
    return GN(r, t), YN(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Ip("Patches").applyPatches_;
    return jp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function ES(e, t) {
  const n = Nx(e) ? Ip("MapSet").proxyMap_(e, t) : Fx(e) ? Ip("MapSet").proxySet_(e, t) : Obe(e, t);
  return (t ? t.scope_ : Gte()).drafts_.push(n), n;
}
function Lbe(e) {
  return jp(e) || ms(10, e), Yte(e);
}
function Yte(e) {
  if (!Ap(e) || zx(e))
    return e;
  const t = e[Js];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = wS(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = wS(e, !0);
  return Zw(n, (r, o) => {
    qte(n, r, Yte(o));
  }), t && (t.finalized_ = !1), n;
}
var Qs = new kbe(), VT = Qs.produce;
Qs.produceWithPatches.bind(
  Qs
);
Qs.setAutoFreeze.bind(Qs);
Qs.setUseStrictShallowCopy.bind(Qs);
Qs.applyPatches.bind(Qs);
var JN = Qs.createDraft.bind(Qs), QN = Qs.finishDraft.bind(Qs), Ke = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ke.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ke.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ke.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ke.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ke.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ke.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ke.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ke.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ke.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ke.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ke.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ke.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ke.isAncestor(t, e) && !Ke.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ke.equals(i, r) || Ke.endsBefore(i, r) || Ke.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ke.equals(a, r) || Ke.isAncestor(a, r))
          return null;
        Ke.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ke.equals(s, r) || Ke.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ke.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ke.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ke.endsBefore(u, r) ? r[u.length - 1] += 1 : Ke.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ke.equals(p, d))
          return r;
        if (Ke.isAncestor(p, r) || Ke.equals(p, r)) {
          var g = d.slice();
          return Ke.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Ke.isSibling(p, d) && (Ke.isAncestor(d, r) || Ke.equals(d, r)) ? Ke.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ke.endsBefore(d, r) || Ke.equals(d, r) || Ke.isAncestor(d, r) ? (Ke.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ke.endsBefore(p, r) && (Ke.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function vg(e) {
  "@babel/helpers - typeof";
  return vg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, vg(e);
}
function Pbe(e, t) {
  if (vg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (vg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function _be(e) {
  var t = Pbe(e, "string");
  return vg(t) === "symbol" ? t : String(t);
}
function zd(e, t, n) {
  return t = _be(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function eF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eF(Object(n), !0).forEach(function(r) {
      zd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Sbe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Dt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Yt.points(t))
          t[l] = Zr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Dt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [y, b] of Yt.points(t))
          t[b] = Zr.transform(y, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Dt.get(e, E), M = Ke.previous(E), O = Dt.get(e, M), v = Dt.parent(e, E), x = E[E.length - 1];
      if (qo.isText(w) && qo.isText(O))
        O.text += w.text;
      else if (!qo.isText(w) && !qo.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(js.stringify(w), " ").concat(js.stringify(O)));
      if (v.children.splice(x, 1), t)
        for (var [_, z] of Yt.points(t))
          t[z] = Zr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (Ke.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = Dt.get(e, L), V = Dt.parent(e, L), Z = L[L.length - 1];
      V.children.splice(Z, 1);
      var H = Ke.transform(L, n), $ = Dt.get(e, Ke.parent(H)), K = H[H.length - 1];
      if ($.children.splice(K, 0, R), t)
        for (var [X, Q] of Yt.points(t))
          t[Q] = Zr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = Dt.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [F, S] of Yt.points(t)) {
          var W = Zr.transform(F, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var C = void 0, I = void 0;
            for (var [U, T] of Dt.texts(e))
              if (Ke.compare(T, J) === -1)
                C = [U, T];
              else {
                I = [U, T];
                break;
              }
            var q = !1;
            C && I && (Ke.equals(I[1], J) ? q = !Ke.hasPrevious(I[1]) : q = Ke.common(C[1], J).length < Ke.common(I[1], J).length), C && !q ? (F.path = C[1], F.offset = C[0].text.length) : I ? (F.path = I[1], F.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: j,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = Dt.leaf(e, j), he = le.text.slice(0, Y), oe = le.text.slice(Y + B.length);
      if (le.text = he + oe, t)
        for (var [Pe, Ue] of Yt.points(t))
          t[Ue] = Zr.transform(Pe, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: _e,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Dt.get(e, Ze);
      for (var ye in rt) {
        if (ye === "children" || ye === "text")
          throw new Error('Cannot set the "'.concat(ye, '" property of nodes!'));
        var Ge = rt[ye];
        Ge == null ? delete Ve[ye] : Ve[ye] = Ge;
      }
      for (var ct in _e)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ve
      } = n;
      if (ve == null)
        t = ve;
      else {
        if (t == null) {
          if (!Yt.isRange(ve))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(js.stringify(ve), " when there is no current selection."));
          t = vf({}, ve);
        }
        for (var Oe in ve) {
          var qe = ve[Oe];
          if (qe == null) {
            if (Oe === "anchor" || Oe === "focus")
              throw new Error('Cannot remove the "'.concat(Oe, '" selection property'));
            delete t[Oe];
          } else
            t[Oe] = qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Se,
        properties: st
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var xe = Dt.get(e, ze), xt = Dt.parent(e, ze), at = ze[ze.length - 1], lt;
      if (qo.isText(xe)) {
        var pt = xe.text.slice(0, Se), Ot = xe.text.slice(Se);
        xe.text = pt, lt = vf(vf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = xe.children.slice(0, Se), ft = xe.children.slice(Se);
        xe.children = dt, lt = vf(vf({}, st), {}, {
          children: ft
        });
      }
      if (xt.children.splice(at + 1, 0, lt), t)
        for (var [ot, He] of Yt.points(t))
          t[He] = Zr.transform(ot, n);
      break;
    }
  }
  return t;
}, Mbe = {
  transform(e, t) {
    e.children = JN(e.children);
    var n = e.selection && JN(e.selection);
    try {
      n = Sbe(e, n, t);
    } finally {
      e.children = QN(e.children), n ? e.selection = jp(n) ? QN(n) : n : e.selection = null;
    }
  }
}, Dbe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Tbe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Xte = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Zi(r) && Zi(o)) {
      if (!Xte(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function jbe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function yg(e, t) {
  if (e == null) return {};
  var n = jbe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Abe = ["anchor", "focus"];
function tF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ibe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tF(Object(n), !0).forEach(function(r) {
      zd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Yt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Yt.edges(e);
    return t;
  },
  equals(e, t) {
    return Zr.equals(e.anchor, t.anchor) && Zr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Yt.isRange(t)) {
      if (Yt.includes(e, t.anchor) || Yt.includes(e, t.focus))
        return !0;
      var [n, r] = Yt.edges(e), [o, i] = Yt.edges(t);
      return Zr.isBefore(n, o) && Zr.isAfter(r, i);
    }
    var [a, s] = Yt.edges(e), l = !1, u = !1;
    return Zr.isPoint(t) ? (l = Zr.compare(t, a) >= 0, u = Zr.compare(t, s) <= 0) : (l = Ke.compare(t, a.path) >= 0, u = Ke.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = yg(e, Abe), [r, o] = Yt.edges(e), [i, a] = Yt.edges(t), s = Zr.isBefore(r, i) ? i : r, l = Zr.isBefore(o, a) ? o : a;
    return Zr.isBefore(l, s) ? null : Ibe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Zr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Zr.equals(t, n);
  },
  isExpanded(e) {
    return !Yt.isCollapsed(e);
  },
  isForward(e) {
    return !Yt.isBackward(e);
  },
  isRange(e) {
    return Zi(e) && Zr.isPoint(e.anchor) && Zr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Yt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return VT(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Yt.isCollapsed(r);
        Yt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Yt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Zr.transform(r.anchor, t, {
        affinity: i
      }), u = Zr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, nF = (e) => Zi(e) && Dt.isNodeList(e.children) && !br.isEditor(e), Ml = {
  isAncestor(e) {
    return Zi(e) && Dt.isNodeList(e.children);
  },
  isElement: nF,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Ml.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return nF(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Bbe = ["children"], Rbe = ["text"], rF = /* @__PURE__ */ new WeakMap(), Dt = {
  ancestor(e, t) {
    var n = Dt.get(e, t);
    if (qo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(js.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ke.ancestors(t, n)) {
        var o = Dt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (qo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(js.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(js.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Dt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Dt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ke.common(t, n), o = Dt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Dt.get(e, t);
    if (br.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(js.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Dt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Dt.nodes(e, t))
        Ml.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Ml.isAncestor(e)) {
      var t = yg(e, Bbe);
      return t;
    } else {
      var t = yg(e, Rbe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Dt.get(e, n); r && !(qo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (qo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(js.stringify(e)));
    var n = VT({
      children: e.children
    }, (r) => {
      var [o, i] = Yt.edges(t), a = Dt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Yt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Yt.includes(t, s)) {
          var l = Dt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ke.equals(s, i.path)) {
          var c = Dt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ke.equals(s, o.path)) {
          var p = Dt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      br.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (qo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(js.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (qo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return qo.isText(e) || Ml.isElement(e) || br.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = rF.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Dt.isNode(r));
    return rF.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Dt.get(e, n); r && !(qo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Dt.get(e, t);
    if (!qo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(js.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ke.levels(t, n)) {
        var o = Dt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Ml.isElement(e) && Ml.isElementProps(t) && Ml.matches(e, t) || qo.isText(e) && qo.isTextProps(t) && qo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ke.isBefore(s, i) : Ke.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !qo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ke.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Dt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ke.next(s);
          if (Dt.has(e, c)) {
            s = c, l = Dt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ke.previous(s);
          s = p, l = Dt.get(e, s);
          continue;
        }
        s = Ke.parent(s), l = Dt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ke.parent(t), r = Dt.get(e, n);
    if (qo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return qo.isText(e) ? e.text : e.children.map(Dt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Dt.nodes(e, t))
        qo.isText(n) && (yield [n, r]);
    }();
  }
};
function oF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function to(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oF(Object(n), !0).forEach(function(r) {
      zd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lh = {
  isNodeOperation(e) {
    return lh.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Zi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ke.isPath(e.path) && Dt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ke.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ke.isPath(e.path) && Zi(e.properties);
      case "move_node":
        return Ke.isPath(e.path) && Ke.isPath(e.newPath);
      case "remove_node":
        return Ke.isPath(e.path) && Dt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ke.isPath(e.path);
      case "set_node":
        return Ke.isPath(e.path) && Zi(e.properties) && Zi(e.newProperties);
      case "set_selection":
        return e.properties === null && Yt.isRange(e.newProperties) || e.newProperties === null && Yt.isRange(e.properties) || Zi(e.properties) && Zi(e.newProperties);
      case "split_node":
        return Ke.isPath(e.path) && typeof e.position == "number" && Zi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => lh.isOperation(t));
  },
  isSelectionOperation(e) {
    return lh.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return lh.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return to(to({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return to(to({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return to(to({}, e), {}, {
          type: "split_node",
          path: Ke.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ke.equals(t, n))
          return e;
        if (Ke.isSibling(n, t))
          return to(to({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ke.transform(n, e), o = Ke.transform(Ke.next(n), e);
        return to(to({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return to(to({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return to(to({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return to(to({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? to(to({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? to(to({}, e), {}, {
          properties: null,
          newProperties: s
        }) : to(to({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return to(to({}, e), {}, {
          type: "merge_node",
          path: Ke.next(e.path)
        });
    }
  }
}, iF = /* @__PURE__ */ new WeakMap(), Nbe = (e) => {
  var t = iF.get(e);
  if (t !== void 0)
    return t;
  if (!Zi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Zi(e.marks)) && (e.selection === null || Yt.isRange(e.selection)) && Dt.isNodeList(e.children) && lh.isOperationList(e.operations);
  return iF.set(e, n), n;
}, br = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Nbe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function sF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sF(Object(n), !0).forEach(function(r) {
      zd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zr = {
  compare(e, t) {
    var n = Ke.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Zr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Zr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ke.equals(e.path, t.path);
  },
  isPoint(e) {
    return Zi(e) && typeof e.offset == "number" && Ke.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return VT(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ke.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ke.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ke.equals(t.path, i) && (r.offset += t.position), r.path = Ke.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ke.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ke.equals(t.path, i) || Ke.isAncestor(t.path, i))
            return null;
          r.path = Ke.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ke.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ke.transform(i, t, aF(aF({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ke.transform(i, t, n);
          break;
        }
      }
    });
  }
}, lF = void 0, js = {
  setScrubber(e) {
    lF = e;
  },
  stringify(e) {
    return JSON.stringify(e, lF);
  }
}, Fbe = ["text"], zbe = ["anchor", "focus"];
function uF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uF(Object(n), !0).forEach(function(r) {
      zd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = yg(i, Fbe);
      return a;
    }
    return Xte(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Zi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => qo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [fl({}, e)];
    for (var r of t) {
      var o = yg(r, zbe), [i, a] = Yt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, y = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = fl(fl({}, f), {}, {
            text: f.text.slice(E)
          }), f = fl(fl({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          y = fl(fl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = fl(fl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), y && s.push(y), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, Ube = (e) => e.selection ? e.selection : e.children.length > 0 ? br.end(e, []) : [0], Nr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Nr || (Nr = {}));
Nr.L, Nr.L | Nr.V | Nr.LV | Nr.LVT, Nr.LV | Nr.V, Nr.V | Nr.T, Nr.LVT | Nr.T, Nr.T, Nr.Any, Nr.Extend | Nr.ZWJ, Nr.Any, Nr.SpacingMark, Nr.Prepend, Nr.Any, Nr.ZWJ, Nr.ExtPict, Nr.RI, Nr.RI;
var Hbe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    br.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Ube(e)
      } = n;
      if (Ke.isPath(o) && (o = br.range(e, o)), Yt.isRange(o))
        if (Yt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Yt.end(o);
          if (!r && br.void(e, {
            at: i
          }))
            return;
          var a = Yt.start(o), s = br.pointRef(e, a), l = br.pointRef(e, i);
          Kw.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Kw.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && br.void(e, {
        at: o
      }) || br.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function cF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cF(Object(n), !0).forEach(function(r) {
      zd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Kw = zv(zv(zv(zv({}, Mbe), Dbe), Tbe), Hbe), Jte = {}, $T = {}, ZT = {}, od = {}, qT = {}, GT = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(GT);
var an = {}, ic = _r && _r.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Ph = _r && _r.__assign || function() {
  return Ph = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ph.apply(this, arguments);
};
Object.defineProperty(an, "__esModule", { value: !0 });
an.cloneNode = an.hasChildren = an.isDocument = an.isDirective = an.isComment = an.isText = an.isCDATA = an.isTag = an.Element = an.Document = an.CDATA = an.NodeWithChildren = an.ProcessingInstruction = an.Comment = an.Text = an.DataNode = an.Node = void 0;
var ks = GT, KT = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), YT(this, t);
    }, e;
  }()
);
an.Node = KT;
var Ux = (
  /** @class */
  function(e) {
    ic(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(KT)
);
an.DataNode = Ux;
var Qte = (
  /** @class */
  function(e) {
    ic(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ks.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ux)
);
an.Text = Qte;
var ene = (
  /** @class */
  function(e) {
    ic(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ks.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ux)
);
an.Comment = ene;
var tne = (
  /** @class */
  function(e) {
    ic(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = ks.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ux)
);
an.ProcessingInstruction = tne;
var Hx = (
  /** @class */
  function(e) {
    ic(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(KT)
);
an.NodeWithChildren = Hx;
var nne = (
  /** @class */
  function(e) {
    ic(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ks.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hx)
);
an.CDATA = nne;
var rne = (
  /** @class */
  function(e) {
    ic(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ks.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hx)
);
an.Document = rne;
var one = (
  /** @class */
  function(e) {
    ic(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? ks.ElementType.Script : n === "style" ? ks.ElementType.Style : ks.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hx)
);
an.Element = one;
function ine(e) {
  return (0, ks.isTag)(e);
}
an.isTag = ine;
function sne(e) {
  return e.type === ks.ElementType.CDATA;
}
an.isCDATA = sne;
function ane(e) {
  return e.type === ks.ElementType.Text;
}
an.isText = ane;
function lne(e) {
  return e.type === ks.ElementType.Comment;
}
an.isComment = lne;
function une(e) {
  return e.type === ks.ElementType.Directive;
}
an.isDirective = une;
function cne(e) {
  return e.type === ks.ElementType.Root;
}
an.isDocument = cne;
function Wbe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
an.hasChildren = Wbe;
function YT(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (ane(e))
    n = new Qte(e.data);
  else if (lne(e))
    n = new ene(e.data);
  else if (ine(e)) {
    var r = t ? Qk(e.children) : [], o = new one(e.name, Ph({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Ph({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Ph({}, e["x-attribsPrefix"])), n = o;
  } else if (sne(e)) {
    var r = t ? Qk(e.children) : [], i = new nne(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (cne(e)) {
    var r = t ? Qk(e.children) : [], a = new rne(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (une(e)) {
    var s = new tne(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
an.cloneNode = YT;
function Qk(e) {
  for (var t = e.map(function(r) {
    return YT(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = _r && _r.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = _r && _r.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = GT, o = an;
  n(an, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(qT);
var pne = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(pne);
Object.defineProperty(od, "__esModule", { value: !0 });
od.formatAttributes = dne;
od.escapeSpecialCharacters = Zbe;
od.revertEscapedCharacters = fne;
od.formatDOM = hne;
var Uv = qT, bg = pne;
function Vbe(e) {
  return bg.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function dne(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function $be(e) {
  e = e.toLowerCase();
  var t = Vbe(e);
  return t || e;
}
function Zbe(e) {
  return e.replace(bg.CARRIAGE_RETURN_REGEX, bg.CARRIAGE_RETURN_PLACEHOLDER);
}
function fne(e) {
  return e.replace(bg.CARRIAGE_RETURN_PLACEHOLDER_REGEX, bg.CARRIAGE_RETURN);
}
function hne(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = $be(s.nodeName);
        o = new Uv.Element(l, dne(s.attributes)), o.children = hne(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Uv.Text(fne(s.nodeValue));
        break;
      case 8:
        o = new Uv.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Uv.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(ZT, "__esModule", { value: !0 });
ZT.default = Xbe;
var qbe = od, pF = "html", dF = "head", Hv = "body", Gbe = /<([a-zA-Z]+[0-9]?)/, fF = /<head[^]*>/i, hF = /<body[^]*>/i, Yw = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, kS = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, gF = typeof window == "object" && window.DOMParser;
if (typeof gF == "function") {
  var Kbe = new gF(), Ybe = "text/html";
  kS = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Kbe.parseFromString(e, Ybe);
  }, Yw = kS;
}
if (typeof document == "object" && document.implementation) {
  var Wv = document.implementation.createHTMLDocument();
  Yw = function(e, t) {
    if (t) {
      var n = Wv.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Wv;
    }
    return Wv.documentElement.innerHTML = e, Wv;
  };
}
var Vv = typeof document == "object" && document.createElement("template"), LS;
Vv && Vv.content && (LS = function(e) {
  return Vv.innerHTML = e, Vv.content.childNodes;
});
function Xbe(e) {
  var t, n;
  e = (0, qbe.escapeSpecialCharacters)(e);
  var r = e.match(Gbe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case pF: {
      var i = kS(e);
      if (!fF.test(e)) {
        var a = i.querySelector(dF);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!hF.test(e)) {
        var a = i.querySelector(Hv);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(pF);
    }
    case dF:
    case Hv: {
      var s = Yw(e).querySelectorAll(o);
      return hF.test(e) && fF.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (LS)
        return LS(e);
      var a = Yw(e, Hv).querySelector(Hv);
      return a.childNodes;
    }
  }
}
var Jbe = _r && _r.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty($T, "__esModule", { value: !0 });
$T.default = nwe;
var Qbe = Jbe(ZT), ewe = od, twe = /<(![a-zA-Z\s]+)>/;
function nwe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(twe), n = t ? t[1] : void 0;
  return (0, ewe.formatDOM)((0, Qbe.default)(e), null, n);
}
var Wx = {}, Pa = {}, Vx = {}, rwe = 0;
Vx.SAME = rwe;
var owe = 1;
Vx.CAMELCASE = owe;
Vx.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const gne = 0, sc = 1, $x = 2, Zx = 3, XT = 4, mne = 5, vne = 6;
function iwe(e) {
  return Ni.hasOwnProperty(e) ? Ni[e] : null;
}
function is(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === $x || t === Zx || t === XT, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Ni = {}, swe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
swe.forEach((e) => {
  Ni[e] = new is(
    e,
    gne,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Ni[e] = new is(
    e,
    sc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Ni[e] = new is(
    e,
    $x,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Ni[e] = new is(
    e,
    $x,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Ni[e] = new is(
    e,
    Zx,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ni[e] = new is(
    e,
    Zx,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ni[e] = new is(
    e,
    XT,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ni[e] = new is(
    e,
    vne,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Ni[e] = new is(
    e,
    mne,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const JT = /[\-\:]([a-z])/g, QT = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(JT, QT);
  Ni[t] = new is(
    t,
    sc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(JT, QT);
  Ni[t] = new is(
    t,
    sc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(JT, QT);
  Ni[t] = new is(
    t,
    sc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Ni[e] = new is(
    e,
    sc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const awe = "xlinkHref";
Ni[awe] = new is(
  "xlinkHref",
  sc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Ni[e] = new is(
    e,
    sc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: lwe,
  SAME: uwe,
  possibleStandardNames: mF
} = Vx, cwe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", pwe = cwe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", dwe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + pwe + "]*$")
), fwe = Object.keys(
  mF
).reduce((e, t) => {
  const n = mF[t];
  return n === uwe ? e[t] = t : n === lwe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Pa.BOOLEAN = Zx;
Pa.BOOLEANISH_STRING = $x;
Pa.NUMERIC = mne;
Pa.OVERLOADED_BOOLEAN = XT;
Pa.POSITIVE_NUMERIC = vne;
Pa.RESERVED = gne;
Pa.STRING = sc;
Pa.getPropertyInfo = iwe;
Pa.isCustomAttribute = dwe;
Pa.possibleStandardNames = fwe;
var ej = {}, tj = {}, vF = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, hwe = /\n/g, gwe = /^\s*/, mwe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, vwe = /^:\s*/, ywe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, bwe = /^[;\s]*/, wwe = /^\s+|\s+$/g, Cwe = `
`, yF = "/", bF = "*", ap = "", xwe = "comment", Owe = "declaration", Ewe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var y = f.match(hwe);
    y && (n += y.length);
    var b = f.lastIndexOf(Cwe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(y) {
      return y.position = new a(f), u(), y;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var y = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (y.reason = f, y.filename = t.source, y.line = n, y.column = r, y.source = e, !t.silent) throw y;
  }
  function l(f) {
    var y = f.exec(e);
    if (y) {
      var b = y[0];
      return o(b), e = e.slice(b.length), y;
    }
  }
  function u() {
    l(gwe);
  }
  function c(f) {
    var y;
    for (f = f || []; y = p(); )
      y !== !1 && f.push(y);
    return f;
  }
  function p() {
    var f = i();
    if (!(yF != e.charAt(0) || bF != e.charAt(1))) {
      for (var y = 2; ap != e.charAt(y) && (bF != e.charAt(y) || yF != e.charAt(y + 1)); )
        ++y;
      if (y += 2, ap === e.charAt(y - 1))
        return s("End of comment missing");
      var b = e.slice(2, y - 2);
      return r += 2, o(b), e = e.slice(y), r += 2, f({
        type: xwe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), y = l(mwe);
    if (y) {
      if (p(), !l(vwe)) return s("property missing ':'");
      var b = l(ywe), E = f({
        type: Owe,
        property: wF(y[0].replace(vF, ap)),
        value: b ? wF(b[0].replace(vF, ap)) : ap
      });
      return l(bwe), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var y; y = d(); )
      y !== !1 && (f.push(y), c(f));
    return f;
  }
  return u(), g();
};
function wF(e) {
  return e ? e.replace(wwe, ap) : ap;
}
var kwe = _r && _r.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(tj, "__esModule", { value: !0 });
tj.default = Pwe;
var Lwe = kwe(Ewe);
function Pwe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Lwe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var qx = {};
Object.defineProperty(qx, "__esModule", { value: !0 });
qx.camelCase = void 0;
var _we = /^--[a-zA-Z0-9_-]+$/, Swe = /-([a-z])/g, Mwe = /^[^-]+$/, Dwe = /^-(webkit|moz|ms|o|khtml)-/, Twe = /^-(ms)-/, jwe = function(e) {
  return !e || Mwe.test(e) || _we.test(e);
}, Awe = function(e, t) {
  return t.toUpperCase();
}, CF = function(e, t) {
  return "".concat(t, "-");
}, Iwe = function(e, t) {
  return t === void 0 && (t = {}), jwe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Twe, CF) : e = e.replace(Dwe, CF), e.replace(Swe, Awe));
};
qx.camelCase = Iwe;
var Bwe = _r && _r.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Rwe = Bwe(tj), Nwe = qx;
function PS(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Rwe.default)(e, function(r, o) {
    r && o && (n[(0, Nwe.camelCase)(r, t)] = o);
  }), n;
}
PS.default = PS;
var Fwe = PS;
(function(e) {
  var t = _r && _r.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(Fwe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(ej);
Object.defineProperty(Wx, "__esModule", { value: !0 });
Wx.default = Wwe;
var uh = Pa, xF = ej, zwe = ["checked", "value"], Uwe = ["input", "select", "textarea"], Hwe = {
  reset: !0,
  submit: !0
};
function Wwe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Hwe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, uh.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = OF(a);
    if (s) {
      var l = (0, uh.getPropertyInfo)(s);
      switch (zwe.includes(s) && Uwe.includes(t) && !r && (s = OF("default" + a)), n[s] = i, l && l.type) {
        case uh.BOOLEAN:
          n[s] = !0;
          break;
        case uh.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    xF.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, xF.setStyleProp)(e.style, n), n;
}
function OF(e) {
  return uh.possibleStandardNames[e];
}
var nj = {}, Vwe = _r && _r.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(nj, "__esModule", { value: !0 });
nj.default = yne;
var eL = we, $we = Vwe(Wx), _h = ej, Zwe = {
  cloneElement: eL.cloneElement,
  createElement: eL.createElement,
  isValidElement: eL.isValidElement
};
function yne(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || _h.returnFirstArg, i = t.library || Zwe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, _h.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, y = {};
    qwe(f) ? ((0, _h.setStyleProp)(f.attribs.style, f.attribs), y = f.attribs) : f.attribs && (y = (0, $we.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (y.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? y.defaultValue = p.children[0].data : p.children && p.children.length && (b = yne(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (y.key = c), n.push(o(s(p.name, y, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function qwe(e) {
  return _h.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, _h.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = _r && _r.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t($T);
  e.htmlToDOM = n.default;
  var r = t(Wx);
  e.attributesToProps = r.default;
  var o = t(nj);
  e.domToReact = o.default;
  var i = qT;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(Jte);
const EF = /* @__PURE__ */ fbe(Jte);
EF.default;
function Gwe(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ Jn.jsx("div", { className: o.trim(), ...r });
}
var Sr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Kwe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var _S = { exports: {} }, yf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var kF;
function Ywe() {
  if (kF) return yf;
  kF = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return yf.Fragment = n, yf.jsx = a, yf.jsxs = a, yf;
}
var $v = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var LF;
function Xwe() {
  return LF || (LF = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, y = "@@iterator";
    function b(m) {
      if (m === null || typeof m != "object")
        return null;
      var A = f && m[f] || m[y];
      return typeof A == "function" ? A : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(m) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), ee = 1; ee < A; ee++)
          G[ee - 1] = arguments[ee];
        M("error", m, G);
      }
    }
    function M(m, A, G) {
      {
        var ee = E.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[m], console, ue);
      }
    }
    var O = !1, v = !1, x = !1, _ = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function N(m) {
      return !!(typeof m == "string" || typeof m == "function" || m === r || m === i || z || m === o || m === u || m === c || _ || m === g || O || v || x || typeof m == "object" && m !== null && (m.$$typeof === d || m.$$typeof === p || m.$$typeof === a || m.$$typeof === s || m.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      m.$$typeof === L || m.getModuleId !== void 0));
    }
    function R(m, A, G) {
      var ee = m.displayName;
      if (ee)
        return ee;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(m) {
      return m.displayName || "Context";
    }
    function Z(m) {
      if (m == null)
        return null;
      if (typeof m.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof m == "function")
        return m.displayName || m.name || null;
      if (typeof m == "string")
        return m;
      switch (m) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case s:
            var A = m;
            return V(A) + ".Consumer";
          case a:
            var G = m;
            return V(G._context) + ".Provider";
          case l:
            return R(m, m.render, "ForwardRef");
          case p:
            var ee = m.displayName || null;
            return ee !== null ? ee : Z(m.type) || "Memo";
          case d: {
            var ae = m, ue = ae._payload, se = ae._init;
            try {
              return Z(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, $ = 0, K, X, Q, J, P, D, F;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if ($ === 0) {
          K = console.log, X = console.info, Q = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, F = console.groupEnd;
          var m = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: m,
            log: m,
            warn: m,
            error: m,
            group: m,
            groupCollapsed: m,
            groupEnd: m
          });
        }
        $++;
      }
    }
    function C() {
      {
        if ($--, $ === 0) {
          var m = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, m, {
              value: K
            }),
            info: H({}, m, {
              value: X
            }),
            warn: H({}, m, {
              value: Q
            }),
            error: H({}, m, {
              value: J
            }),
            group: H({}, m, {
              value: P
            }),
            groupCollapsed: H({}, m, {
              value: D
            }),
            groupEnd: H({}, m, {
              value: F
            })
          });
        }
        $ < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = E.ReactCurrentDispatcher, U;
    function T(m, A, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            U = ee && ee[1] || "";
          }
        return `
` + U + m;
      }
    }
    var q = !1, j;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      j = new Y();
    }
    function B(m, A) {
      if (!m || q)
        return "";
      {
        var G = j.get(m);
        if (G !== void 0)
          return G;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Ee) {
              ee = Ee;
            }
            Reflect.construct(m, [], se);
          } else {
            try {
              se.call();
            } catch (Ee) {
              ee = Ee;
            }
            m.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ee) {
            ee = Ee;
          }
          m();
        }
      } catch (Ee) {
        if (Ee && ee && typeof Ee.stack == "string") {
          for (var ie = Ee.stack.split(`
`), be = ee.stack.split(`
`), de = ie.length - 1, fe = be.length - 1; de >= 1 && fe >= 0 && ie[de] !== be[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== be[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== be[fe]) {
                    var Fe = `
` + ie[de].replace(" at new ", " at ");
                    return m.displayName && Fe.includes("<anonymous>") && (Fe = Fe.replace("<anonymous>", m.displayName)), typeof m == "function" && j.set(m, Fe), Fe;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, C(), Error.prepareStackTrace = ae;
      }
      var Lt = m ? m.displayName || m.name : "", bt = Lt ? T(Lt) : "";
      return typeof m == "function" && j.set(m, bt), bt;
    }
    function le(m, A, G) {
      return B(m, !1);
    }
    function he(m) {
      var A = m.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(m, A, G) {
      if (m == null)
        return "";
      if (typeof m == "function")
        return B(m, he(m));
      if (typeof m == "string")
        return T(m);
      switch (m) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case l:
            return le(m.render);
          case p:
            return oe(m.type, A, G);
          case d: {
            var ee = m, ae = ee._payload, ue = ee._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Pe = Object.prototype.hasOwnProperty, Ue = {}, Ze = E.ReactDebugCurrentFrame;
    function _e(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        Ze.setExtraStackFrame(G);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(m, A, G, ee, ae) {
      {
        var ue = Function.call.bind(Pe);
        for (var se in m)
          if (ue(m, se)) {
            var ie = void 0;
            try {
              if (typeof m[se] != "function") {
                var be = Error((ee || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof m[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw be.name = "Invariant Violation", be;
              }
              ie = m[se](A, se, ee, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (_e(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", G, se, typeof ie), _e(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, _e(ae), w("Failed %s type: %s", G, ie.message), _e(null));
          }
      }
    }
    var Ve = Array.isArray;
    function ye(m) {
      return Ve(m);
    }
    function Ge(m) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && m[Symbol.toStringTag] || m.constructor.name || "Object";
        return G;
      }
    }
    function ct(m) {
      try {
        return ve(m), !1;
      } catch {
        return !0;
      }
    }
    function ve(m) {
      return "" + m;
    }
    function Oe(m) {
      if (ct(m))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ge(m)), ve(m);
    }
    var qe = E.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Se, st;
    function xe(m) {
      if (Pe.call(m, "ref")) {
        var A = Object.getOwnPropertyDescriptor(m, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.ref !== void 0;
    }
    function xt(m) {
      if (Pe.call(m, "key")) {
        var A = Object.getOwnPropertyDescriptor(m, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.key !== void 0;
    }
    function at(m, A) {
      typeof m.ref == "string" && qe.current;
    }
    function lt(m, A) {
      {
        var G = function() {
          Se || (Se = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function pt(m, A) {
      {
        var G = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(m, A, G, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: m,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function dt(m, A, G, ee, ae) {
      {
        var ue, se = {}, ie = null, be = null;
        G !== void 0 && (Oe(G), ie = "" + G), xt(A) && (Oe(A.key), ie = "" + A.key), xe(A) && (be = A.ref, at(A));
        for (ue in A)
          Pe.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (m && m.defaultProps) {
          var de = m.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || be) {
          var fe = typeof m == "function" ? m.displayName || m.name || "Unknown" : m;
          ie && lt(se, fe), be && pt(se, fe);
        }
        return Ot(m, ie, be, ae, ee, qe.current, se);
      }
    }
    var ft = E.ReactCurrentOwner, ot = E.ReactDebugCurrentFrame;
    function He(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        ot.setExtraStackFrame(G);
      } else
        ot.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(m) {
      return typeof m == "object" && m !== null && m.$$typeof === t;
    }
    function gt() {
      {
        if (ft.current) {
          var m = Z(ft.current.type);
          if (m)
            return `

Check the render method of \`` + m + "`.";
        }
        return "";
      }
    }
    function St(m) {
      return "";
    }
    var mt = {};
    function Mt(m) {
      {
        var A = gt();
        if (!A) {
          var G = typeof m == "string" ? m : m.displayName || m.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function vt(m, A) {
      {
        if (!m._store || m._store.validated || m.key != null)
          return;
        m._store.validated = !0;
        var G = Mt(A);
        if (mt[G])
          return;
        mt[G] = !0;
        var ee = "";
        m && m._owner && m._owner !== ft.current && (ee = " It was passed a child from " + Z(m._owner.type) + "."), He(m), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ee), He(null);
      }
    }
    function Pt(m, A) {
      {
        if (typeof m != "object")
          return;
        if (ye(m))
          for (var G = 0; G < m.length; G++) {
            var ee = m[G];
            kt(ee) && vt(ee, A);
          }
        else if (kt(m))
          m._store && (m._store.validated = !0);
        else if (m) {
          var ae = b(m);
          if (typeof ae == "function" && ae !== m.entries)
            for (var ue = ae.call(m), se; !(se = ue.next()).done; )
              kt(se.value) && vt(se.value, A);
        }
      }
    }
    function jn(m) {
      {
        var A = m.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var ee = Z(A);
          rt(G, m.props, "prop", ee, m);
        } else if (A.PropTypes !== void 0 && !Et) {
          Et = !0;
          var ae = Z(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(m) {
      {
        for (var A = Object.keys(m.props), G = 0; G < A.length; G++) {
          var ee = A[G];
          if (ee !== "children" && ee !== "key") {
            He(m), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), He(null);
            break;
          }
        }
        m.ref !== null && (He(m), w("Invalid attribute `ref` supplied to `React.Fragment`."), He(null));
      }
    }
    var te = {};
    function Rr(m, A, G, ee, ae, ue) {
      {
        var se = N(m);
        if (!se) {
          var ie = "";
          (m === void 0 || typeof m == "object" && m !== null && Object.keys(m).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var be = St();
          be ? ie += be : ie += gt();
          var de;
          m === null ? de = "null" : ye(m) ? de = "array" : m !== void 0 && m.$$typeof === t ? (de = "<" + (Z(m.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof m, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = dt(m, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Fe = A.children;
          if (Fe !== void 0)
            if (ee)
              if (ye(Fe)) {
                for (var Lt = 0; Lt < Fe.length; Lt++)
                  Pt(Fe[Lt], m);
                Object.freeze && Object.freeze(Fe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Pt(Fe, m);
        }
        if (Pe.call(A, "key")) {
          var bt = Z(m), Ee = Object.keys(A).filter(function(_i) {
            return _i !== "key";
          }), An = Ee.length > 0 ? "{key: someKey, " + Ee.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!te[bt + An]) {
            var Pi = Ee.length > 0 ? "{" + Ee.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, An, bt, Pi, bt), te[bt + An] = !0;
          }
        }
        return m === r ? yt(fe) : jn(fe), fe;
      }
    }
    function Oi(m, A, G) {
      return Rr(m, A, G, !0);
    }
    function Ei(m, A, G) {
      return Rr(m, A, G, !1);
    }
    var ki = Ei, Li = Oi;
    $v.Fragment = r, $v.jsx = ki, $v.jsxs = Li;
  }()), $v;
}
process.env.NODE_ENV === "production" ? _S.exports = Ywe() : _S.exports = Xwe();
var Mi = _S.exports;
We({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function PF(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function qi(e) {
  var t, n;
  return PF(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(PF(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var bne = Symbol.for("immer-nothing"), _F = Symbol.for("immer-draftable"), ea = Symbol.for("immer-state"), Jwe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function vs(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Jwe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Md = Object.getPrototypeOf;
function Bp(e) {
  return !!e && !!e[ea];
}
function Rp(e) {
  var t;
  return e ? wne(e) || Array.isArray(e) || !!e[_F] || !!((t = e.constructor) != null && t[_F]) || Kx(e) || Yx(e) : !1;
}
var Qwe = Object.prototype.constructor.toString();
function wne(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Md(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Qwe;
}
function Xw(e, t) {
  Gx(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Gx(e) {
  const t = e[ea];
  return t ? t.type_ : Array.isArray(e) ? 1 : Kx(e) ? 2 : Yx(e) ? 3 : 0;
}
function SS(e, t) {
  return Gx(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Cne(e, t, n) {
  const r = Gx(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function e0e(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Kx(e) {
  return e instanceof Map;
}
function Yx(e) {
  return e instanceof Set;
}
function Jc(e) {
  return e.copy_ || e.base_;
}
function MS(e, t) {
  if (Kx(e))
    return new Map(e);
  if (Yx(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = wne(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ea];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Md(e), r);
  } else {
    const r = Md(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function rj(e, t = !1) {
  return Xx(e) || Bp(e) || !Rp(e) || (Gx(e) > 1 && (e.set = e.add = e.clear = e.delete = t0e), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => rj(r, !0))), e;
}
function t0e() {
  vs(2);
}
function Xx(e) {
  return Object.isFrozen(e);
}
var n0e = {};
function Np(e) {
  const t = n0e[e];
  return t || vs(0, e), t;
}
var wg;
function xne() {
  return wg;
}
function r0e(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function SF(e, t) {
  t && (Np("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function DS(e) {
  TS(e), e.drafts_.forEach(o0e), e.drafts_ = null;
}
function TS(e) {
  e === wg && (wg = e.parent_);
}
function MF(e) {
  return wg = r0e(wg, e);
}
function o0e(e) {
  const t = e[ea];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function DF(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ea].modified_ && (DS(t), vs(4)), Rp(e) && (e = Jw(t, e), t.parent_ || Qw(t, e)), t.patches_ && Np("Patches").generateReplacementPatches_(
    n[ea].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Jw(t, n, []), DS(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== bne ? e : void 0;
}
function Jw(e, t, n) {
  if (Xx(t))
    return t;
  const r = t[ea];
  if (!r)
    return Xw(
      t,
      (o, i) => TF(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Qw(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Xw(
      i,
      (s, l) => TF(e, r, o, s, l, n, a)
    ), Qw(e, o, !1), n && e.patches_ && Np("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function TF(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && vs(5), Bp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !SS(t.assigned_, r) ? i.concat(r) : void 0, l = Jw(e, o, s);
    if (Cne(n, r, l), Bp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Rp(o) && !Xx(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Jw(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Qw(e, o);
  }
}
function Qw(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && rj(t, n);
}
function i0e(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : xne(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = oj;
  n && (o = [r], i = Cg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var oj = {
  get(e, t) {
    if (t === ea)
      return e;
    const n = Jc(e);
    if (!SS(n, t))
      return s0e(e, n, t);
    const r = n[t];
    return e.finalized_ || !Rp(r) ? r : r === tL(e.base_, t) ? (nL(e), e.copy_[t] = AS(r, e)) : r;
  },
  has(e, t) {
    return t in Jc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Jc(e));
  },
  set(e, t, n) {
    const r = One(Jc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = tL(Jc(e), t), i = o == null ? void 0 : o[ea];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (e0e(n, o) && (n !== void 0 || SS(e.base_, t)))
        return !0;
      nL(e), jS(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return tL(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, nL(e), jS(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Jc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    vs(11);
  },
  getPrototypeOf(e) {
    return Md(e.base_);
  },
  setPrototypeOf() {
    vs(12);
  }
}, Cg = {};
Xw(oj, (e, t) => {
  Cg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Cg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && vs(13), Cg.set.call(this, e, t, void 0);
};
Cg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && vs(14), oj.set.call(this, e[0], t, n, e[0]);
};
function tL(e, t) {
  const n = e[ea];
  return (n ? Jc(n) : e)[t];
}
function s0e(e, t, n) {
  var r;
  const o = One(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function One(e, t) {
  if (!(t in e))
    return;
  let n = Md(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Md(n);
  }
}
function jS(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && jS(e.parent_));
}
function nL(e) {
  e.copy_ || (e.copy_ = MS(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var a0e = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && vs(6), r !== void 0 && typeof r != "function" && vs(7);
      let o;
      if (Rp(t)) {
        const i = MF(this), a = AS(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? DS(i) : TS(i);
        }
        return SF(i, r), DF(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === bne && (o = void 0), this.autoFreeze_ && rj(o, !0), r) {
          const i = [], a = [];
          Np("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        vs(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Rp(e) || vs(8), Bp(e) && (e = l0e(e));
    const t = MF(this), n = AS(e, void 0);
    return n[ea].isManual_ = !0, TS(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ea];
    (!n || !n.isManual_) && vs(9);
    const { scope_: r } = n;
    return SF(r, t), DF(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Np("Patches").applyPatches_;
    return Bp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function AS(e, t) {
  const n = Kx(e) ? Np("MapSet").proxyMap_(e, t) : Yx(e) ? Np("MapSet").proxySet_(e, t) : i0e(e, t);
  return (t ? t.scope_ : xne()).drafts_.push(n), n;
}
function l0e(e) {
  return Bp(e) || vs(10, e), Ene(e);
}
function Ene(e) {
  if (!Rp(e) || Xx(e))
    return e;
  const t = e[ea];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = MS(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = MS(e, !0);
  return Xw(n, (r, o) => {
    Cne(n, r, Ene(o));
  }), t && (t.finalized_ = !1), n;
}
var ta = new a0e(), ij = ta.produce;
ta.produceWithPatches.bind(
  ta
);
ta.setAutoFreeze.bind(ta);
ta.setUseStrictShallowCopy.bind(ta);
ta.applyPatches.bind(ta);
var jF = ta.createDraft.bind(ta), AF = ta.finishDraft.bind(ta), Ye = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ye.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ye.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ye.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ye.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ye.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ye.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ye.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ye.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ye.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ye.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ye.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ye.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ye.isAncestor(t, e) && !Ye.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ye.equals(i, r) || Ye.endsBefore(i, r) || Ye.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ye.equals(a, r) || Ye.isAncestor(a, r))
          return null;
        Ye.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ye.equals(s, r) || Ye.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ye.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ye.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ye.endsBefore(u, r) ? r[u.length - 1] += 1 : Ye.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ye.equals(p, d))
          return r;
        if (Ye.isAncestor(p, r) || Ye.equals(p, r)) {
          var g = d.slice();
          return Ye.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Ye.isSibling(p, d) && (Ye.isAncestor(d, r) || Ye.equals(d, r)) ? Ye.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ye.endsBefore(d, r) || Ye.equals(d, r) || Ye.isAncestor(d, r) ? (Ye.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ye.endsBefore(p, r) && (Ye.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function xg(e) {
  "@babel/helpers - typeof";
  return xg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, xg(e);
}
function u0e(e, t) {
  if (xg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (xg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function c0e(e) {
  var t = u0e(e, "string");
  return xg(t) === "symbol" ? t : String(t);
}
function Ud(e, t, n) {
  return t = c0e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function IF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IF(Object(n), !0).forEach(function(r) {
      Ud(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var p0e = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Tt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Xt.points(t))
          t[l] = qr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Tt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [y, b] of Xt.points(t))
          t[b] = qr.transform(y, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Tt.get(e, E), M = Ye.previous(E), O = Tt.get(e, M), v = Tt.parent(e, E), x = E[E.length - 1];
      if (Go.isText(w) && Go.isText(O))
        O.text += w.text;
      else if (!Go.isText(w) && !Go.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(As.stringify(w), " ").concat(As.stringify(O)));
      if (v.children.splice(x, 1), t)
        for (var [_, z] of Xt.points(t))
          t[z] = qr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (Ye.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = Tt.get(e, L), V = Tt.parent(e, L), Z = L[L.length - 1];
      V.children.splice(Z, 1);
      var H = Ye.transform(L, n), $ = Tt.get(e, Ye.parent(H)), K = H[H.length - 1];
      if ($.children.splice(K, 0, R), t)
        for (var [X, Q] of Xt.points(t))
          t[Q] = qr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = Tt.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [F, S] of Xt.points(t)) {
          var W = qr.transform(F, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var C = void 0, I = void 0;
            for (var [U, T] of Tt.texts(e))
              if (Ye.compare(T, J) === -1)
                C = [U, T];
              else {
                I = [U, T];
                break;
              }
            var q = !1;
            C && I && (Ye.equals(I[1], J) ? q = !Ye.hasPrevious(I[1]) : q = Ye.common(C[1], J).length < Ye.common(I[1], J).length), C && !q ? (F.path = C[1], F.offset = C[0].text.length) : I ? (F.path = I[1], F.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: j,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = Tt.leaf(e, j), he = le.text.slice(0, Y), oe = le.text.slice(Y + B.length);
      if (le.text = he + oe, t)
        for (var [Pe, Ue] of Xt.points(t))
          t[Ue] = qr.transform(Pe, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: _e,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Tt.get(e, Ze);
      for (var ye in rt) {
        if (ye === "children" || ye === "text")
          throw new Error('Cannot set the "'.concat(ye, '" property of nodes!'));
        var Ge = rt[ye];
        Ge == null ? delete Ve[ye] : Ve[ye] = Ge;
      }
      for (var ct in _e)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ve
      } = n;
      if (ve == null)
        t = ve;
      else {
        if (t == null) {
          if (!Xt.isRange(ve))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(As.stringify(ve), " when there is no current selection."));
          t = bf({}, ve);
        }
        for (var Oe in ve) {
          var qe = ve[Oe];
          if (qe == null) {
            if (Oe === "anchor" || Oe === "focus")
              throw new Error('Cannot remove the "'.concat(Oe, '" selection property'));
            delete t[Oe];
          } else
            t[Oe] = qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Se,
        properties: st
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var xe = Tt.get(e, ze), xt = Tt.parent(e, ze), at = ze[ze.length - 1], lt;
      if (Go.isText(xe)) {
        var pt = xe.text.slice(0, Se), Ot = xe.text.slice(Se);
        xe.text = pt, lt = bf(bf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = xe.children.slice(0, Se), ft = xe.children.slice(Se);
        xe.children = dt, lt = bf(bf({}, st), {}, {
          children: ft
        });
      }
      if (xt.children.splice(at + 1, 0, lt), t)
        for (var [ot, He] of Xt.points(t))
          t[He] = qr.transform(ot, n);
      break;
    }
  }
  return t;
}, d0e = {
  transform(e, t) {
    e.children = jF(e.children);
    var n = e.selection && jF(e.selection);
    try {
      n = p0e(e, n, t);
    } finally {
      e.children = AF(e.children), n ? e.selection = Bp(n) ? AF(n) : n : e.selection = null;
    }
  }
}, f0e = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, h0e = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, kne = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (qi(r) && qi(o)) {
      if (!kne(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function g0e(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Og(e, t) {
  if (e == null) return {};
  var n = g0e(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var m0e = ["anchor", "focus"];
function BF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function v0e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BF(Object(n), !0).forEach(function(r) {
      Ud(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Xt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Xt.edges(e);
    return t;
  },
  equals(e, t) {
    return qr.equals(e.anchor, t.anchor) && qr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Xt.isRange(t)) {
      if (Xt.includes(e, t.anchor) || Xt.includes(e, t.focus))
        return !0;
      var [n, r] = Xt.edges(e), [o, i] = Xt.edges(t);
      return qr.isBefore(n, o) && qr.isAfter(r, i);
    }
    var [a, s] = Xt.edges(e), l = !1, u = !1;
    return qr.isPoint(t) ? (l = qr.compare(t, a) >= 0, u = qr.compare(t, s) <= 0) : (l = Ye.compare(t, a.path) >= 0, u = Ye.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Og(e, m0e), [r, o] = Xt.edges(e), [i, a] = Xt.edges(t), s = qr.isBefore(r, i) ? i : r, l = qr.isBefore(o, a) ? o : a;
    return qr.isBefore(l, s) ? null : v0e({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return qr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return qr.equals(t, n);
  },
  isExpanded(e) {
    return !Xt.isCollapsed(e);
  },
  isForward(e) {
    return !Xt.isBackward(e);
  },
  isRange(e) {
    return qi(e) && qr.isPoint(e.anchor) && qr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Xt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ij(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Xt.isCollapsed(r);
        Xt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Xt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = qr.transform(r.anchor, t, {
        affinity: i
      }), u = qr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, RF = (e) => qi(e) && Tt.isNodeList(e.children) && !wr.isEditor(e), Dl = {
  isAncestor(e) {
    return qi(e) && Tt.isNodeList(e.children);
  },
  isElement: RF,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Dl.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return RF(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, y0e = ["children"], b0e = ["text"], NF = /* @__PURE__ */ new WeakMap(), Tt = {
  ancestor(e, t) {
    var n = Tt.get(e, t);
    if (Go.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(As.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ye.ancestors(t, n)) {
        var o = Tt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Go.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(As.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(As.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Tt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Tt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ye.common(t, n), o = Tt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Tt.get(e, t);
    if (wr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(As.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Tt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Tt.nodes(e, t))
        Dl.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Dl.isAncestor(e)) {
      var t = Og(e, y0e);
      return t;
    } else {
      var t = Og(e, b0e);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Tt.get(e, n); r && !(Go.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Go.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(As.stringify(e)));
    var n = ij({
      children: e.children
    }, (r) => {
      var [o, i] = Xt.edges(t), a = Tt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Xt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Xt.includes(t, s)) {
          var l = Tt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ye.equals(s, i.path)) {
          var c = Tt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ye.equals(s, o.path)) {
          var p = Tt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      wr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Go.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(As.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Go.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Go.isText(e) || Dl.isElement(e) || wr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = NF.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Tt.isNode(r));
    return NF.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Tt.get(e, n); r && !(Go.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Tt.get(e, t);
    if (!Go.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(As.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ye.levels(t, n)) {
        var o = Tt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Dl.isElement(e) && Dl.isElementProps(t) && Dl.matches(e, t) || Go.isText(e) && Go.isTextProps(t) && Go.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ye.isBefore(s, i) : Ye.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Go.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ye.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Tt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ye.next(s);
          if (Tt.has(e, c)) {
            s = c, l = Tt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ye.previous(s);
          s = p, l = Tt.get(e, s);
          continue;
        }
        s = Ye.parent(s), l = Tt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ye.parent(t), r = Tt.get(e, n);
    if (Go.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Go.isText(e) ? e.text : e.children.map(Tt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Tt.nodes(e, t))
        Go.isText(n) && (yield [n, r]);
    }();
  }
};
function FF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function no(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FF(Object(n), !0).forEach(function(r) {
      Ud(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ch = {
  isNodeOperation(e) {
    return ch.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!qi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ye.isPath(e.path) && Tt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ye.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ye.isPath(e.path) && qi(e.properties);
      case "move_node":
        return Ye.isPath(e.path) && Ye.isPath(e.newPath);
      case "remove_node":
        return Ye.isPath(e.path) && Tt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ye.isPath(e.path);
      case "set_node":
        return Ye.isPath(e.path) && qi(e.properties) && qi(e.newProperties);
      case "set_selection":
        return e.properties === null && Xt.isRange(e.newProperties) || e.newProperties === null && Xt.isRange(e.properties) || qi(e.properties) && qi(e.newProperties);
      case "split_node":
        return Ye.isPath(e.path) && typeof e.position == "number" && qi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => ch.isOperation(t));
  },
  isSelectionOperation(e) {
    return ch.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return ch.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return no(no({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return no(no({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return no(no({}, e), {}, {
          type: "split_node",
          path: Ye.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ye.equals(t, n))
          return e;
        if (Ye.isSibling(n, t))
          return no(no({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ye.transform(n, e), o = Ye.transform(Ye.next(n), e);
        return no(no({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return no(no({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return no(no({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return no(no({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? no(no({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? no(no({}, e), {}, {
          properties: null,
          newProperties: s
        }) : no(no({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return no(no({}, e), {}, {
          type: "merge_node",
          path: Ye.next(e.path)
        });
    }
  }
}, zF = /* @__PURE__ */ new WeakMap(), w0e = (e) => {
  var t = zF.get(e);
  if (t !== void 0)
    return t;
  if (!qi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || qi(e.marks)) && (e.selection === null || Xt.isRange(e.selection)) && Tt.isNodeList(e.children) && ch.isOperationList(e.operations);
  return zF.set(e, n), n;
}, wr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return w0e(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function UF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function HF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UF(Object(n), !0).forEach(function(r) {
      Ud(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qr = {
  compare(e, t) {
    var n = Ye.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return qr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return qr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ye.equals(e.path, t.path);
  },
  isPoint(e) {
    return qi(e) && typeof e.offset == "number" && Ye.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ij(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ye.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ye.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ye.equals(t.path, i) && (r.offset += t.position), r.path = Ye.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ye.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ye.equals(t.path, i) || Ye.isAncestor(t.path, i))
            return null;
          r.path = Ye.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ye.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ye.transform(i, t, HF(HF({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ye.transform(i, t, n);
          break;
        }
      }
    });
  }
}, WF = void 0, As = {
  setScrubber(e) {
    WF = e;
  },
  stringify(e) {
    return JSON.stringify(e, WF);
  }
}, C0e = ["text"], x0e = ["anchor", "focus"];
function VF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VF(Object(n), !0).forEach(function(r) {
      Ud(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Go = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Og(i, C0e);
      return a;
    }
    return kne(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return qi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Go.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [hl({}, e)];
    for (var r of t) {
      var o = Og(r, x0e), [i, a] = Xt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, y = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = hl(hl({}, f), {}, {
            text: f.text.slice(E)
          }), f = hl(hl({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          y = hl(hl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = hl(hl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), y && s.push(y), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, O0e = (e) => e.selection ? e.selection : e.children.length > 0 ? wr.end(e, []) : [0], Fr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Fr || (Fr = {}));
Fr.L, Fr.L | Fr.V | Fr.LV | Fr.LVT, Fr.LV | Fr.V, Fr.V | Fr.T, Fr.LVT | Fr.T, Fr.T, Fr.Any, Fr.Extend | Fr.ZWJ, Fr.Any, Fr.SpacingMark, Fr.Prepend, Fr.Any, Fr.ZWJ, Fr.ExtPict, Fr.RI, Fr.RI;
var E0e = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    wr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = O0e(e)
      } = n;
      if (Ye.isPath(o) && (o = wr.range(e, o)), Xt.isRange(o))
        if (Xt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Xt.end(o);
          if (!r && wr.void(e, {
            at: i
          }))
            return;
          var a = Xt.start(o), s = wr.pointRef(e, a), l = wr.pointRef(e, i);
          e0.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, e0.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && wr.void(e, {
        at: o
      }) || wr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function $F(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $F(Object(n), !0).forEach(function(r) {
      Ud(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $F(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var e0 = Zv(Zv(Zv(Zv({}, d0e), f0e), h0e), E0e), Lne = {}, sj = {}, aj = {}, id = {}, lj = {}, uj = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(uj);
var ln = {}, ac = Sr && Sr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Sh = Sr && Sr.__assign || function() {
  return Sh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Sh.apply(this, arguments);
};
Object.defineProperty(ln, "__esModule", { value: !0 });
ln.cloneNode = ln.hasChildren = ln.isDocument = ln.isDirective = ln.isComment = ln.isText = ln.isCDATA = ln.isTag = ln.Element = ln.Document = ln.CDATA = ln.NodeWithChildren = ln.ProcessingInstruction = ln.Comment = ln.Text = ln.DataNode = ln.Node = void 0;
var Ls = uj, cj = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), pj(this, t);
    }, e;
  }()
);
ln.Node = cj;
var Jx = (
  /** @class */
  function(e) {
    ac(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cj)
);
ln.DataNode = Jx;
var Pne = (
  /** @class */
  function(e) {
    ac(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ls.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Jx)
);
ln.Text = Pne;
var _ne = (
  /** @class */
  function(e) {
    ac(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ls.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Jx)
);
ln.Comment = _ne;
var Sne = (
  /** @class */
  function(e) {
    ac(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ls.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Jx)
);
ln.ProcessingInstruction = Sne;
var Qx = (
  /** @class */
  function(e) {
    ac(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cj)
);
ln.NodeWithChildren = Qx;
var Mne = (
  /** @class */
  function(e) {
    ac(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ls.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qx)
);
ln.CDATA = Mne;
var Dne = (
  /** @class */
  function(e) {
    ac(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ls.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qx)
);
ln.Document = Dne;
var Tne = (
  /** @class */
  function(e) {
    ac(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ls.ElementType.Script : n === "style" ? Ls.ElementType.Style : Ls.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qx)
);
ln.Element = Tne;
function jne(e) {
  return (0, Ls.isTag)(e);
}
ln.isTag = jne;
function Ane(e) {
  return e.type === Ls.ElementType.CDATA;
}
ln.isCDATA = Ane;
function Ine(e) {
  return e.type === Ls.ElementType.Text;
}
ln.isText = Ine;
function Bne(e) {
  return e.type === Ls.ElementType.Comment;
}
ln.isComment = Bne;
function Rne(e) {
  return e.type === Ls.ElementType.Directive;
}
ln.isDirective = Rne;
function Nne(e) {
  return e.type === Ls.ElementType.Root;
}
ln.isDocument = Nne;
function k0e(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
ln.hasChildren = k0e;
function pj(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (Ine(e))
    n = new Pne(e.data);
  else if (Bne(e))
    n = new _ne(e.data);
  else if (jne(e)) {
    var r = t ? rL(e.children) : [], o = new Tne(e.name, Sh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Sh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Sh({}, e["x-attribsPrefix"])), n = o;
  } else if (Ane(e)) {
    var r = t ? rL(e.children) : [], i = new Mne(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (Nne(e)) {
    var r = t ? rL(e.children) : [], a = new Dne(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (Rne(e)) {
    var s = new Sne(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
ln.cloneNode = pj;
function rL(e) {
  for (var t = e.map(function(r) {
    return pj(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Sr && Sr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Sr && Sr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = uj, o = ln;
  n(ln, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(lj);
var Fne = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(Fne);
Object.defineProperty(id, "__esModule", { value: !0 });
id.formatAttributes = zne;
id.escapeSpecialCharacters = _0e;
id.revertEscapedCharacters = Une;
id.formatDOM = Hne;
var qv = lj, Eg = Fne;
function L0e(e) {
  return Eg.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function zne(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function P0e(e) {
  e = e.toLowerCase();
  var t = L0e(e);
  return t || e;
}
function _0e(e) {
  return e.replace(Eg.CARRIAGE_RETURN_REGEX, Eg.CARRIAGE_RETURN_PLACEHOLDER);
}
function Une(e) {
  return e.replace(Eg.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Eg.CARRIAGE_RETURN);
}
function Hne(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = P0e(s.nodeName);
        o = new qv.Element(l, zne(s.attributes)), o.children = Hne(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new qv.Text(Une(s.nodeValue));
        break;
      case 8:
        o = new qv.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new qv.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(aj, "__esModule", { value: !0 });
aj.default = j0e;
var S0e = id, ZF = "html", qF = "head", Gv = "body", M0e = /<([a-zA-Z]+[0-9]?)/, GF = /<head[^]*>/i, KF = /<body[^]*>/i, t0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, IS = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, YF = typeof window == "object" && window.DOMParser;
if (typeof YF == "function") {
  var D0e = new YF(), T0e = "text/html";
  IS = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), D0e.parseFromString(e, T0e);
  }, t0 = IS;
}
if (typeof document == "object" && document.implementation) {
  var Kv = document.implementation.createHTMLDocument();
  t0 = function(e, t) {
    if (t) {
      var n = Kv.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Kv;
    }
    return Kv.documentElement.innerHTML = e, Kv;
  };
}
var Yv = typeof document == "object" && document.createElement("template"), BS;
Yv && Yv.content && (BS = function(e) {
  return Yv.innerHTML = e, Yv.content.childNodes;
});
function j0e(e) {
  var t, n;
  e = (0, S0e.escapeSpecialCharacters)(e);
  var r = e.match(M0e), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case ZF: {
      var i = IS(e);
      if (!GF.test(e)) {
        var a = i.querySelector(qF);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!KF.test(e)) {
        var a = i.querySelector(Gv);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(ZF);
    }
    case qF:
    case Gv: {
      var s = t0(e).querySelectorAll(o);
      return KF.test(e) && GF.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (BS)
        return BS(e);
      var a = t0(e, Gv).querySelector(Gv);
      return a.childNodes;
    }
  }
}
var A0e = Sr && Sr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(sj, "__esModule", { value: !0 });
sj.default = N0e;
var I0e = A0e(aj), B0e = id, R0e = /<(![a-zA-Z\s]+)>/;
function N0e(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(R0e), n = t ? t[1] : void 0;
  return (0, B0e.formatDOM)((0, I0e.default)(e), null, n);
}
var eO = {}, _a = {}, tO = {}, F0e = 0;
tO.SAME = F0e;
var z0e = 1;
tO.CAMELCASE = z0e;
tO.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const Wne = 0, lc = 1, nO = 2, rO = 3, dj = 4, Vne = 5, $ne = 6;
function U0e(e) {
  return Fi.hasOwnProperty(e) ? Fi[e] : null;
}
function ss(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === nO || t === rO || t === dj, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Fi = {}, H0e = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
H0e.forEach((e) => {
  Fi[e] = new ss(
    e,
    Wne,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Fi[e] = new ss(
    e,
    lc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Fi[e] = new ss(
    e,
    nO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Fi[e] = new ss(
    e,
    nO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Fi[e] = new ss(
    e,
    rO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Fi[e] = new ss(
    e,
    rO,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Fi[e] = new ss(
    e,
    dj,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Fi[e] = new ss(
    e,
    $ne,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Fi[e] = new ss(
    e,
    Vne,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const fj = /[\-\:]([a-z])/g, hj = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(fj, hj);
  Fi[t] = new ss(
    t,
    lc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(fj, hj);
  Fi[t] = new ss(
    t,
    lc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(fj, hj);
  Fi[t] = new ss(
    t,
    lc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Fi[e] = new ss(
    e,
    lc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const W0e = "xlinkHref";
Fi[W0e] = new ss(
  "xlinkHref",
  lc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Fi[e] = new ss(
    e,
    lc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: V0e,
  SAME: $0e,
  possibleStandardNames: XF
} = tO, Z0e = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", q0e = Z0e + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", G0e = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + q0e + "]*$")
), K0e = Object.keys(
  XF
).reduce((e, t) => {
  const n = XF[t];
  return n === $0e ? e[t] = t : n === V0e ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
_a.BOOLEAN = rO;
_a.BOOLEANISH_STRING = nO;
_a.NUMERIC = Vne;
_a.OVERLOADED_BOOLEAN = dj;
_a.POSITIVE_NUMERIC = $ne;
_a.RESERVED = Wne;
_a.STRING = lc;
_a.getPropertyInfo = U0e;
_a.isCustomAttribute = G0e;
_a.possibleStandardNames = K0e;
var gj = {}, mj = {}, JF = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Y0e = /\n/g, X0e = /^\s*/, J0e = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Q0e = /^:\s*/, eCe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, tCe = /^[;\s]*/, nCe = /^\s+|\s+$/g, rCe = `
`, QF = "/", ez = "*", lp = "", oCe = "comment", iCe = "declaration", sCe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var y = f.match(Y0e);
    y && (n += y.length);
    var b = f.lastIndexOf(rCe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(y) {
      return y.position = new a(f), u(), y;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var y = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (y.reason = f, y.filename = t.source, y.line = n, y.column = r, y.source = e, !t.silent) throw y;
  }
  function l(f) {
    var y = f.exec(e);
    if (y) {
      var b = y[0];
      return o(b), e = e.slice(b.length), y;
    }
  }
  function u() {
    l(X0e);
  }
  function c(f) {
    var y;
    for (f = f || []; y = p(); )
      y !== !1 && f.push(y);
    return f;
  }
  function p() {
    var f = i();
    if (!(QF != e.charAt(0) || ez != e.charAt(1))) {
      for (var y = 2; lp != e.charAt(y) && (ez != e.charAt(y) || QF != e.charAt(y + 1)); )
        ++y;
      if (y += 2, lp === e.charAt(y - 1))
        return s("End of comment missing");
      var b = e.slice(2, y - 2);
      return r += 2, o(b), e = e.slice(y), r += 2, f({
        type: oCe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), y = l(J0e);
    if (y) {
      if (p(), !l(Q0e)) return s("property missing ':'");
      var b = l(eCe), E = f({
        type: iCe,
        property: tz(y[0].replace(JF, lp)),
        value: b ? tz(b[0].replace(JF, lp)) : lp
      });
      return l(tCe), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var y; y = d(); )
      y !== !1 && (f.push(y), c(f));
    return f;
  }
  return u(), g();
};
function tz(e) {
  return e ? e.replace(nCe, lp) : lp;
}
var aCe = Sr && Sr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(mj, "__esModule", { value: !0 });
mj.default = uCe;
var lCe = aCe(sCe);
function uCe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, lCe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var oO = {};
Object.defineProperty(oO, "__esModule", { value: !0 });
oO.camelCase = void 0;
var cCe = /^--[a-zA-Z0-9_-]+$/, pCe = /-([a-z])/g, dCe = /^[^-]+$/, fCe = /^-(webkit|moz|ms|o|khtml)-/, hCe = /^-(ms)-/, gCe = function(e) {
  return !e || dCe.test(e) || cCe.test(e);
}, mCe = function(e, t) {
  return t.toUpperCase();
}, nz = function(e, t) {
  return "".concat(t, "-");
}, vCe = function(e, t) {
  return t === void 0 && (t = {}), gCe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(hCe, nz) : e = e.replace(fCe, nz), e.replace(pCe, mCe));
};
oO.camelCase = vCe;
var yCe = Sr && Sr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, bCe = yCe(mj), wCe = oO;
function RS(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, bCe.default)(e, function(r, o) {
    r && o && (n[(0, wCe.camelCase)(r, t)] = o);
  }), n;
}
RS.default = RS;
var CCe = RS;
(function(e) {
  var t = Sr && Sr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(CCe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(gj);
Object.defineProperty(eO, "__esModule", { value: !0 });
eO.default = kCe;
var ph = _a, rz = gj, xCe = ["checked", "value"], OCe = ["input", "select", "textarea"], ECe = {
  reset: !0,
  submit: !0
};
function kCe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && ECe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, ph.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = oz(a);
    if (s) {
      var l = (0, ph.getPropertyInfo)(s);
      switch (xCe.includes(s) && OCe.includes(t) && !r && (s = oz("default" + a)), n[s] = i, l && l.type) {
        case ph.BOOLEAN:
          n[s] = !0;
          break;
        case ph.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    rz.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, rz.setStyleProp)(e.style, n), n;
}
function oz(e) {
  return ph.possibleStandardNames[e];
}
var vj = {}, LCe = Sr && Sr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(vj, "__esModule", { value: !0 });
vj.default = Zne;
var oL = we, PCe = LCe(eO), Mh = gj, _Ce = {
  cloneElement: oL.cloneElement,
  createElement: oL.createElement,
  isValidElement: oL.isValidElement
};
function Zne(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Mh.returnFirstArg, i = t.library || _Ce, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Mh.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, y = {};
    SCe(f) ? ((0, Mh.setStyleProp)(f.attribs.style, f.attribs), y = f.attribs) : f.attribs && (y = (0, PCe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (y.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? y.defaultValue = p.children[0].data : p.children && p.children.length && (b = Zne(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (y.key = c), n.push(o(s(p.name, y, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function SCe(e) {
  return Mh.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Mh.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Sr && Sr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(sj);
  e.htmlToDOM = n.default;
  var r = t(eO);
  e.attributesToProps = r.default;
  var o = t(vj);
  e.domToReact = o.default;
  var i = lj;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(Lne);
const MCe = /* @__PURE__ */ Kwe(Lne);
MCe.default;
var Mr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function DCe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var NS = { exports: {} }, wf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iz;
function TCe() {
  if (iz) return wf;
  iz = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return wf.Fragment = n, wf.jsx = a, wf.jsxs = a, wf;
}
var Xv = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sz;
function jCe() {
  return sz || (sz = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, y = "@@iterator";
    function b(m) {
      if (m === null || typeof m != "object")
        return null;
      var A = f && m[f] || m[y];
      return typeof A == "function" ? A : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(m) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), ee = 1; ee < A; ee++)
          G[ee - 1] = arguments[ee];
        M("error", m, G);
      }
    }
    function M(m, A, G) {
      {
        var ee = E.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[m], console, ue);
      }
    }
    var O = !1, v = !1, x = !1, _ = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function N(m) {
      return !!(typeof m == "string" || typeof m == "function" || m === r || m === i || z || m === o || m === u || m === c || _ || m === g || O || v || x || typeof m == "object" && m !== null && (m.$$typeof === d || m.$$typeof === p || m.$$typeof === a || m.$$typeof === s || m.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      m.$$typeof === L || m.getModuleId !== void 0));
    }
    function R(m, A, G) {
      var ee = m.displayName;
      if (ee)
        return ee;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(m) {
      return m.displayName || "Context";
    }
    function Z(m) {
      if (m == null)
        return null;
      if (typeof m.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof m == "function")
        return m.displayName || m.name || null;
      if (typeof m == "string")
        return m;
      switch (m) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case s:
            var A = m;
            return V(A) + ".Consumer";
          case a:
            var G = m;
            return V(G._context) + ".Provider";
          case l:
            return R(m, m.render, "ForwardRef");
          case p:
            var ee = m.displayName || null;
            return ee !== null ? ee : Z(m.type) || "Memo";
          case d: {
            var ae = m, ue = ae._payload, se = ae._init;
            try {
              return Z(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, $ = 0, K, X, Q, J, P, D, F;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if ($ === 0) {
          K = console.log, X = console.info, Q = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, F = console.groupEnd;
          var m = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: m,
            log: m,
            warn: m,
            error: m,
            group: m,
            groupCollapsed: m,
            groupEnd: m
          });
        }
        $++;
      }
    }
    function C() {
      {
        if ($--, $ === 0) {
          var m = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, m, {
              value: K
            }),
            info: H({}, m, {
              value: X
            }),
            warn: H({}, m, {
              value: Q
            }),
            error: H({}, m, {
              value: J
            }),
            group: H({}, m, {
              value: P
            }),
            groupCollapsed: H({}, m, {
              value: D
            }),
            groupEnd: H({}, m, {
              value: F
            })
          });
        }
        $ < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = E.ReactCurrentDispatcher, U;
    function T(m, A, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            U = ee && ee[1] || "";
          }
        return `
` + U + m;
      }
    }
    var q = !1, j;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      j = new Y();
    }
    function B(m, A) {
      if (!m || q)
        return "";
      {
        var G = j.get(m);
        if (G !== void 0)
          return G;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Ee) {
              ee = Ee;
            }
            Reflect.construct(m, [], se);
          } else {
            try {
              se.call();
            } catch (Ee) {
              ee = Ee;
            }
            m.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ee) {
            ee = Ee;
          }
          m();
        }
      } catch (Ee) {
        if (Ee && ee && typeof Ee.stack == "string") {
          for (var ie = Ee.stack.split(`
`), be = ee.stack.split(`
`), de = ie.length - 1, fe = be.length - 1; de >= 1 && fe >= 0 && ie[de] !== be[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== be[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== be[fe]) {
                    var Fe = `
` + ie[de].replace(" at new ", " at ");
                    return m.displayName && Fe.includes("<anonymous>") && (Fe = Fe.replace("<anonymous>", m.displayName)), typeof m == "function" && j.set(m, Fe), Fe;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, C(), Error.prepareStackTrace = ae;
      }
      var Lt = m ? m.displayName || m.name : "", bt = Lt ? T(Lt) : "";
      return typeof m == "function" && j.set(m, bt), bt;
    }
    function le(m, A, G) {
      return B(m, !1);
    }
    function he(m) {
      var A = m.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(m, A, G) {
      if (m == null)
        return "";
      if (typeof m == "function")
        return B(m, he(m));
      if (typeof m == "string")
        return T(m);
      switch (m) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case l:
            return le(m.render);
          case p:
            return oe(m.type, A, G);
          case d: {
            var ee = m, ae = ee._payload, ue = ee._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Pe = Object.prototype.hasOwnProperty, Ue = {}, Ze = E.ReactDebugCurrentFrame;
    function _e(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        Ze.setExtraStackFrame(G);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(m, A, G, ee, ae) {
      {
        var ue = Function.call.bind(Pe);
        for (var se in m)
          if (ue(m, se)) {
            var ie = void 0;
            try {
              if (typeof m[se] != "function") {
                var be = Error((ee || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof m[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw be.name = "Invariant Violation", be;
              }
              ie = m[se](A, se, ee, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (_e(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", G, se, typeof ie), _e(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, _e(ae), w("Failed %s type: %s", G, ie.message), _e(null));
          }
      }
    }
    var Ve = Array.isArray;
    function ye(m) {
      return Ve(m);
    }
    function Ge(m) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && m[Symbol.toStringTag] || m.constructor.name || "Object";
        return G;
      }
    }
    function ct(m) {
      try {
        return ve(m), !1;
      } catch {
        return !0;
      }
    }
    function ve(m) {
      return "" + m;
    }
    function Oe(m) {
      if (ct(m))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ge(m)), ve(m);
    }
    var qe = E.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Se, st;
    function xe(m) {
      if (Pe.call(m, "ref")) {
        var A = Object.getOwnPropertyDescriptor(m, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.ref !== void 0;
    }
    function xt(m) {
      if (Pe.call(m, "key")) {
        var A = Object.getOwnPropertyDescriptor(m, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.key !== void 0;
    }
    function at(m, A) {
      typeof m.ref == "string" && qe.current;
    }
    function lt(m, A) {
      {
        var G = function() {
          Se || (Se = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function pt(m, A) {
      {
        var G = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(m, A, G, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: m,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function dt(m, A, G, ee, ae) {
      {
        var ue, se = {}, ie = null, be = null;
        G !== void 0 && (Oe(G), ie = "" + G), xt(A) && (Oe(A.key), ie = "" + A.key), xe(A) && (be = A.ref, at(A));
        for (ue in A)
          Pe.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (m && m.defaultProps) {
          var de = m.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || be) {
          var fe = typeof m == "function" ? m.displayName || m.name || "Unknown" : m;
          ie && lt(se, fe), be && pt(se, fe);
        }
        return Ot(m, ie, be, ae, ee, qe.current, se);
      }
    }
    var ft = E.ReactCurrentOwner, ot = E.ReactDebugCurrentFrame;
    function He(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        ot.setExtraStackFrame(G);
      } else
        ot.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(m) {
      return typeof m == "object" && m !== null && m.$$typeof === t;
    }
    function gt() {
      {
        if (ft.current) {
          var m = Z(ft.current.type);
          if (m)
            return `

Check the render method of \`` + m + "`.";
        }
        return "";
      }
    }
    function St(m) {
      return "";
    }
    var mt = {};
    function Mt(m) {
      {
        var A = gt();
        if (!A) {
          var G = typeof m == "string" ? m : m.displayName || m.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function vt(m, A) {
      {
        if (!m._store || m._store.validated || m.key != null)
          return;
        m._store.validated = !0;
        var G = Mt(A);
        if (mt[G])
          return;
        mt[G] = !0;
        var ee = "";
        m && m._owner && m._owner !== ft.current && (ee = " It was passed a child from " + Z(m._owner.type) + "."), He(m), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ee), He(null);
      }
    }
    function Pt(m, A) {
      {
        if (typeof m != "object")
          return;
        if (ye(m))
          for (var G = 0; G < m.length; G++) {
            var ee = m[G];
            kt(ee) && vt(ee, A);
          }
        else if (kt(m))
          m._store && (m._store.validated = !0);
        else if (m) {
          var ae = b(m);
          if (typeof ae == "function" && ae !== m.entries)
            for (var ue = ae.call(m), se; !(se = ue.next()).done; )
              kt(se.value) && vt(se.value, A);
        }
      }
    }
    function jn(m) {
      {
        var A = m.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var ee = Z(A);
          rt(G, m.props, "prop", ee, m);
        } else if (A.PropTypes !== void 0 && !Et) {
          Et = !0;
          var ae = Z(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(m) {
      {
        for (var A = Object.keys(m.props), G = 0; G < A.length; G++) {
          var ee = A[G];
          if (ee !== "children" && ee !== "key") {
            He(m), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), He(null);
            break;
          }
        }
        m.ref !== null && (He(m), w("Invalid attribute `ref` supplied to `React.Fragment`."), He(null));
      }
    }
    var te = {};
    function Rr(m, A, G, ee, ae, ue) {
      {
        var se = N(m);
        if (!se) {
          var ie = "";
          (m === void 0 || typeof m == "object" && m !== null && Object.keys(m).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var be = St();
          be ? ie += be : ie += gt();
          var de;
          m === null ? de = "null" : ye(m) ? de = "array" : m !== void 0 && m.$$typeof === t ? (de = "<" + (Z(m.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof m, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = dt(m, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Fe = A.children;
          if (Fe !== void 0)
            if (ee)
              if (ye(Fe)) {
                for (var Lt = 0; Lt < Fe.length; Lt++)
                  Pt(Fe[Lt], m);
                Object.freeze && Object.freeze(Fe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Pt(Fe, m);
        }
        if (Pe.call(A, "key")) {
          var bt = Z(m), Ee = Object.keys(A).filter(function(_i) {
            return _i !== "key";
          }), An = Ee.length > 0 ? "{key: someKey, " + Ee.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!te[bt + An]) {
            var Pi = Ee.length > 0 ? "{" + Ee.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, An, bt, Pi, bt), te[bt + An] = !0;
          }
        }
        return m === r ? yt(fe) : jn(fe), fe;
      }
    }
    function Oi(m, A, G) {
      return Rr(m, A, G, !0);
    }
    function Ei(m, A, G) {
      return Rr(m, A, G, !1);
    }
    var ki = Ei, Li = Oi;
    Xv.Fragment = r, Xv.jsx = ki, Xv.jsxs = Li;
  }()), Xv;
}
process.env.NODE_ENV === "production" ? NS.exports = TCe() : NS.exports = jCe();
var Di = NS.exports;
We({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function az(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Gi(e) {
  var t, n;
  return az(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(az(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var qne = Symbol.for("immer-nothing"), lz = Symbol.for("immer-draftable"), na = Symbol.for("immer-state"), ACe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ys(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = ACe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Dd = Object.getPrototypeOf;
function Fp(e) {
  return !!e && !!e[na];
}
function zp(e) {
  var t;
  return e ? Gne(e) || Array.isArray(e) || !!e[lz] || !!((t = e.constructor) != null && t[lz]) || sO(e) || aO(e) : !1;
}
var ICe = Object.prototype.constructor.toString();
function Gne(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Dd(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === ICe;
}
function n0(e, t) {
  iO(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function iO(e) {
  const t = e[na];
  return t ? t.type_ : Array.isArray(e) ? 1 : sO(e) ? 2 : aO(e) ? 3 : 0;
}
function FS(e, t) {
  return iO(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Kne(e, t, n) {
  const r = iO(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function BCe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function sO(e) {
  return e instanceof Map;
}
function aO(e) {
  return e instanceof Set;
}
function Qc(e) {
  return e.copy_ || e.base_;
}
function zS(e, t) {
  if (sO(e))
    return new Map(e);
  if (aO(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Gne(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[na];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Dd(e), r);
  } else {
    const r = Dd(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function yj(e, t = !1) {
  return lO(e) || Fp(e) || !zp(e) || (iO(e) > 1 && (e.set = e.add = e.clear = e.delete = RCe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => yj(r, !0))), e;
}
function RCe() {
  ys(2);
}
function lO(e) {
  return Object.isFrozen(e);
}
var NCe = {};
function Up(e) {
  const t = NCe[e];
  return t || ys(0, e), t;
}
var kg;
function Yne() {
  return kg;
}
function FCe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function uz(e, t) {
  t && (Up("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function US(e) {
  HS(e), e.drafts_.forEach(zCe), e.drafts_ = null;
}
function HS(e) {
  e === kg && (kg = e.parent_);
}
function cz(e) {
  return kg = FCe(kg, e);
}
function zCe(e) {
  const t = e[na];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function pz(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[na].modified_ && (US(t), ys(4)), zp(e) && (e = r0(t, e), t.parent_ || o0(t, e)), t.patches_ && Up("Patches").generateReplacementPatches_(
    n[na].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = r0(t, n, []), US(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== qne ? e : void 0;
}
function r0(e, t, n) {
  if (lO(t))
    return t;
  const r = t[na];
  if (!r)
    return n0(
      t,
      (o, i) => dz(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return o0(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), n0(
      i,
      (s, l) => dz(e, r, o, s, l, n, a)
    ), o0(e, o, !1), n && e.patches_ && Up("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function dz(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ys(5), Fp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !FS(t.assigned_, r) ? i.concat(r) : void 0, l = r0(e, o, s);
    if (Kne(n, r, l), Fp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (zp(o) && !lO(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    r0(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && o0(e, o);
  }
}
function o0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && yj(t, n);
}
function UCe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Yne(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = bj;
  n && (o = [r], i = Lg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var bj = {
  get(e, t) {
    if (t === na)
      return e;
    const n = Qc(e);
    if (!FS(n, t))
      return HCe(e, n, t);
    const r = n[t];
    return e.finalized_ || !zp(r) ? r : r === iL(e.base_, t) ? (sL(e), e.copy_[t] = VS(r, e)) : r;
  },
  has(e, t) {
    return t in Qc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Qc(e));
  },
  set(e, t, n) {
    const r = Xne(Qc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = iL(Qc(e), t), i = o == null ? void 0 : o[na];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (BCe(n, o) && (n !== void 0 || FS(e.base_, t)))
        return !0;
      sL(e), WS(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return iL(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, sL(e), WS(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Qc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ys(11);
  },
  getPrototypeOf(e) {
    return Dd(e.base_);
  },
  setPrototypeOf() {
    ys(12);
  }
}, Lg = {};
n0(bj, (e, t) => {
  Lg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Lg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ys(13), Lg.set.call(this, e, t, void 0);
};
Lg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ys(14), bj.set.call(this, e[0], t, n, e[0]);
};
function iL(e, t) {
  const n = e[na];
  return (n ? Qc(n) : e)[t];
}
function HCe(e, t, n) {
  var r;
  const o = Xne(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Xne(e, t) {
  if (!(t in e))
    return;
  let n = Dd(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Dd(n);
  }
}
function WS(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && WS(e.parent_));
}
function sL(e) {
  e.copy_ || (e.copy_ = zS(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var WCe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ys(6), r !== void 0 && typeof r != "function" && ys(7);
      let o;
      if (zp(t)) {
        const i = cz(this), a = VS(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? US(i) : HS(i);
        }
        return uz(i, r), pz(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === qne && (o = void 0), this.autoFreeze_ && yj(o, !0), r) {
          const i = [], a = [];
          Up("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ys(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    zp(e) || ys(8), Fp(e) && (e = VCe(e));
    const t = cz(this), n = VS(e, void 0);
    return n[na].isManual_ = !0, HS(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[na];
    (!n || !n.isManual_) && ys(9);
    const { scope_: r } = n;
    return uz(r, t), pz(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Up("Patches").applyPatches_;
    return Fp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function VS(e, t) {
  const n = sO(e) ? Up("MapSet").proxyMap_(e, t) : aO(e) ? Up("MapSet").proxySet_(e, t) : UCe(e, t);
  return (t ? t.scope_ : Yne()).drafts_.push(n), n;
}
function VCe(e) {
  return Fp(e) || ys(10, e), Jne(e);
}
function Jne(e) {
  if (!zp(e) || lO(e))
    return e;
  const t = e[na];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = zS(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = zS(e, !0);
  return n0(n, (r, o) => {
    Kne(n, r, Jne(o));
  }), t && (t.finalized_ = !1), n;
}
var ra = new WCe(), wj = ra.produce;
ra.produceWithPatches.bind(
  ra
);
ra.setAutoFreeze.bind(ra);
ra.setUseStrictShallowCopy.bind(ra);
ra.applyPatches.bind(ra);
var fz = ra.createDraft.bind(ra), hz = ra.finishDraft.bind(ra), Xe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Xe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Xe.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Xe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Xe.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Xe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Xe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Xe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Xe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Xe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Xe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Xe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Xe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Xe.isAncestor(t, e) && !Xe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Xe.equals(i, r) || Xe.endsBefore(i, r) || Xe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Xe.equals(a, r) || Xe.isAncestor(a, r))
          return null;
        Xe.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Xe.equals(s, r) || Xe.endsBefore(s, r) ? r[s.length - 1] -= 1 : Xe.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Xe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Xe.endsBefore(u, r) ? r[u.length - 1] += 1 : Xe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Xe.equals(p, d))
          return r;
        if (Xe.isAncestor(p, r) || Xe.equals(p, r)) {
          var g = d.slice();
          return Xe.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Xe.isSibling(p, d) && (Xe.isAncestor(d, r) || Xe.equals(d, r)) ? Xe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Xe.endsBefore(d, r) || Xe.equals(d, r) || Xe.isAncestor(d, r) ? (Xe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Xe.endsBefore(p, r) && (Xe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Pg(e) {
  "@babel/helpers - typeof";
  return Pg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Pg(e);
}
function $Ce(e, t) {
  if (Pg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Pg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function ZCe(e) {
  var t = $Ce(e, "string");
  return Pg(t) === "symbol" ? t : String(t);
}
function Hd(e, t, n) {
  return t = ZCe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function gz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gz(Object(n), !0).forEach(function(r) {
      Hd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qCe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = jt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Jt.points(t))
          t[l] = Gr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = jt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [y, b] of Jt.points(t))
          t[b] = Gr.transform(y, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = jt.get(e, E), M = Xe.previous(E), O = jt.get(e, M), v = jt.parent(e, E), x = E[E.length - 1];
      if (Ko.isText(w) && Ko.isText(O))
        O.text += w.text;
      else if (!Ko.isText(w) && !Ko.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Is.stringify(w), " ").concat(Is.stringify(O)));
      if (v.children.splice(x, 1), t)
        for (var [_, z] of Jt.points(t))
          t[z] = Gr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (Xe.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = jt.get(e, L), V = jt.parent(e, L), Z = L[L.length - 1];
      V.children.splice(Z, 1);
      var H = Xe.transform(L, n), $ = jt.get(e, Xe.parent(H)), K = H[H.length - 1];
      if ($.children.splice(K, 0, R), t)
        for (var [X, Q] of Jt.points(t))
          t[Q] = Gr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = jt.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [F, S] of Jt.points(t)) {
          var W = Gr.transform(F, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var C = void 0, I = void 0;
            for (var [U, T] of jt.texts(e))
              if (Xe.compare(T, J) === -1)
                C = [U, T];
              else {
                I = [U, T];
                break;
              }
            var q = !1;
            C && I && (Xe.equals(I[1], J) ? q = !Xe.hasPrevious(I[1]) : q = Xe.common(C[1], J).length < Xe.common(I[1], J).length), C && !q ? (F.path = C[1], F.offset = C[0].text.length) : I ? (F.path = I[1], F.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: j,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = jt.leaf(e, j), he = le.text.slice(0, Y), oe = le.text.slice(Y + B.length);
      if (le.text = he + oe, t)
        for (var [Pe, Ue] of Jt.points(t))
          t[Ue] = Gr.transform(Pe, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: _e,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = jt.get(e, Ze);
      for (var ye in rt) {
        if (ye === "children" || ye === "text")
          throw new Error('Cannot set the "'.concat(ye, '" property of nodes!'));
        var Ge = rt[ye];
        Ge == null ? delete Ve[ye] : Ve[ye] = Ge;
      }
      for (var ct in _e)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ve
      } = n;
      if (ve == null)
        t = ve;
      else {
        if (t == null) {
          if (!Jt.isRange(ve))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Is.stringify(ve), " when there is no current selection."));
          t = Cf({}, ve);
        }
        for (var Oe in ve) {
          var qe = ve[Oe];
          if (qe == null) {
            if (Oe === "anchor" || Oe === "focus")
              throw new Error('Cannot remove the "'.concat(Oe, '" selection property'));
            delete t[Oe];
          } else
            t[Oe] = qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Se,
        properties: st
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var xe = jt.get(e, ze), xt = jt.parent(e, ze), at = ze[ze.length - 1], lt;
      if (Ko.isText(xe)) {
        var pt = xe.text.slice(0, Se), Ot = xe.text.slice(Se);
        xe.text = pt, lt = Cf(Cf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = xe.children.slice(0, Se), ft = xe.children.slice(Se);
        xe.children = dt, lt = Cf(Cf({}, st), {}, {
          children: ft
        });
      }
      if (xt.children.splice(at + 1, 0, lt), t)
        for (var [ot, He] of Jt.points(t))
          t[He] = Gr.transform(ot, n);
      break;
    }
  }
  return t;
}, GCe = {
  transform(e, t) {
    e.children = fz(e.children);
    var n = e.selection && fz(e.selection);
    try {
      n = qCe(e, n, t);
    } finally {
      e.children = hz(e.children), n ? e.selection = Fp(n) ? hz(n) : n : e.selection = null;
    }
  }
}, KCe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, YCe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Qne = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Gi(r) && Gi(o)) {
      if (!Qne(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function XCe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function _g(e, t) {
  if (e == null) return {};
  var n = XCe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var JCe = ["anchor", "focus"];
function mz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function QCe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mz(Object(n), !0).forEach(function(r) {
      Hd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Jt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Jt.edges(e);
    return t;
  },
  equals(e, t) {
    return Gr.equals(e.anchor, t.anchor) && Gr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Jt.isRange(t)) {
      if (Jt.includes(e, t.anchor) || Jt.includes(e, t.focus))
        return !0;
      var [n, r] = Jt.edges(e), [o, i] = Jt.edges(t);
      return Gr.isBefore(n, o) && Gr.isAfter(r, i);
    }
    var [a, s] = Jt.edges(e), l = !1, u = !1;
    return Gr.isPoint(t) ? (l = Gr.compare(t, a) >= 0, u = Gr.compare(t, s) <= 0) : (l = Xe.compare(t, a.path) >= 0, u = Xe.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = _g(e, JCe), [r, o] = Jt.edges(e), [i, a] = Jt.edges(t), s = Gr.isBefore(r, i) ? i : r, l = Gr.isBefore(o, a) ? o : a;
    return Gr.isBefore(l, s) ? null : QCe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Gr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Gr.equals(t, n);
  },
  isExpanded(e) {
    return !Jt.isCollapsed(e);
  },
  isForward(e) {
    return !Jt.isBackward(e);
  },
  isRange(e) {
    return Gi(e) && Gr.isPoint(e.anchor) && Gr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Jt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return wj(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Jt.isCollapsed(r);
        Jt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Jt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Gr.transform(r.anchor, t, {
        affinity: i
      }), u = Gr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, vz = (e) => Gi(e) && jt.isNodeList(e.children) && !Cr.isEditor(e), Tl = {
  isAncestor(e) {
    return Gi(e) && jt.isNodeList(e.children);
  },
  isElement: vz,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Tl.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return vz(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, exe = ["children"], txe = ["text"], yz = /* @__PURE__ */ new WeakMap(), jt = {
  ancestor(e, t) {
    var n = jt.get(e, t);
    if (Ko.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Is.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Xe.ancestors(t, n)) {
        var o = jt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Ko.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Is.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Is.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = jt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = jt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Xe.common(t, n), o = jt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = jt.get(e, t);
    if (Cr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Is.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of jt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of jt.nodes(e, t))
        Tl.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Tl.isAncestor(e)) {
      var t = _g(e, exe);
      return t;
    } else {
      var t = _g(e, txe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = jt.get(e, n); r && !(Ko.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Ko.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Is.stringify(e)));
    var n = wj({
      children: e.children
    }, (r) => {
      var [o, i] = Jt.edges(t), a = jt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Jt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Jt.includes(t, s)) {
          var l = jt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Xe.equals(s, i.path)) {
          var c = jt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Xe.equals(s, o.path)) {
          var p = jt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Cr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ko.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Is.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ko.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Ko.isText(e) || Tl.isElement(e) || Cr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = yz.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => jt.isNode(r));
    return yz.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = jt.get(e, n); r && !(Ko.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = jt.get(e, t);
    if (!Ko.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Is.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Xe.levels(t, n)) {
        var o = jt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Tl.isElement(e) && Tl.isElementProps(t) && Tl.matches(e, t) || Ko.isText(e) && Ko.isTextProps(t) && Ko.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Xe.isBefore(s, i) : Xe.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Ko.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Xe.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = jt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Xe.next(s);
          if (jt.has(e, c)) {
            s = c, l = jt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Xe.previous(s);
          s = p, l = jt.get(e, s);
          continue;
        }
        s = Xe.parent(s), l = jt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Xe.parent(t), r = jt.get(e, n);
    if (Ko.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Ko.isText(e) ? e.text : e.children.map(jt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of jt.nodes(e, t))
        Ko.isText(n) && (yield [n, r]);
    }();
  }
};
function bz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ro(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bz(Object(n), !0).forEach(function(r) {
      Hd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dh = {
  isNodeOperation(e) {
    return dh.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Gi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Xe.isPath(e.path) && jt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Xe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Xe.isPath(e.path) && Gi(e.properties);
      case "move_node":
        return Xe.isPath(e.path) && Xe.isPath(e.newPath);
      case "remove_node":
        return Xe.isPath(e.path) && jt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Xe.isPath(e.path);
      case "set_node":
        return Xe.isPath(e.path) && Gi(e.properties) && Gi(e.newProperties);
      case "set_selection":
        return e.properties === null && Jt.isRange(e.newProperties) || e.newProperties === null && Jt.isRange(e.properties) || Gi(e.properties) && Gi(e.newProperties);
      case "split_node":
        return Xe.isPath(e.path) && typeof e.position == "number" && Gi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => dh.isOperation(t));
  },
  isSelectionOperation(e) {
    return dh.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return dh.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return ro(ro({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return ro(ro({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return ro(ro({}, e), {}, {
          type: "split_node",
          path: Xe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Xe.equals(t, n))
          return e;
        if (Xe.isSibling(n, t))
          return ro(ro({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Xe.transform(n, e), o = Xe.transform(Xe.next(n), e);
        return ro(ro({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return ro(ro({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return ro(ro({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return ro(ro({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? ro(ro({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? ro(ro({}, e), {}, {
          properties: null,
          newProperties: s
        }) : ro(ro({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return ro(ro({}, e), {}, {
          type: "merge_node",
          path: Xe.next(e.path)
        });
    }
  }
}, wz = /* @__PURE__ */ new WeakMap(), nxe = (e) => {
  var t = wz.get(e);
  if (t !== void 0)
    return t;
  if (!Gi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Gi(e.marks)) && (e.selection === null || Jt.isRange(e.selection)) && jt.isNodeList(e.children) && dh.isOperationList(e.operations);
  return wz.set(e, n), n;
}, Cr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return nxe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function Cz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Cz(Object(n), !0).forEach(function(r) {
      Hd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Cz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Gr = {
  compare(e, t) {
    var n = Xe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Gr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Gr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Xe.equals(e.path, t.path);
  },
  isPoint(e) {
    return Gi(e) && typeof e.offset == "number" && Xe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return wj(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Xe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Xe.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Xe.equals(t.path, i) && (r.offset += t.position), r.path = Xe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Xe.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Xe.equals(t.path, i) || Xe.isAncestor(t.path, i))
            return null;
          r.path = Xe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Xe.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Xe.transform(i, t, xz(xz({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Xe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, Oz = void 0, Is = {
  setScrubber(e) {
    Oz = e;
  },
  stringify(e) {
    return JSON.stringify(e, Oz);
  }
}, rxe = ["text"], oxe = ["anchor", "focus"];
function Ez(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ez(Object(n), !0).forEach(function(r) {
      Hd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ez(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ko = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = _g(i, rxe);
      return a;
    }
    return Qne(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Gi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Ko.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [gl({}, e)];
    for (var r of t) {
      var o = _g(r, oxe), [i, a] = Jt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, y = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = gl(gl({}, f), {}, {
            text: f.text.slice(E)
          }), f = gl(gl({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          y = gl(gl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = gl(gl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), y && s.push(y), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, ixe = (e) => e.selection ? e.selection : e.children.length > 0 ? Cr.end(e, []) : [0], zr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(zr || (zr = {}));
zr.L, zr.L | zr.V | zr.LV | zr.LVT, zr.LV | zr.V, zr.V | zr.T, zr.LVT | zr.T, zr.T, zr.Any, zr.Extend | zr.ZWJ, zr.Any, zr.SpacingMark, zr.Prepend, zr.Any, zr.ZWJ, zr.ExtPict, zr.RI, zr.RI;
var sxe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Cr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = ixe(e)
      } = n;
      if (Xe.isPath(o) && (o = Cr.range(e, o)), Jt.isRange(o))
        if (Jt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Jt.end(o);
          if (!r && Cr.void(e, {
            at: i
          }))
            return;
          var a = Jt.start(o), s = Cr.pointRef(e, a), l = Cr.pointRef(e, i);
          i0.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, i0.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Cr.void(e, {
        at: o
      }) || Cr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function kz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kz(Object(n), !0).forEach(function(r) {
      Hd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var i0 = Jv(Jv(Jv(Jv({}, GCe), KCe), YCe), sxe), ere = {}, Cj = {}, xj = {}, sd = {}, Oj = {}, Ej = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Ej);
var un = {}, uc = Mr && Mr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Dh = Mr && Mr.__assign || function() {
  return Dh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Dh.apply(this, arguments);
};
Object.defineProperty(un, "__esModule", { value: !0 });
un.cloneNode = un.hasChildren = un.isDocument = un.isDirective = un.isComment = un.isText = un.isCDATA = un.isTag = un.Element = un.Document = un.CDATA = un.NodeWithChildren = un.ProcessingInstruction = un.Comment = un.Text = un.DataNode = un.Node = void 0;
var Ps = Ej, kj = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Lj(this, t);
    }, e;
  }()
);
un.Node = kj;
var uO = (
  /** @class */
  function(e) {
    uc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(kj)
);
un.DataNode = uO;
var tre = (
  /** @class */
  function(e) {
    uc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ps.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uO)
);
un.Text = tre;
var nre = (
  /** @class */
  function(e) {
    uc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ps.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uO)
);
un.Comment = nre;
var rre = (
  /** @class */
  function(e) {
    uc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ps.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uO)
);
un.ProcessingInstruction = rre;
var cO = (
  /** @class */
  function(e) {
    uc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(kj)
);
un.NodeWithChildren = cO;
var ore = (
  /** @class */
  function(e) {
    uc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ps.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cO)
);
un.CDATA = ore;
var ire = (
  /** @class */
  function(e) {
    uc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ps.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cO)
);
un.Document = ire;
var sre = (
  /** @class */
  function(e) {
    uc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ps.ElementType.Script : n === "style" ? Ps.ElementType.Style : Ps.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cO)
);
un.Element = sre;
function are(e) {
  return (0, Ps.isTag)(e);
}
un.isTag = are;
function lre(e) {
  return e.type === Ps.ElementType.CDATA;
}
un.isCDATA = lre;
function ure(e) {
  return e.type === Ps.ElementType.Text;
}
un.isText = ure;
function cre(e) {
  return e.type === Ps.ElementType.Comment;
}
un.isComment = cre;
function pre(e) {
  return e.type === Ps.ElementType.Directive;
}
un.isDirective = pre;
function dre(e) {
  return e.type === Ps.ElementType.Root;
}
un.isDocument = dre;
function axe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
un.hasChildren = axe;
function Lj(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (ure(e))
    n = new tre(e.data);
  else if (cre(e))
    n = new nre(e.data);
  else if (are(e)) {
    var r = t ? aL(e.children) : [], o = new sre(e.name, Dh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Dh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Dh({}, e["x-attribsPrefix"])), n = o;
  } else if (lre(e)) {
    var r = t ? aL(e.children) : [], i = new ore(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (dre(e)) {
    var r = t ? aL(e.children) : [], a = new ire(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (pre(e)) {
    var s = new rre(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
un.cloneNode = Lj;
function aL(e) {
  for (var t = e.map(function(r) {
    return Lj(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Mr && Mr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Mr && Mr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Ej, o = un;
  n(un, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(Oj);
var fre = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(fre);
Object.defineProperty(sd, "__esModule", { value: !0 });
sd.formatAttributes = hre;
sd.escapeSpecialCharacters = cxe;
sd.revertEscapedCharacters = gre;
sd.formatDOM = mre;
var Qv = Oj, Sg = fre;
function lxe(e) {
  return Sg.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function hre(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function uxe(e) {
  e = e.toLowerCase();
  var t = lxe(e);
  return t || e;
}
function cxe(e) {
  return e.replace(Sg.CARRIAGE_RETURN_REGEX, Sg.CARRIAGE_RETURN_PLACEHOLDER);
}
function gre(e) {
  return e.replace(Sg.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Sg.CARRIAGE_RETURN);
}
function mre(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = uxe(s.nodeName);
        o = new Qv.Element(l, hre(s.attributes)), o.children = mre(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Qv.Text(gre(s.nodeValue));
        break;
      case 8:
        o = new Qv.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Qv.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(xj, "__esModule", { value: !0 });
xj.default = gxe;
var pxe = sd, Lz = "html", Pz = "head", ey = "body", dxe = /<([a-zA-Z]+[0-9]?)/, _z = /<head[^]*>/i, Sz = /<body[^]*>/i, s0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, $S = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, Mz = typeof window == "object" && window.DOMParser;
if (typeof Mz == "function") {
  var fxe = new Mz(), hxe = "text/html";
  $S = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), fxe.parseFromString(e, hxe);
  }, s0 = $S;
}
if (typeof document == "object" && document.implementation) {
  var ty = document.implementation.createHTMLDocument();
  s0 = function(e, t) {
    if (t) {
      var n = ty.documentElement.querySelector(t);
      return n && (n.innerHTML = e), ty;
    }
    return ty.documentElement.innerHTML = e, ty;
  };
}
var ny = typeof document == "object" && document.createElement("template"), ZS;
ny && ny.content && (ZS = function(e) {
  return ny.innerHTML = e, ny.content.childNodes;
});
function gxe(e) {
  var t, n;
  e = (0, pxe.escapeSpecialCharacters)(e);
  var r = e.match(dxe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case Lz: {
      var i = $S(e);
      if (!_z.test(e)) {
        var a = i.querySelector(Pz);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!Sz.test(e)) {
        var a = i.querySelector(ey);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(Lz);
    }
    case Pz:
    case ey: {
      var s = s0(e).querySelectorAll(o);
      return Sz.test(e) && _z.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (ZS)
        return ZS(e);
      var a = s0(e, ey).querySelector(ey);
      return a.childNodes;
    }
  }
}
var mxe = Mr && Mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Cj, "__esModule", { value: !0 });
Cj.default = wxe;
var vxe = mxe(xj), yxe = sd, bxe = /<(![a-zA-Z\s]+)>/;
function wxe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(bxe), n = t ? t[1] : void 0;
  return (0, yxe.formatDOM)((0, vxe.default)(e), null, n);
}
var pO = {}, Sa = {}, dO = {}, Cxe = 0;
dO.SAME = Cxe;
var xxe = 1;
dO.CAMELCASE = xxe;
dO.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const vre = 0, cc = 1, fO = 2, hO = 3, Pj = 4, yre = 5, bre = 6;
function Oxe(e) {
  return zi.hasOwnProperty(e) ? zi[e] : null;
}
function as(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === fO || t === hO || t === Pj, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const zi = {}, Exe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Exe.forEach((e) => {
  zi[e] = new as(
    e,
    vre,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  zi[e] = new as(
    e,
    cc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  zi[e] = new as(
    e,
    fO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  zi[e] = new as(
    e,
    fO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  zi[e] = new as(
    e,
    hO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  zi[e] = new as(
    e,
    hO,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  zi[e] = new as(
    e,
    Pj,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  zi[e] = new as(
    e,
    bre,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  zi[e] = new as(
    e,
    yre,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const _j = /[\-\:]([a-z])/g, Sj = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(_j, Sj);
  zi[t] = new as(
    t,
    cc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(_j, Sj);
  zi[t] = new as(
    t,
    cc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(_j, Sj);
  zi[t] = new as(
    t,
    cc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  zi[e] = new as(
    e,
    cc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const kxe = "xlinkHref";
zi[kxe] = new as(
  "xlinkHref",
  cc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  zi[e] = new as(
    e,
    cc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Lxe,
  SAME: Pxe,
  possibleStandardNames: Dz
} = dO, _xe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Sxe = _xe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Mxe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Sxe + "]*$")
), Dxe = Object.keys(
  Dz
).reduce((e, t) => {
  const n = Dz[t];
  return n === Pxe ? e[t] = t : n === Lxe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Sa.BOOLEAN = hO;
Sa.BOOLEANISH_STRING = fO;
Sa.NUMERIC = yre;
Sa.OVERLOADED_BOOLEAN = Pj;
Sa.POSITIVE_NUMERIC = bre;
Sa.RESERVED = vre;
Sa.STRING = cc;
Sa.getPropertyInfo = Oxe;
Sa.isCustomAttribute = Mxe;
Sa.possibleStandardNames = Dxe;
var Mj = {}, Dj = {}, Tz = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Txe = /\n/g, jxe = /^\s*/, Axe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Ixe = /^:\s*/, Bxe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Rxe = /^[;\s]*/, Nxe = /^\s+|\s+$/g, Fxe = `
`, jz = "/", Az = "*", up = "", zxe = "comment", Uxe = "declaration", Hxe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var y = f.match(Txe);
    y && (n += y.length);
    var b = f.lastIndexOf(Fxe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(y) {
      return y.position = new a(f), u(), y;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var y = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (y.reason = f, y.filename = t.source, y.line = n, y.column = r, y.source = e, !t.silent) throw y;
  }
  function l(f) {
    var y = f.exec(e);
    if (y) {
      var b = y[0];
      return o(b), e = e.slice(b.length), y;
    }
  }
  function u() {
    l(jxe);
  }
  function c(f) {
    var y;
    for (f = f || []; y = p(); )
      y !== !1 && f.push(y);
    return f;
  }
  function p() {
    var f = i();
    if (!(jz != e.charAt(0) || Az != e.charAt(1))) {
      for (var y = 2; up != e.charAt(y) && (Az != e.charAt(y) || jz != e.charAt(y + 1)); )
        ++y;
      if (y += 2, up === e.charAt(y - 1))
        return s("End of comment missing");
      var b = e.slice(2, y - 2);
      return r += 2, o(b), e = e.slice(y), r += 2, f({
        type: zxe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), y = l(Axe);
    if (y) {
      if (p(), !l(Ixe)) return s("property missing ':'");
      var b = l(Bxe), E = f({
        type: Uxe,
        property: Iz(y[0].replace(Tz, up)),
        value: b ? Iz(b[0].replace(Tz, up)) : up
      });
      return l(Rxe), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var y; y = d(); )
      y !== !1 && (f.push(y), c(f));
    return f;
  }
  return u(), g();
};
function Iz(e) {
  return e ? e.replace(Nxe, up) : up;
}
var Wxe = Mr && Mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Dj, "__esModule", { value: !0 });
Dj.default = $xe;
var Vxe = Wxe(Hxe);
function $xe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Vxe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var gO = {};
Object.defineProperty(gO, "__esModule", { value: !0 });
gO.camelCase = void 0;
var Zxe = /^--[a-zA-Z0-9_-]+$/, qxe = /-([a-z])/g, Gxe = /^[^-]+$/, Kxe = /^-(webkit|moz|ms|o|khtml)-/, Yxe = /^-(ms)-/, Xxe = function(e) {
  return !e || Gxe.test(e) || Zxe.test(e);
}, Jxe = function(e, t) {
  return t.toUpperCase();
}, Bz = function(e, t) {
  return "".concat(t, "-");
}, Qxe = function(e, t) {
  return t === void 0 && (t = {}), Xxe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Yxe, Bz) : e = e.replace(Kxe, Bz), e.replace(qxe, Jxe));
};
gO.camelCase = Qxe;
var eOe = Mr && Mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, tOe = eOe(Dj), nOe = gO;
function qS(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, tOe.default)(e, function(r, o) {
    r && o && (n[(0, nOe.camelCase)(r, t)] = o);
  }), n;
}
qS.default = qS;
var rOe = qS;
(function(e) {
  var t = Mr && Mr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(rOe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Mj);
Object.defineProperty(pO, "__esModule", { value: !0 });
pO.default = aOe;
var fh = Sa, Rz = Mj, oOe = ["checked", "value"], iOe = ["input", "select", "textarea"], sOe = {
  reset: !0,
  submit: !0
};
function aOe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && sOe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, fh.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = Nz(a);
    if (s) {
      var l = (0, fh.getPropertyInfo)(s);
      switch (oOe.includes(s) && iOe.includes(t) && !r && (s = Nz("default" + a)), n[s] = i, l && l.type) {
        case fh.BOOLEAN:
          n[s] = !0;
          break;
        case fh.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    Rz.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, Rz.setStyleProp)(e.style, n), n;
}
function Nz(e) {
  return fh.possibleStandardNames[e];
}
var Tj = {}, lOe = Mr && Mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Tj, "__esModule", { value: !0 });
Tj.default = wre;
var lL = we, uOe = lOe(pO), Th = Mj, cOe = {
  cloneElement: lL.cloneElement,
  createElement: lL.createElement,
  isValidElement: lL.isValidElement
};
function wre(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Th.returnFirstArg, i = t.library || cOe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Th.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, y = {};
    pOe(f) ? ((0, Th.setStyleProp)(f.attribs.style, f.attribs), y = f.attribs) : f.attribs && (y = (0, uOe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (y.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? y.defaultValue = p.children[0].data : p.children && p.children.length && (b = wre(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (y.key = c), n.push(o(s(p.name, y, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function pOe(e) {
  return Th.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Th.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Mr && Mr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(Cj);
  e.htmlToDOM = n.default;
  var r = t(pO);
  e.attributesToProps = r.default;
  var o = t(Tj);
  e.domToReact = o.default;
  var i = Oj;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(ere);
const dOe = /* @__PURE__ */ DCe(ere);
dOe.default;
var Dr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function fOe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var GS = { exports: {} }, xf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Fz;
function hOe() {
  if (Fz) return xf;
  Fz = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return xf.Fragment = n, xf.jsx = a, xf.jsxs = a, xf;
}
var ry = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zz;
function gOe() {
  return zz || (zz = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, y = "@@iterator";
    function b(m) {
      if (m === null || typeof m != "object")
        return null;
      var A = f && m[f] || m[y];
      return typeof A == "function" ? A : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(m) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), ee = 1; ee < A; ee++)
          G[ee - 1] = arguments[ee];
        M("error", m, G);
      }
    }
    function M(m, A, G) {
      {
        var ee = E.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[m], console, ue);
      }
    }
    var O = !1, v = !1, x = !1, _ = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function N(m) {
      return !!(typeof m == "string" || typeof m == "function" || m === r || m === i || z || m === o || m === u || m === c || _ || m === g || O || v || x || typeof m == "object" && m !== null && (m.$$typeof === d || m.$$typeof === p || m.$$typeof === a || m.$$typeof === s || m.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      m.$$typeof === L || m.getModuleId !== void 0));
    }
    function R(m, A, G) {
      var ee = m.displayName;
      if (ee)
        return ee;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(m) {
      return m.displayName || "Context";
    }
    function Z(m) {
      if (m == null)
        return null;
      if (typeof m.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof m == "function")
        return m.displayName || m.name || null;
      if (typeof m == "string")
        return m;
      switch (m) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case s:
            var A = m;
            return V(A) + ".Consumer";
          case a:
            var G = m;
            return V(G._context) + ".Provider";
          case l:
            return R(m, m.render, "ForwardRef");
          case p:
            var ee = m.displayName || null;
            return ee !== null ? ee : Z(m.type) || "Memo";
          case d: {
            var ae = m, ue = ae._payload, se = ae._init;
            try {
              return Z(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, $ = 0, K, X, Q, J, P, D, F;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if ($ === 0) {
          K = console.log, X = console.info, Q = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, F = console.groupEnd;
          var m = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: m,
            log: m,
            warn: m,
            error: m,
            group: m,
            groupCollapsed: m,
            groupEnd: m
          });
        }
        $++;
      }
    }
    function C() {
      {
        if ($--, $ === 0) {
          var m = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, m, {
              value: K
            }),
            info: H({}, m, {
              value: X
            }),
            warn: H({}, m, {
              value: Q
            }),
            error: H({}, m, {
              value: J
            }),
            group: H({}, m, {
              value: P
            }),
            groupCollapsed: H({}, m, {
              value: D
            }),
            groupEnd: H({}, m, {
              value: F
            })
          });
        }
        $ < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = E.ReactCurrentDispatcher, U;
    function T(m, A, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            U = ee && ee[1] || "";
          }
        return `
` + U + m;
      }
    }
    var q = !1, j;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      j = new Y();
    }
    function B(m, A) {
      if (!m || q)
        return "";
      {
        var G = j.get(m);
        if (G !== void 0)
          return G;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Ee) {
              ee = Ee;
            }
            Reflect.construct(m, [], se);
          } else {
            try {
              se.call();
            } catch (Ee) {
              ee = Ee;
            }
            m.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ee) {
            ee = Ee;
          }
          m();
        }
      } catch (Ee) {
        if (Ee && ee && typeof Ee.stack == "string") {
          for (var ie = Ee.stack.split(`
`), be = ee.stack.split(`
`), de = ie.length - 1, fe = be.length - 1; de >= 1 && fe >= 0 && ie[de] !== be[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== be[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== be[fe]) {
                    var Fe = `
` + ie[de].replace(" at new ", " at ");
                    return m.displayName && Fe.includes("<anonymous>") && (Fe = Fe.replace("<anonymous>", m.displayName)), typeof m == "function" && j.set(m, Fe), Fe;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, C(), Error.prepareStackTrace = ae;
      }
      var Lt = m ? m.displayName || m.name : "", bt = Lt ? T(Lt) : "";
      return typeof m == "function" && j.set(m, bt), bt;
    }
    function le(m, A, G) {
      return B(m, !1);
    }
    function he(m) {
      var A = m.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(m, A, G) {
      if (m == null)
        return "";
      if (typeof m == "function")
        return B(m, he(m));
      if (typeof m == "string")
        return T(m);
      switch (m) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case l:
            return le(m.render);
          case p:
            return oe(m.type, A, G);
          case d: {
            var ee = m, ae = ee._payload, ue = ee._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Pe = Object.prototype.hasOwnProperty, Ue = {}, Ze = E.ReactDebugCurrentFrame;
    function _e(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        Ze.setExtraStackFrame(G);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(m, A, G, ee, ae) {
      {
        var ue = Function.call.bind(Pe);
        for (var se in m)
          if (ue(m, se)) {
            var ie = void 0;
            try {
              if (typeof m[se] != "function") {
                var be = Error((ee || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof m[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw be.name = "Invariant Violation", be;
              }
              ie = m[se](A, se, ee, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (_e(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", G, se, typeof ie), _e(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, _e(ae), w("Failed %s type: %s", G, ie.message), _e(null));
          }
      }
    }
    var Ve = Array.isArray;
    function ye(m) {
      return Ve(m);
    }
    function Ge(m) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && m[Symbol.toStringTag] || m.constructor.name || "Object";
        return G;
      }
    }
    function ct(m) {
      try {
        return ve(m), !1;
      } catch {
        return !0;
      }
    }
    function ve(m) {
      return "" + m;
    }
    function Oe(m) {
      if (ct(m))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ge(m)), ve(m);
    }
    var qe = E.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Se, st;
    function xe(m) {
      if (Pe.call(m, "ref")) {
        var A = Object.getOwnPropertyDescriptor(m, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.ref !== void 0;
    }
    function xt(m) {
      if (Pe.call(m, "key")) {
        var A = Object.getOwnPropertyDescriptor(m, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.key !== void 0;
    }
    function at(m, A) {
      typeof m.ref == "string" && qe.current;
    }
    function lt(m, A) {
      {
        var G = function() {
          Se || (Se = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function pt(m, A) {
      {
        var G = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(m, A, G, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: m,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function dt(m, A, G, ee, ae) {
      {
        var ue, se = {}, ie = null, be = null;
        G !== void 0 && (Oe(G), ie = "" + G), xt(A) && (Oe(A.key), ie = "" + A.key), xe(A) && (be = A.ref, at(A));
        for (ue in A)
          Pe.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (m && m.defaultProps) {
          var de = m.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || be) {
          var fe = typeof m == "function" ? m.displayName || m.name || "Unknown" : m;
          ie && lt(se, fe), be && pt(se, fe);
        }
        return Ot(m, ie, be, ae, ee, qe.current, se);
      }
    }
    var ft = E.ReactCurrentOwner, ot = E.ReactDebugCurrentFrame;
    function He(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        ot.setExtraStackFrame(G);
      } else
        ot.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(m) {
      return typeof m == "object" && m !== null && m.$$typeof === t;
    }
    function gt() {
      {
        if (ft.current) {
          var m = Z(ft.current.type);
          if (m)
            return `

Check the render method of \`` + m + "`.";
        }
        return "";
      }
    }
    function St(m) {
      return "";
    }
    var mt = {};
    function Mt(m) {
      {
        var A = gt();
        if (!A) {
          var G = typeof m == "string" ? m : m.displayName || m.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function vt(m, A) {
      {
        if (!m._store || m._store.validated || m.key != null)
          return;
        m._store.validated = !0;
        var G = Mt(A);
        if (mt[G])
          return;
        mt[G] = !0;
        var ee = "";
        m && m._owner && m._owner !== ft.current && (ee = " It was passed a child from " + Z(m._owner.type) + "."), He(m), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ee), He(null);
      }
    }
    function Pt(m, A) {
      {
        if (typeof m != "object")
          return;
        if (ye(m))
          for (var G = 0; G < m.length; G++) {
            var ee = m[G];
            kt(ee) && vt(ee, A);
          }
        else if (kt(m))
          m._store && (m._store.validated = !0);
        else if (m) {
          var ae = b(m);
          if (typeof ae == "function" && ae !== m.entries)
            for (var ue = ae.call(m), se; !(se = ue.next()).done; )
              kt(se.value) && vt(se.value, A);
        }
      }
    }
    function jn(m) {
      {
        var A = m.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var ee = Z(A);
          rt(G, m.props, "prop", ee, m);
        } else if (A.PropTypes !== void 0 && !Et) {
          Et = !0;
          var ae = Z(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(m) {
      {
        for (var A = Object.keys(m.props), G = 0; G < A.length; G++) {
          var ee = A[G];
          if (ee !== "children" && ee !== "key") {
            He(m), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), He(null);
            break;
          }
        }
        m.ref !== null && (He(m), w("Invalid attribute `ref` supplied to `React.Fragment`."), He(null));
      }
    }
    var te = {};
    function Rr(m, A, G, ee, ae, ue) {
      {
        var se = N(m);
        if (!se) {
          var ie = "";
          (m === void 0 || typeof m == "object" && m !== null && Object.keys(m).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var be = St();
          be ? ie += be : ie += gt();
          var de;
          m === null ? de = "null" : ye(m) ? de = "array" : m !== void 0 && m.$$typeof === t ? (de = "<" + (Z(m.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof m, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = dt(m, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Fe = A.children;
          if (Fe !== void 0)
            if (ee)
              if (ye(Fe)) {
                for (var Lt = 0; Lt < Fe.length; Lt++)
                  Pt(Fe[Lt], m);
                Object.freeze && Object.freeze(Fe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Pt(Fe, m);
        }
        if (Pe.call(A, "key")) {
          var bt = Z(m), Ee = Object.keys(A).filter(function(_i) {
            return _i !== "key";
          }), An = Ee.length > 0 ? "{key: someKey, " + Ee.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!te[bt + An]) {
            var Pi = Ee.length > 0 ? "{" + Ee.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, An, bt, Pi, bt), te[bt + An] = !0;
          }
        }
        return m === r ? yt(fe) : jn(fe), fe;
      }
    }
    function Oi(m, A, G) {
      return Rr(m, A, G, !0);
    }
    function Ei(m, A, G) {
      return Rr(m, A, G, !1);
    }
    var ki = Ei, Li = Oi;
    ry.Fragment = r, ry.jsx = ki, ry.jsxs = Li;
  }()), ry;
}
process.env.NODE_ENV === "production" ? GS.exports = hOe() : GS.exports = gOe();
var Ti = GS.exports;
We({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Uz(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Ki(e) {
  var t, n;
  return Uz(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(Uz(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Cre = Symbol.for("immer-nothing"), Hz = Symbol.for("immer-draftable"), oa = Symbol.for("immer-state"), mOe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function bs(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = mOe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Td = Object.getPrototypeOf;
function Hp(e) {
  return !!e && !!e[oa];
}
function Wp(e) {
  var t;
  return e ? xre(e) || Array.isArray(e) || !!e[Hz] || !!((t = e.constructor) != null && t[Hz]) || vO(e) || yO(e) : !1;
}
var vOe = Object.prototype.constructor.toString();
function xre(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Td(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === vOe;
}
function a0(e, t) {
  mO(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function mO(e) {
  const t = e[oa];
  return t ? t.type_ : Array.isArray(e) ? 1 : vO(e) ? 2 : yO(e) ? 3 : 0;
}
function KS(e, t) {
  return mO(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Ore(e, t, n) {
  const r = mO(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function yOe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function vO(e) {
  return e instanceof Map;
}
function yO(e) {
  return e instanceof Set;
}
function ep(e) {
  return e.copy_ || e.base_;
}
function YS(e, t) {
  if (vO(e))
    return new Map(e);
  if (yO(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = xre(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[oa];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Td(e), r);
  } else {
    const r = Td(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function jj(e, t = !1) {
  return bO(e) || Hp(e) || !Wp(e) || (mO(e) > 1 && (e.set = e.add = e.clear = e.delete = bOe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => jj(r, !0))), e;
}
function bOe() {
  bs(2);
}
function bO(e) {
  return Object.isFrozen(e);
}
var wOe = {};
function Vp(e) {
  const t = wOe[e];
  return t || bs(0, e), t;
}
var Mg;
function Ere() {
  return Mg;
}
function COe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Wz(e, t) {
  t && (Vp("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function XS(e) {
  JS(e), e.drafts_.forEach(xOe), e.drafts_ = null;
}
function JS(e) {
  e === Mg && (Mg = e.parent_);
}
function Vz(e) {
  return Mg = COe(Mg, e);
}
function xOe(e) {
  const t = e[oa];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function $z(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[oa].modified_ && (XS(t), bs(4)), Wp(e) && (e = l0(t, e), t.parent_ || u0(t, e)), t.patches_ && Vp("Patches").generateReplacementPatches_(
    n[oa].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = l0(t, n, []), XS(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== Cre ? e : void 0;
}
function l0(e, t, n) {
  if (bO(t))
    return t;
  const r = t[oa];
  if (!r)
    return a0(
      t,
      (o, i) => Zz(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return u0(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), a0(
      i,
      (s, l) => Zz(e, r, o, s, l, n, a)
    ), u0(e, o, !1), n && e.patches_ && Vp("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Zz(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && bs(5), Hp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !KS(t.assigned_, r) ? i.concat(r) : void 0, l = l0(e, o, s);
    if (Ore(n, r, l), Hp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Wp(o) && !bO(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    l0(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && u0(e, o);
  }
}
function u0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && jj(t, n);
}
function OOe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Ere(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Aj;
  n && (o = [r], i = Dg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var Aj = {
  get(e, t) {
    if (t === oa)
      return e;
    const n = ep(e);
    if (!KS(n, t))
      return EOe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Wp(r) ? r : r === uL(e.base_, t) ? (cL(e), e.copy_[t] = eM(r, e)) : r;
  },
  has(e, t) {
    return t in ep(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(ep(e));
  },
  set(e, t, n) {
    const r = kre(ep(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = uL(ep(e), t), i = o == null ? void 0 : o[oa];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (yOe(n, o) && (n !== void 0 || KS(e.base_, t)))
        return !0;
      cL(e), QS(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return uL(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, cL(e), QS(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = ep(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    bs(11);
  },
  getPrototypeOf(e) {
    return Td(e.base_);
  },
  setPrototypeOf() {
    bs(12);
  }
}, Dg = {};
a0(Aj, (e, t) => {
  Dg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Dg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && bs(13), Dg.set.call(this, e, t, void 0);
};
Dg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && bs(14), Aj.set.call(this, e[0], t, n, e[0]);
};
function uL(e, t) {
  const n = e[oa];
  return (n ? ep(n) : e)[t];
}
function EOe(e, t, n) {
  var r;
  const o = kre(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function kre(e, t) {
  if (!(t in e))
    return;
  let n = Td(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Td(n);
  }
}
function QS(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && QS(e.parent_));
}
function cL(e) {
  e.copy_ || (e.copy_ = YS(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var kOe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && bs(6), r !== void 0 && typeof r != "function" && bs(7);
      let o;
      if (Wp(t)) {
        const i = Vz(this), a = eM(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? XS(i) : JS(i);
        }
        return Wz(i, r), $z(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === Cre && (o = void 0), this.autoFreeze_ && jj(o, !0), r) {
          const i = [], a = [];
          Vp("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        bs(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Wp(e) || bs(8), Hp(e) && (e = LOe(e));
    const t = Vz(this), n = eM(e, void 0);
    return n[oa].isManual_ = !0, JS(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[oa];
    (!n || !n.isManual_) && bs(9);
    const { scope_: r } = n;
    return Wz(r, t), $z(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Vp("Patches").applyPatches_;
    return Hp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function eM(e, t) {
  const n = vO(e) ? Vp("MapSet").proxyMap_(e, t) : yO(e) ? Vp("MapSet").proxySet_(e, t) : OOe(e, t);
  return (t ? t.scope_ : Ere()).drafts_.push(n), n;
}
function LOe(e) {
  return Hp(e) || bs(10, e), Lre(e);
}
function Lre(e) {
  if (!Wp(e) || bO(e))
    return e;
  const t = e[oa];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = YS(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = YS(e, !0);
  return a0(n, (r, o) => {
    Ore(n, r, Lre(o));
  }), t && (t.finalized_ = !1), n;
}
var ia = new kOe(), Ij = ia.produce;
ia.produceWithPatches.bind(
  ia
);
ia.setAutoFreeze.bind(ia);
ia.setUseStrictShallowCopy.bind(ia);
ia.applyPatches.bind(ia);
var qz = ia.createDraft.bind(ia), Gz = ia.finishDraft.bind(ia), Je = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Je.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Je.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Je.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Je.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Je.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Je.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Je.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Je.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Je.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Je.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Je.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Je.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Je.isAncestor(t, e) && !Je.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Je.equals(i, r) || Je.endsBefore(i, r) || Je.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Je.equals(a, r) || Je.isAncestor(a, r))
          return null;
        Je.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Je.equals(s, r) || Je.endsBefore(s, r) ? r[s.length - 1] -= 1 : Je.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Je.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Je.endsBefore(u, r) ? r[u.length - 1] += 1 : Je.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Je.equals(p, d))
          return r;
        if (Je.isAncestor(p, r) || Je.equals(p, r)) {
          var g = d.slice();
          return Je.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Je.isSibling(p, d) && (Je.isAncestor(d, r) || Je.equals(d, r)) ? Je.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Je.endsBefore(d, r) || Je.equals(d, r) || Je.isAncestor(d, r) ? (Je.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Je.endsBefore(p, r) && (Je.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Tg(e) {
  "@babel/helpers - typeof";
  return Tg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Tg(e);
}
function POe(e, t) {
  if (Tg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Tg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function _Oe(e) {
  var t = POe(e, "string");
  return Tg(t) === "symbol" ? t : String(t);
}
function Wd(e, t, n) {
  return t = _Oe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Kz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Of(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Kz(Object(n), !0).forEach(function(r) {
      Wd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Kz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SOe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = At.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Qt.points(t))
          t[l] = Kr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = At.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [y, b] of Qt.points(t))
          t[b] = Kr.transform(y, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = At.get(e, E), M = Je.previous(E), O = At.get(e, M), v = At.parent(e, E), x = E[E.length - 1];
      if (Yo.isText(w) && Yo.isText(O))
        O.text += w.text;
      else if (!Yo.isText(w) && !Yo.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Bs.stringify(w), " ").concat(Bs.stringify(O)));
      if (v.children.splice(x, 1), t)
        for (var [_, z] of Qt.points(t))
          t[z] = Kr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (Je.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = At.get(e, L), V = At.parent(e, L), Z = L[L.length - 1];
      V.children.splice(Z, 1);
      var H = Je.transform(L, n), $ = At.get(e, Je.parent(H)), K = H[H.length - 1];
      if ($.children.splice(K, 0, R), t)
        for (var [X, Q] of Qt.points(t))
          t[Q] = Kr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = At.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [F, S] of Qt.points(t)) {
          var W = Kr.transform(F, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var C = void 0, I = void 0;
            for (var [U, T] of At.texts(e))
              if (Je.compare(T, J) === -1)
                C = [U, T];
              else {
                I = [U, T];
                break;
              }
            var q = !1;
            C && I && (Je.equals(I[1], J) ? q = !Je.hasPrevious(I[1]) : q = Je.common(C[1], J).length < Je.common(I[1], J).length), C && !q ? (F.path = C[1], F.offset = C[0].text.length) : I ? (F.path = I[1], F.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: j,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = At.leaf(e, j), he = le.text.slice(0, Y), oe = le.text.slice(Y + B.length);
      if (le.text = he + oe, t)
        for (var [Pe, Ue] of Qt.points(t))
          t[Ue] = Kr.transform(Pe, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: _e,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = At.get(e, Ze);
      for (var ye in rt) {
        if (ye === "children" || ye === "text")
          throw new Error('Cannot set the "'.concat(ye, '" property of nodes!'));
        var Ge = rt[ye];
        Ge == null ? delete Ve[ye] : Ve[ye] = Ge;
      }
      for (var ct in _e)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ve
      } = n;
      if (ve == null)
        t = ve;
      else {
        if (t == null) {
          if (!Qt.isRange(ve))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Bs.stringify(ve), " when there is no current selection."));
          t = Of({}, ve);
        }
        for (var Oe in ve) {
          var qe = ve[Oe];
          if (qe == null) {
            if (Oe === "anchor" || Oe === "focus")
              throw new Error('Cannot remove the "'.concat(Oe, '" selection property'));
            delete t[Oe];
          } else
            t[Oe] = qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Se,
        properties: st
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var xe = At.get(e, ze), xt = At.parent(e, ze), at = ze[ze.length - 1], lt;
      if (Yo.isText(xe)) {
        var pt = xe.text.slice(0, Se), Ot = xe.text.slice(Se);
        xe.text = pt, lt = Of(Of({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = xe.children.slice(0, Se), ft = xe.children.slice(Se);
        xe.children = dt, lt = Of(Of({}, st), {}, {
          children: ft
        });
      }
      if (xt.children.splice(at + 1, 0, lt), t)
        for (var [ot, He] of Qt.points(t))
          t[He] = Kr.transform(ot, n);
      break;
    }
  }
  return t;
}, MOe = {
  transform(e, t) {
    e.children = qz(e.children);
    var n = e.selection && qz(e.selection);
    try {
      n = SOe(e, n, t);
    } finally {
      e.children = Gz(e.children), n ? e.selection = Hp(n) ? Gz(n) : n : e.selection = null;
    }
  }
}, DOe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, TOe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Pre = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Ki(r) && Ki(o)) {
      if (!Pre(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function jOe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function jg(e, t) {
  if (e == null) return {};
  var n = jOe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var AOe = ["anchor", "focus"];
function Yz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function IOe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Yz(Object(n), !0).forEach(function(r) {
      Wd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Yz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Qt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Qt.edges(e);
    return t;
  },
  equals(e, t) {
    return Kr.equals(e.anchor, t.anchor) && Kr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Qt.isRange(t)) {
      if (Qt.includes(e, t.anchor) || Qt.includes(e, t.focus))
        return !0;
      var [n, r] = Qt.edges(e), [o, i] = Qt.edges(t);
      return Kr.isBefore(n, o) && Kr.isAfter(r, i);
    }
    var [a, s] = Qt.edges(e), l = !1, u = !1;
    return Kr.isPoint(t) ? (l = Kr.compare(t, a) >= 0, u = Kr.compare(t, s) <= 0) : (l = Je.compare(t, a.path) >= 0, u = Je.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = jg(e, AOe), [r, o] = Qt.edges(e), [i, a] = Qt.edges(t), s = Kr.isBefore(r, i) ? i : r, l = Kr.isBefore(o, a) ? o : a;
    return Kr.isBefore(l, s) ? null : IOe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Kr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Kr.equals(t, n);
  },
  isExpanded(e) {
    return !Qt.isCollapsed(e);
  },
  isForward(e) {
    return !Qt.isBackward(e);
  },
  isRange(e) {
    return Ki(e) && Kr.isPoint(e.anchor) && Kr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Qt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Ij(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Qt.isCollapsed(r);
        Qt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Qt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Kr.transform(r.anchor, t, {
        affinity: i
      }), u = Kr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, Xz = (e) => Ki(e) && At.isNodeList(e.children) && !xr.isEditor(e), jl = {
  isAncestor(e) {
    return Ki(e) && At.isNodeList(e.children);
  },
  isElement: Xz,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => jl.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return Xz(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, BOe = ["children"], ROe = ["text"], Jz = /* @__PURE__ */ new WeakMap(), At = {
  ancestor(e, t) {
    var n = At.get(e, t);
    if (Yo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Bs.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Je.ancestors(t, n)) {
        var o = At.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Yo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Bs.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Bs.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = At.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = At.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Je.common(t, n), o = At.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = At.get(e, t);
    if (xr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Bs.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of At.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of At.nodes(e, t))
        jl.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (jl.isAncestor(e)) {
      var t = jg(e, BOe);
      return t;
    } else {
      var t = jg(e, ROe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = At.get(e, n); r && !(Yo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Yo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Bs.stringify(e)));
    var n = Ij({
      children: e.children
    }, (r) => {
      var [o, i] = Qt.edges(t), a = At.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Qt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Qt.includes(t, s)) {
          var l = At.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Je.equals(s, i.path)) {
          var c = At.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Je.equals(s, o.path)) {
          var p = At.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      xr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Yo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Bs.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Yo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Yo.isText(e) || jl.isElement(e) || xr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = Jz.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => At.isNode(r));
    return Jz.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = At.get(e, n); r && !(Yo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = At.get(e, t);
    if (!Yo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Bs.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Je.levels(t, n)) {
        var o = At.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return jl.isElement(e) && jl.isElementProps(t) && jl.matches(e, t) || Yo.isText(e) && Yo.isTextProps(t) && Yo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Je.isBefore(s, i) : Je.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Yo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Je.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = At.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Je.next(s);
          if (At.has(e, c)) {
            s = c, l = At.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Je.previous(s);
          s = p, l = At.get(e, s);
          continue;
        }
        s = Je.parent(s), l = At.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Je.parent(t), r = At.get(e, n);
    if (Yo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Yo.isText(e) ? e.text : e.children.map(At.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of At.nodes(e, t))
        Yo.isText(n) && (yield [n, r]);
    }();
  }
};
function Qz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qz(Object(n), !0).forEach(function(r) {
      Wd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Qz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hh = {
  isNodeOperation(e) {
    return hh.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Ki(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Je.isPath(e.path) && At.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Je.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Je.isPath(e.path) && Ki(e.properties);
      case "move_node":
        return Je.isPath(e.path) && Je.isPath(e.newPath);
      case "remove_node":
        return Je.isPath(e.path) && At.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Je.isPath(e.path);
      case "set_node":
        return Je.isPath(e.path) && Ki(e.properties) && Ki(e.newProperties);
      case "set_selection":
        return e.properties === null && Qt.isRange(e.newProperties) || e.newProperties === null && Qt.isRange(e.properties) || Ki(e.properties) && Ki(e.newProperties);
      case "split_node":
        return Je.isPath(e.path) && typeof e.position == "number" && Ki(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => hh.isOperation(t));
  },
  isSelectionOperation(e) {
    return hh.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return hh.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return oo(oo({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return oo(oo({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return oo(oo({}, e), {}, {
          type: "split_node",
          path: Je.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Je.equals(t, n))
          return e;
        if (Je.isSibling(n, t))
          return oo(oo({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Je.transform(n, e), o = Je.transform(Je.next(n), e);
        return oo(oo({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return oo(oo({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return oo(oo({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return oo(oo({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? oo(oo({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? oo(oo({}, e), {}, {
          properties: null,
          newProperties: s
        }) : oo(oo({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return oo(oo({}, e), {}, {
          type: "merge_node",
          path: Je.next(e.path)
        });
    }
  }
}, e2 = /* @__PURE__ */ new WeakMap(), NOe = (e) => {
  var t = e2.get(e);
  if (t !== void 0)
    return t;
  if (!Ki(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Ki(e.marks)) && (e.selection === null || Qt.isRange(e.selection)) && At.isNodeList(e.children) && hh.isOperationList(e.operations);
  return e2.set(e, n), n;
}, xr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return NOe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function t2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function n2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? t2(Object(n), !0).forEach(function(r) {
      Wd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : t2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Kr = {
  compare(e, t) {
    var n = Je.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Kr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Kr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Je.equals(e.path, t.path);
  },
  isPoint(e) {
    return Ki(e) && typeof e.offset == "number" && Je.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Ij(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Je.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Je.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Je.equals(t.path, i) && (r.offset += t.position), r.path = Je.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Je.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Je.equals(t.path, i) || Je.isAncestor(t.path, i))
            return null;
          r.path = Je.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Je.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Je.transform(i, t, n2(n2({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Je.transform(i, t, n);
          break;
        }
      }
    });
  }
}, r2 = void 0, Bs = {
  setScrubber(e) {
    r2 = e;
  },
  stringify(e) {
    return JSON.stringify(e, r2);
  }
}, FOe = ["text"], zOe = ["anchor", "focus"];
function o2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ml(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? o2(Object(n), !0).forEach(function(r) {
      Wd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : o2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = jg(i, FOe);
      return a;
    }
    return Pre(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Ki(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Yo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [ml({}, e)];
    for (var r of t) {
      var o = jg(r, zOe), [i, a] = Qt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, y = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = ml(ml({}, f), {}, {
            text: f.text.slice(E)
          }), f = ml(ml({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          y = ml(ml({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = ml(ml({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), y && s.push(y), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, UOe = (e) => e.selection ? e.selection : e.children.length > 0 ? xr.end(e, []) : [0], Ur;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Ur || (Ur = {}));
Ur.L, Ur.L | Ur.V | Ur.LV | Ur.LVT, Ur.LV | Ur.V, Ur.V | Ur.T, Ur.LVT | Ur.T, Ur.T, Ur.Any, Ur.Extend | Ur.ZWJ, Ur.Any, Ur.SpacingMark, Ur.Prepend, Ur.Any, Ur.ZWJ, Ur.ExtPict, Ur.RI, Ur.RI;
var HOe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    xr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = UOe(e)
      } = n;
      if (Je.isPath(o) && (o = xr.range(e, o)), Qt.isRange(o))
        if (Qt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Qt.end(o);
          if (!r && xr.void(e, {
            at: i
          }))
            return;
          var a = Qt.start(o), s = xr.pointRef(e, a), l = xr.pointRef(e, i);
          c0.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, c0.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && xr.void(e, {
        at: o
      }) || xr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function i2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? i2(Object(n), !0).forEach(function(r) {
      Wd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var c0 = oy(oy(oy(oy({}, MOe), DOe), TOe), HOe), _re = {}, Bj = {}, Rj = {}, ad = {}, Nj = {}, Fj = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Fj);
var cn = {}, pc = Dr && Dr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), jh = Dr && Dr.__assign || function() {
  return jh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, jh.apply(this, arguments);
};
Object.defineProperty(cn, "__esModule", { value: !0 });
cn.cloneNode = cn.hasChildren = cn.isDocument = cn.isDirective = cn.isComment = cn.isText = cn.isCDATA = cn.isTag = cn.Element = cn.Document = cn.CDATA = cn.NodeWithChildren = cn.ProcessingInstruction = cn.Comment = cn.Text = cn.DataNode = cn.Node = void 0;
var _s = Fj, zj = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Uj(this, t);
    }, e;
  }()
);
cn.Node = zj;
var wO = (
  /** @class */
  function(e) {
    pc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(zj)
);
cn.DataNode = wO;
var Sre = (
  /** @class */
  function(e) {
    pc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = _s.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wO)
);
cn.Text = Sre;
var Mre = (
  /** @class */
  function(e) {
    pc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = _s.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wO)
);
cn.Comment = Mre;
var Dre = (
  /** @class */
  function(e) {
    pc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = _s.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wO)
);
cn.ProcessingInstruction = Dre;
var CO = (
  /** @class */
  function(e) {
    pc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(zj)
);
cn.NodeWithChildren = CO;
var Tre = (
  /** @class */
  function(e) {
    pc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = _s.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(CO)
);
cn.CDATA = Tre;
var jre = (
  /** @class */
  function(e) {
    pc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = _s.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(CO)
);
cn.Document = jre;
var Are = (
  /** @class */
  function(e) {
    pc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? _s.ElementType.Script : n === "style" ? _s.ElementType.Style : _s.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(CO)
);
cn.Element = Are;
function Ire(e) {
  return (0, _s.isTag)(e);
}
cn.isTag = Ire;
function Bre(e) {
  return e.type === _s.ElementType.CDATA;
}
cn.isCDATA = Bre;
function Rre(e) {
  return e.type === _s.ElementType.Text;
}
cn.isText = Rre;
function Nre(e) {
  return e.type === _s.ElementType.Comment;
}
cn.isComment = Nre;
function Fre(e) {
  return e.type === _s.ElementType.Directive;
}
cn.isDirective = Fre;
function zre(e) {
  return e.type === _s.ElementType.Root;
}
cn.isDocument = zre;
function WOe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
cn.hasChildren = WOe;
function Uj(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (Rre(e))
    n = new Sre(e.data);
  else if (Nre(e))
    n = new Mre(e.data);
  else if (Ire(e)) {
    var r = t ? pL(e.children) : [], o = new Are(e.name, jh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = jh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = jh({}, e["x-attribsPrefix"])), n = o;
  } else if (Bre(e)) {
    var r = t ? pL(e.children) : [], i = new Tre(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (zre(e)) {
    var r = t ? pL(e.children) : [], a = new jre(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (Fre(e)) {
    var s = new Dre(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
cn.cloneNode = Uj;
function pL(e) {
  for (var t = e.map(function(r) {
    return Uj(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Dr && Dr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Dr && Dr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Fj, o = cn;
  n(cn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(Nj);
var Ure = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(Ure);
Object.defineProperty(ad, "__esModule", { value: !0 });
ad.formatAttributes = Hre;
ad.escapeSpecialCharacters = ZOe;
ad.revertEscapedCharacters = Wre;
ad.formatDOM = Vre;
var iy = Nj, Ag = Ure;
function VOe(e) {
  return Ag.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function Hre(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function $Oe(e) {
  e = e.toLowerCase();
  var t = VOe(e);
  return t || e;
}
function ZOe(e) {
  return e.replace(Ag.CARRIAGE_RETURN_REGEX, Ag.CARRIAGE_RETURN_PLACEHOLDER);
}
function Wre(e) {
  return e.replace(Ag.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Ag.CARRIAGE_RETURN);
}
function Vre(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = $Oe(s.nodeName);
        o = new iy.Element(l, Hre(s.attributes)), o.children = Vre(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new iy.Text(Wre(s.nodeValue));
        break;
      case 8:
        o = new iy.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new iy.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(Rj, "__esModule", { value: !0 });
Rj.default = XOe;
var qOe = ad, s2 = "html", a2 = "head", sy = "body", GOe = /<([a-zA-Z]+[0-9]?)/, l2 = /<head[^]*>/i, u2 = /<body[^]*>/i, p0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, tM = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, c2 = typeof window == "object" && window.DOMParser;
if (typeof c2 == "function") {
  var KOe = new c2(), YOe = "text/html";
  tM = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), KOe.parseFromString(e, YOe);
  }, p0 = tM;
}
if (typeof document == "object" && document.implementation) {
  var ay = document.implementation.createHTMLDocument();
  p0 = function(e, t) {
    if (t) {
      var n = ay.documentElement.querySelector(t);
      return n && (n.innerHTML = e), ay;
    }
    return ay.documentElement.innerHTML = e, ay;
  };
}
var ly = typeof document == "object" && document.createElement("template"), nM;
ly && ly.content && (nM = function(e) {
  return ly.innerHTML = e, ly.content.childNodes;
});
function XOe(e) {
  var t, n;
  e = (0, qOe.escapeSpecialCharacters)(e);
  var r = e.match(GOe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case s2: {
      var i = tM(e);
      if (!l2.test(e)) {
        var a = i.querySelector(a2);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!u2.test(e)) {
        var a = i.querySelector(sy);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(s2);
    }
    case a2:
    case sy: {
      var s = p0(e).querySelectorAll(o);
      return u2.test(e) && l2.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (nM)
        return nM(e);
      var a = p0(e, sy).querySelector(sy);
      return a.childNodes;
    }
  }
}
var JOe = Dr && Dr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Bj, "__esModule", { value: !0 });
Bj.default = nEe;
var QOe = JOe(Rj), eEe = ad, tEe = /<(![a-zA-Z\s]+)>/;
function nEe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(tEe), n = t ? t[1] : void 0;
  return (0, eEe.formatDOM)((0, QOe.default)(e), null, n);
}
var xO = {}, Ma = {}, OO = {}, rEe = 0;
OO.SAME = rEe;
var oEe = 1;
OO.CAMELCASE = oEe;
OO.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const $re = 0, dc = 1, EO = 2, kO = 3, Hj = 4, Zre = 5, qre = 6;
function iEe(e) {
  return Ui.hasOwnProperty(e) ? Ui[e] : null;
}
function ls(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === EO || t === kO || t === Hj, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Ui = {}, sEe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
sEe.forEach((e) => {
  Ui[e] = new ls(
    e,
    $re,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Ui[e] = new ls(
    e,
    dc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Ui[e] = new ls(
    e,
    EO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Ui[e] = new ls(
    e,
    EO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Ui[e] = new ls(
    e,
    kO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ui[e] = new ls(
    e,
    kO,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ui[e] = new ls(
    e,
    Hj,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ui[e] = new ls(
    e,
    qre,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Ui[e] = new ls(
    e,
    Zre,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Wj = /[\-\:]([a-z])/g, Vj = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Wj, Vj);
  Ui[t] = new ls(
    t,
    dc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Wj, Vj);
  Ui[t] = new ls(
    t,
    dc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Wj, Vj);
  Ui[t] = new ls(
    t,
    dc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Ui[e] = new ls(
    e,
    dc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const aEe = "xlinkHref";
Ui[aEe] = new ls(
  "xlinkHref",
  dc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Ui[e] = new ls(
    e,
    dc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: lEe,
  SAME: uEe,
  possibleStandardNames: p2
} = OO, cEe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", pEe = cEe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", dEe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + pEe + "]*$")
), fEe = Object.keys(
  p2
).reduce((e, t) => {
  const n = p2[t];
  return n === uEe ? e[t] = t : n === lEe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Ma.BOOLEAN = kO;
Ma.BOOLEANISH_STRING = EO;
Ma.NUMERIC = Zre;
Ma.OVERLOADED_BOOLEAN = Hj;
Ma.POSITIVE_NUMERIC = qre;
Ma.RESERVED = $re;
Ma.STRING = dc;
Ma.getPropertyInfo = iEe;
Ma.isCustomAttribute = dEe;
Ma.possibleStandardNames = fEe;
var $j = {}, Zj = {}, d2 = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, hEe = /\n/g, gEe = /^\s*/, mEe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, vEe = /^:\s*/, yEe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, bEe = /^[;\s]*/, wEe = /^\s+|\s+$/g, CEe = `
`, f2 = "/", h2 = "*", cp = "", xEe = "comment", OEe = "declaration", EEe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var y = f.match(hEe);
    y && (n += y.length);
    var b = f.lastIndexOf(CEe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(y) {
      return y.position = new a(f), u(), y;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var y = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (y.reason = f, y.filename = t.source, y.line = n, y.column = r, y.source = e, !t.silent) throw y;
  }
  function l(f) {
    var y = f.exec(e);
    if (y) {
      var b = y[0];
      return o(b), e = e.slice(b.length), y;
    }
  }
  function u() {
    l(gEe);
  }
  function c(f) {
    var y;
    for (f = f || []; y = p(); )
      y !== !1 && f.push(y);
    return f;
  }
  function p() {
    var f = i();
    if (!(f2 != e.charAt(0) || h2 != e.charAt(1))) {
      for (var y = 2; cp != e.charAt(y) && (h2 != e.charAt(y) || f2 != e.charAt(y + 1)); )
        ++y;
      if (y += 2, cp === e.charAt(y - 1))
        return s("End of comment missing");
      var b = e.slice(2, y - 2);
      return r += 2, o(b), e = e.slice(y), r += 2, f({
        type: xEe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), y = l(mEe);
    if (y) {
      if (p(), !l(vEe)) return s("property missing ':'");
      var b = l(yEe), E = f({
        type: OEe,
        property: g2(y[0].replace(d2, cp)),
        value: b ? g2(b[0].replace(d2, cp)) : cp
      });
      return l(bEe), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var y; y = d(); )
      y !== !1 && (f.push(y), c(f));
    return f;
  }
  return u(), g();
};
function g2(e) {
  return e ? e.replace(wEe, cp) : cp;
}
var kEe = Dr && Dr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Zj, "__esModule", { value: !0 });
Zj.default = PEe;
var LEe = kEe(EEe);
function PEe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, LEe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var LO = {};
Object.defineProperty(LO, "__esModule", { value: !0 });
LO.camelCase = void 0;
var _Ee = /^--[a-zA-Z0-9_-]+$/, SEe = /-([a-z])/g, MEe = /^[^-]+$/, DEe = /^-(webkit|moz|ms|o|khtml)-/, TEe = /^-(ms)-/, jEe = function(e) {
  return !e || MEe.test(e) || _Ee.test(e);
}, AEe = function(e, t) {
  return t.toUpperCase();
}, m2 = function(e, t) {
  return "".concat(t, "-");
}, IEe = function(e, t) {
  return t === void 0 && (t = {}), jEe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(TEe, m2) : e = e.replace(DEe, m2), e.replace(SEe, AEe));
};
LO.camelCase = IEe;
var BEe = Dr && Dr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, REe = BEe(Zj), NEe = LO;
function rM(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, REe.default)(e, function(r, o) {
    r && o && (n[(0, NEe.camelCase)(r, t)] = o);
  }), n;
}
rM.default = rM;
var FEe = rM;
(function(e) {
  var t = Dr && Dr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(FEe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})($j);
Object.defineProperty(xO, "__esModule", { value: !0 });
xO.default = WEe;
var gh = Ma, v2 = $j, zEe = ["checked", "value"], UEe = ["input", "select", "textarea"], HEe = {
  reset: !0,
  submit: !0
};
function WEe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && HEe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, gh.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = y2(a);
    if (s) {
      var l = (0, gh.getPropertyInfo)(s);
      switch (zEe.includes(s) && UEe.includes(t) && !r && (s = y2("default" + a)), n[s] = i, l && l.type) {
        case gh.BOOLEAN:
          n[s] = !0;
          break;
        case gh.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    v2.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, v2.setStyleProp)(e.style, n), n;
}
function y2(e) {
  return gh.possibleStandardNames[e];
}
var qj = {}, VEe = Dr && Dr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(qj, "__esModule", { value: !0 });
qj.default = Gre;
var dL = we, $Ee = VEe(xO), Ah = $j, ZEe = {
  cloneElement: dL.cloneElement,
  createElement: dL.createElement,
  isValidElement: dL.isValidElement
};
function Gre(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Ah.returnFirstArg, i = t.library || ZEe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Ah.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, y = {};
    qEe(f) ? ((0, Ah.setStyleProp)(f.attribs.style, f.attribs), y = f.attribs) : f.attribs && (y = (0, $Ee.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (y.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? y.defaultValue = p.children[0].data : p.children && p.children.length && (b = Gre(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (y.key = c), n.push(o(s(p.name, y, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function qEe(e) {
  return Ah.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Ah.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Dr && Dr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(Bj);
  e.htmlToDOM = n.default;
  var r = t(xO);
  e.attributesToProps = r.default;
  var o = t(qj);
  e.domToReact = o.default;
  var i = Nj;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(_re);
const GEe = /* @__PURE__ */ fOe(_re);
GEe.default;
var Tr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function KEe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var oM = { exports: {} }, Ef = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b2;
function YEe() {
  if (b2) return Ef;
  b2 = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return Ef.Fragment = n, Ef.jsx = a, Ef.jsxs = a, Ef;
}
var uy = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var w2;
function XEe() {
  return w2 || (w2 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, y = "@@iterator";
    function b(m) {
      if (m === null || typeof m != "object")
        return null;
      var A = f && m[f] || m[y];
      return typeof A == "function" ? A : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(m) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), ee = 1; ee < A; ee++)
          G[ee - 1] = arguments[ee];
        M("error", m, G);
      }
    }
    function M(m, A, G) {
      {
        var ee = E.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[m], console, ue);
      }
    }
    var O = !1, v = !1, x = !1, _ = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function N(m) {
      return !!(typeof m == "string" || typeof m == "function" || m === r || m === i || z || m === o || m === u || m === c || _ || m === g || O || v || x || typeof m == "object" && m !== null && (m.$$typeof === d || m.$$typeof === p || m.$$typeof === a || m.$$typeof === s || m.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      m.$$typeof === L || m.getModuleId !== void 0));
    }
    function R(m, A, G) {
      var ee = m.displayName;
      if (ee)
        return ee;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(m) {
      return m.displayName || "Context";
    }
    function Z(m) {
      if (m == null)
        return null;
      if (typeof m.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof m == "function")
        return m.displayName || m.name || null;
      if (typeof m == "string")
        return m;
      switch (m) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case s:
            var A = m;
            return V(A) + ".Consumer";
          case a:
            var G = m;
            return V(G._context) + ".Provider";
          case l:
            return R(m, m.render, "ForwardRef");
          case p:
            var ee = m.displayName || null;
            return ee !== null ? ee : Z(m.type) || "Memo";
          case d: {
            var ae = m, ue = ae._payload, se = ae._init;
            try {
              return Z(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, $ = 0, K, X, Q, J, P, D, F;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if ($ === 0) {
          K = console.log, X = console.info, Q = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, F = console.groupEnd;
          var m = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: m,
            log: m,
            warn: m,
            error: m,
            group: m,
            groupCollapsed: m,
            groupEnd: m
          });
        }
        $++;
      }
    }
    function C() {
      {
        if ($--, $ === 0) {
          var m = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, m, {
              value: K
            }),
            info: H({}, m, {
              value: X
            }),
            warn: H({}, m, {
              value: Q
            }),
            error: H({}, m, {
              value: J
            }),
            group: H({}, m, {
              value: P
            }),
            groupCollapsed: H({}, m, {
              value: D
            }),
            groupEnd: H({}, m, {
              value: F
            })
          });
        }
        $ < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = E.ReactCurrentDispatcher, U;
    function T(m, A, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            U = ee && ee[1] || "";
          }
        return `
` + U + m;
      }
    }
    var q = !1, j;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      j = new Y();
    }
    function B(m, A) {
      if (!m || q)
        return "";
      {
        var G = j.get(m);
        if (G !== void 0)
          return G;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Ee) {
              ee = Ee;
            }
            Reflect.construct(m, [], se);
          } else {
            try {
              se.call();
            } catch (Ee) {
              ee = Ee;
            }
            m.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ee) {
            ee = Ee;
          }
          m();
        }
      } catch (Ee) {
        if (Ee && ee && typeof Ee.stack == "string") {
          for (var ie = Ee.stack.split(`
`), be = ee.stack.split(`
`), de = ie.length - 1, fe = be.length - 1; de >= 1 && fe >= 0 && ie[de] !== be[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== be[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== be[fe]) {
                    var Fe = `
` + ie[de].replace(" at new ", " at ");
                    return m.displayName && Fe.includes("<anonymous>") && (Fe = Fe.replace("<anonymous>", m.displayName)), typeof m == "function" && j.set(m, Fe), Fe;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, C(), Error.prepareStackTrace = ae;
      }
      var Lt = m ? m.displayName || m.name : "", bt = Lt ? T(Lt) : "";
      return typeof m == "function" && j.set(m, bt), bt;
    }
    function le(m, A, G) {
      return B(m, !1);
    }
    function he(m) {
      var A = m.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(m, A, G) {
      if (m == null)
        return "";
      if (typeof m == "function")
        return B(m, he(m));
      if (typeof m == "string")
        return T(m);
      switch (m) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case l:
            return le(m.render);
          case p:
            return oe(m.type, A, G);
          case d: {
            var ee = m, ae = ee._payload, ue = ee._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Pe = Object.prototype.hasOwnProperty, Ue = {}, Ze = E.ReactDebugCurrentFrame;
    function _e(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        Ze.setExtraStackFrame(G);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(m, A, G, ee, ae) {
      {
        var ue = Function.call.bind(Pe);
        for (var se in m)
          if (ue(m, se)) {
            var ie = void 0;
            try {
              if (typeof m[se] != "function") {
                var be = Error((ee || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof m[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw be.name = "Invariant Violation", be;
              }
              ie = m[se](A, se, ee, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (_e(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", G, se, typeof ie), _e(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, _e(ae), w("Failed %s type: %s", G, ie.message), _e(null));
          }
      }
    }
    var Ve = Array.isArray;
    function ye(m) {
      return Ve(m);
    }
    function Ge(m) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && m[Symbol.toStringTag] || m.constructor.name || "Object";
        return G;
      }
    }
    function ct(m) {
      try {
        return ve(m), !1;
      } catch {
        return !0;
      }
    }
    function ve(m) {
      return "" + m;
    }
    function Oe(m) {
      if (ct(m))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ge(m)), ve(m);
    }
    var qe = E.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Se, st;
    function xe(m) {
      if (Pe.call(m, "ref")) {
        var A = Object.getOwnPropertyDescriptor(m, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.ref !== void 0;
    }
    function xt(m) {
      if (Pe.call(m, "key")) {
        var A = Object.getOwnPropertyDescriptor(m, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.key !== void 0;
    }
    function at(m, A) {
      typeof m.ref == "string" && qe.current;
    }
    function lt(m, A) {
      {
        var G = function() {
          Se || (Se = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function pt(m, A) {
      {
        var G = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(m, A, G, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: m,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function dt(m, A, G, ee, ae) {
      {
        var ue, se = {}, ie = null, be = null;
        G !== void 0 && (Oe(G), ie = "" + G), xt(A) && (Oe(A.key), ie = "" + A.key), xe(A) && (be = A.ref, at(A));
        for (ue in A)
          Pe.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (m && m.defaultProps) {
          var de = m.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || be) {
          var fe = typeof m == "function" ? m.displayName || m.name || "Unknown" : m;
          ie && lt(se, fe), be && pt(se, fe);
        }
        return Ot(m, ie, be, ae, ee, qe.current, se);
      }
    }
    var ft = E.ReactCurrentOwner, ot = E.ReactDebugCurrentFrame;
    function He(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        ot.setExtraStackFrame(G);
      } else
        ot.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(m) {
      return typeof m == "object" && m !== null && m.$$typeof === t;
    }
    function gt() {
      {
        if (ft.current) {
          var m = Z(ft.current.type);
          if (m)
            return `

Check the render method of \`` + m + "`.";
        }
        return "";
      }
    }
    function St(m) {
      return "";
    }
    var mt = {};
    function Mt(m) {
      {
        var A = gt();
        if (!A) {
          var G = typeof m == "string" ? m : m.displayName || m.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function vt(m, A) {
      {
        if (!m._store || m._store.validated || m.key != null)
          return;
        m._store.validated = !0;
        var G = Mt(A);
        if (mt[G])
          return;
        mt[G] = !0;
        var ee = "";
        m && m._owner && m._owner !== ft.current && (ee = " It was passed a child from " + Z(m._owner.type) + "."), He(m), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ee), He(null);
      }
    }
    function Pt(m, A) {
      {
        if (typeof m != "object")
          return;
        if (ye(m))
          for (var G = 0; G < m.length; G++) {
            var ee = m[G];
            kt(ee) && vt(ee, A);
          }
        else if (kt(m))
          m._store && (m._store.validated = !0);
        else if (m) {
          var ae = b(m);
          if (typeof ae == "function" && ae !== m.entries)
            for (var ue = ae.call(m), se; !(se = ue.next()).done; )
              kt(se.value) && vt(se.value, A);
        }
      }
    }
    function jn(m) {
      {
        var A = m.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var ee = Z(A);
          rt(G, m.props, "prop", ee, m);
        } else if (A.PropTypes !== void 0 && !Et) {
          Et = !0;
          var ae = Z(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(m) {
      {
        for (var A = Object.keys(m.props), G = 0; G < A.length; G++) {
          var ee = A[G];
          if (ee !== "children" && ee !== "key") {
            He(m), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), He(null);
            break;
          }
        }
        m.ref !== null && (He(m), w("Invalid attribute `ref` supplied to `React.Fragment`."), He(null));
      }
    }
    var te = {};
    function Rr(m, A, G, ee, ae, ue) {
      {
        var se = N(m);
        if (!se) {
          var ie = "";
          (m === void 0 || typeof m == "object" && m !== null && Object.keys(m).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var be = St();
          be ? ie += be : ie += gt();
          var de;
          m === null ? de = "null" : ye(m) ? de = "array" : m !== void 0 && m.$$typeof === t ? (de = "<" + (Z(m.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof m, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = dt(m, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Fe = A.children;
          if (Fe !== void 0)
            if (ee)
              if (ye(Fe)) {
                for (var Lt = 0; Lt < Fe.length; Lt++)
                  Pt(Fe[Lt], m);
                Object.freeze && Object.freeze(Fe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Pt(Fe, m);
        }
        if (Pe.call(A, "key")) {
          var bt = Z(m), Ee = Object.keys(A).filter(function(_i) {
            return _i !== "key";
          }), An = Ee.length > 0 ? "{key: someKey, " + Ee.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!te[bt + An]) {
            var Pi = Ee.length > 0 ? "{" + Ee.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, An, bt, Pi, bt), te[bt + An] = !0;
          }
        }
        return m === r ? yt(fe) : jn(fe), fe;
      }
    }
    function Oi(m, A, G) {
      return Rr(m, A, G, !0);
    }
    function Ei(m, A, G) {
      return Rr(m, A, G, !1);
    }
    var ki = Ei, Li = Oi;
    uy.Fragment = r, uy.jsx = ki, uy.jsxs = Li;
  }()), uy;
}
process.env.NODE_ENV === "production" ? oM.exports = YEe() : oM.exports = XEe();
var ji = oM.exports;
We({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function C2(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Yi(e) {
  var t, n;
  return C2(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(C2(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Kre = Symbol.for("immer-nothing"), x2 = Symbol.for("immer-draftable"), sa = Symbol.for("immer-state"), JEe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ws(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = JEe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var jd = Object.getPrototypeOf;
function $p(e) {
  return !!e && !!e[sa];
}
function Zp(e) {
  var t;
  return e ? Yre(e) || Array.isArray(e) || !!e[x2] || !!((t = e.constructor) != null && t[x2]) || _O(e) || SO(e) : !1;
}
var QEe = Object.prototype.constructor.toString();
function Yre(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = jd(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === QEe;
}
function d0(e, t) {
  PO(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function PO(e) {
  const t = e[sa];
  return t ? t.type_ : Array.isArray(e) ? 1 : _O(e) ? 2 : SO(e) ? 3 : 0;
}
function iM(e, t) {
  return PO(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Xre(e, t, n) {
  const r = PO(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function eke(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function _O(e) {
  return e instanceof Map;
}
function SO(e) {
  return e instanceof Set;
}
function tp(e) {
  return e.copy_ || e.base_;
}
function sM(e, t) {
  if (_O(e))
    return new Map(e);
  if (SO(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Yre(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[sa];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(jd(e), r);
  } else {
    const r = jd(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Gj(e, t = !1) {
  return MO(e) || $p(e) || !Zp(e) || (PO(e) > 1 && (e.set = e.add = e.clear = e.delete = tke), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Gj(r, !0))), e;
}
function tke() {
  ws(2);
}
function MO(e) {
  return Object.isFrozen(e);
}
var nke = {};
function qp(e) {
  const t = nke[e];
  return t || ws(0, e), t;
}
var Ig;
function Jre() {
  return Ig;
}
function rke(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function O2(e, t) {
  t && (qp("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function aM(e) {
  lM(e), e.drafts_.forEach(oke), e.drafts_ = null;
}
function lM(e) {
  e === Ig && (Ig = e.parent_);
}
function E2(e) {
  return Ig = rke(Ig, e);
}
function oke(e) {
  const t = e[sa];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function k2(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[sa].modified_ && (aM(t), ws(4)), Zp(e) && (e = f0(t, e), t.parent_ || h0(t, e)), t.patches_ && qp("Patches").generateReplacementPatches_(
    n[sa].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = f0(t, n, []), aM(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== Kre ? e : void 0;
}
function f0(e, t, n) {
  if (MO(t))
    return t;
  const r = t[sa];
  if (!r)
    return d0(
      t,
      (o, i) => L2(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return h0(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), d0(
      i,
      (s, l) => L2(e, r, o, s, l, n, a)
    ), h0(e, o, !1), n && e.patches_ && qp("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function L2(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ws(5), $p(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !iM(t.assigned_, r) ? i.concat(r) : void 0, l = f0(e, o, s);
    if (Xre(n, r, l), $p(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Zp(o) && !MO(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    f0(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && h0(e, o);
  }
}
function h0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Gj(t, n);
}
function ike(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Jre(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Kj;
  n && (o = [r], i = Bg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var Kj = {
  get(e, t) {
    if (t === sa)
      return e;
    const n = tp(e);
    if (!iM(n, t))
      return ske(e, n, t);
    const r = n[t];
    return e.finalized_ || !Zp(r) ? r : r === fL(e.base_, t) ? (hL(e), e.copy_[t] = cM(r, e)) : r;
  },
  has(e, t) {
    return t in tp(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(tp(e));
  },
  set(e, t, n) {
    const r = Qre(tp(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = fL(tp(e), t), i = o == null ? void 0 : o[sa];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (eke(n, o) && (n !== void 0 || iM(e.base_, t)))
        return !0;
      hL(e), uM(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return fL(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, hL(e), uM(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = tp(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ws(11);
  },
  getPrototypeOf(e) {
    return jd(e.base_);
  },
  setPrototypeOf() {
    ws(12);
  }
}, Bg = {};
d0(Kj, (e, t) => {
  Bg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Bg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ws(13), Bg.set.call(this, e, t, void 0);
};
Bg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ws(14), Kj.set.call(this, e[0], t, n, e[0]);
};
function fL(e, t) {
  const n = e[sa];
  return (n ? tp(n) : e)[t];
}
function ske(e, t, n) {
  var r;
  const o = Qre(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Qre(e, t) {
  if (!(t in e))
    return;
  let n = jd(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = jd(n);
  }
}
function uM(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && uM(e.parent_));
}
function hL(e) {
  e.copy_ || (e.copy_ = sM(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var ake = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ws(6), r !== void 0 && typeof r != "function" && ws(7);
      let o;
      if (Zp(t)) {
        const i = E2(this), a = cM(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? aM(i) : lM(i);
        }
        return O2(i, r), k2(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === Kre && (o = void 0), this.autoFreeze_ && Gj(o, !0), r) {
          const i = [], a = [];
          qp("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ws(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Zp(e) || ws(8), $p(e) && (e = lke(e));
    const t = E2(this), n = cM(e, void 0);
    return n[sa].isManual_ = !0, lM(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[sa];
    (!n || !n.isManual_) && ws(9);
    const { scope_: r } = n;
    return O2(r, t), k2(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = qp("Patches").applyPatches_;
    return $p(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function cM(e, t) {
  const n = _O(e) ? qp("MapSet").proxyMap_(e, t) : SO(e) ? qp("MapSet").proxySet_(e, t) : ike(e, t);
  return (t ? t.scope_ : Jre()).drafts_.push(n), n;
}
function lke(e) {
  return $p(e) || ws(10, e), eoe(e);
}
function eoe(e) {
  if (!Zp(e) || MO(e))
    return e;
  const t = e[sa];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = sM(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = sM(e, !0);
  return d0(n, (r, o) => {
    Xre(n, r, eoe(o));
  }), t && (t.finalized_ = !1), n;
}
var aa = new ake(), Yj = aa.produce;
aa.produceWithPatches.bind(
  aa
);
aa.setAutoFreeze.bind(aa);
aa.setUseStrictShallowCopy.bind(aa);
aa.applyPatches.bind(aa);
var P2 = aa.createDraft.bind(aa), _2 = aa.finishDraft.bind(aa), Qe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Qe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Qe.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Qe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Qe.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Qe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Qe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Qe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Qe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Qe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Qe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Qe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Qe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Qe.isAncestor(t, e) && !Qe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Qe.equals(i, r) || Qe.endsBefore(i, r) || Qe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Qe.equals(a, r) || Qe.isAncestor(a, r))
          return null;
        Qe.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Qe.equals(s, r) || Qe.endsBefore(s, r) ? r[s.length - 1] -= 1 : Qe.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Qe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Qe.endsBefore(u, r) ? r[u.length - 1] += 1 : Qe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Qe.equals(p, d))
          return r;
        if (Qe.isAncestor(p, r) || Qe.equals(p, r)) {
          var g = d.slice();
          return Qe.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Qe.isSibling(p, d) && (Qe.isAncestor(d, r) || Qe.equals(d, r)) ? Qe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Qe.endsBefore(d, r) || Qe.equals(d, r) || Qe.isAncestor(d, r) ? (Qe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Qe.endsBefore(p, r) && (Qe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Rg(e) {
  "@babel/helpers - typeof";
  return Rg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Rg(e);
}
function uke(e, t) {
  if (Rg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Rg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function cke(e) {
  var t = uke(e, "string");
  return Rg(t) === "symbol" ? t : String(t);
}
function Vd(e, t, n) {
  return t = cke(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function S2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? S2(Object(n), !0).forEach(function(r) {
      Vd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : S2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pke = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = It.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of en.points(t))
          t[l] = Yr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = It.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [y, b] of en.points(t))
          t[b] = Yr.transform(y, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = It.get(e, E), M = Qe.previous(E), O = It.get(e, M), v = It.parent(e, E), x = E[E.length - 1];
      if (Xo.isText(w) && Xo.isText(O))
        O.text += w.text;
      else if (!Xo.isText(w) && !Xo.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Rs.stringify(w), " ").concat(Rs.stringify(O)));
      if (v.children.splice(x, 1), t)
        for (var [_, z] of en.points(t))
          t[z] = Yr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (Qe.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = It.get(e, L), V = It.parent(e, L), Z = L[L.length - 1];
      V.children.splice(Z, 1);
      var H = Qe.transform(L, n), $ = It.get(e, Qe.parent(H)), K = H[H.length - 1];
      if ($.children.splice(K, 0, R), t)
        for (var [X, Q] of en.points(t))
          t[Q] = Yr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = It.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [F, S] of en.points(t)) {
          var W = Yr.transform(F, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var C = void 0, I = void 0;
            for (var [U, T] of It.texts(e))
              if (Qe.compare(T, J) === -1)
                C = [U, T];
              else {
                I = [U, T];
                break;
              }
            var q = !1;
            C && I && (Qe.equals(I[1], J) ? q = !Qe.hasPrevious(I[1]) : q = Qe.common(C[1], J).length < Qe.common(I[1], J).length), C && !q ? (F.path = C[1], F.offset = C[0].text.length) : I ? (F.path = I[1], F.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: j,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = It.leaf(e, j), he = le.text.slice(0, Y), oe = le.text.slice(Y + B.length);
      if (le.text = he + oe, t)
        for (var [Pe, Ue] of en.points(t))
          t[Ue] = Yr.transform(Pe, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: _e,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = It.get(e, Ze);
      for (var ye in rt) {
        if (ye === "children" || ye === "text")
          throw new Error('Cannot set the "'.concat(ye, '" property of nodes!'));
        var Ge = rt[ye];
        Ge == null ? delete Ve[ye] : Ve[ye] = Ge;
      }
      for (var ct in _e)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ve
      } = n;
      if (ve == null)
        t = ve;
      else {
        if (t == null) {
          if (!en.isRange(ve))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Rs.stringify(ve), " when there is no current selection."));
          t = kf({}, ve);
        }
        for (var Oe in ve) {
          var qe = ve[Oe];
          if (qe == null) {
            if (Oe === "anchor" || Oe === "focus")
              throw new Error('Cannot remove the "'.concat(Oe, '" selection property'));
            delete t[Oe];
          } else
            t[Oe] = qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Se,
        properties: st
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var xe = It.get(e, ze), xt = It.parent(e, ze), at = ze[ze.length - 1], lt;
      if (Xo.isText(xe)) {
        var pt = xe.text.slice(0, Se), Ot = xe.text.slice(Se);
        xe.text = pt, lt = kf(kf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = xe.children.slice(0, Se), ft = xe.children.slice(Se);
        xe.children = dt, lt = kf(kf({}, st), {}, {
          children: ft
        });
      }
      if (xt.children.splice(at + 1, 0, lt), t)
        for (var [ot, He] of en.points(t))
          t[He] = Yr.transform(ot, n);
      break;
    }
  }
  return t;
}, dke = {
  transform(e, t) {
    e.children = P2(e.children);
    var n = e.selection && P2(e.selection);
    try {
      n = pke(e, n, t);
    } finally {
      e.children = _2(e.children), n ? e.selection = $p(n) ? _2(n) : n : e.selection = null;
    }
  }
}, fke = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, hke = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, toe = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Yi(r) && Yi(o)) {
      if (!toe(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function gke(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Ng(e, t) {
  if (e == null) return {};
  var n = gke(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var mke = ["anchor", "focus"];
function M2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vke(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? M2(Object(n), !0).forEach(function(r) {
      Vd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : M2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var en = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return en.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = en.edges(e);
    return t;
  },
  equals(e, t) {
    return Yr.equals(e.anchor, t.anchor) && Yr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (en.isRange(t)) {
      if (en.includes(e, t.anchor) || en.includes(e, t.focus))
        return !0;
      var [n, r] = en.edges(e), [o, i] = en.edges(t);
      return Yr.isBefore(n, o) && Yr.isAfter(r, i);
    }
    var [a, s] = en.edges(e), l = !1, u = !1;
    return Yr.isPoint(t) ? (l = Yr.compare(t, a) >= 0, u = Yr.compare(t, s) <= 0) : (l = Qe.compare(t, a.path) >= 0, u = Qe.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Ng(e, mke), [r, o] = en.edges(e), [i, a] = en.edges(t), s = Yr.isBefore(r, i) ? i : r, l = Yr.isBefore(o, a) ? o : a;
    return Yr.isBefore(l, s) ? null : vke({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Yr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Yr.equals(t, n);
  },
  isExpanded(e) {
    return !en.isCollapsed(e);
  },
  isForward(e) {
    return !en.isBackward(e);
  },
  isRange(e) {
    return Yi(e) && Yr.isPoint(e.anchor) && Yr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = en.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Yj(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = en.isCollapsed(r);
        en.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? en.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Yr.transform(r.anchor, t, {
        affinity: i
      }), u = Yr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, D2 = (e) => Yi(e) && It.isNodeList(e.children) && !Or.isEditor(e), Al = {
  isAncestor(e) {
    return Yi(e) && It.isNodeList(e.children);
  },
  isElement: D2,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Al.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return D2(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, yke = ["children"], bke = ["text"], T2 = /* @__PURE__ */ new WeakMap(), It = {
  ancestor(e, t) {
    var n = It.get(e, t);
    if (Xo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Rs.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Qe.ancestors(t, n)) {
        var o = It.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Xo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Rs.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Rs.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = It.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = It.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Qe.common(t, n), o = It.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = It.get(e, t);
    if (Or.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Rs.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of It.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of It.nodes(e, t))
        Al.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Al.isAncestor(e)) {
      var t = Ng(e, yke);
      return t;
    } else {
      var t = Ng(e, bke);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = It.get(e, n); r && !(Xo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Xo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Rs.stringify(e)));
    var n = Yj({
      children: e.children
    }, (r) => {
      var [o, i] = en.edges(t), a = It.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !en.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!en.includes(t, s)) {
          var l = It.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Qe.equals(s, i.path)) {
          var c = It.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Qe.equals(s, o.path)) {
          var p = It.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Or.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Xo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Rs.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Xo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Xo.isText(e) || Al.isElement(e) || Or.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = T2.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => It.isNode(r));
    return T2.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = It.get(e, n); r && !(Xo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = It.get(e, t);
    if (!Xo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Rs.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Qe.levels(t, n)) {
        var o = It.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Al.isElement(e) && Al.isElementProps(t) && Al.matches(e, t) || Xo.isText(e) && Xo.isTextProps(t) && Xo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Qe.isBefore(s, i) : Qe.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Xo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Qe.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = It.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Qe.next(s);
          if (It.has(e, c)) {
            s = c, l = It.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Qe.previous(s);
          s = p, l = It.get(e, s);
          continue;
        }
        s = Qe.parent(s), l = It.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Qe.parent(t), r = It.get(e, n);
    if (Xo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Xo.isText(e) ? e.text : e.children.map(It.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of It.nodes(e, t))
        Xo.isText(n) && (yield [n, r]);
    }();
  }
};
function j2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function io(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? j2(Object(n), !0).forEach(function(r) {
      Vd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : j2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mh = {
  isNodeOperation(e) {
    return mh.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Yi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Qe.isPath(e.path) && It.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Qe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Qe.isPath(e.path) && Yi(e.properties);
      case "move_node":
        return Qe.isPath(e.path) && Qe.isPath(e.newPath);
      case "remove_node":
        return Qe.isPath(e.path) && It.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Qe.isPath(e.path);
      case "set_node":
        return Qe.isPath(e.path) && Yi(e.properties) && Yi(e.newProperties);
      case "set_selection":
        return e.properties === null && en.isRange(e.newProperties) || e.newProperties === null && en.isRange(e.properties) || Yi(e.properties) && Yi(e.newProperties);
      case "split_node":
        return Qe.isPath(e.path) && typeof e.position == "number" && Yi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => mh.isOperation(t));
  },
  isSelectionOperation(e) {
    return mh.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return mh.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return io(io({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return io(io({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return io(io({}, e), {}, {
          type: "split_node",
          path: Qe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Qe.equals(t, n))
          return e;
        if (Qe.isSibling(n, t))
          return io(io({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Qe.transform(n, e), o = Qe.transform(Qe.next(n), e);
        return io(io({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return io(io({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return io(io({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return io(io({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? io(io({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? io(io({}, e), {}, {
          properties: null,
          newProperties: s
        }) : io(io({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return io(io({}, e), {}, {
          type: "merge_node",
          path: Qe.next(e.path)
        });
    }
  }
}, A2 = /* @__PURE__ */ new WeakMap(), wke = (e) => {
  var t = A2.get(e);
  if (t !== void 0)
    return t;
  if (!Yi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Yi(e.marks)) && (e.selection === null || en.isRange(e.selection)) && It.isNodeList(e.children) && mh.isOperationList(e.operations);
  return A2.set(e, n), n;
}, Or = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return wke(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function I2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function B2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? I2(Object(n), !0).forEach(function(r) {
      Vd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : I2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yr = {
  compare(e, t) {
    var n = Qe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Yr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Yr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Qe.equals(e.path, t.path);
  },
  isPoint(e) {
    return Yi(e) && typeof e.offset == "number" && Qe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Yj(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Qe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Qe.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Qe.equals(t.path, i) && (r.offset += t.position), r.path = Qe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Qe.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Qe.equals(t.path, i) || Qe.isAncestor(t.path, i))
            return null;
          r.path = Qe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Qe.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Qe.transform(i, t, B2(B2({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Qe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, R2 = void 0, Rs = {
  setScrubber(e) {
    R2 = e;
  },
  stringify(e) {
    return JSON.stringify(e, R2);
  }
}, Cke = ["text"], xke = ["anchor", "focus"];
function N2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? N2(Object(n), !0).forEach(function(r) {
      Vd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : N2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Ng(i, Cke);
      return a;
    }
    return toe(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Yi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Xo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [vl({}, e)];
    for (var r of t) {
      var o = Ng(r, xke), [i, a] = en.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, y = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = vl(vl({}, f), {}, {
            text: f.text.slice(E)
          }), f = vl(vl({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          y = vl(vl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = vl(vl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), y && s.push(y), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, Oke = (e) => e.selection ? e.selection : e.children.length > 0 ? Or.end(e, []) : [0], Hr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Hr || (Hr = {}));
Hr.L, Hr.L | Hr.V | Hr.LV | Hr.LVT, Hr.LV | Hr.V, Hr.V | Hr.T, Hr.LVT | Hr.T, Hr.T, Hr.Any, Hr.Extend | Hr.ZWJ, Hr.Any, Hr.SpacingMark, Hr.Prepend, Hr.Any, Hr.ZWJ, Hr.ExtPict, Hr.RI, Hr.RI;
var Eke = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Or.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Oke(e)
      } = n;
      if (Qe.isPath(o) && (o = Or.range(e, o)), en.isRange(o))
        if (en.isCollapsed(o))
          o = o.anchor;
        else {
          var i = en.end(o);
          if (!r && Or.void(e, {
            at: i
          }))
            return;
          var a = en.start(o), s = Or.pointRef(e, a), l = Or.pointRef(e, i);
          g0.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, g0.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Or.void(e, {
        at: o
      }) || Or.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function F2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? F2(Object(n), !0).forEach(function(r) {
      Vd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : F2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var g0 = cy(cy(cy(cy({}, dke), fke), hke), Eke), noe = {}, Xj = {}, Jj = {}, ld = {}, Qj = {}, eA = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(eA);
var pn = {}, fc = Tr && Tr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Ih = Tr && Tr.__assign || function() {
  return Ih = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ih.apply(this, arguments);
};
Object.defineProperty(pn, "__esModule", { value: !0 });
pn.cloneNode = pn.hasChildren = pn.isDocument = pn.isDirective = pn.isComment = pn.isText = pn.isCDATA = pn.isTag = pn.Element = pn.Document = pn.CDATA = pn.NodeWithChildren = pn.ProcessingInstruction = pn.Comment = pn.Text = pn.DataNode = pn.Node = void 0;
var Ss = eA, tA = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), nA(this, t);
    }, e;
  }()
);
pn.Node = tA;
var DO = (
  /** @class */
  function(e) {
    fc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(tA)
);
pn.DataNode = DO;
var roe = (
  /** @class */
  function(e) {
    fc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ss.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(DO)
);
pn.Text = roe;
var ooe = (
  /** @class */
  function(e) {
    fc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ss.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(DO)
);
pn.Comment = ooe;
var ioe = (
  /** @class */
  function(e) {
    fc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ss.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(DO)
);
pn.ProcessingInstruction = ioe;
var TO = (
  /** @class */
  function(e) {
    fc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(tA)
);
pn.NodeWithChildren = TO;
var soe = (
  /** @class */
  function(e) {
    fc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ss.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(TO)
);
pn.CDATA = soe;
var aoe = (
  /** @class */
  function(e) {
    fc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ss.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(TO)
);
pn.Document = aoe;
var loe = (
  /** @class */
  function(e) {
    fc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ss.ElementType.Script : n === "style" ? Ss.ElementType.Style : Ss.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(TO)
);
pn.Element = loe;
function uoe(e) {
  return (0, Ss.isTag)(e);
}
pn.isTag = uoe;
function coe(e) {
  return e.type === Ss.ElementType.CDATA;
}
pn.isCDATA = coe;
function poe(e) {
  return e.type === Ss.ElementType.Text;
}
pn.isText = poe;
function doe(e) {
  return e.type === Ss.ElementType.Comment;
}
pn.isComment = doe;
function foe(e) {
  return e.type === Ss.ElementType.Directive;
}
pn.isDirective = foe;
function hoe(e) {
  return e.type === Ss.ElementType.Root;
}
pn.isDocument = hoe;
function kke(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
pn.hasChildren = kke;
function nA(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (poe(e))
    n = new roe(e.data);
  else if (doe(e))
    n = new ooe(e.data);
  else if (uoe(e)) {
    var r = t ? gL(e.children) : [], o = new loe(e.name, Ih({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Ih({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Ih({}, e["x-attribsPrefix"])), n = o;
  } else if (coe(e)) {
    var r = t ? gL(e.children) : [], i = new soe(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (hoe(e)) {
    var r = t ? gL(e.children) : [], a = new aoe(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (foe(e)) {
    var s = new ioe(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
pn.cloneNode = nA;
function gL(e) {
  for (var t = e.map(function(r) {
    return nA(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Tr && Tr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Tr && Tr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = eA, o = pn;
  n(pn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(Qj);
var goe = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(goe);
Object.defineProperty(ld, "__esModule", { value: !0 });
ld.formatAttributes = moe;
ld.escapeSpecialCharacters = _ke;
ld.revertEscapedCharacters = voe;
ld.formatDOM = yoe;
var py = Qj, Fg = goe;
function Lke(e) {
  return Fg.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function moe(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Pke(e) {
  e = e.toLowerCase();
  var t = Lke(e);
  return t || e;
}
function _ke(e) {
  return e.replace(Fg.CARRIAGE_RETURN_REGEX, Fg.CARRIAGE_RETURN_PLACEHOLDER);
}
function voe(e) {
  return e.replace(Fg.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Fg.CARRIAGE_RETURN);
}
function yoe(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Pke(s.nodeName);
        o = new py.Element(l, moe(s.attributes)), o.children = yoe(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new py.Text(voe(s.nodeValue));
        break;
      case 8:
        o = new py.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new py.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(Jj, "__esModule", { value: !0 });
Jj.default = jke;
var Ske = ld, z2 = "html", U2 = "head", dy = "body", Mke = /<([a-zA-Z]+[0-9]?)/, H2 = /<head[^]*>/i, W2 = /<body[^]*>/i, m0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, pM = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, V2 = typeof window == "object" && window.DOMParser;
if (typeof V2 == "function") {
  var Dke = new V2(), Tke = "text/html";
  pM = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Dke.parseFromString(e, Tke);
  }, m0 = pM;
}
if (typeof document == "object" && document.implementation) {
  var fy = document.implementation.createHTMLDocument();
  m0 = function(e, t) {
    if (t) {
      var n = fy.documentElement.querySelector(t);
      return n && (n.innerHTML = e), fy;
    }
    return fy.documentElement.innerHTML = e, fy;
  };
}
var hy = typeof document == "object" && document.createElement("template"), dM;
hy && hy.content && (dM = function(e) {
  return hy.innerHTML = e, hy.content.childNodes;
});
function jke(e) {
  var t, n;
  e = (0, Ske.escapeSpecialCharacters)(e);
  var r = e.match(Mke), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case z2: {
      var i = pM(e);
      if (!H2.test(e)) {
        var a = i.querySelector(U2);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!W2.test(e)) {
        var a = i.querySelector(dy);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(z2);
    }
    case U2:
    case dy: {
      var s = m0(e).querySelectorAll(o);
      return W2.test(e) && H2.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (dM)
        return dM(e);
      var a = m0(e, dy).querySelector(dy);
      return a.childNodes;
    }
  }
}
var Ake = Tr && Tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Xj, "__esModule", { value: !0 });
Xj.default = Nke;
var Ike = Ake(Jj), Bke = ld, Rke = /<(![a-zA-Z\s]+)>/;
function Nke(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Rke), n = t ? t[1] : void 0;
  return (0, Bke.formatDOM)((0, Ike.default)(e), null, n);
}
var jO = {}, Da = {}, AO = {}, Fke = 0;
AO.SAME = Fke;
var zke = 1;
AO.CAMELCASE = zke;
AO.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const boe = 0, hc = 1, IO = 2, BO = 3, rA = 4, woe = 5, Coe = 6;
function Uke(e) {
  return Hi.hasOwnProperty(e) ? Hi[e] : null;
}
function us(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === IO || t === BO || t === rA, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Hi = {}, Hke = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Hke.forEach((e) => {
  Hi[e] = new us(
    e,
    boe,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Hi[e] = new us(
    e,
    hc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Hi[e] = new us(
    e,
    IO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Hi[e] = new us(
    e,
    IO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Hi[e] = new us(
    e,
    BO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Hi[e] = new us(
    e,
    BO,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Hi[e] = new us(
    e,
    rA,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Hi[e] = new us(
    e,
    Coe,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Hi[e] = new us(
    e,
    woe,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const oA = /[\-\:]([a-z])/g, iA = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(oA, iA);
  Hi[t] = new us(
    t,
    hc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(oA, iA);
  Hi[t] = new us(
    t,
    hc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(oA, iA);
  Hi[t] = new us(
    t,
    hc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Hi[e] = new us(
    e,
    hc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Wke = "xlinkHref";
Hi[Wke] = new us(
  "xlinkHref",
  hc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Hi[e] = new us(
    e,
    hc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Vke,
  SAME: $ke,
  possibleStandardNames: $2
} = AO, Zke = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", qke = Zke + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Gke = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + qke + "]*$")
), Kke = Object.keys(
  $2
).reduce((e, t) => {
  const n = $2[t];
  return n === $ke ? e[t] = t : n === Vke ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Da.BOOLEAN = BO;
Da.BOOLEANISH_STRING = IO;
Da.NUMERIC = woe;
Da.OVERLOADED_BOOLEAN = rA;
Da.POSITIVE_NUMERIC = Coe;
Da.RESERVED = boe;
Da.STRING = hc;
Da.getPropertyInfo = Uke;
Da.isCustomAttribute = Gke;
Da.possibleStandardNames = Kke;
var sA = {}, aA = {}, Z2 = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Yke = /\n/g, Xke = /^\s*/, Jke = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Qke = /^:\s*/, eLe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, tLe = /^[;\s]*/, nLe = /^\s+|\s+$/g, rLe = `
`, q2 = "/", G2 = "*", pp = "", oLe = "comment", iLe = "declaration", sLe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var y = f.match(Yke);
    y && (n += y.length);
    var b = f.lastIndexOf(rLe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(y) {
      return y.position = new a(f), u(), y;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var y = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (y.reason = f, y.filename = t.source, y.line = n, y.column = r, y.source = e, !t.silent) throw y;
  }
  function l(f) {
    var y = f.exec(e);
    if (y) {
      var b = y[0];
      return o(b), e = e.slice(b.length), y;
    }
  }
  function u() {
    l(Xke);
  }
  function c(f) {
    var y;
    for (f = f || []; y = p(); )
      y !== !1 && f.push(y);
    return f;
  }
  function p() {
    var f = i();
    if (!(q2 != e.charAt(0) || G2 != e.charAt(1))) {
      for (var y = 2; pp != e.charAt(y) && (G2 != e.charAt(y) || q2 != e.charAt(y + 1)); )
        ++y;
      if (y += 2, pp === e.charAt(y - 1))
        return s("End of comment missing");
      var b = e.slice(2, y - 2);
      return r += 2, o(b), e = e.slice(y), r += 2, f({
        type: oLe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), y = l(Jke);
    if (y) {
      if (p(), !l(Qke)) return s("property missing ':'");
      var b = l(eLe), E = f({
        type: iLe,
        property: K2(y[0].replace(Z2, pp)),
        value: b ? K2(b[0].replace(Z2, pp)) : pp
      });
      return l(tLe), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var y; y = d(); )
      y !== !1 && (f.push(y), c(f));
    return f;
  }
  return u(), g();
};
function K2(e) {
  return e ? e.replace(nLe, pp) : pp;
}
var aLe = Tr && Tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(aA, "__esModule", { value: !0 });
aA.default = uLe;
var lLe = aLe(sLe);
function uLe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, lLe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var RO = {};
Object.defineProperty(RO, "__esModule", { value: !0 });
RO.camelCase = void 0;
var cLe = /^--[a-zA-Z0-9_-]+$/, pLe = /-([a-z])/g, dLe = /^[^-]+$/, fLe = /^-(webkit|moz|ms|o|khtml)-/, hLe = /^-(ms)-/, gLe = function(e) {
  return !e || dLe.test(e) || cLe.test(e);
}, mLe = function(e, t) {
  return t.toUpperCase();
}, Y2 = function(e, t) {
  return "".concat(t, "-");
}, vLe = function(e, t) {
  return t === void 0 && (t = {}), gLe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(hLe, Y2) : e = e.replace(fLe, Y2), e.replace(pLe, mLe));
};
RO.camelCase = vLe;
var yLe = Tr && Tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, bLe = yLe(aA), wLe = RO;
function fM(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, bLe.default)(e, function(r, o) {
    r && o && (n[(0, wLe.camelCase)(r, t)] = o);
  }), n;
}
fM.default = fM;
var CLe = fM;
(function(e) {
  var t = Tr && Tr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(CLe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(sA);
Object.defineProperty(jO, "__esModule", { value: !0 });
jO.default = kLe;
var vh = Da, X2 = sA, xLe = ["checked", "value"], OLe = ["input", "select", "textarea"], ELe = {
  reset: !0,
  submit: !0
};
function kLe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && ELe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, vh.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = J2(a);
    if (s) {
      var l = (0, vh.getPropertyInfo)(s);
      switch (xLe.includes(s) && OLe.includes(t) && !r && (s = J2("default" + a)), n[s] = i, l && l.type) {
        case vh.BOOLEAN:
          n[s] = !0;
          break;
        case vh.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    X2.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, X2.setStyleProp)(e.style, n), n;
}
function J2(e) {
  return vh.possibleStandardNames[e];
}
var lA = {}, LLe = Tr && Tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(lA, "__esModule", { value: !0 });
lA.default = xoe;
var mL = we, PLe = LLe(jO), Bh = sA, _Le = {
  cloneElement: mL.cloneElement,
  createElement: mL.createElement,
  isValidElement: mL.isValidElement
};
function xoe(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Bh.returnFirstArg, i = t.library || _Le, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Bh.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, y = {};
    SLe(f) ? ((0, Bh.setStyleProp)(f.attribs.style, f.attribs), y = f.attribs) : f.attribs && (y = (0, PLe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (y.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? y.defaultValue = p.children[0].data : p.children && p.children.length && (b = xoe(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (y.key = c), n.push(o(s(p.name, y, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function SLe(e) {
  return Bh.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Bh.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Tr && Tr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(Xj);
  e.htmlToDOM = n.default;
  var r = t(jO);
  e.attributesToProps = r.default;
  var o = t(lA);
  e.domToReact = o.default;
  var i = Qj;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(noe);
const MLe = /* @__PURE__ */ KEe(noe);
MLe.default;
var jr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function DLe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var hM = { exports: {} }, Lf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Q2;
function TLe() {
  if (Q2) return Lf;
  Q2 = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return Lf.Fragment = n, Lf.jsx = a, Lf.jsxs = a, Lf;
}
var gy = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eU;
function jLe() {
  return eU || (eU = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, y = "@@iterator";
    function b(m) {
      if (m === null || typeof m != "object")
        return null;
      var A = f && m[f] || m[y];
      return typeof A == "function" ? A : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(m) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), ee = 1; ee < A; ee++)
          G[ee - 1] = arguments[ee];
        M("error", m, G);
      }
    }
    function M(m, A, G) {
      {
        var ee = E.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[m], console, ue);
      }
    }
    var O = !1, v = !1, x = !1, _ = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function N(m) {
      return !!(typeof m == "string" || typeof m == "function" || m === r || m === i || z || m === o || m === u || m === c || _ || m === g || O || v || x || typeof m == "object" && m !== null && (m.$$typeof === d || m.$$typeof === p || m.$$typeof === a || m.$$typeof === s || m.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      m.$$typeof === L || m.getModuleId !== void 0));
    }
    function R(m, A, G) {
      var ee = m.displayName;
      if (ee)
        return ee;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(m) {
      return m.displayName || "Context";
    }
    function Z(m) {
      if (m == null)
        return null;
      if (typeof m.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof m == "function")
        return m.displayName || m.name || null;
      if (typeof m == "string")
        return m;
      switch (m) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case s:
            var A = m;
            return V(A) + ".Consumer";
          case a:
            var G = m;
            return V(G._context) + ".Provider";
          case l:
            return R(m, m.render, "ForwardRef");
          case p:
            var ee = m.displayName || null;
            return ee !== null ? ee : Z(m.type) || "Memo";
          case d: {
            var ae = m, ue = ae._payload, se = ae._init;
            try {
              return Z(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, $ = 0, K, X, Q, J, P, D, F;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if ($ === 0) {
          K = console.log, X = console.info, Q = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, F = console.groupEnd;
          var m = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: m,
            log: m,
            warn: m,
            error: m,
            group: m,
            groupCollapsed: m,
            groupEnd: m
          });
        }
        $++;
      }
    }
    function C() {
      {
        if ($--, $ === 0) {
          var m = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, m, {
              value: K
            }),
            info: H({}, m, {
              value: X
            }),
            warn: H({}, m, {
              value: Q
            }),
            error: H({}, m, {
              value: J
            }),
            group: H({}, m, {
              value: P
            }),
            groupCollapsed: H({}, m, {
              value: D
            }),
            groupEnd: H({}, m, {
              value: F
            })
          });
        }
        $ < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = E.ReactCurrentDispatcher, U;
    function T(m, A, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            U = ee && ee[1] || "";
          }
        return `
` + U + m;
      }
    }
    var q = !1, j;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      j = new Y();
    }
    function B(m, A) {
      if (!m || q)
        return "";
      {
        var G = j.get(m);
        if (G !== void 0)
          return G;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Ee) {
              ee = Ee;
            }
            Reflect.construct(m, [], se);
          } else {
            try {
              se.call();
            } catch (Ee) {
              ee = Ee;
            }
            m.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ee) {
            ee = Ee;
          }
          m();
        }
      } catch (Ee) {
        if (Ee && ee && typeof Ee.stack == "string") {
          for (var ie = Ee.stack.split(`
`), be = ee.stack.split(`
`), de = ie.length - 1, fe = be.length - 1; de >= 1 && fe >= 0 && ie[de] !== be[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== be[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== be[fe]) {
                    var Fe = `
` + ie[de].replace(" at new ", " at ");
                    return m.displayName && Fe.includes("<anonymous>") && (Fe = Fe.replace("<anonymous>", m.displayName)), typeof m == "function" && j.set(m, Fe), Fe;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, C(), Error.prepareStackTrace = ae;
      }
      var Lt = m ? m.displayName || m.name : "", bt = Lt ? T(Lt) : "";
      return typeof m == "function" && j.set(m, bt), bt;
    }
    function le(m, A, G) {
      return B(m, !1);
    }
    function he(m) {
      var A = m.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(m, A, G) {
      if (m == null)
        return "";
      if (typeof m == "function")
        return B(m, he(m));
      if (typeof m == "string")
        return T(m);
      switch (m) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case l:
            return le(m.render);
          case p:
            return oe(m.type, A, G);
          case d: {
            var ee = m, ae = ee._payload, ue = ee._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Pe = Object.prototype.hasOwnProperty, Ue = {}, Ze = E.ReactDebugCurrentFrame;
    function _e(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        Ze.setExtraStackFrame(G);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(m, A, G, ee, ae) {
      {
        var ue = Function.call.bind(Pe);
        for (var se in m)
          if (ue(m, se)) {
            var ie = void 0;
            try {
              if (typeof m[se] != "function") {
                var be = Error((ee || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof m[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw be.name = "Invariant Violation", be;
              }
              ie = m[se](A, se, ee, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (_e(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", G, se, typeof ie), _e(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, _e(ae), w("Failed %s type: %s", G, ie.message), _e(null));
          }
      }
    }
    var Ve = Array.isArray;
    function ye(m) {
      return Ve(m);
    }
    function Ge(m) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && m[Symbol.toStringTag] || m.constructor.name || "Object";
        return G;
      }
    }
    function ct(m) {
      try {
        return ve(m), !1;
      } catch {
        return !0;
      }
    }
    function ve(m) {
      return "" + m;
    }
    function Oe(m) {
      if (ct(m))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ge(m)), ve(m);
    }
    var qe = E.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Se, st;
    function xe(m) {
      if (Pe.call(m, "ref")) {
        var A = Object.getOwnPropertyDescriptor(m, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.ref !== void 0;
    }
    function xt(m) {
      if (Pe.call(m, "key")) {
        var A = Object.getOwnPropertyDescriptor(m, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.key !== void 0;
    }
    function at(m, A) {
      typeof m.ref == "string" && qe.current;
    }
    function lt(m, A) {
      {
        var G = function() {
          Se || (Se = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function pt(m, A) {
      {
        var G = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(m, A, G, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: m,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function dt(m, A, G, ee, ae) {
      {
        var ue, se = {}, ie = null, be = null;
        G !== void 0 && (Oe(G), ie = "" + G), xt(A) && (Oe(A.key), ie = "" + A.key), xe(A) && (be = A.ref, at(A));
        for (ue in A)
          Pe.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (m && m.defaultProps) {
          var de = m.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || be) {
          var fe = typeof m == "function" ? m.displayName || m.name || "Unknown" : m;
          ie && lt(se, fe), be && pt(se, fe);
        }
        return Ot(m, ie, be, ae, ee, qe.current, se);
      }
    }
    var ft = E.ReactCurrentOwner, ot = E.ReactDebugCurrentFrame;
    function He(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        ot.setExtraStackFrame(G);
      } else
        ot.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(m) {
      return typeof m == "object" && m !== null && m.$$typeof === t;
    }
    function gt() {
      {
        if (ft.current) {
          var m = Z(ft.current.type);
          if (m)
            return `

Check the render method of \`` + m + "`.";
        }
        return "";
      }
    }
    function St(m) {
      return "";
    }
    var mt = {};
    function Mt(m) {
      {
        var A = gt();
        if (!A) {
          var G = typeof m == "string" ? m : m.displayName || m.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function vt(m, A) {
      {
        if (!m._store || m._store.validated || m.key != null)
          return;
        m._store.validated = !0;
        var G = Mt(A);
        if (mt[G])
          return;
        mt[G] = !0;
        var ee = "";
        m && m._owner && m._owner !== ft.current && (ee = " It was passed a child from " + Z(m._owner.type) + "."), He(m), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ee), He(null);
      }
    }
    function Pt(m, A) {
      {
        if (typeof m != "object")
          return;
        if (ye(m))
          for (var G = 0; G < m.length; G++) {
            var ee = m[G];
            kt(ee) && vt(ee, A);
          }
        else if (kt(m))
          m._store && (m._store.validated = !0);
        else if (m) {
          var ae = b(m);
          if (typeof ae == "function" && ae !== m.entries)
            for (var ue = ae.call(m), se; !(se = ue.next()).done; )
              kt(se.value) && vt(se.value, A);
        }
      }
    }
    function jn(m) {
      {
        var A = m.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var ee = Z(A);
          rt(G, m.props, "prop", ee, m);
        } else if (A.PropTypes !== void 0 && !Et) {
          Et = !0;
          var ae = Z(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(m) {
      {
        for (var A = Object.keys(m.props), G = 0; G < A.length; G++) {
          var ee = A[G];
          if (ee !== "children" && ee !== "key") {
            He(m), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), He(null);
            break;
          }
        }
        m.ref !== null && (He(m), w("Invalid attribute `ref` supplied to `React.Fragment`."), He(null));
      }
    }
    var te = {};
    function Rr(m, A, G, ee, ae, ue) {
      {
        var se = N(m);
        if (!se) {
          var ie = "";
          (m === void 0 || typeof m == "object" && m !== null && Object.keys(m).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var be = St();
          be ? ie += be : ie += gt();
          var de;
          m === null ? de = "null" : ye(m) ? de = "array" : m !== void 0 && m.$$typeof === t ? (de = "<" + (Z(m.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof m, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = dt(m, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Fe = A.children;
          if (Fe !== void 0)
            if (ee)
              if (ye(Fe)) {
                for (var Lt = 0; Lt < Fe.length; Lt++)
                  Pt(Fe[Lt], m);
                Object.freeze && Object.freeze(Fe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Pt(Fe, m);
        }
        if (Pe.call(A, "key")) {
          var bt = Z(m), Ee = Object.keys(A).filter(function(_i) {
            return _i !== "key";
          }), An = Ee.length > 0 ? "{key: someKey, " + Ee.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!te[bt + An]) {
            var Pi = Ee.length > 0 ? "{" + Ee.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, An, bt, Pi, bt), te[bt + An] = !0;
          }
        }
        return m === r ? yt(fe) : jn(fe), fe;
      }
    }
    function Oi(m, A, G) {
      return Rr(m, A, G, !0);
    }
    function Ei(m, A, G) {
      return Rr(m, A, G, !1);
    }
    var ki = Ei, Li = Oi;
    gy.Fragment = r, gy.jsx = ki, gy.jsxs = Li;
  }()), gy;
}
process.env.NODE_ENV === "production" ? hM.exports = TLe() : hM.exports = jLe();
var Ai = hM.exports;
We({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function tU(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Xi(e) {
  var t, n;
  return tU(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(tU(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Ooe = Symbol.for("immer-nothing"), nU = Symbol.for("immer-draftable"), la = Symbol.for("immer-state"), ALe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Cs(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = ALe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Ad = Object.getPrototypeOf;
function Gp(e) {
  return !!e && !!e[la];
}
function Kp(e) {
  var t;
  return e ? Eoe(e) || Array.isArray(e) || !!e[nU] || !!((t = e.constructor) != null && t[nU]) || FO(e) || zO(e) : !1;
}
var ILe = Object.prototype.constructor.toString();
function Eoe(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Ad(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === ILe;
}
function v0(e, t) {
  NO(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function NO(e) {
  const t = e[la];
  return t ? t.type_ : Array.isArray(e) ? 1 : FO(e) ? 2 : zO(e) ? 3 : 0;
}
function gM(e, t) {
  return NO(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function koe(e, t, n) {
  const r = NO(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function BLe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function FO(e) {
  return e instanceof Map;
}
function zO(e) {
  return e instanceof Set;
}
function np(e) {
  return e.copy_ || e.base_;
}
function mM(e, t) {
  if (FO(e))
    return new Map(e);
  if (zO(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Eoe(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[la];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Ad(e), r);
  } else {
    const r = Ad(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function uA(e, t = !1) {
  return UO(e) || Gp(e) || !Kp(e) || (NO(e) > 1 && (e.set = e.add = e.clear = e.delete = RLe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => uA(r, !0))), e;
}
function RLe() {
  Cs(2);
}
function UO(e) {
  return Object.isFrozen(e);
}
var NLe = {};
function Yp(e) {
  const t = NLe[e];
  return t || Cs(0, e), t;
}
var zg;
function Loe() {
  return zg;
}
function FLe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function rU(e, t) {
  t && (Yp("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function vM(e) {
  yM(e), e.drafts_.forEach(zLe), e.drafts_ = null;
}
function yM(e) {
  e === zg && (zg = e.parent_);
}
function oU(e) {
  return zg = FLe(zg, e);
}
function zLe(e) {
  const t = e[la];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function iU(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[la].modified_ && (vM(t), Cs(4)), Kp(e) && (e = y0(t, e), t.parent_ || b0(t, e)), t.patches_ && Yp("Patches").generateReplacementPatches_(
    n[la].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = y0(t, n, []), vM(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== Ooe ? e : void 0;
}
function y0(e, t, n) {
  if (UO(t))
    return t;
  const r = t[la];
  if (!r)
    return v0(
      t,
      (o, i) => sU(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return b0(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), v0(
      i,
      (s, l) => sU(e, r, o, s, l, n, a)
    ), b0(e, o, !1), n && e.patches_ && Yp("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function sU(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Cs(5), Gp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !gM(t.assigned_, r) ? i.concat(r) : void 0, l = y0(e, o, s);
    if (koe(n, r, l), Gp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Kp(o) && !UO(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    y0(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && b0(e, o);
  }
}
function b0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && uA(t, n);
}
function ULe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Loe(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = cA;
  n && (o = [r], i = Ug);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var cA = {
  get(e, t) {
    if (t === la)
      return e;
    const n = np(e);
    if (!gM(n, t))
      return HLe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Kp(r) ? r : r === vL(e.base_, t) ? (yL(e), e.copy_[t] = wM(r, e)) : r;
  },
  has(e, t) {
    return t in np(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(np(e));
  },
  set(e, t, n) {
    const r = Poe(np(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = vL(np(e), t), i = o == null ? void 0 : o[la];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (BLe(n, o) && (n !== void 0 || gM(e.base_, t)))
        return !0;
      yL(e), bM(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return vL(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, yL(e), bM(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = np(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Cs(11);
  },
  getPrototypeOf(e) {
    return Ad(e.base_);
  },
  setPrototypeOf() {
    Cs(12);
  }
}, Ug = {};
v0(cA, (e, t) => {
  Ug[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Ug.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Cs(13), Ug.set.call(this, e, t, void 0);
};
Ug.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Cs(14), cA.set.call(this, e[0], t, n, e[0]);
};
function vL(e, t) {
  const n = e[la];
  return (n ? np(n) : e)[t];
}
function HLe(e, t, n) {
  var r;
  const o = Poe(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Poe(e, t) {
  if (!(t in e))
    return;
  let n = Ad(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Ad(n);
  }
}
function bM(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && bM(e.parent_));
}
function yL(e) {
  e.copy_ || (e.copy_ = mM(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var WLe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Cs(6), r !== void 0 && typeof r != "function" && Cs(7);
      let o;
      if (Kp(t)) {
        const i = oU(this), a = wM(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? vM(i) : yM(i);
        }
        return rU(i, r), iU(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === Ooe && (o = void 0), this.autoFreeze_ && uA(o, !0), r) {
          const i = [], a = [];
          Yp("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Cs(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Kp(e) || Cs(8), Gp(e) && (e = VLe(e));
    const t = oU(this), n = wM(e, void 0);
    return n[la].isManual_ = !0, yM(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[la];
    (!n || !n.isManual_) && Cs(9);
    const { scope_: r } = n;
    return rU(r, t), iU(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Yp("Patches").applyPatches_;
    return Gp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function wM(e, t) {
  const n = FO(e) ? Yp("MapSet").proxyMap_(e, t) : zO(e) ? Yp("MapSet").proxySet_(e, t) : ULe(e, t);
  return (t ? t.scope_ : Loe()).drafts_.push(n), n;
}
function VLe(e) {
  return Gp(e) || Cs(10, e), _oe(e);
}
function _oe(e) {
  if (!Kp(e) || UO(e))
    return e;
  const t = e[la];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = mM(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = mM(e, !0);
  return v0(n, (r, o) => {
    koe(n, r, _oe(o));
  }), t && (t.finalized_ = !1), n;
}
var ua = new WLe(), pA = ua.produce;
ua.produceWithPatches.bind(
  ua
);
ua.setAutoFreeze.bind(ua);
ua.setUseStrictShallowCopy.bind(ua);
ua.applyPatches.bind(ua);
var aU = ua.createDraft.bind(ua), lU = ua.finishDraft.bind(ua), et = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = et.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return et.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return et.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return et.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return et.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && et.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return et.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && et.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && et.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && et.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && et.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && et.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!et.isAncestor(t, e) && !et.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (et.equals(i, r) || et.endsBefore(i, r) || et.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (et.equals(a, r) || et.isAncestor(a, r))
          return null;
        et.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        et.equals(s, r) || et.endsBefore(s, r) ? r[s.length - 1] -= 1 : et.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (et.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else et.endsBefore(u, r) ? r[u.length - 1] += 1 : et.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (et.equals(p, d))
          return r;
        if (et.isAncestor(p, r) || et.equals(p, r)) {
          var g = d.slice();
          return et.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else et.isSibling(p, d) && (et.isAncestor(d, r) || et.equals(d, r)) ? et.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : et.endsBefore(d, r) || et.equals(d, r) || et.isAncestor(d, r) ? (et.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : et.endsBefore(p, r) && (et.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Hg(e) {
  "@babel/helpers - typeof";
  return Hg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Hg(e);
}
function $Le(e, t) {
  if (Hg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Hg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function ZLe(e) {
  var t = $Le(e, "string");
  return Hg(t) === "symbol" ? t : String(t);
}
function $d(e, t, n) {
  return t = ZLe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function uU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uU(Object(n), !0).forEach(function(r) {
      $d(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qLe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Bt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of tn.points(t))
          t[l] = Xr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Bt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [y, b] of tn.points(t))
          t[b] = Xr.transform(y, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Bt.get(e, E), M = et.previous(E), O = Bt.get(e, M), v = Bt.parent(e, E), x = E[E.length - 1];
      if (Jo.isText(w) && Jo.isText(O))
        O.text += w.text;
      else if (!Jo.isText(w) && !Jo.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Ns.stringify(w), " ").concat(Ns.stringify(O)));
      if (v.children.splice(x, 1), t)
        for (var [_, z] of tn.points(t))
          t[z] = Xr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (et.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = Bt.get(e, L), V = Bt.parent(e, L), Z = L[L.length - 1];
      V.children.splice(Z, 1);
      var H = et.transform(L, n), $ = Bt.get(e, et.parent(H)), K = H[H.length - 1];
      if ($.children.splice(K, 0, R), t)
        for (var [X, Q] of tn.points(t))
          t[Q] = Xr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = Bt.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [F, S] of tn.points(t)) {
          var W = Xr.transform(F, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var C = void 0, I = void 0;
            for (var [U, T] of Bt.texts(e))
              if (et.compare(T, J) === -1)
                C = [U, T];
              else {
                I = [U, T];
                break;
              }
            var q = !1;
            C && I && (et.equals(I[1], J) ? q = !et.hasPrevious(I[1]) : q = et.common(C[1], J).length < et.common(I[1], J).length), C && !q ? (F.path = C[1], F.offset = C[0].text.length) : I ? (F.path = I[1], F.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: j,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = Bt.leaf(e, j), he = le.text.slice(0, Y), oe = le.text.slice(Y + B.length);
      if (le.text = he + oe, t)
        for (var [Pe, Ue] of tn.points(t))
          t[Ue] = Xr.transform(Pe, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: _e,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Bt.get(e, Ze);
      for (var ye in rt) {
        if (ye === "children" || ye === "text")
          throw new Error('Cannot set the "'.concat(ye, '" property of nodes!'));
        var Ge = rt[ye];
        Ge == null ? delete Ve[ye] : Ve[ye] = Ge;
      }
      for (var ct in _e)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ve
      } = n;
      if (ve == null)
        t = ve;
      else {
        if (t == null) {
          if (!tn.isRange(ve))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Ns.stringify(ve), " when there is no current selection."));
          t = Pf({}, ve);
        }
        for (var Oe in ve) {
          var qe = ve[Oe];
          if (qe == null) {
            if (Oe === "anchor" || Oe === "focus")
              throw new Error('Cannot remove the "'.concat(Oe, '" selection property'));
            delete t[Oe];
          } else
            t[Oe] = qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Se,
        properties: st
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var xe = Bt.get(e, ze), xt = Bt.parent(e, ze), at = ze[ze.length - 1], lt;
      if (Jo.isText(xe)) {
        var pt = xe.text.slice(0, Se), Ot = xe.text.slice(Se);
        xe.text = pt, lt = Pf(Pf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = xe.children.slice(0, Se), ft = xe.children.slice(Se);
        xe.children = dt, lt = Pf(Pf({}, st), {}, {
          children: ft
        });
      }
      if (xt.children.splice(at + 1, 0, lt), t)
        for (var [ot, He] of tn.points(t))
          t[He] = Xr.transform(ot, n);
      break;
    }
  }
  return t;
}, GLe = {
  transform(e, t) {
    e.children = aU(e.children);
    var n = e.selection && aU(e.selection);
    try {
      n = qLe(e, n, t);
    } finally {
      e.children = lU(e.children), n ? e.selection = Gp(n) ? lU(n) : n : e.selection = null;
    }
  }
}, KLe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, YLe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Soe = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Xi(r) && Xi(o)) {
      if (!Soe(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function XLe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Wg(e, t) {
  if (e == null) return {};
  var n = XLe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var JLe = ["anchor", "focus"];
function cU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function QLe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cU(Object(n), !0).forEach(function(r) {
      $d(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tn = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return tn.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = tn.edges(e);
    return t;
  },
  equals(e, t) {
    return Xr.equals(e.anchor, t.anchor) && Xr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (tn.isRange(t)) {
      if (tn.includes(e, t.anchor) || tn.includes(e, t.focus))
        return !0;
      var [n, r] = tn.edges(e), [o, i] = tn.edges(t);
      return Xr.isBefore(n, o) && Xr.isAfter(r, i);
    }
    var [a, s] = tn.edges(e), l = !1, u = !1;
    return Xr.isPoint(t) ? (l = Xr.compare(t, a) >= 0, u = Xr.compare(t, s) <= 0) : (l = et.compare(t, a.path) >= 0, u = et.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Wg(e, JLe), [r, o] = tn.edges(e), [i, a] = tn.edges(t), s = Xr.isBefore(r, i) ? i : r, l = Xr.isBefore(o, a) ? o : a;
    return Xr.isBefore(l, s) ? null : QLe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Xr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Xr.equals(t, n);
  },
  isExpanded(e) {
    return !tn.isCollapsed(e);
  },
  isForward(e) {
    return !tn.isBackward(e);
  },
  isRange(e) {
    return Xi(e) && Xr.isPoint(e.anchor) && Xr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = tn.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return pA(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = tn.isCollapsed(r);
        tn.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? tn.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Xr.transform(r.anchor, t, {
        affinity: i
      }), u = Xr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, pU = (e) => Xi(e) && Bt.isNodeList(e.children) && !Er.isEditor(e), Il = {
  isAncestor(e) {
    return Xi(e) && Bt.isNodeList(e.children);
  },
  isElement: pU,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Il.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return pU(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, e1e = ["children"], t1e = ["text"], dU = /* @__PURE__ */ new WeakMap(), Bt = {
  ancestor(e, t) {
    var n = Bt.get(e, t);
    if (Jo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Ns.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of et.ancestors(t, n)) {
        var o = Bt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Jo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Ns.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Ns.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Bt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Bt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = et.common(t, n), o = Bt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Bt.get(e, t);
    if (Er.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Ns.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Bt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Bt.nodes(e, t))
        Il.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Il.isAncestor(e)) {
      var t = Wg(e, e1e);
      return t;
    } else {
      var t = Wg(e, t1e);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Bt.get(e, n); r && !(Jo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Jo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Ns.stringify(e)));
    var n = pA({
      children: e.children
    }, (r) => {
      var [o, i] = tn.edges(t), a = Bt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !tn.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!tn.includes(t, s)) {
          var l = Bt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (et.equals(s, i.path)) {
          var c = Bt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (et.equals(s, o.path)) {
          var p = Bt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Er.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Jo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Ns.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Jo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Jo.isText(e) || Il.isElement(e) || Er.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = dU.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Bt.isNode(r));
    return dU.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Bt.get(e, n); r && !(Jo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Bt.get(e, t);
    if (!Jo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Ns.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of et.levels(t, n)) {
        var o = Bt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Il.isElement(e) && Il.isElementProps(t) && Il.matches(e, t) || Jo.isText(e) && Jo.isTextProps(t) && Jo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? et.isBefore(s, i) : et.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Jo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          et.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Bt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = et.next(s);
          if (Bt.has(e, c)) {
            s = c, l = Bt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = et.previous(s);
          s = p, l = Bt.get(e, s);
          continue;
        }
        s = et.parent(s), l = Bt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = et.parent(t), r = Bt.get(e, n);
    if (Jo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Jo.isText(e) ? e.text : e.children.map(Bt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Bt.nodes(e, t))
        Jo.isText(n) && (yield [n, r]);
    }();
  }
};
function fU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function so(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fU(Object(n), !0).forEach(function(r) {
      $d(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yh = {
  isNodeOperation(e) {
    return yh.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Xi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return et.isPath(e.path) && Bt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && et.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && et.isPath(e.path) && Xi(e.properties);
      case "move_node":
        return et.isPath(e.path) && et.isPath(e.newPath);
      case "remove_node":
        return et.isPath(e.path) && Bt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && et.isPath(e.path);
      case "set_node":
        return et.isPath(e.path) && Xi(e.properties) && Xi(e.newProperties);
      case "set_selection":
        return e.properties === null && tn.isRange(e.newProperties) || e.newProperties === null && tn.isRange(e.properties) || Xi(e.properties) && Xi(e.newProperties);
      case "split_node":
        return et.isPath(e.path) && typeof e.position == "number" && Xi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => yh.isOperation(t));
  },
  isSelectionOperation(e) {
    return yh.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return yh.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return so(so({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return so(so({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return so(so({}, e), {}, {
          type: "split_node",
          path: et.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (et.equals(t, n))
          return e;
        if (et.isSibling(n, t))
          return so(so({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = et.transform(n, e), o = et.transform(et.next(n), e);
        return so(so({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return so(so({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return so(so({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return so(so({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? so(so({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? so(so({}, e), {}, {
          properties: null,
          newProperties: s
        }) : so(so({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return so(so({}, e), {}, {
          type: "merge_node",
          path: et.next(e.path)
        });
    }
  }
}, hU = /* @__PURE__ */ new WeakMap(), n1e = (e) => {
  var t = hU.get(e);
  if (t !== void 0)
    return t;
  if (!Xi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Xi(e.marks)) && (e.selection === null || tn.isRange(e.selection)) && Bt.isNodeList(e.children) && yh.isOperationList(e.operations);
  return hU.set(e, n), n;
}, Er = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return n1e(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function gU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gU(Object(n), !0).forEach(function(r) {
      $d(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xr = {
  compare(e, t) {
    var n = et.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Xr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Xr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && et.equals(e.path, t.path);
  },
  isPoint(e) {
    return Xi(e) && typeof e.offset == "number" && et.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return pA(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = et.transform(i, t, n);
          break;
        }
        case "insert_text": {
          et.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          et.equals(t.path, i) && (r.offset += t.position), r.path = et.transform(i, t, n);
          break;
        }
        case "remove_text": {
          et.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (et.equals(t.path, i) || et.isAncestor(t.path, i))
            return null;
          r.path = et.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (et.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = et.transform(i, t, mU(mU({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = et.transform(i, t, n);
          break;
        }
      }
    });
  }
}, vU = void 0, Ns = {
  setScrubber(e) {
    vU = e;
  },
  stringify(e) {
    return JSON.stringify(e, vU);
  }
}, r1e = ["text"], o1e = ["anchor", "focus"];
function yU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yU(Object(n), !0).forEach(function(r) {
      $d(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Wg(i, r1e);
      return a;
    }
    return Soe(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Xi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Jo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [yl({}, e)];
    for (var r of t) {
      var o = Wg(r, o1e), [i, a] = tn.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, y = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = yl(yl({}, f), {}, {
            text: f.text.slice(E)
          }), f = yl(yl({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          y = yl(yl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = yl(yl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), y && s.push(y), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, i1e = (e) => e.selection ? e.selection : e.children.length > 0 ? Er.end(e, []) : [0], Wr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Wr || (Wr = {}));
Wr.L, Wr.L | Wr.V | Wr.LV | Wr.LVT, Wr.LV | Wr.V, Wr.V | Wr.T, Wr.LVT | Wr.T, Wr.T, Wr.Any, Wr.Extend | Wr.ZWJ, Wr.Any, Wr.SpacingMark, Wr.Prepend, Wr.Any, Wr.ZWJ, Wr.ExtPict, Wr.RI, Wr.RI;
var s1e = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Er.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = i1e(e)
      } = n;
      if (et.isPath(o) && (o = Er.range(e, o)), tn.isRange(o))
        if (tn.isCollapsed(o))
          o = o.anchor;
        else {
          var i = tn.end(o);
          if (!r && Er.void(e, {
            at: i
          }))
            return;
          var a = tn.start(o), s = Er.pointRef(e, a), l = Er.pointRef(e, i);
          w0.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, w0.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Er.void(e, {
        at: o
      }) || Er.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function bU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function my(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bU(Object(n), !0).forEach(function(r) {
      $d(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var w0 = my(my(my(my({}, GLe), KLe), YLe), s1e), Moe = {}, dA = {}, fA = {}, ud = {}, hA = {}, gA = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(gA);
var dn = {}, gc = jr && jr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Rh = jr && jr.__assign || function() {
  return Rh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Rh.apply(this, arguments);
};
Object.defineProperty(dn, "__esModule", { value: !0 });
dn.cloneNode = dn.hasChildren = dn.isDocument = dn.isDirective = dn.isComment = dn.isText = dn.isCDATA = dn.isTag = dn.Element = dn.Document = dn.CDATA = dn.NodeWithChildren = dn.ProcessingInstruction = dn.Comment = dn.Text = dn.DataNode = dn.Node = void 0;
var Ms = gA, mA = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), vA(this, t);
    }, e;
  }()
);
dn.Node = mA;
var HO = (
  /** @class */
  function(e) {
    gc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(mA)
);
dn.DataNode = HO;
var Doe = (
  /** @class */
  function(e) {
    gc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ms.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(HO)
);
dn.Text = Doe;
var Toe = (
  /** @class */
  function(e) {
    gc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ms.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(HO)
);
dn.Comment = Toe;
var joe = (
  /** @class */
  function(e) {
    gc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ms.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(HO)
);
dn.ProcessingInstruction = joe;
var WO = (
  /** @class */
  function(e) {
    gc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(mA)
);
dn.NodeWithChildren = WO;
var Aoe = (
  /** @class */
  function(e) {
    gc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ms.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(WO)
);
dn.CDATA = Aoe;
var Ioe = (
  /** @class */
  function(e) {
    gc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ms.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(WO)
);
dn.Document = Ioe;
var Boe = (
  /** @class */
  function(e) {
    gc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ms.ElementType.Script : n === "style" ? Ms.ElementType.Style : Ms.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(WO)
);
dn.Element = Boe;
function Roe(e) {
  return (0, Ms.isTag)(e);
}
dn.isTag = Roe;
function Noe(e) {
  return e.type === Ms.ElementType.CDATA;
}
dn.isCDATA = Noe;
function Foe(e) {
  return e.type === Ms.ElementType.Text;
}
dn.isText = Foe;
function zoe(e) {
  return e.type === Ms.ElementType.Comment;
}
dn.isComment = zoe;
function Uoe(e) {
  return e.type === Ms.ElementType.Directive;
}
dn.isDirective = Uoe;
function Hoe(e) {
  return e.type === Ms.ElementType.Root;
}
dn.isDocument = Hoe;
function a1e(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
dn.hasChildren = a1e;
function vA(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (Foe(e))
    n = new Doe(e.data);
  else if (zoe(e))
    n = new Toe(e.data);
  else if (Roe(e)) {
    var r = t ? bL(e.children) : [], o = new Boe(e.name, Rh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Rh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Rh({}, e["x-attribsPrefix"])), n = o;
  } else if (Noe(e)) {
    var r = t ? bL(e.children) : [], i = new Aoe(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (Hoe(e)) {
    var r = t ? bL(e.children) : [], a = new Ioe(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (Uoe(e)) {
    var s = new joe(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
dn.cloneNode = vA;
function bL(e) {
  for (var t = e.map(function(r) {
    return vA(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = jr && jr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = jr && jr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = gA, o = dn;
  n(dn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(hA);
var Woe = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(Woe);
Object.defineProperty(ud, "__esModule", { value: !0 });
ud.formatAttributes = Voe;
ud.escapeSpecialCharacters = c1e;
ud.revertEscapedCharacters = $oe;
ud.formatDOM = Zoe;
var vy = hA, Vg = Woe;
function l1e(e) {
  return Vg.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function Voe(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function u1e(e) {
  e = e.toLowerCase();
  var t = l1e(e);
  return t || e;
}
function c1e(e) {
  return e.replace(Vg.CARRIAGE_RETURN_REGEX, Vg.CARRIAGE_RETURN_PLACEHOLDER);
}
function $oe(e) {
  return e.replace(Vg.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Vg.CARRIAGE_RETURN);
}
function Zoe(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = u1e(s.nodeName);
        o = new vy.Element(l, Voe(s.attributes)), o.children = Zoe(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new vy.Text($oe(s.nodeValue));
        break;
      case 8:
        o = new vy.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new vy.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(fA, "__esModule", { value: !0 });
fA.default = g1e;
var p1e = ud, wU = "html", CU = "head", yy = "body", d1e = /<([a-zA-Z]+[0-9]?)/, xU = /<head[^]*>/i, OU = /<body[^]*>/i, C0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, CM = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, EU = typeof window == "object" && window.DOMParser;
if (typeof EU == "function") {
  var f1e = new EU(), h1e = "text/html";
  CM = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), f1e.parseFromString(e, h1e);
  }, C0 = CM;
}
if (typeof document == "object" && document.implementation) {
  var by = document.implementation.createHTMLDocument();
  C0 = function(e, t) {
    if (t) {
      var n = by.documentElement.querySelector(t);
      return n && (n.innerHTML = e), by;
    }
    return by.documentElement.innerHTML = e, by;
  };
}
var wy = typeof document == "object" && document.createElement("template"), xM;
wy && wy.content && (xM = function(e) {
  return wy.innerHTML = e, wy.content.childNodes;
});
function g1e(e) {
  var t, n;
  e = (0, p1e.escapeSpecialCharacters)(e);
  var r = e.match(d1e), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case wU: {
      var i = CM(e);
      if (!xU.test(e)) {
        var a = i.querySelector(CU);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!OU.test(e)) {
        var a = i.querySelector(yy);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(wU);
    }
    case CU:
    case yy: {
      var s = C0(e).querySelectorAll(o);
      return OU.test(e) && xU.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (xM)
        return xM(e);
      var a = C0(e, yy).querySelector(yy);
      return a.childNodes;
    }
  }
}
var m1e = jr && jr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(dA, "__esModule", { value: !0 });
dA.default = w1e;
var v1e = m1e(fA), y1e = ud, b1e = /<(![a-zA-Z\s]+)>/;
function w1e(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(b1e), n = t ? t[1] : void 0;
  return (0, y1e.formatDOM)((0, v1e.default)(e), null, n);
}
var VO = {}, Ta = {}, $O = {}, C1e = 0;
$O.SAME = C1e;
var x1e = 1;
$O.CAMELCASE = x1e;
$O.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const qoe = 0, mc = 1, ZO = 2, qO = 3, yA = 4, Goe = 5, Koe = 6;
function O1e(e) {
  return Wi.hasOwnProperty(e) ? Wi[e] : null;
}
function cs(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === ZO || t === qO || t === yA, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Wi = {}, E1e = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
E1e.forEach((e) => {
  Wi[e] = new cs(
    e,
    qoe,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Wi[e] = new cs(
    e,
    mc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Wi[e] = new cs(
    e,
    ZO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Wi[e] = new cs(
    e,
    ZO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Wi[e] = new cs(
    e,
    qO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Wi[e] = new cs(
    e,
    qO,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Wi[e] = new cs(
    e,
    yA,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Wi[e] = new cs(
    e,
    Koe,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Wi[e] = new cs(
    e,
    Goe,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const bA = /[\-\:]([a-z])/g, wA = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(bA, wA);
  Wi[t] = new cs(
    t,
    mc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(bA, wA);
  Wi[t] = new cs(
    t,
    mc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(bA, wA);
  Wi[t] = new cs(
    t,
    mc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Wi[e] = new cs(
    e,
    mc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const k1e = "xlinkHref";
Wi[k1e] = new cs(
  "xlinkHref",
  mc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Wi[e] = new cs(
    e,
    mc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: L1e,
  SAME: P1e,
  possibleStandardNames: kU
} = $O, _1e = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", S1e = _1e + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", M1e = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + S1e + "]*$")
), D1e = Object.keys(
  kU
).reduce((e, t) => {
  const n = kU[t];
  return n === P1e ? e[t] = t : n === L1e ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Ta.BOOLEAN = qO;
Ta.BOOLEANISH_STRING = ZO;
Ta.NUMERIC = Goe;
Ta.OVERLOADED_BOOLEAN = yA;
Ta.POSITIVE_NUMERIC = Koe;
Ta.RESERVED = qoe;
Ta.STRING = mc;
Ta.getPropertyInfo = O1e;
Ta.isCustomAttribute = M1e;
Ta.possibleStandardNames = D1e;
var CA = {}, xA = {}, LU = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, T1e = /\n/g, j1e = /^\s*/, A1e = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, I1e = /^:\s*/, B1e = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, R1e = /^[;\s]*/, N1e = /^\s+|\s+$/g, F1e = `
`, PU = "/", _U = "*", dp = "", z1e = "comment", U1e = "declaration", H1e = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var y = f.match(T1e);
    y && (n += y.length);
    var b = f.lastIndexOf(F1e);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(y) {
      return y.position = new a(f), u(), y;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var y = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (y.reason = f, y.filename = t.source, y.line = n, y.column = r, y.source = e, !t.silent) throw y;
  }
  function l(f) {
    var y = f.exec(e);
    if (y) {
      var b = y[0];
      return o(b), e = e.slice(b.length), y;
    }
  }
  function u() {
    l(j1e);
  }
  function c(f) {
    var y;
    for (f = f || []; y = p(); )
      y !== !1 && f.push(y);
    return f;
  }
  function p() {
    var f = i();
    if (!(PU != e.charAt(0) || _U != e.charAt(1))) {
      for (var y = 2; dp != e.charAt(y) && (_U != e.charAt(y) || PU != e.charAt(y + 1)); )
        ++y;
      if (y += 2, dp === e.charAt(y - 1))
        return s("End of comment missing");
      var b = e.slice(2, y - 2);
      return r += 2, o(b), e = e.slice(y), r += 2, f({
        type: z1e,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), y = l(A1e);
    if (y) {
      if (p(), !l(I1e)) return s("property missing ':'");
      var b = l(B1e), E = f({
        type: U1e,
        property: SU(y[0].replace(LU, dp)),
        value: b ? SU(b[0].replace(LU, dp)) : dp
      });
      return l(R1e), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var y; y = d(); )
      y !== !1 && (f.push(y), c(f));
    return f;
  }
  return u(), g();
};
function SU(e) {
  return e ? e.replace(N1e, dp) : dp;
}
var W1e = jr && jr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(xA, "__esModule", { value: !0 });
xA.default = $1e;
var V1e = W1e(H1e);
function $1e(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, V1e.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var GO = {};
Object.defineProperty(GO, "__esModule", { value: !0 });
GO.camelCase = void 0;
var Z1e = /^--[a-zA-Z0-9_-]+$/, q1e = /-([a-z])/g, G1e = /^[^-]+$/, K1e = /^-(webkit|moz|ms|o|khtml)-/, Y1e = /^-(ms)-/, X1e = function(e) {
  return !e || G1e.test(e) || Z1e.test(e);
}, J1e = function(e, t) {
  return t.toUpperCase();
}, MU = function(e, t) {
  return "".concat(t, "-");
}, Q1e = function(e, t) {
  return t === void 0 && (t = {}), X1e(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Y1e, MU) : e = e.replace(K1e, MU), e.replace(q1e, J1e));
};
GO.camelCase = Q1e;
var ePe = jr && jr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, tPe = ePe(xA), nPe = GO;
function OM(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, tPe.default)(e, function(r, o) {
    r && o && (n[(0, nPe.camelCase)(r, t)] = o);
  }), n;
}
OM.default = OM;
var rPe = OM;
(function(e) {
  var t = jr && jr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(rPe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(CA);
Object.defineProperty(VO, "__esModule", { value: !0 });
VO.default = aPe;
var bh = Ta, DU = CA, oPe = ["checked", "value"], iPe = ["input", "select", "textarea"], sPe = {
  reset: !0,
  submit: !0
};
function aPe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && sPe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, bh.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = TU(a);
    if (s) {
      var l = (0, bh.getPropertyInfo)(s);
      switch (oPe.includes(s) && iPe.includes(t) && !r && (s = TU("default" + a)), n[s] = i, l && l.type) {
        case bh.BOOLEAN:
          n[s] = !0;
          break;
        case bh.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    DU.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, DU.setStyleProp)(e.style, n), n;
}
function TU(e) {
  return bh.possibleStandardNames[e];
}
var OA = {}, lPe = jr && jr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(OA, "__esModule", { value: !0 });
OA.default = Yoe;
var wL = we, uPe = lPe(VO), Nh = CA, cPe = {
  cloneElement: wL.cloneElement,
  createElement: wL.createElement,
  isValidElement: wL.isValidElement
};
function Yoe(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Nh.returnFirstArg, i = t.library || cPe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Nh.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, y = {};
    pPe(f) ? ((0, Nh.setStyleProp)(f.attribs.style, f.attribs), y = f.attribs) : f.attribs && (y = (0, uPe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (y.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? y.defaultValue = p.children[0].data : p.children && p.children.length && (b = Yoe(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (y.key = c), n.push(o(s(p.name, y, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function pPe(e) {
  return Nh.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Nh.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = jr && jr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(dA);
  e.htmlToDOM = n.default;
  var r = t(VO);
  e.attributesToProps = r.default;
  var o = t(OA);
  e.domToReact = o.default;
  var i = hA;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(Moe);
const dPe = /* @__PURE__ */ DLe(Moe);
dPe.default;
var Ar = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function fPe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var EM = { exports: {} }, _f = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jU;
function hPe() {
  if (jU) return _f;
  jU = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return _f.Fragment = n, _f.jsx = a, _f.jsxs = a, _f;
}
var Cy = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var AU;
function gPe() {
  return AU || (AU = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, y = "@@iterator";
    function b(m) {
      if (m === null || typeof m != "object")
        return null;
      var A = f && m[f] || m[y];
      return typeof A == "function" ? A : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(m) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), ee = 1; ee < A; ee++)
          G[ee - 1] = arguments[ee];
        M("error", m, G);
      }
    }
    function M(m, A, G) {
      {
        var ee = E.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[m], console, ue);
      }
    }
    var O = !1, v = !1, x = !1, _ = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function N(m) {
      return !!(typeof m == "string" || typeof m == "function" || m === r || m === i || z || m === o || m === u || m === c || _ || m === g || O || v || x || typeof m == "object" && m !== null && (m.$$typeof === d || m.$$typeof === p || m.$$typeof === a || m.$$typeof === s || m.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      m.$$typeof === L || m.getModuleId !== void 0));
    }
    function R(m, A, G) {
      var ee = m.displayName;
      if (ee)
        return ee;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(m) {
      return m.displayName || "Context";
    }
    function Z(m) {
      if (m == null)
        return null;
      if (typeof m.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof m == "function")
        return m.displayName || m.name || null;
      if (typeof m == "string")
        return m;
      switch (m) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case s:
            var A = m;
            return V(A) + ".Consumer";
          case a:
            var G = m;
            return V(G._context) + ".Provider";
          case l:
            return R(m, m.render, "ForwardRef");
          case p:
            var ee = m.displayName || null;
            return ee !== null ? ee : Z(m.type) || "Memo";
          case d: {
            var ae = m, ue = ae._payload, se = ae._init;
            try {
              return Z(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, $ = 0, K, X, Q, J, P, D, F;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if ($ === 0) {
          K = console.log, X = console.info, Q = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, F = console.groupEnd;
          var m = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: m,
            log: m,
            warn: m,
            error: m,
            group: m,
            groupCollapsed: m,
            groupEnd: m
          });
        }
        $++;
      }
    }
    function C() {
      {
        if ($--, $ === 0) {
          var m = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, m, {
              value: K
            }),
            info: H({}, m, {
              value: X
            }),
            warn: H({}, m, {
              value: Q
            }),
            error: H({}, m, {
              value: J
            }),
            group: H({}, m, {
              value: P
            }),
            groupCollapsed: H({}, m, {
              value: D
            }),
            groupEnd: H({}, m, {
              value: F
            })
          });
        }
        $ < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = E.ReactCurrentDispatcher, U;
    function T(m, A, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            U = ee && ee[1] || "";
          }
        return `
` + U + m;
      }
    }
    var q = !1, j;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      j = new Y();
    }
    function B(m, A) {
      if (!m || q)
        return "";
      {
        var G = j.get(m);
        if (G !== void 0)
          return G;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Ee) {
              ee = Ee;
            }
            Reflect.construct(m, [], se);
          } else {
            try {
              se.call();
            } catch (Ee) {
              ee = Ee;
            }
            m.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ee) {
            ee = Ee;
          }
          m();
        }
      } catch (Ee) {
        if (Ee && ee && typeof Ee.stack == "string") {
          for (var ie = Ee.stack.split(`
`), be = ee.stack.split(`
`), de = ie.length - 1, fe = be.length - 1; de >= 1 && fe >= 0 && ie[de] !== be[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== be[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== be[fe]) {
                    var Fe = `
` + ie[de].replace(" at new ", " at ");
                    return m.displayName && Fe.includes("<anonymous>") && (Fe = Fe.replace("<anonymous>", m.displayName)), typeof m == "function" && j.set(m, Fe), Fe;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, C(), Error.prepareStackTrace = ae;
      }
      var Lt = m ? m.displayName || m.name : "", bt = Lt ? T(Lt) : "";
      return typeof m == "function" && j.set(m, bt), bt;
    }
    function le(m, A, G) {
      return B(m, !1);
    }
    function he(m) {
      var A = m.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(m, A, G) {
      if (m == null)
        return "";
      if (typeof m == "function")
        return B(m, he(m));
      if (typeof m == "string")
        return T(m);
      switch (m) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case l:
            return le(m.render);
          case p:
            return oe(m.type, A, G);
          case d: {
            var ee = m, ae = ee._payload, ue = ee._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Pe = Object.prototype.hasOwnProperty, Ue = {}, Ze = E.ReactDebugCurrentFrame;
    function _e(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        Ze.setExtraStackFrame(G);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(m, A, G, ee, ae) {
      {
        var ue = Function.call.bind(Pe);
        for (var se in m)
          if (ue(m, se)) {
            var ie = void 0;
            try {
              if (typeof m[se] != "function") {
                var be = Error((ee || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof m[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw be.name = "Invariant Violation", be;
              }
              ie = m[se](A, se, ee, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (_e(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", G, se, typeof ie), _e(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, _e(ae), w("Failed %s type: %s", G, ie.message), _e(null));
          }
      }
    }
    var Ve = Array.isArray;
    function ye(m) {
      return Ve(m);
    }
    function Ge(m) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && m[Symbol.toStringTag] || m.constructor.name || "Object";
        return G;
      }
    }
    function ct(m) {
      try {
        return ve(m), !1;
      } catch {
        return !0;
      }
    }
    function ve(m) {
      return "" + m;
    }
    function Oe(m) {
      if (ct(m))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ge(m)), ve(m);
    }
    var qe = E.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Se, st;
    function xe(m) {
      if (Pe.call(m, "ref")) {
        var A = Object.getOwnPropertyDescriptor(m, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.ref !== void 0;
    }
    function xt(m) {
      if (Pe.call(m, "key")) {
        var A = Object.getOwnPropertyDescriptor(m, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.key !== void 0;
    }
    function at(m, A) {
      typeof m.ref == "string" && qe.current;
    }
    function lt(m, A) {
      {
        var G = function() {
          Se || (Se = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function pt(m, A) {
      {
        var G = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(m, A, G, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: m,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function dt(m, A, G, ee, ae) {
      {
        var ue, se = {}, ie = null, be = null;
        G !== void 0 && (Oe(G), ie = "" + G), xt(A) && (Oe(A.key), ie = "" + A.key), xe(A) && (be = A.ref, at(A));
        for (ue in A)
          Pe.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (m && m.defaultProps) {
          var de = m.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || be) {
          var fe = typeof m == "function" ? m.displayName || m.name || "Unknown" : m;
          ie && lt(se, fe), be && pt(se, fe);
        }
        return Ot(m, ie, be, ae, ee, qe.current, se);
      }
    }
    var ft = E.ReactCurrentOwner, ot = E.ReactDebugCurrentFrame;
    function He(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        ot.setExtraStackFrame(G);
      } else
        ot.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(m) {
      return typeof m == "object" && m !== null && m.$$typeof === t;
    }
    function gt() {
      {
        if (ft.current) {
          var m = Z(ft.current.type);
          if (m)
            return `

Check the render method of \`` + m + "`.";
        }
        return "";
      }
    }
    function St(m) {
      return "";
    }
    var mt = {};
    function Mt(m) {
      {
        var A = gt();
        if (!A) {
          var G = typeof m == "string" ? m : m.displayName || m.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function vt(m, A) {
      {
        if (!m._store || m._store.validated || m.key != null)
          return;
        m._store.validated = !0;
        var G = Mt(A);
        if (mt[G])
          return;
        mt[G] = !0;
        var ee = "";
        m && m._owner && m._owner !== ft.current && (ee = " It was passed a child from " + Z(m._owner.type) + "."), He(m), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ee), He(null);
      }
    }
    function Pt(m, A) {
      {
        if (typeof m != "object")
          return;
        if (ye(m))
          for (var G = 0; G < m.length; G++) {
            var ee = m[G];
            kt(ee) && vt(ee, A);
          }
        else if (kt(m))
          m._store && (m._store.validated = !0);
        else if (m) {
          var ae = b(m);
          if (typeof ae == "function" && ae !== m.entries)
            for (var ue = ae.call(m), se; !(se = ue.next()).done; )
              kt(se.value) && vt(se.value, A);
        }
      }
    }
    function jn(m) {
      {
        var A = m.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var ee = Z(A);
          rt(G, m.props, "prop", ee, m);
        } else if (A.PropTypes !== void 0 && !Et) {
          Et = !0;
          var ae = Z(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(m) {
      {
        for (var A = Object.keys(m.props), G = 0; G < A.length; G++) {
          var ee = A[G];
          if (ee !== "children" && ee !== "key") {
            He(m), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), He(null);
            break;
          }
        }
        m.ref !== null && (He(m), w("Invalid attribute `ref` supplied to `React.Fragment`."), He(null));
      }
    }
    var te = {};
    function Rr(m, A, G, ee, ae, ue) {
      {
        var se = N(m);
        if (!se) {
          var ie = "";
          (m === void 0 || typeof m == "object" && m !== null && Object.keys(m).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var be = St();
          be ? ie += be : ie += gt();
          var de;
          m === null ? de = "null" : ye(m) ? de = "array" : m !== void 0 && m.$$typeof === t ? (de = "<" + (Z(m.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof m, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = dt(m, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Fe = A.children;
          if (Fe !== void 0)
            if (ee)
              if (ye(Fe)) {
                for (var Lt = 0; Lt < Fe.length; Lt++)
                  Pt(Fe[Lt], m);
                Object.freeze && Object.freeze(Fe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Pt(Fe, m);
        }
        if (Pe.call(A, "key")) {
          var bt = Z(m), Ee = Object.keys(A).filter(function(_i) {
            return _i !== "key";
          }), An = Ee.length > 0 ? "{key: someKey, " + Ee.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!te[bt + An]) {
            var Pi = Ee.length > 0 ? "{" + Ee.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, An, bt, Pi, bt), te[bt + An] = !0;
          }
        }
        return m === r ? yt(fe) : jn(fe), fe;
      }
    }
    function Oi(m, A, G) {
      return Rr(m, A, G, !0);
    }
    function Ei(m, A, G) {
      return Rr(m, A, G, !1);
    }
    var ki = Ei, Li = Oi;
    Cy.Fragment = r, Cy.jsx = ki, Cy.jsxs = Li;
  }()), Cy;
}
process.env.NODE_ENV === "production" ? EM.exports = hPe() : EM.exports = gPe();
var Ii = EM.exports;
We({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function IU(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Ji(e) {
  var t, n;
  return IU(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(IU(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Xoe = Symbol.for("immer-nothing"), BU = Symbol.for("immer-draftable"), ca = Symbol.for("immer-state"), mPe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function xs(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = mPe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Id = Object.getPrototypeOf;
function Xp(e) {
  return !!e && !!e[ca];
}
function Jp(e) {
  var t;
  return e ? Joe(e) || Array.isArray(e) || !!e[BU] || !!((t = e.constructor) != null && t[BU]) || YO(e) || XO(e) : !1;
}
var vPe = Object.prototype.constructor.toString();
function Joe(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Id(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === vPe;
}
function x0(e, t) {
  KO(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function KO(e) {
  const t = e[ca];
  return t ? t.type_ : Array.isArray(e) ? 1 : YO(e) ? 2 : XO(e) ? 3 : 0;
}
function kM(e, t) {
  return KO(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Qoe(e, t, n) {
  const r = KO(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function yPe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function YO(e) {
  return e instanceof Map;
}
function XO(e) {
  return e instanceof Set;
}
function rp(e) {
  return e.copy_ || e.base_;
}
function LM(e, t) {
  if (YO(e))
    return new Map(e);
  if (XO(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Joe(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ca];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Id(e), r);
  } else {
    const r = Id(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function EA(e, t = !1) {
  return JO(e) || Xp(e) || !Jp(e) || (KO(e) > 1 && (e.set = e.add = e.clear = e.delete = bPe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => EA(r, !0))), e;
}
function bPe() {
  xs(2);
}
function JO(e) {
  return Object.isFrozen(e);
}
var wPe = {};
function Qp(e) {
  const t = wPe[e];
  return t || xs(0, e), t;
}
var $g;
function eie() {
  return $g;
}
function CPe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function RU(e, t) {
  t && (Qp("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function PM(e) {
  _M(e), e.drafts_.forEach(xPe), e.drafts_ = null;
}
function _M(e) {
  e === $g && ($g = e.parent_);
}
function NU(e) {
  return $g = CPe($g, e);
}
function xPe(e) {
  const t = e[ca];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function FU(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ca].modified_ && (PM(t), xs(4)), Jp(e) && (e = O0(t, e), t.parent_ || E0(t, e)), t.patches_ && Qp("Patches").generateReplacementPatches_(
    n[ca].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = O0(t, n, []), PM(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== Xoe ? e : void 0;
}
function O0(e, t, n) {
  if (JO(t))
    return t;
  const r = t[ca];
  if (!r)
    return x0(
      t,
      (o, i) => zU(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return E0(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), x0(
      i,
      (s, l) => zU(e, r, o, s, l, n, a)
    ), E0(e, o, !1), n && e.patches_ && Qp("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function zU(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && xs(5), Xp(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !kM(t.assigned_, r) ? i.concat(r) : void 0, l = O0(e, o, s);
    if (Qoe(n, r, l), Xp(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Jp(o) && !JO(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    O0(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && E0(e, o);
  }
}
function E0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && EA(t, n);
}
function OPe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : eie(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = kA;
  n && (o = [r], i = Zg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var kA = {
  get(e, t) {
    if (t === ca)
      return e;
    const n = rp(e);
    if (!kM(n, t))
      return EPe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Jp(r) ? r : r === CL(e.base_, t) ? (xL(e), e.copy_[t] = MM(r, e)) : r;
  },
  has(e, t) {
    return t in rp(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(rp(e));
  },
  set(e, t, n) {
    const r = tie(rp(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = CL(rp(e), t), i = o == null ? void 0 : o[ca];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (yPe(n, o) && (n !== void 0 || kM(e.base_, t)))
        return !0;
      xL(e), SM(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return CL(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, xL(e), SM(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = rp(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    xs(11);
  },
  getPrototypeOf(e) {
    return Id(e.base_);
  },
  setPrototypeOf() {
    xs(12);
  }
}, Zg = {};
x0(kA, (e, t) => {
  Zg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Zg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && xs(13), Zg.set.call(this, e, t, void 0);
};
Zg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && xs(14), kA.set.call(this, e[0], t, n, e[0]);
};
function CL(e, t) {
  const n = e[ca];
  return (n ? rp(n) : e)[t];
}
function EPe(e, t, n) {
  var r;
  const o = tie(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function tie(e, t) {
  if (!(t in e))
    return;
  let n = Id(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Id(n);
  }
}
function SM(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && SM(e.parent_));
}
function xL(e) {
  e.copy_ || (e.copy_ = LM(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var kPe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && xs(6), r !== void 0 && typeof r != "function" && xs(7);
      let o;
      if (Jp(t)) {
        const i = NU(this), a = MM(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? PM(i) : _M(i);
        }
        return RU(i, r), FU(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === Xoe && (o = void 0), this.autoFreeze_ && EA(o, !0), r) {
          const i = [], a = [];
          Qp("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        xs(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Jp(e) || xs(8), Xp(e) && (e = LPe(e));
    const t = NU(this), n = MM(e, void 0);
    return n[ca].isManual_ = !0, _M(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ca];
    (!n || !n.isManual_) && xs(9);
    const { scope_: r } = n;
    return RU(r, t), FU(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Qp("Patches").applyPatches_;
    return Xp(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function MM(e, t) {
  const n = YO(e) ? Qp("MapSet").proxyMap_(e, t) : XO(e) ? Qp("MapSet").proxySet_(e, t) : OPe(e, t);
  return (t ? t.scope_ : eie()).drafts_.push(n), n;
}
function LPe(e) {
  return Xp(e) || xs(10, e), nie(e);
}
function nie(e) {
  if (!Jp(e) || JO(e))
    return e;
  const t = e[ca];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = LM(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = LM(e, !0);
  return x0(n, (r, o) => {
    Qoe(n, r, nie(o));
  }), t && (t.finalized_ = !1), n;
}
var pa = new kPe(), LA = pa.produce;
pa.produceWithPatches.bind(
  pa
);
pa.setAutoFreeze.bind(pa);
pa.setUseStrictShallowCopy.bind(pa);
pa.applyPatches.bind(pa);
var UU = pa.createDraft.bind(pa), HU = pa.finishDraft.bind(pa), tt = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = tt.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return tt.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return tt.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return tt.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return tt.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && tt.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return tt.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && tt.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && tt.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && tt.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && tt.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && tt.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!tt.isAncestor(t, e) && !tt.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (tt.equals(i, r) || tt.endsBefore(i, r) || tt.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (tt.equals(a, r) || tt.isAncestor(a, r))
          return null;
        tt.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        tt.equals(s, r) || tt.endsBefore(s, r) ? r[s.length - 1] -= 1 : tt.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (tt.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else tt.endsBefore(u, r) ? r[u.length - 1] += 1 : tt.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (tt.equals(p, d))
          return r;
        if (tt.isAncestor(p, r) || tt.equals(p, r)) {
          var g = d.slice();
          return tt.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else tt.isSibling(p, d) && (tt.isAncestor(d, r) || tt.equals(d, r)) ? tt.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : tt.endsBefore(d, r) || tt.equals(d, r) || tt.isAncestor(d, r) ? (tt.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : tt.endsBefore(p, r) && (tt.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function qg(e) {
  "@babel/helpers - typeof";
  return qg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, qg(e);
}
function PPe(e, t) {
  if (qg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (qg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function _Pe(e) {
  var t = PPe(e, "string");
  return qg(t) === "symbol" ? t : String(t);
}
function Zd(e, t, n) {
  return t = _Pe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function WU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WU(Object(n), !0).forEach(function(r) {
      Zd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SPe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Rt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of nn.points(t))
          t[l] = Jr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Rt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [y, b] of nn.points(t))
          t[b] = Jr.transform(y, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Rt.get(e, E), M = tt.previous(E), O = Rt.get(e, M), v = Rt.parent(e, E), x = E[E.length - 1];
      if (Qo.isText(w) && Qo.isText(O))
        O.text += w.text;
      else if (!Qo.isText(w) && !Qo.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Fs.stringify(w), " ").concat(Fs.stringify(O)));
      if (v.children.splice(x, 1), t)
        for (var [_, z] of nn.points(t))
          t[z] = Jr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (tt.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = Rt.get(e, L), V = Rt.parent(e, L), Z = L[L.length - 1];
      V.children.splice(Z, 1);
      var H = tt.transform(L, n), $ = Rt.get(e, tt.parent(H)), K = H[H.length - 1];
      if ($.children.splice(K, 0, R), t)
        for (var [X, Q] of nn.points(t))
          t[Q] = Jr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = Rt.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [F, S] of nn.points(t)) {
          var W = Jr.transform(F, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var C = void 0, I = void 0;
            for (var [U, T] of Rt.texts(e))
              if (tt.compare(T, J) === -1)
                C = [U, T];
              else {
                I = [U, T];
                break;
              }
            var q = !1;
            C && I && (tt.equals(I[1], J) ? q = !tt.hasPrevious(I[1]) : q = tt.common(C[1], J).length < tt.common(I[1], J).length), C && !q ? (F.path = C[1], F.offset = C[0].text.length) : I ? (F.path = I[1], F.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: j,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = Rt.leaf(e, j), he = le.text.slice(0, Y), oe = le.text.slice(Y + B.length);
      if (le.text = he + oe, t)
        for (var [Pe, Ue] of nn.points(t))
          t[Ue] = Jr.transform(Pe, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: _e,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Rt.get(e, Ze);
      for (var ye in rt) {
        if (ye === "children" || ye === "text")
          throw new Error('Cannot set the "'.concat(ye, '" property of nodes!'));
        var Ge = rt[ye];
        Ge == null ? delete Ve[ye] : Ve[ye] = Ge;
      }
      for (var ct in _e)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ve
      } = n;
      if (ve == null)
        t = ve;
      else {
        if (t == null) {
          if (!nn.isRange(ve))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Fs.stringify(ve), " when there is no current selection."));
          t = Sf({}, ve);
        }
        for (var Oe in ve) {
          var qe = ve[Oe];
          if (qe == null) {
            if (Oe === "anchor" || Oe === "focus")
              throw new Error('Cannot remove the "'.concat(Oe, '" selection property'));
            delete t[Oe];
          } else
            t[Oe] = qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Se,
        properties: st
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var xe = Rt.get(e, ze), xt = Rt.parent(e, ze), at = ze[ze.length - 1], lt;
      if (Qo.isText(xe)) {
        var pt = xe.text.slice(0, Se), Ot = xe.text.slice(Se);
        xe.text = pt, lt = Sf(Sf({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = xe.children.slice(0, Se), ft = xe.children.slice(Se);
        xe.children = dt, lt = Sf(Sf({}, st), {}, {
          children: ft
        });
      }
      if (xt.children.splice(at + 1, 0, lt), t)
        for (var [ot, He] of nn.points(t))
          t[He] = Jr.transform(ot, n);
      break;
    }
  }
  return t;
}, MPe = {
  transform(e, t) {
    e.children = UU(e.children);
    var n = e.selection && UU(e.selection);
    try {
      n = SPe(e, n, t);
    } finally {
      e.children = HU(e.children), n ? e.selection = Xp(n) ? HU(n) : n : e.selection = null;
    }
  }
}, DPe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, TPe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, rie = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Ji(r) && Ji(o)) {
      if (!rie(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function jPe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Gg(e, t) {
  if (e == null) return {};
  var n = jPe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var APe = ["anchor", "focus"];
function VU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function IPe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VU(Object(n), !0).forEach(function(r) {
      Zd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nn = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return nn.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = nn.edges(e);
    return t;
  },
  equals(e, t) {
    return Jr.equals(e.anchor, t.anchor) && Jr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (nn.isRange(t)) {
      if (nn.includes(e, t.anchor) || nn.includes(e, t.focus))
        return !0;
      var [n, r] = nn.edges(e), [o, i] = nn.edges(t);
      return Jr.isBefore(n, o) && Jr.isAfter(r, i);
    }
    var [a, s] = nn.edges(e), l = !1, u = !1;
    return Jr.isPoint(t) ? (l = Jr.compare(t, a) >= 0, u = Jr.compare(t, s) <= 0) : (l = tt.compare(t, a.path) >= 0, u = tt.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Gg(e, APe), [r, o] = nn.edges(e), [i, a] = nn.edges(t), s = Jr.isBefore(r, i) ? i : r, l = Jr.isBefore(o, a) ? o : a;
    return Jr.isBefore(l, s) ? null : IPe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Jr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Jr.equals(t, n);
  },
  isExpanded(e) {
    return !nn.isCollapsed(e);
  },
  isForward(e) {
    return !nn.isBackward(e);
  },
  isRange(e) {
    return Ji(e) && Jr.isPoint(e.anchor) && Jr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = nn.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return LA(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = nn.isCollapsed(r);
        nn.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? nn.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Jr.transform(r.anchor, t, {
        affinity: i
      }), u = Jr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, $U = (e) => Ji(e) && Rt.isNodeList(e.children) && !kr.isEditor(e), Bl = {
  isAncestor(e) {
    return Ji(e) && Rt.isNodeList(e.children);
  },
  isElement: $U,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Bl.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return $U(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, BPe = ["children"], RPe = ["text"], ZU = /* @__PURE__ */ new WeakMap(), Rt = {
  ancestor(e, t) {
    var n = Rt.get(e, t);
    if (Qo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Fs.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of tt.ancestors(t, n)) {
        var o = Rt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Qo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Fs.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Fs.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Rt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Rt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = tt.common(t, n), o = Rt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Rt.get(e, t);
    if (kr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Fs.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Rt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Rt.nodes(e, t))
        Bl.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Bl.isAncestor(e)) {
      var t = Gg(e, BPe);
      return t;
    } else {
      var t = Gg(e, RPe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Rt.get(e, n); r && !(Qo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Qo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Fs.stringify(e)));
    var n = LA({
      children: e.children
    }, (r) => {
      var [o, i] = nn.edges(t), a = Rt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !nn.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!nn.includes(t, s)) {
          var l = Rt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (tt.equals(s, i.path)) {
          var c = Rt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (tt.equals(s, o.path)) {
          var p = Rt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      kr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Qo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Fs.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Qo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Qo.isText(e) || Bl.isElement(e) || kr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = ZU.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Rt.isNode(r));
    return ZU.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Rt.get(e, n); r && !(Qo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Rt.get(e, t);
    if (!Qo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Fs.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of tt.levels(t, n)) {
        var o = Rt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Bl.isElement(e) && Bl.isElementProps(t) && Bl.matches(e, t) || Qo.isText(e) && Qo.isTextProps(t) && Qo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? tt.isBefore(s, i) : tt.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Qo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          tt.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Rt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = tt.next(s);
          if (Rt.has(e, c)) {
            s = c, l = Rt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = tt.previous(s);
          s = p, l = Rt.get(e, s);
          continue;
        }
        s = tt.parent(s), l = Rt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = tt.parent(t), r = Rt.get(e, n);
    if (Qo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Qo.isText(e) ? e.text : e.children.map(Rt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Rt.nodes(e, t))
        Qo.isText(n) && (yield [n, r]);
    }();
  }
};
function qU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ao(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qU(Object(n), !0).forEach(function(r) {
      Zd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wh = {
  isNodeOperation(e) {
    return wh.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Ji(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return tt.isPath(e.path) && Rt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && tt.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && tt.isPath(e.path) && Ji(e.properties);
      case "move_node":
        return tt.isPath(e.path) && tt.isPath(e.newPath);
      case "remove_node":
        return tt.isPath(e.path) && Rt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && tt.isPath(e.path);
      case "set_node":
        return tt.isPath(e.path) && Ji(e.properties) && Ji(e.newProperties);
      case "set_selection":
        return e.properties === null && nn.isRange(e.newProperties) || e.newProperties === null && nn.isRange(e.properties) || Ji(e.properties) && Ji(e.newProperties);
      case "split_node":
        return tt.isPath(e.path) && typeof e.position == "number" && Ji(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => wh.isOperation(t));
  },
  isSelectionOperation(e) {
    return wh.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return wh.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return ao(ao({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return ao(ao({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return ao(ao({}, e), {}, {
          type: "split_node",
          path: tt.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (tt.equals(t, n))
          return e;
        if (tt.isSibling(n, t))
          return ao(ao({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = tt.transform(n, e), o = tt.transform(tt.next(n), e);
        return ao(ao({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return ao(ao({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return ao(ao({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return ao(ao({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? ao(ao({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? ao(ao({}, e), {}, {
          properties: null,
          newProperties: s
        }) : ao(ao({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return ao(ao({}, e), {}, {
          type: "merge_node",
          path: tt.next(e.path)
        });
    }
  }
}, GU = /* @__PURE__ */ new WeakMap(), NPe = (e) => {
  var t = GU.get(e);
  if (t !== void 0)
    return t;
  if (!Ji(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Ji(e.marks)) && (e.selection === null || nn.isRange(e.selection)) && Rt.isNodeList(e.children) && wh.isOperationList(e.operations);
  return GU.set(e, n), n;
}, kr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return NPe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function KU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function YU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KU(Object(n), !0).forEach(function(r) {
      Zd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jr = {
  compare(e, t) {
    var n = tt.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Jr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Jr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && tt.equals(e.path, t.path);
  },
  isPoint(e) {
    return Ji(e) && typeof e.offset == "number" && tt.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return LA(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = tt.transform(i, t, n);
          break;
        }
        case "insert_text": {
          tt.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          tt.equals(t.path, i) && (r.offset += t.position), r.path = tt.transform(i, t, n);
          break;
        }
        case "remove_text": {
          tt.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (tt.equals(t.path, i) || tt.isAncestor(t.path, i))
            return null;
          r.path = tt.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (tt.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = tt.transform(i, t, YU(YU({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = tt.transform(i, t, n);
          break;
        }
      }
    });
  }
}, XU = void 0, Fs = {
  setScrubber(e) {
    XU = e;
  },
  stringify(e) {
    return JSON.stringify(e, XU);
  }
}, FPe = ["text"], zPe = ["anchor", "focus"];
function JU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JU(Object(n), !0).forEach(function(r) {
      Zd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Gg(i, FPe);
      return a;
    }
    return rie(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Ji(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Qo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [bl({}, e)];
    for (var r of t) {
      var o = Gg(r, zPe), [i, a] = nn.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, y = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = bl(bl({}, f), {}, {
            text: f.text.slice(E)
          }), f = bl(bl({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          y = bl(bl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = bl(bl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), y && s.push(y), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, UPe = (e) => e.selection ? e.selection : e.children.length > 0 ? kr.end(e, []) : [0], Vr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Vr || (Vr = {}));
Vr.L, Vr.L | Vr.V | Vr.LV | Vr.LVT, Vr.LV | Vr.V, Vr.V | Vr.T, Vr.LVT | Vr.T, Vr.T, Vr.Any, Vr.Extend | Vr.ZWJ, Vr.Any, Vr.SpacingMark, Vr.Prepend, Vr.Any, Vr.ZWJ, Vr.ExtPict, Vr.RI, Vr.RI;
var HPe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    kr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = UPe(e)
      } = n;
      if (tt.isPath(o) && (o = kr.range(e, o)), nn.isRange(o))
        if (nn.isCollapsed(o))
          o = o.anchor;
        else {
          var i = nn.end(o);
          if (!r && kr.void(e, {
            at: i
          }))
            return;
          var a = nn.start(o), s = kr.pointRef(e, a), l = kr.pointRef(e, i);
          k0.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, k0.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && kr.void(e, {
        at: o
      }) || kr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function QU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QU(Object(n), !0).forEach(function(r) {
      Zd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var k0 = xy(xy(xy(xy({}, MPe), DPe), TPe), HPe), oie = {}, PA = {}, _A = {}, cd = {}, SA = {}, MA = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(MA);
var fn = {}, vc = Ar && Ar.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Fh = Ar && Ar.__assign || function() {
  return Fh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Fh.apply(this, arguments);
};
Object.defineProperty(fn, "__esModule", { value: !0 });
fn.cloneNode = fn.hasChildren = fn.isDocument = fn.isDirective = fn.isComment = fn.isText = fn.isCDATA = fn.isTag = fn.Element = fn.Document = fn.CDATA = fn.NodeWithChildren = fn.ProcessingInstruction = fn.Comment = fn.Text = fn.DataNode = fn.Node = void 0;
var Ds = MA, DA = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), TA(this, t);
    }, e;
  }()
);
fn.Node = DA;
var QO = (
  /** @class */
  function(e) {
    vc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(DA)
);
fn.DataNode = QO;
var iie = (
  /** @class */
  function(e) {
    vc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ds.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(QO)
);
fn.Text = iie;
var sie = (
  /** @class */
  function(e) {
    vc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ds.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(QO)
);
fn.Comment = sie;
var aie = (
  /** @class */
  function(e) {
    vc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ds.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(QO)
);
fn.ProcessingInstruction = aie;
var eE = (
  /** @class */
  function(e) {
    vc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(DA)
);
fn.NodeWithChildren = eE;
var lie = (
  /** @class */
  function(e) {
    vc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ds.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(eE)
);
fn.CDATA = lie;
var uie = (
  /** @class */
  function(e) {
    vc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ds.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(eE)
);
fn.Document = uie;
var cie = (
  /** @class */
  function(e) {
    vc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ds.ElementType.Script : n === "style" ? Ds.ElementType.Style : Ds.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(eE)
);
fn.Element = cie;
function pie(e) {
  return (0, Ds.isTag)(e);
}
fn.isTag = pie;
function die(e) {
  return e.type === Ds.ElementType.CDATA;
}
fn.isCDATA = die;
function fie(e) {
  return e.type === Ds.ElementType.Text;
}
fn.isText = fie;
function hie(e) {
  return e.type === Ds.ElementType.Comment;
}
fn.isComment = hie;
function gie(e) {
  return e.type === Ds.ElementType.Directive;
}
fn.isDirective = gie;
function mie(e) {
  return e.type === Ds.ElementType.Root;
}
fn.isDocument = mie;
function WPe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
fn.hasChildren = WPe;
function TA(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (fie(e))
    n = new iie(e.data);
  else if (hie(e))
    n = new sie(e.data);
  else if (pie(e)) {
    var r = t ? OL(e.children) : [], o = new cie(e.name, Fh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Fh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Fh({}, e["x-attribsPrefix"])), n = o;
  } else if (die(e)) {
    var r = t ? OL(e.children) : [], i = new lie(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (mie(e)) {
    var r = t ? OL(e.children) : [], a = new uie(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (gie(e)) {
    var s = new aie(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
fn.cloneNode = TA;
function OL(e) {
  for (var t = e.map(function(r) {
    return TA(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Ar && Ar.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Ar && Ar.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = MA, o = fn;
  n(fn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(SA);
var vie = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(vie);
Object.defineProperty(cd, "__esModule", { value: !0 });
cd.formatAttributes = yie;
cd.escapeSpecialCharacters = ZPe;
cd.revertEscapedCharacters = bie;
cd.formatDOM = wie;
var Oy = SA, Kg = vie;
function VPe(e) {
  return Kg.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function yie(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function $Pe(e) {
  e = e.toLowerCase();
  var t = VPe(e);
  return t || e;
}
function ZPe(e) {
  return e.replace(Kg.CARRIAGE_RETURN_REGEX, Kg.CARRIAGE_RETURN_PLACEHOLDER);
}
function bie(e) {
  return e.replace(Kg.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Kg.CARRIAGE_RETURN);
}
function wie(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = $Pe(s.nodeName);
        o = new Oy.Element(l, yie(s.attributes)), o.children = wie(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Oy.Text(bie(s.nodeValue));
        break;
      case 8:
        o = new Oy.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Oy.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(_A, "__esModule", { value: !0 });
_A.default = XPe;
var qPe = cd, eH = "html", tH = "head", Ey = "body", GPe = /<([a-zA-Z]+[0-9]?)/, nH = /<head[^]*>/i, rH = /<body[^]*>/i, L0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, DM = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, oH = typeof window == "object" && window.DOMParser;
if (typeof oH == "function") {
  var KPe = new oH(), YPe = "text/html";
  DM = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), KPe.parseFromString(e, YPe);
  }, L0 = DM;
}
if (typeof document == "object" && document.implementation) {
  var ky = document.implementation.createHTMLDocument();
  L0 = function(e, t) {
    if (t) {
      var n = ky.documentElement.querySelector(t);
      return n && (n.innerHTML = e), ky;
    }
    return ky.documentElement.innerHTML = e, ky;
  };
}
var Ly = typeof document == "object" && document.createElement("template"), TM;
Ly && Ly.content && (TM = function(e) {
  return Ly.innerHTML = e, Ly.content.childNodes;
});
function XPe(e) {
  var t, n;
  e = (0, qPe.escapeSpecialCharacters)(e);
  var r = e.match(GPe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case eH: {
      var i = DM(e);
      if (!nH.test(e)) {
        var a = i.querySelector(tH);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!rH.test(e)) {
        var a = i.querySelector(Ey);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(eH);
    }
    case tH:
    case Ey: {
      var s = L0(e).querySelectorAll(o);
      return rH.test(e) && nH.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (TM)
        return TM(e);
      var a = L0(e, Ey).querySelector(Ey);
      return a.childNodes;
    }
  }
}
var JPe = Ar && Ar.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(PA, "__esModule", { value: !0 });
PA.default = n_e;
var QPe = JPe(_A), e_e = cd, t_e = /<(![a-zA-Z\s]+)>/;
function n_e(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(t_e), n = t ? t[1] : void 0;
  return (0, e_e.formatDOM)((0, QPe.default)(e), null, n);
}
var tE = {}, ja = {}, nE = {}, r_e = 0;
nE.SAME = r_e;
var o_e = 1;
nE.CAMELCASE = o_e;
nE.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const Cie = 0, yc = 1, rE = 2, oE = 3, jA = 4, xie = 5, Oie = 6;
function i_e(e) {
  return Vi.hasOwnProperty(e) ? Vi[e] : null;
}
function ps(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === rE || t === oE || t === jA, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Vi = {}, s_e = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
s_e.forEach((e) => {
  Vi[e] = new ps(
    e,
    Cie,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Vi[e] = new ps(
    e,
    yc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Vi[e] = new ps(
    e,
    rE,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Vi[e] = new ps(
    e,
    rE,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Vi[e] = new ps(
    e,
    oE,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Vi[e] = new ps(
    e,
    oE,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Vi[e] = new ps(
    e,
    jA,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Vi[e] = new ps(
    e,
    Oie,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Vi[e] = new ps(
    e,
    xie,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const AA = /[\-\:]([a-z])/g, IA = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(AA, IA);
  Vi[t] = new ps(
    t,
    yc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(AA, IA);
  Vi[t] = new ps(
    t,
    yc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(AA, IA);
  Vi[t] = new ps(
    t,
    yc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Vi[e] = new ps(
    e,
    yc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const a_e = "xlinkHref";
Vi[a_e] = new ps(
  "xlinkHref",
  yc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Vi[e] = new ps(
    e,
    yc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: l_e,
  SAME: u_e,
  possibleStandardNames: iH
} = nE, c_e = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", p_e = c_e + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", d_e = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + p_e + "]*$")
), f_e = Object.keys(
  iH
).reduce((e, t) => {
  const n = iH[t];
  return n === u_e ? e[t] = t : n === l_e ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
ja.BOOLEAN = oE;
ja.BOOLEANISH_STRING = rE;
ja.NUMERIC = xie;
ja.OVERLOADED_BOOLEAN = jA;
ja.POSITIVE_NUMERIC = Oie;
ja.RESERVED = Cie;
ja.STRING = yc;
ja.getPropertyInfo = i_e;
ja.isCustomAttribute = d_e;
ja.possibleStandardNames = f_e;
var BA = {}, RA = {}, sH = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, h_e = /\n/g, g_e = /^\s*/, m_e = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, v_e = /^:\s*/, y_e = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, b_e = /^[;\s]*/, w_e = /^\s+|\s+$/g, C_e = `
`, aH = "/", lH = "*", fp = "", x_e = "comment", O_e = "declaration", E_e = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var y = f.match(h_e);
    y && (n += y.length);
    var b = f.lastIndexOf(C_e);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(y) {
      return y.position = new a(f), u(), y;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var y = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (y.reason = f, y.filename = t.source, y.line = n, y.column = r, y.source = e, !t.silent) throw y;
  }
  function l(f) {
    var y = f.exec(e);
    if (y) {
      var b = y[0];
      return o(b), e = e.slice(b.length), y;
    }
  }
  function u() {
    l(g_e);
  }
  function c(f) {
    var y;
    for (f = f || []; y = p(); )
      y !== !1 && f.push(y);
    return f;
  }
  function p() {
    var f = i();
    if (!(aH != e.charAt(0) || lH != e.charAt(1))) {
      for (var y = 2; fp != e.charAt(y) && (lH != e.charAt(y) || aH != e.charAt(y + 1)); )
        ++y;
      if (y += 2, fp === e.charAt(y - 1))
        return s("End of comment missing");
      var b = e.slice(2, y - 2);
      return r += 2, o(b), e = e.slice(y), r += 2, f({
        type: x_e,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), y = l(m_e);
    if (y) {
      if (p(), !l(v_e)) return s("property missing ':'");
      var b = l(y_e), E = f({
        type: O_e,
        property: uH(y[0].replace(sH, fp)),
        value: b ? uH(b[0].replace(sH, fp)) : fp
      });
      return l(b_e), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var y; y = d(); )
      y !== !1 && (f.push(y), c(f));
    return f;
  }
  return u(), g();
};
function uH(e) {
  return e ? e.replace(w_e, fp) : fp;
}
var k_e = Ar && Ar.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(RA, "__esModule", { value: !0 });
RA.default = P_e;
var L_e = k_e(E_e);
function P_e(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, L_e.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var iE = {};
Object.defineProperty(iE, "__esModule", { value: !0 });
iE.camelCase = void 0;
var __e = /^--[a-zA-Z0-9_-]+$/, S_e = /-([a-z])/g, M_e = /^[^-]+$/, D_e = /^-(webkit|moz|ms|o|khtml)-/, T_e = /^-(ms)-/, j_e = function(e) {
  return !e || M_e.test(e) || __e.test(e);
}, A_e = function(e, t) {
  return t.toUpperCase();
}, cH = function(e, t) {
  return "".concat(t, "-");
}, I_e = function(e, t) {
  return t === void 0 && (t = {}), j_e(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(T_e, cH) : e = e.replace(D_e, cH), e.replace(S_e, A_e));
};
iE.camelCase = I_e;
var B_e = Ar && Ar.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, R_e = B_e(RA), N_e = iE;
function jM(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, R_e.default)(e, function(r, o) {
    r && o && (n[(0, N_e.camelCase)(r, t)] = o);
  }), n;
}
jM.default = jM;
var F_e = jM;
(function(e) {
  var t = Ar && Ar.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(F_e), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(BA);
Object.defineProperty(tE, "__esModule", { value: !0 });
tE.default = W_e;
var Ch = ja, pH = BA, z_e = ["checked", "value"], U_e = ["input", "select", "textarea"], H_e = {
  reset: !0,
  submit: !0
};
function W_e(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && H_e[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Ch.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = dH(a);
    if (s) {
      var l = (0, Ch.getPropertyInfo)(s);
      switch (z_e.includes(s) && U_e.includes(t) && !r && (s = dH("default" + a)), n[s] = i, l && l.type) {
        case Ch.BOOLEAN:
          n[s] = !0;
          break;
        case Ch.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    pH.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, pH.setStyleProp)(e.style, n), n;
}
function dH(e) {
  return Ch.possibleStandardNames[e];
}
var NA = {}, V_e = Ar && Ar.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(NA, "__esModule", { value: !0 });
NA.default = Eie;
var EL = we, $_e = V_e(tE), zh = BA, Z_e = {
  cloneElement: EL.cloneElement,
  createElement: EL.createElement,
  isValidElement: EL.isValidElement
};
function Eie(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || zh.returnFirstArg, i = t.library || Z_e, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, zh.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, y = {};
    q_e(f) ? ((0, zh.setStyleProp)(f.attribs.style, f.attribs), y = f.attribs) : f.attribs && (y = (0, $_e.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (y.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? y.defaultValue = p.children[0].data : p.children && p.children.length && (b = Eie(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (y.key = c), n.push(o(s(p.name, y, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function q_e(e) {
  return zh.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, zh.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Ar && Ar.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(PA);
  e.htmlToDOM = n.default;
  var r = t(tE);
  e.attributesToProps = r.default;
  var o = t(NA);
  e.domToReact = o.default;
  var i = SA;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(oie);
const G_e = /* @__PURE__ */ fPe(oie);
G_e.default;
var Ir = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function K_e(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var AM = { exports: {} }, Mf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fH;
function Y_e() {
  if (fH) return Mf;
  fH = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return Mf.Fragment = n, Mf.jsx = a, Mf.jsxs = a, Mf;
}
var Py = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hH;
function X_e() {
  return hH || (hH = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, y = "@@iterator";
    function b(m) {
      if (m === null || typeof m != "object")
        return null;
      var A = f && m[f] || m[y];
      return typeof A == "function" ? A : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(m) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), ee = 1; ee < A; ee++)
          G[ee - 1] = arguments[ee];
        M("error", m, G);
      }
    }
    function M(m, A, G) {
      {
        var ee = E.ReactDebugCurrentFrame, ae = ee.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[m], console, ue);
      }
    }
    var O = !1, v = !1, x = !1, _ = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function N(m) {
      return !!(typeof m == "string" || typeof m == "function" || m === r || m === i || z || m === o || m === u || m === c || _ || m === g || O || v || x || typeof m == "object" && m !== null && (m.$$typeof === d || m.$$typeof === p || m.$$typeof === a || m.$$typeof === s || m.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      m.$$typeof === L || m.getModuleId !== void 0));
    }
    function R(m, A, G) {
      var ee = m.displayName;
      if (ee)
        return ee;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(m) {
      return m.displayName || "Context";
    }
    function Z(m) {
      if (m == null)
        return null;
      if (typeof m.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof m == "function")
        return m.displayName || m.name || null;
      if (typeof m == "string")
        return m;
      switch (m) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case s:
            var A = m;
            return V(A) + ".Consumer";
          case a:
            var G = m;
            return V(G._context) + ".Provider";
          case l:
            return R(m, m.render, "ForwardRef");
          case p:
            var ee = m.displayName || null;
            return ee !== null ? ee : Z(m.type) || "Memo";
          case d: {
            var ae = m, ue = ae._payload, se = ae._init;
            try {
              return Z(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, $ = 0, K, X, Q, J, P, D, F;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if ($ === 0) {
          K = console.log, X = console.info, Q = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, F = console.groupEnd;
          var m = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: m,
            log: m,
            warn: m,
            error: m,
            group: m,
            groupCollapsed: m,
            groupEnd: m
          });
        }
        $++;
      }
    }
    function C() {
      {
        if ($--, $ === 0) {
          var m = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, m, {
              value: K
            }),
            info: H({}, m, {
              value: X
            }),
            warn: H({}, m, {
              value: Q
            }),
            error: H({}, m, {
              value: J
            }),
            group: H({}, m, {
              value: P
            }),
            groupCollapsed: H({}, m, {
              value: D
            }),
            groupEnd: H({}, m, {
              value: F
            })
          });
        }
        $ < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var I = E.ReactCurrentDispatcher, U;
    function T(m, A, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ee = ae.stack.trim().match(/\n( *(at )?)/);
            U = ee && ee[1] || "";
          }
        return `
` + U + m;
      }
    }
    var q = !1, j;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      j = new Y();
    }
    function B(m, A) {
      if (!m || q)
        return "";
      {
        var G = j.get(m);
        if (G !== void 0)
          return G;
      }
      var ee;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = I.current, I.current = null, W();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Ee) {
              ee = Ee;
            }
            Reflect.construct(m, [], se);
          } else {
            try {
              se.call();
            } catch (Ee) {
              ee = Ee;
            }
            m.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ee) {
            ee = Ee;
          }
          m();
        }
      } catch (Ee) {
        if (Ee && ee && typeof Ee.stack == "string") {
          for (var ie = Ee.stack.split(`
`), be = ee.stack.split(`
`), de = ie.length - 1, fe = be.length - 1; de >= 1 && fe >= 0 && ie[de] !== be[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== be[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== be[fe]) {
                    var Fe = `
` + ie[de].replace(" at new ", " at ");
                    return m.displayName && Fe.includes("<anonymous>") && (Fe = Fe.replace("<anonymous>", m.displayName)), typeof m == "function" && j.set(m, Fe), Fe;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, I.current = ue, C(), Error.prepareStackTrace = ae;
      }
      var Lt = m ? m.displayName || m.name : "", bt = Lt ? T(Lt) : "";
      return typeof m == "function" && j.set(m, bt), bt;
    }
    function le(m, A, G) {
      return B(m, !1);
    }
    function he(m) {
      var A = m.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(m, A, G) {
      if (m == null)
        return "";
      if (typeof m == "function")
        return B(m, he(m));
      if (typeof m == "string")
        return T(m);
      switch (m) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case l:
            return le(m.render);
          case p:
            return oe(m.type, A, G);
          case d: {
            var ee = m, ae = ee._payload, ue = ee._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Pe = Object.prototype.hasOwnProperty, Ue = {}, Ze = E.ReactDebugCurrentFrame;
    function _e(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        Ze.setExtraStackFrame(G);
      } else
        Ze.setExtraStackFrame(null);
    }
    function rt(m, A, G, ee, ae) {
      {
        var ue = Function.call.bind(Pe);
        for (var se in m)
          if (ue(m, se)) {
            var ie = void 0;
            try {
              if (typeof m[se] != "function") {
                var be = Error((ee || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof m[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw be.name = "Invariant Violation", be;
              }
              ie = m[se](A, se, ee, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (_e(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ee || "React class", G, se, typeof ie), _e(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, _e(ae), w("Failed %s type: %s", G, ie.message), _e(null));
          }
      }
    }
    var Ve = Array.isArray;
    function ye(m) {
      return Ve(m);
    }
    function Ge(m) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && m[Symbol.toStringTag] || m.constructor.name || "Object";
        return G;
      }
    }
    function ct(m) {
      try {
        return ve(m), !1;
      } catch {
        return !0;
      }
    }
    function ve(m) {
      return "" + m;
    }
    function Oe(m) {
      if (ct(m))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ge(m)), ve(m);
    }
    var qe = E.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Se, st;
    function xe(m) {
      if (Pe.call(m, "ref")) {
        var A = Object.getOwnPropertyDescriptor(m, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.ref !== void 0;
    }
    function xt(m) {
      if (Pe.call(m, "key")) {
        var A = Object.getOwnPropertyDescriptor(m, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return m.key !== void 0;
    }
    function at(m, A) {
      typeof m.ref == "string" && qe.current;
    }
    function lt(m, A) {
      {
        var G = function() {
          Se || (Se = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function pt(m, A) {
      {
        var G = function() {
          st || (st = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(m, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(m, A, G, ee, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: m,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ee
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function dt(m, A, G, ee, ae) {
      {
        var ue, se = {}, ie = null, be = null;
        G !== void 0 && (Oe(G), ie = "" + G), xt(A) && (Oe(A.key), ie = "" + A.key), xe(A) && (be = A.ref, at(A));
        for (ue in A)
          Pe.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (m && m.defaultProps) {
          var de = m.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || be) {
          var fe = typeof m == "function" ? m.displayName || m.name || "Unknown" : m;
          ie && lt(se, fe), be && pt(se, fe);
        }
        return Ot(m, ie, be, ae, ee, qe.current, se);
      }
    }
    var ft = E.ReactCurrentOwner, ot = E.ReactDebugCurrentFrame;
    function He(m) {
      if (m) {
        var A = m._owner, G = oe(m.type, m._source, A ? A.type : null);
        ot.setExtraStackFrame(G);
      } else
        ot.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(m) {
      return typeof m == "object" && m !== null && m.$$typeof === t;
    }
    function gt() {
      {
        if (ft.current) {
          var m = Z(ft.current.type);
          if (m)
            return `

Check the render method of \`` + m + "`.";
        }
        return "";
      }
    }
    function St(m) {
      return "";
    }
    var mt = {};
    function Mt(m) {
      {
        var A = gt();
        if (!A) {
          var G = typeof m == "string" ? m : m.displayName || m.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function vt(m, A) {
      {
        if (!m._store || m._store.validated || m.key != null)
          return;
        m._store.validated = !0;
        var G = Mt(A);
        if (mt[G])
          return;
        mt[G] = !0;
        var ee = "";
        m && m._owner && m._owner !== ft.current && (ee = " It was passed a child from " + Z(m._owner.type) + "."), He(m), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ee), He(null);
      }
    }
    function Pt(m, A) {
      {
        if (typeof m != "object")
          return;
        if (ye(m))
          for (var G = 0; G < m.length; G++) {
            var ee = m[G];
            kt(ee) && vt(ee, A);
          }
        else if (kt(m))
          m._store && (m._store.validated = !0);
        else if (m) {
          var ae = b(m);
          if (typeof ae == "function" && ae !== m.entries)
            for (var ue = ae.call(m), se; !(se = ue.next()).done; )
              kt(se.value) && vt(se.value, A);
        }
      }
    }
    function jn(m) {
      {
        var A = m.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var ee = Z(A);
          rt(G, m.props, "prop", ee, m);
        } else if (A.PropTypes !== void 0 && !Et) {
          Et = !0;
          var ae = Z(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(m) {
      {
        for (var A = Object.keys(m.props), G = 0; G < A.length; G++) {
          var ee = A[G];
          if (ee !== "children" && ee !== "key") {
            He(m), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ee), He(null);
            break;
          }
        }
        m.ref !== null && (He(m), w("Invalid attribute `ref` supplied to `React.Fragment`."), He(null));
      }
    }
    var te = {};
    function Rr(m, A, G, ee, ae, ue) {
      {
        var se = N(m);
        if (!se) {
          var ie = "";
          (m === void 0 || typeof m == "object" && m !== null && Object.keys(m).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var be = St();
          be ? ie += be : ie += gt();
          var de;
          m === null ? de = "null" : ye(m) ? de = "array" : m !== void 0 && m.$$typeof === t ? (de = "<" + (Z(m.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof m, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = dt(m, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Fe = A.children;
          if (Fe !== void 0)
            if (ee)
              if (ye(Fe)) {
                for (var Lt = 0; Lt < Fe.length; Lt++)
                  Pt(Fe[Lt], m);
                Object.freeze && Object.freeze(Fe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Pt(Fe, m);
        }
        if (Pe.call(A, "key")) {
          var bt = Z(m), Ee = Object.keys(A).filter(function(_i) {
            return _i !== "key";
          }), An = Ee.length > 0 ? "{key: someKey, " + Ee.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!te[bt + An]) {
            var Pi = Ee.length > 0 ? "{" + Ee.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, An, bt, Pi, bt), te[bt + An] = !0;
          }
        }
        return m === r ? yt(fe) : jn(fe), fe;
      }
    }
    function Oi(m, A, G) {
      return Rr(m, A, G, !0);
    }
    function Ei(m, A, G) {
      return Rr(m, A, G, !1);
    }
    var ki = Ei, Li = Oi;
    Py.Fragment = r, Py.jsx = ki, Py.jsxs = Li;
  }()), Py;
}
process.env.NODE_ENV === "production" ? AM.exports = Y_e() : AM.exports = X_e();
var Bi = AM.exports;
We({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function gH(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Qi(e) {
  var t, n;
  return gH(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(gH(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var kie = Symbol.for("immer-nothing"), mH = Symbol.for("immer-draftable"), da = Symbol.for("immer-state"), J_e = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Os(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = J_e[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Bd = Object.getPrototypeOf;
function ed(e) {
  return !!e && !!e[da];
}
function td(e) {
  var t;
  return e ? Lie(e) || Array.isArray(e) || !!e[mH] || !!((t = e.constructor) != null && t[mH]) || aE(e) || lE(e) : !1;
}
var Q_e = Object.prototype.constructor.toString();
function Lie(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Bd(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Q_e;
}
function P0(e, t) {
  sE(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function sE(e) {
  const t = e[da];
  return t ? t.type_ : Array.isArray(e) ? 1 : aE(e) ? 2 : lE(e) ? 3 : 0;
}
function IM(e, t) {
  return sE(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Pie(e, t, n) {
  const r = sE(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function eSe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function aE(e) {
  return e instanceof Map;
}
function lE(e) {
  return e instanceof Set;
}
function op(e) {
  return e.copy_ || e.base_;
}
function BM(e, t) {
  if (aE(e))
    return new Map(e);
  if (lE(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = Lie(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[da];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Bd(e), r);
  } else {
    const r = Bd(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function FA(e, t = !1) {
  return uE(e) || ed(e) || !td(e) || (sE(e) > 1 && (e.set = e.add = e.clear = e.delete = tSe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => FA(r, !0))), e;
}
function tSe() {
  Os(2);
}
function uE(e) {
  return Object.isFrozen(e);
}
var nSe = {};
function nd(e) {
  const t = nSe[e];
  return t || Os(0, e), t;
}
var Yg;
function _ie() {
  return Yg;
}
function rSe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function vH(e, t) {
  t && (nd("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function RM(e) {
  NM(e), e.drafts_.forEach(oSe), e.drafts_ = null;
}
function NM(e) {
  e === Yg && (Yg = e.parent_);
}
function yH(e) {
  return Yg = rSe(Yg, e);
}
function oSe(e) {
  const t = e[da];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function bH(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[da].modified_ && (RM(t), Os(4)), td(e) && (e = _0(t, e), t.parent_ || S0(t, e)), t.patches_ && nd("Patches").generateReplacementPatches_(
    n[da].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = _0(t, n, []), RM(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== kie ? e : void 0;
}
function _0(e, t, n) {
  if (uE(t))
    return t;
  const r = t[da];
  if (!r)
    return P0(
      t,
      (o, i) => wH(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return S0(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), P0(
      i,
      (s, l) => wH(e, r, o, s, l, n, a)
    ), S0(e, o, !1), n && e.patches_ && nd("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function wH(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Os(5), ed(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !IM(t.assigned_, r) ? i.concat(r) : void 0, l = _0(e, o, s);
    if (Pie(n, r, l), ed(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (td(o) && !uE(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    _0(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && S0(e, o);
  }
}
function S0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && FA(t, n);
}
function iSe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : _ie(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = zA;
  n && (o = [r], i = Xg);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var zA = {
  get(e, t) {
    if (t === da)
      return e;
    const n = op(e);
    if (!IM(n, t))
      return sSe(e, n, t);
    const r = n[t];
    return e.finalized_ || !td(r) ? r : r === kL(e.base_, t) ? (LL(e), e.copy_[t] = zM(r, e)) : r;
  },
  has(e, t) {
    return t in op(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(op(e));
  },
  set(e, t, n) {
    const r = Sie(op(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = kL(op(e), t), i = o == null ? void 0 : o[da];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (eSe(n, o) && (n !== void 0 || IM(e.base_, t)))
        return !0;
      LL(e), FM(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return kL(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, LL(e), FM(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = op(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Os(11);
  },
  getPrototypeOf(e) {
    return Bd(e.base_);
  },
  setPrototypeOf() {
    Os(12);
  }
}, Xg = {};
P0(zA, (e, t) => {
  Xg[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Xg.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Os(13), Xg.set.call(this, e, t, void 0);
};
Xg.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Os(14), zA.set.call(this, e[0], t, n, e[0]);
};
function kL(e, t) {
  const n = e[da];
  return (n ? op(n) : e)[t];
}
function sSe(e, t, n) {
  var r;
  const o = Sie(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function Sie(e, t) {
  if (!(t in e))
    return;
  let n = Bd(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Bd(n);
  }
}
function FM(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && FM(e.parent_));
}
function LL(e) {
  e.copy_ || (e.copy_ = BM(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var aSe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Os(6), r !== void 0 && typeof r != "function" && Os(7);
      let o;
      if (td(t)) {
        const i = yH(this), a = zM(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? RM(i) : NM(i);
        }
        return vH(i, r), bH(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === kie && (o = void 0), this.autoFreeze_ && FA(o, !0), r) {
          const i = [], a = [];
          nd("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Os(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    td(e) || Os(8), ed(e) && (e = lSe(e));
    const t = yH(this), n = zM(e, void 0);
    return n[da].isManual_ = !0, NM(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[da];
    (!n || !n.isManual_) && Os(9);
    const { scope_: r } = n;
    return vH(r, t), bH(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = nd("Patches").applyPatches_;
    return ed(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function zM(e, t) {
  const n = aE(e) ? nd("MapSet").proxyMap_(e, t) : lE(e) ? nd("MapSet").proxySet_(e, t) : iSe(e, t);
  return (t ? t.scope_ : _ie()).drafts_.push(n), n;
}
function lSe(e) {
  return ed(e) || Os(10, e), Mie(e);
}
function Mie(e) {
  if (!td(e) || uE(e))
    return e;
  const t = e[da];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = BM(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = BM(e, !0);
  return P0(n, (r, o) => {
    Pie(n, r, Mie(o));
  }), t && (t.finalized_ = !1), n;
}
var fa = new aSe(), UA = fa.produce;
fa.produceWithPatches.bind(
  fa
);
fa.setAutoFreeze.bind(fa);
fa.setUseStrictShallowCopy.bind(fa);
fa.applyPatches.bind(fa);
var CH = fa.createDraft.bind(fa), xH = fa.finishDraft.bind(fa), nt = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = nt.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return nt.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return nt.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return nt.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return nt.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && nt.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return nt.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && nt.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && nt.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && nt.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && nt.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && nt.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!nt.isAncestor(t, e) && !nt.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (nt.equals(i, r) || nt.endsBefore(i, r) || nt.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (nt.equals(a, r) || nt.isAncestor(a, r))
          return null;
        nt.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        nt.equals(s, r) || nt.endsBefore(s, r) ? r[s.length - 1] -= 1 : nt.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (nt.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else nt.endsBefore(u, r) ? r[u.length - 1] += 1 : nt.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (nt.equals(p, d))
          return r;
        if (nt.isAncestor(p, r) || nt.equals(p, r)) {
          var g = d.slice();
          return nt.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else nt.isSibling(p, d) && (nt.isAncestor(d, r) || nt.equals(d, r)) ? nt.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : nt.endsBefore(d, r) || nt.equals(d, r) || nt.isAncestor(d, r) ? (nt.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : nt.endsBefore(p, r) && (nt.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Jg(e) {
  "@babel/helpers - typeof";
  return Jg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Jg(e);
}
function uSe(e, t) {
  if (Jg(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Jg(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function cSe(e) {
  var t = uSe(e, "string");
  return Jg(t) === "symbol" ? t : String(t);
}
function qd(e, t, n) {
  return t = cSe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function OH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Df(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OH(Object(n), !0).forEach(function(r) {
      qd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pSe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Nt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of rn.points(t))
          t[l] = Qr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Nt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [y, b] of rn.points(t))
          t[b] = Qr.transform(y, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Nt.get(e, E), M = nt.previous(E), O = Nt.get(e, M), v = Nt.parent(e, E), x = E[E.length - 1];
      if (ei.isText(w) && ei.isText(O))
        O.text += w.text;
      else if (!ei.isText(w) && !ei.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(zs.stringify(w), " ").concat(zs.stringify(O)));
      if (v.children.splice(x, 1), t)
        for (var [_, z] of rn.points(t))
          t[z] = Qr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (nt.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = Nt.get(e, L), V = Nt.parent(e, L), Z = L[L.length - 1];
      V.children.splice(Z, 1);
      var H = nt.transform(L, n), $ = Nt.get(e, nt.parent(H)), K = H[H.length - 1];
      if ($.children.splice(K, 0, R), t)
        for (var [X, Q] of rn.points(t))
          t[Q] = Qr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = Nt.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [F, S] of rn.points(t)) {
          var W = Qr.transform(F, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var C = void 0, I = void 0;
            for (var [U, T] of Nt.texts(e))
              if (nt.compare(T, J) === -1)
                C = [U, T];
              else {
                I = [U, T];
                break;
              }
            var q = !1;
            C && I && (nt.equals(I[1], J) ? q = !nt.hasPrevious(I[1]) : q = nt.common(C[1], J).length < nt.common(I[1], J).length), C && !q ? (F.path = C[1], F.offset = C[0].text.length) : I ? (F.path = I[1], F.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: j,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var le = Nt.leaf(e, j), he = le.text.slice(0, Y), oe = le.text.slice(Y + B.length);
      if (le.text = he + oe, t)
        for (var [Pe, Ue] of rn.points(t))
          t[Ue] = Qr.transform(Pe, n);
      break;
    }
    case "set_node": {
      var {
        path: Ze,
        properties: _e,
        newProperties: rt
      } = n;
      if (Ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Nt.get(e, Ze);
      for (var ye in rt) {
        if (ye === "children" || ye === "text")
          throw new Error('Cannot set the "'.concat(ye, '" property of nodes!'));
        var Ge = rt[ye];
        Ge == null ? delete Ve[ye] : Ve[ye] = Ge;
      }
      for (var ct in _e)
        rt.hasOwnProperty(ct) || delete Ve[ct];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ve
      } = n;
      if (ve == null)
        t = ve;
      else {
        if (t == null) {
          if (!rn.isRange(ve))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(zs.stringify(ve), " when there is no current selection."));
          t = Df({}, ve);
        }
        for (var Oe in ve) {
          var qe = ve[Oe];
          if (qe == null) {
            if (Oe === "anchor" || Oe === "focus")
              throw new Error('Cannot remove the "'.concat(Oe, '" selection property'));
            delete t[Oe];
          } else
            t[Oe] = qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Se,
        properties: st
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var xe = Nt.get(e, ze), xt = Nt.parent(e, ze), at = ze[ze.length - 1], lt;
      if (ei.isText(xe)) {
        var pt = xe.text.slice(0, Se), Ot = xe.text.slice(Se);
        xe.text = pt, lt = Df(Df({}, st), {}, {
          text: Ot
        });
      } else {
        var dt = xe.children.slice(0, Se), ft = xe.children.slice(Se);
        xe.children = dt, lt = Df(Df({}, st), {}, {
          children: ft
        });
      }
      if (xt.children.splice(at + 1, 0, lt), t)
        for (var [ot, He] of rn.points(t))
          t[He] = Qr.transform(ot, n);
      break;
    }
  }
  return t;
}, dSe = {
  transform(e, t) {
    e.children = CH(e.children);
    var n = e.selection && CH(e.selection);
    try {
      n = pSe(e, n, t);
    } finally {
      e.children = xH(e.children), n ? e.selection = ed(n) ? xH(n) : n : e.selection = null;
    }
  }
}, fSe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, hSe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Die = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Qi(r) && Qi(o)) {
      if (!Die(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function gSe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Qg(e, t) {
  if (e == null) return {};
  var n = gSe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var mSe = ["anchor", "focus"];
function EH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vSe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EH(Object(n), !0).forEach(function(r) {
      qd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rn = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return rn.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = rn.edges(e);
    return t;
  },
  equals(e, t) {
    return Qr.equals(e.anchor, t.anchor) && Qr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (rn.isRange(t)) {
      if (rn.includes(e, t.anchor) || rn.includes(e, t.focus))
        return !0;
      var [n, r] = rn.edges(e), [o, i] = rn.edges(t);
      return Qr.isBefore(n, o) && Qr.isAfter(r, i);
    }
    var [a, s] = rn.edges(e), l = !1, u = !1;
    return Qr.isPoint(t) ? (l = Qr.compare(t, a) >= 0, u = Qr.compare(t, s) <= 0) : (l = nt.compare(t, a.path) >= 0, u = nt.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Qg(e, mSe), [r, o] = rn.edges(e), [i, a] = rn.edges(t), s = Qr.isBefore(r, i) ? i : r, l = Qr.isBefore(o, a) ? o : a;
    return Qr.isBefore(l, s) ? null : vSe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Qr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Qr.equals(t, n);
  },
  isExpanded(e) {
    return !rn.isCollapsed(e);
  },
  isForward(e) {
    return !rn.isBackward(e);
  },
  isRange(e) {
    return Qi(e) && Qr.isPoint(e.anchor) && Qr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = rn.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return UA(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = rn.isCollapsed(r);
        rn.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? rn.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Qr.transform(r.anchor, t, {
        affinity: i
      }), u = Qr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, kH = (e) => Qi(e) && Nt.isNodeList(e.children) && !Lr.isEditor(e), Rl = {
  isAncestor(e) {
    return Qi(e) && Nt.isNodeList(e.children);
  },
  isElement: kH,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Rl.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return kH(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, ySe = ["children"], bSe = ["text"], LH = /* @__PURE__ */ new WeakMap(), Nt = {
  ancestor(e, t) {
    var n = Nt.get(e, t);
    if (ei.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(zs.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of nt.ancestors(t, n)) {
        var o = Nt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (ei.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(zs.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(zs.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Nt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Nt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = nt.common(t, n), o = Nt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Nt.get(e, t);
    if (Lr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(zs.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Nt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Nt.nodes(e, t))
        Rl.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Rl.isAncestor(e)) {
      var t = Qg(e, ySe);
      return t;
    } else {
      var t = Qg(e, bSe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Nt.get(e, n); r && !(ei.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (ei.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(zs.stringify(e)));
    var n = UA({
      children: e.children
    }, (r) => {
      var [o, i] = rn.edges(t), a = Nt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !rn.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!rn.includes(t, s)) {
          var l = Nt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (nt.equals(s, i.path)) {
          var c = Nt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (nt.equals(s, o.path)) {
          var p = Nt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Lr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ei.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(zs.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ei.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return ei.isText(e) || Rl.isElement(e) || Lr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = LH.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Nt.isNode(r));
    return LH.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Nt.get(e, n); r && !(ei.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Nt.get(e, t);
    if (!ei.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(zs.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of nt.levels(t, n)) {
        var o = Nt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Rl.isElement(e) && Rl.isElementProps(t) && Rl.matches(e, t) || ei.isText(e) && ei.isTextProps(t) && ei.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? nt.isBefore(s, i) : nt.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !ei.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          nt.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Nt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = nt.next(s);
          if (Nt.has(e, c)) {
            s = c, l = Nt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = nt.previous(s);
          s = p, l = Nt.get(e, s);
          continue;
        }
        s = nt.parent(s), l = Nt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = nt.parent(t), r = Nt.get(e, n);
    if (ei.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return ei.isText(e) ? e.text : e.children.map(Nt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Nt.nodes(e, t))
        ei.isText(n) && (yield [n, r]);
    }();
  }
};
function PH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PH(Object(n), !0).forEach(function(r) {
      qd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xh = {
  isNodeOperation(e) {
    return xh.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Qi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return nt.isPath(e.path) && Nt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && nt.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && nt.isPath(e.path) && Qi(e.properties);
      case "move_node":
        return nt.isPath(e.path) && nt.isPath(e.newPath);
      case "remove_node":
        return nt.isPath(e.path) && Nt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && nt.isPath(e.path);
      case "set_node":
        return nt.isPath(e.path) && Qi(e.properties) && Qi(e.newProperties);
      case "set_selection":
        return e.properties === null && rn.isRange(e.newProperties) || e.newProperties === null && rn.isRange(e.properties) || Qi(e.properties) && Qi(e.newProperties);
      case "split_node":
        return nt.isPath(e.path) && typeof e.position == "number" && Qi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => xh.isOperation(t));
  },
  isSelectionOperation(e) {
    return xh.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return xh.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return lo(lo({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return lo(lo({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return lo(lo({}, e), {}, {
          type: "split_node",
          path: nt.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (nt.equals(t, n))
          return e;
        if (nt.isSibling(n, t))
          return lo(lo({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = nt.transform(n, e), o = nt.transform(nt.next(n), e);
        return lo(lo({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return lo(lo({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return lo(lo({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return lo(lo({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? lo(lo({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? lo(lo({}, e), {}, {
          properties: null,
          newProperties: s
        }) : lo(lo({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return lo(lo({}, e), {}, {
          type: "merge_node",
          path: nt.next(e.path)
        });
    }
  }
}, _H = /* @__PURE__ */ new WeakMap(), wSe = (e) => {
  var t = _H.get(e);
  if (t !== void 0)
    return t;
  if (!Qi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Qi(e.marks)) && (e.selection === null || rn.isRange(e.selection)) && Nt.isNodeList(e.children) && xh.isOperationList(e.operations);
  return _H.set(e, n), n;
}, Lr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return wSe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function SH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function MH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SH(Object(n), !0).forEach(function(r) {
      qd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qr = {
  compare(e, t) {
    var n = nt.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Qr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Qr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && nt.equals(e.path, t.path);
  },
  isPoint(e) {
    return Qi(e) && typeof e.offset == "number" && nt.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return UA(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = nt.transform(i, t, n);
          break;
        }
        case "insert_text": {
          nt.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          nt.equals(t.path, i) && (r.offset += t.position), r.path = nt.transform(i, t, n);
          break;
        }
        case "remove_text": {
          nt.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (nt.equals(t.path, i) || nt.isAncestor(t.path, i))
            return null;
          r.path = nt.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (nt.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = nt.transform(i, t, MH(MH({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = nt.transform(i, t, n);
          break;
        }
      }
    });
  }
}, DH = void 0, zs = {
  setScrubber(e) {
    DH = e;
  },
  stringify(e) {
    return JSON.stringify(e, DH);
  }
}, CSe = ["text"], xSe = ["anchor", "focus"];
function TH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TH(Object(n), !0).forEach(function(r) {
      qd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ei = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Qg(i, CSe);
      return a;
    }
    return Die(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Qi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => ei.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [wl({}, e)];
    for (var r of t) {
      var o = Qg(r, xSe), [i, a] = rn.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, y = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = wl(wl({}, f), {}, {
            text: f.text.slice(E)
          }), f = wl(wl({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          y = wl(wl({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = wl(wl({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), y && s.push(y), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, OSe = (e) => e.selection ? e.selection : e.children.length > 0 ? Lr.end(e, []) : [0], $r;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})($r || ($r = {}));
$r.L, $r.L | $r.V | $r.LV | $r.LVT, $r.LV | $r.V, $r.V | $r.T, $r.LVT | $r.T, $r.T, $r.Any, $r.Extend | $r.ZWJ, $r.Any, $r.SpacingMark, $r.Prepend, $r.Any, $r.ZWJ, $r.ExtPict, $r.RI, $r.RI;
var ESe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Lr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = OSe(e)
      } = n;
      if (nt.isPath(o) && (o = Lr.range(e, o)), rn.isRange(o))
        if (rn.isCollapsed(o))
          o = o.anchor;
        else {
          var i = rn.end(o);
          if (!r && Lr.void(e, {
            at: i
          }))
            return;
          var a = rn.start(o), s = Lr.pointRef(e, a), l = Lr.pointRef(e, i);
          M0.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, M0.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Lr.void(e, {
        at: o
      }) || Lr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function jH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _y(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jH(Object(n), !0).forEach(function(r) {
      qd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var M0 = _y(_y(_y(_y({}, dSe), fSe), hSe), ESe), Tie = {}, HA = {}, WA = {}, pd = {}, VA = {}, $A = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})($A);
var hn = {}, bc = Ir && Ir.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Uh = Ir && Ir.__assign || function() {
  return Uh = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Uh.apply(this, arguments);
};
Object.defineProperty(hn, "__esModule", { value: !0 });
hn.cloneNode = hn.hasChildren = hn.isDocument = hn.isDirective = hn.isComment = hn.isText = hn.isCDATA = hn.isTag = hn.Element = hn.Document = hn.CDATA = hn.NodeWithChildren = hn.ProcessingInstruction = hn.Comment = hn.Text = hn.DataNode = hn.Node = void 0;
var Ts = $A, ZA = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), qA(this, t);
    }, e;
  }()
);
hn.Node = ZA;
var cE = (
  /** @class */
  function(e) {
    bc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ZA)
);
hn.DataNode = cE;
var jie = (
  /** @class */
  function(e) {
    bc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ts.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cE)
);
hn.Text = jie;
var Aie = (
  /** @class */
  function(e) {
    bc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ts.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cE)
);
hn.Comment = Aie;
var Iie = (
  /** @class */
  function(e) {
    bc(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ts.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cE)
);
hn.ProcessingInstruction = Iie;
var pE = (
  /** @class */
  function(e) {
    bc(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ZA)
);
hn.NodeWithChildren = pE;
var Bie = (
  /** @class */
  function(e) {
    bc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ts.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(pE)
);
hn.CDATA = Bie;
var Rie = (
  /** @class */
  function(e) {
    bc(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ts.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(pE)
);
hn.Document = Rie;
var Nie = (
  /** @class */
  function(e) {
    bc(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ts.ElementType.Script : n === "style" ? Ts.ElementType.Style : Ts.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(pE)
);
hn.Element = Nie;
function Fie(e) {
  return (0, Ts.isTag)(e);
}
hn.isTag = Fie;
function zie(e) {
  return e.type === Ts.ElementType.CDATA;
}
hn.isCDATA = zie;
function Uie(e) {
  return e.type === Ts.ElementType.Text;
}
hn.isText = Uie;
function Hie(e) {
  return e.type === Ts.ElementType.Comment;
}
hn.isComment = Hie;
function Wie(e) {
  return e.type === Ts.ElementType.Directive;
}
hn.isDirective = Wie;
function Vie(e) {
  return e.type === Ts.ElementType.Root;
}
hn.isDocument = Vie;
function kSe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
hn.hasChildren = kSe;
function qA(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (Uie(e))
    n = new jie(e.data);
  else if (Hie(e))
    n = new Aie(e.data);
  else if (Fie(e)) {
    var r = t ? PL(e.children) : [], o = new Nie(e.name, Uh({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Uh({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Uh({}, e["x-attribsPrefix"])), n = o;
  } else if (zie(e)) {
    var r = t ? PL(e.children) : [], i = new Bie(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (Vie(e)) {
    var r = t ? PL(e.children) : [], a = new Rie(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (Wie(e)) {
    var s = new Iie(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
hn.cloneNode = qA;
function PL(e) {
  for (var t = e.map(function(r) {
    return qA(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Ir && Ir.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Ir && Ir.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = $A, o = hn;
  n(hn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(VA);
var $ie = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})($ie);
Object.defineProperty(pd, "__esModule", { value: !0 });
pd.formatAttributes = Zie;
pd.escapeSpecialCharacters = _Se;
pd.revertEscapedCharacters = qie;
pd.formatDOM = Gie;
var Sy = VA, em = $ie;
function LSe(e) {
  return em.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function Zie(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function PSe(e) {
  e = e.toLowerCase();
  var t = LSe(e);
  return t || e;
}
function _Se(e) {
  return e.replace(em.CARRIAGE_RETURN_REGEX, em.CARRIAGE_RETURN_PLACEHOLDER);
}
function qie(e) {
  return e.replace(em.CARRIAGE_RETURN_PLACEHOLDER_REGEX, em.CARRIAGE_RETURN);
}
function Gie(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = PSe(s.nodeName);
        o = new Sy.Element(l, Zie(s.attributes)), o.children = Gie(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Sy.Text(qie(s.nodeValue));
        break;
      case 8:
        o = new Sy.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Sy.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(WA, "__esModule", { value: !0 });
WA.default = jSe;
var SSe = pd, AH = "html", IH = "head", My = "body", MSe = /<([a-zA-Z]+[0-9]?)/, BH = /<head[^]*>/i, RH = /<body[^]*>/i, D0 = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, UM = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, NH = typeof window == "object" && window.DOMParser;
if (typeof NH == "function") {
  var DSe = new NH(), TSe = "text/html";
  UM = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), DSe.parseFromString(e, TSe);
  }, D0 = UM;
}
if (typeof document == "object" && document.implementation) {
  var Dy = document.implementation.createHTMLDocument();
  D0 = function(e, t) {
    if (t) {
      var n = Dy.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Dy;
    }
    return Dy.documentElement.innerHTML = e, Dy;
  };
}
var Ty = typeof document == "object" && document.createElement("template"), HM;
Ty && Ty.content && (HM = function(e) {
  return Ty.innerHTML = e, Ty.content.childNodes;
});
function jSe(e) {
  var t, n;
  e = (0, SSe.escapeSpecialCharacters)(e);
  var r = e.match(MSe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case AH: {
      var i = UM(e);
      if (!BH.test(e)) {
        var a = i.querySelector(IH);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!RH.test(e)) {
        var a = i.querySelector(My);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(AH);
    }
    case IH:
    case My: {
      var s = D0(e).querySelectorAll(o);
      return RH.test(e) && BH.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (HM)
        return HM(e);
      var a = D0(e, My).querySelector(My);
      return a.childNodes;
    }
  }
}
var ASe = Ir && Ir.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(HA, "__esModule", { value: !0 });
HA.default = NSe;
var ISe = ASe(WA), BSe = pd, RSe = /<(![a-zA-Z\s]+)>/;
function NSe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(RSe), n = t ? t[1] : void 0;
  return (0, BSe.formatDOM)((0, ISe.default)(e), null, n);
}
var dE = {}, Aa = {}, fE = {}, FSe = 0;
fE.SAME = FSe;
var zSe = 1;
fE.CAMELCASE = zSe;
fE.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const Kie = 0, wc = 1, hE = 2, gE = 3, GA = 4, Yie = 5, Xie = 6;
function USe(e) {
  return $i.hasOwnProperty(e) ? $i[e] : null;
}
function ds(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === hE || t === gE || t === GA, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const $i = {}, HSe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
HSe.forEach((e) => {
  $i[e] = new ds(
    e,
    Kie,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  $i[e] = new ds(
    e,
    wc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  $i[e] = new ds(
    e,
    hE,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  $i[e] = new ds(
    e,
    hE,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  $i[e] = new ds(
    e,
    gE,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  $i[e] = new ds(
    e,
    gE,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  $i[e] = new ds(
    e,
    GA,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  $i[e] = new ds(
    e,
    Xie,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  $i[e] = new ds(
    e,
    Yie,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const KA = /[\-\:]([a-z])/g, YA = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(KA, YA);
  $i[t] = new ds(
    t,
    wc,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(KA, YA);
  $i[t] = new ds(
    t,
    wc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(KA, YA);
  $i[t] = new ds(
    t,
    wc,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  $i[e] = new ds(
    e,
    wc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const WSe = "xlinkHref";
$i[WSe] = new ds(
  "xlinkHref",
  wc,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  $i[e] = new ds(
    e,
    wc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: VSe,
  SAME: $Se,
  possibleStandardNames: FH
} = fE, ZSe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", qSe = ZSe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", GSe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + qSe + "]*$")
), KSe = Object.keys(
  FH
).reduce((e, t) => {
  const n = FH[t];
  return n === $Se ? e[t] = t : n === VSe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Aa.BOOLEAN = gE;
Aa.BOOLEANISH_STRING = hE;
Aa.NUMERIC = Yie;
Aa.OVERLOADED_BOOLEAN = GA;
Aa.POSITIVE_NUMERIC = Xie;
Aa.RESERVED = Kie;
Aa.STRING = wc;
Aa.getPropertyInfo = USe;
Aa.isCustomAttribute = GSe;
Aa.possibleStandardNames = KSe;
var XA = {}, JA = {}, zH = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, YSe = /\n/g, XSe = /^\s*/, JSe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, QSe = /^:\s*/, eMe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, tMe = /^[;\s]*/, nMe = /^\s+|\s+$/g, rMe = `
`, UH = "/", HH = "*", hp = "", oMe = "comment", iMe = "declaration", sMe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var y = f.match(YSe);
    y && (n += y.length);
    var b = f.lastIndexOf(rMe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(y) {
      return y.position = new a(f), u(), y;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var y = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (y.reason = f, y.filename = t.source, y.line = n, y.column = r, y.source = e, !t.silent) throw y;
  }
  function l(f) {
    var y = f.exec(e);
    if (y) {
      var b = y[0];
      return o(b), e = e.slice(b.length), y;
    }
  }
  function u() {
    l(XSe);
  }
  function c(f) {
    var y;
    for (f = f || []; y = p(); )
      y !== !1 && f.push(y);
    return f;
  }
  function p() {
    var f = i();
    if (!(UH != e.charAt(0) || HH != e.charAt(1))) {
      for (var y = 2; hp != e.charAt(y) && (HH != e.charAt(y) || UH != e.charAt(y + 1)); )
        ++y;
      if (y += 2, hp === e.charAt(y - 1))
        return s("End of comment missing");
      var b = e.slice(2, y - 2);
      return r += 2, o(b), e = e.slice(y), r += 2, f({
        type: oMe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), y = l(JSe);
    if (y) {
      if (p(), !l(QSe)) return s("property missing ':'");
      var b = l(eMe), E = f({
        type: iMe,
        property: WH(y[0].replace(zH, hp)),
        value: b ? WH(b[0].replace(zH, hp)) : hp
      });
      return l(tMe), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var y; y = d(); )
      y !== !1 && (f.push(y), c(f));
    return f;
  }
  return u(), g();
};
function WH(e) {
  return e ? e.replace(nMe, hp) : hp;
}
var aMe = Ir && Ir.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(JA, "__esModule", { value: !0 });
JA.default = uMe;
var lMe = aMe(sMe);
function uMe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, lMe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var mE = {};
Object.defineProperty(mE, "__esModule", { value: !0 });
mE.camelCase = void 0;
var cMe = /^--[a-zA-Z0-9_-]+$/, pMe = /-([a-z])/g, dMe = /^[^-]+$/, fMe = /^-(webkit|moz|ms|o|khtml)-/, hMe = /^-(ms)-/, gMe = function(e) {
  return !e || dMe.test(e) || cMe.test(e);
}, mMe = function(e, t) {
  return t.toUpperCase();
}, VH = function(e, t) {
  return "".concat(t, "-");
}, vMe = function(e, t) {
  return t === void 0 && (t = {}), gMe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(hMe, VH) : e = e.replace(fMe, VH), e.replace(pMe, mMe));
};
mE.camelCase = vMe;
var yMe = Ir && Ir.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, bMe = yMe(JA), wMe = mE;
function WM(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, bMe.default)(e, function(r, o) {
    r && o && (n[(0, wMe.camelCase)(r, t)] = o);
  }), n;
}
WM.default = WM;
var CMe = WM;
(function(e) {
  var t = Ir && Ir.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(CMe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(XA);
Object.defineProperty(dE, "__esModule", { value: !0 });
dE.default = kMe;
var Oh = Aa, $H = XA, xMe = ["checked", "value"], OMe = ["input", "select", "textarea"], EMe = {
  reset: !0,
  submit: !0
};
function kMe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && EMe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Oh.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = ZH(a);
    if (s) {
      var l = (0, Oh.getPropertyInfo)(s);
      switch (xMe.includes(s) && OMe.includes(t) && !r && (s = ZH("default" + a)), n[s] = i, l && l.type) {
        case Oh.BOOLEAN:
          n[s] = !0;
          break;
        case Oh.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    $H.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, $H.setStyleProp)(e.style, n), n;
}
function ZH(e) {
  return Oh.possibleStandardNames[e];
}
var QA = {}, LMe = Ir && Ir.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(QA, "__esModule", { value: !0 });
QA.default = Jie;
var _L = we, PMe = LMe(dE), Hh = XA, _Me = {
  cloneElement: _L.cloneElement,
  createElement: _L.createElement,
  isValidElement: _L.isValidElement
};
function Jie(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Hh.returnFirstArg, i = t.library || _Me, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Hh.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, y = {};
    SMe(f) ? ((0, Hh.setStyleProp)(f.attribs.style, f.attribs), y = f.attribs) : f.attribs && (y = (0, PMe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (y.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? y.defaultValue = p.children[0].data : p.children && p.children.length && (b = Jie(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (y.key = c), n.push(o(s(p.name, y, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function SMe(e) {
  return Hh.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Hh.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Ir && Ir.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(HA);
  e.htmlToDOM = n.default;
  var r = t(dE);
  e.attributesToProps = r.default;
  var o = t(QA);
  e.domToReact = o.default;
  var i = VA;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(Tie);
const MMe = /* @__PURE__ */ K_e(Tie);
MMe.default;
We({});
function DMe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const TMe = {
  CNPJ: "99.999.999/9999-99"
};
DMe(TMe.CNPJ).length;
yr((e, t) => /* @__PURE__ */ Bi.jsx("input", { ref: t, ...e }));
function Qie(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const ese = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function jMe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function AMe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const IMe = Qie(ese.NINE).length, BMe = yr((e, t) => /* @__PURE__ */ Bi.jsx("input", { ref: t, ...e }));
yr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = Qie(g.target.value);
      const y = AMe(f);
      f.length > IMe || (f = jMe(f, ese[y]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Bi.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Bi.jsx(
      tl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: BMe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
We({});
var Yl = {};
Object.defineProperty(Yl, "__esModule", {
  value: !0
});
var RMe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), SL = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, tse = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: RMe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, eI = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var jy = 1; jy < 20; jy++)
  eI["f" + jy] = 111 + jy;
function vE(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return nse(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return rse(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function NMe(e, t) {
  return vE(e, t);
}
function FMe(e, t) {
  return vE(e, { byKey: !0 }, t);
}
function nse(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in SL)
    r[SL[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = tI(d), y = SL[f];
      if (d.length > 1 && !y && !tse[d] && !eI[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !y) && (n ? r.key = f : r.which = ose(d)), y && (r[y] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function rse(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function ose(e) {
  e = tI(e);
  var t = eI[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function tI(e) {
  return e = e.toLowerCase(), e = tse[e] || e, e;
}
Yl.default = vE;
var ML = Yl.isHotkey = vE;
Yl.isCodeHotkey = NMe;
Yl.isKeyHotkey = FMe;
Yl.parseHotkey = nse;
Yl.compareHotkey = rse;
Yl.toKeyCode = ose;
Yl.toKeyName = tI;
var zMe = typeof Ir == "object" && Ir && Ir.Object === Object && Ir, UMe = zMe, HMe = UMe, WMe = typeof self == "object" && self && self.Object === Object && self, VMe = HMe || WMe || Function("return this")(), $Me = VMe, ZMe = $Me, qMe = ZMe.Symbol, ise = qMe, qH = ise;
qH && qH.toStringTag;
var GH = ise;
GH && GH.toStringTag;
var KH;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(KH || (KH = {}));
var nI = function(e) {
  return Object.freeze(e);
}, GMe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, nI(this);
  }
  return e;
}(), KMe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, nI(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), YH = typeof window < "u" ? window : {};
/msie|trident/i.test(YH.navigator && YH.navigator.userAgent);
var DL = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new GMe((n ? t : e) || 0, (n ? e : t) || 0);
};
nI({
  devicePixelContentBoxSize: DL(),
  borderBoxSize: DL(),
  contentBoxSize: DL(),
  contentRect: new KMe(0, 0, 0, 0)
});
function tm(e) {
  "@babel/helpers - typeof";
  return tm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, tm(e);
}
function YMe(e, t) {
  if (tm(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (tm(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function XMe(e) {
  var t = YMe(e, "string");
  return tm(t) === "symbol" ? t : String(t);
}
function Wh(e, t, n) {
  return t = XMe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var JMe = /* @__PURE__ */ We(null), TL, jL;
parseInt(we.version.split(".")[0], 10);
var XH = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), AL = typeof navigator < "u" && /Android/.test(navigator.userAgent), Ay = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), QMe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (TL = navigator.userAgent.match(/Version\/(\d+)/)) !== null && TL !== void 0 && TL[1] && parseInt((jL = navigator.userAgent.match(/Version\/(\d+)/)) === null || jL === void 0 ? void 0 : jL[1], 10) < 17;
var eDe = /* @__PURE__ */ new WeakMap(), tDe = /* @__PURE__ */ new WeakMap(), nDe = /* @__PURE__ */ new WeakMap(), rDe = /* @__PURE__ */ new WeakMap(), oDe = /* @__PURE__ */ new WeakMap(), JH = /* @__PURE__ */ new WeakMap(), iDe = /* @__PURE__ */ new WeakMap(), QH = /* @__PURE__ */ new WeakMap(), Iy = /* @__PURE__ */ new WeakMap(), sDe = /* @__PURE__ */ new WeakMap(), aDe = /* @__PURE__ */ new WeakMap(), lDe = /* @__PURE__ */ new WeakMap(), sse = globalThis.Node, uDe = globalThis.Text, ase = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, cDe = (e) => T0(e) && e.nodeType === 8, Za = (e) => T0(e) && e.nodeType === 1, T0 = (e) => {
  var t = ase(e);
  return !!t && e instanceof t.Node;
}, eW = (e) => {
  var t = e && e.anchorNode && ase(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, pDe = (e) => {
  var [t, n] = e;
  if (Za(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = lse(t, o, r ? "backward" : "forward"), r = o < n; Za(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = fDe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, dDe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, lse = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (cDe(o) || Za(o) && o.childNodes.length === 0 || Za(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, fDe = (e, t, n) => {
  var [r] = lse(e, t, n);
  return r;
}, tW = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), use = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Za(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = mn.getWindow(e);
  if (o.contains(r))
    return mn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : use(e, i, n);
}, nW = (e, t) => !!(e.compareDocumentPosition(t) & sse.DOCUMENT_POSITION_PRECEDING), hDe = (e, t) => !!(e.compareDocumentPosition(t) & sse.DOCUMENT_POSITION_FOLLOWING), gDe = 0;
class mDe {
  constructor() {
    Wh(this, "id", void 0), this.id = "".concat(gDe++);
  }
}
var mn = {
  androidPendingDiffs: (e) => lDe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = aDe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = mn.toDOMNode(e, e), n = mn.findDocumentOrShadowRoot(e);
    Iy.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = mn.findDocumentOrShadowRoot(e), r = tW(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && M0.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = mn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = mn.toSlateNode(e, t.target), a = mn.findPath(e, i);
    if (Rl.isElement(i) && Lr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Lr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Lr.before(e, u) : Lr.after(e, u);
      if (c) {
        var p = Lr.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = mn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var y = mn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return y;
  },
  findKey: (e, t) => {
    var n = JH.get(t);
    return n || (n = new mDe(), JH.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = tDe.get(r);
      if (o == null) {
        if (Lr.isEditor(r))
          return n;
        break;
      }
      var i = eDe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(zs.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Iy.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          mn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = mn.toDOMNode(e, e), r = mn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = tW(r), i = mn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || M0.select(e, Lr.start(e, [])), Iy.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = nDe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = mn.toDOMNode(e, e), i;
    try {
      i = Za(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => T0(t) && mn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Lr.hasPath(e, n.path) && Lr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => mn.hasEditableTarget(e, t) || mn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => T0(t) && mn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!sDe.get(e),
  isFocused: (e) => !!Iy.get(e),
  isReadOnly: (e) => !!QH.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (QH.get(e)) return !1;
    var n = mn.hasTarget(e, t) && mn.toSlateNode(e, t);
    return Rl.isElement(n) && Lr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = iDe.get(e), r = Lr.isEditor(t) ? rDe.get(e) : n == null ? void 0 : n.get(mn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(zs.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Lr.node(e, t.path), r = mn.toDOMNode(e, n), o;
    Lr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, y = a[l + 1];
        if (t.offset === f && y !== null && y !== void 0 && y.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = y.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof uDe ? E : y,
            (b = y.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(zs.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = rn.isBackward(t), i = mn.toDOMPoint(e, n), a = rn.isCollapsed(t) ? i : mn.toDOMPoint(e, r), s = mn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Za(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), y = Za(p) ? p : p.parentElement, b = !!y.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Za(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? oDe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : pDe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = mn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), y = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = mn.getWindow(e), v = O.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var x = v.cloneContents(), _ = [...Array.prototype.slice.call(x.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(x.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (AL && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = x.textContent.length, M = u;
        }
      } else if (y) {
        for (var z = y.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var N = z[L];
          if (mn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var Z, H = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = (Z = H.find((S) => hDe(E, S))) !== null && Z !== void 0 ? Z : null;
        } else {
          var $, K = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = ($ = K.findLast((S) => nW(E, S))) !== null && $ !== void 0 ? $ : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      AL && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Ay && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (AL && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && mn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var Q = mn.toSlateNode(e, X), {
          path: J,
          offset: P
        } = Lr.start(e, mn.findPath(e, Q));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = mn.toSlateNode(e, u), F = mn.findPath(e, D);
    return {
      path: F,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = eW(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (eW(t)) {
        if (Ay && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let x = function(_) {
              return _.childElementCount > 0 ? x(_.children[0]) : _;
            };
            var f = d.startContainer, y = g.startContainer, b = x(f.children[d.startOffset]), E = x(y.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        QMe && dDe(s) || Ay ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Ay && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = mn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = nW(s, u) || s === u && c < l, O = p ? w : mn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var v = {
      anchor: w,
      focus: O
    };
    return rn.isExpanded(v) && rn.isForward(v) && Za(u) && Lr.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = Lr.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, vDe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, yDe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, bDe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, uo = (e) => {
  var t = vDe[e], n = yDe[e], r = bDe[e], o = t && ML(t), i = n && ML(n), a = r && ML(r);
  return (s) => !!(o && o(s) || XH && i && i(s) || !XH && a && a(s));
};
uo("bold"), uo("compose"), uo("moveBackward"), uo("moveForward"), uo("deleteBackward"), uo("deleteForward"), uo("deleteLineBackward"), uo("deleteLineForward"), uo("deleteWordBackward"), uo("deleteWordForward"), uo("extendBackward"), uo("extendForward"), uo("extendLineBackward"), uo("extendLineForward"), uo("italic"), uo("moveLineBackward"), uo("moveLineForward"), uo("moveWordBackward"), uo("moveWordForward"), uo("redo"), uo("insertSoftBreak"), uo("splitBlock"), uo("transposeCharacter"), uo("undo");
var wDe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => use(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, CDe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class xDe extends Kl {
  constructor() {
    super(...arguments), Wh(this, "context", null), Wh(this, "manager", null), Wh(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, CDe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = wDe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Wh(xDe, "contextType", JMe);
We({});
We({});
We({});
var ti = {}, rI = {}, Om = {}, Em = {}, cse = "Expected a function", rW = NaN, ODe = "[object Symbol]", EDe = /^\s+|\s+$/g, kDe = /^[-+]0x[0-9a-f]+$/i, LDe = /^0b[01]+$/i, PDe = /^0o[0-7]+$/i, _De = parseInt, SDe = typeof Ir == "object" && Ir && Ir.Object === Object && Ir, MDe = typeof self == "object" && self && self.Object === Object && self, DDe = SDe || MDe || Function("return this")(), TDe = Object.prototype, jDe = TDe.toString, ADe = Math.max, IDe = Math.min, IL = function() {
  return DDe.Date.now();
};
function BDe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(cse);
  t = oW(t) || 0, j0(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? ADe(oW(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(x) {
    var _ = r, z = o;
    return r = o = void 0, u = x, a = e.apply(z, _), a;
  }
  function f(x) {
    return u = x, s = setTimeout(E, t), c ? g(x) : a;
  }
  function y(x) {
    var _ = x - l, z = x - u, L = t - _;
    return p ? IDe(L, i - z) : L;
  }
  function b(x) {
    var _ = x - l, z = x - u;
    return l === void 0 || _ >= t || _ < 0 || p && z >= i;
  }
  function E() {
    var x = IL();
    if (b(x))
      return w(x);
    s = setTimeout(E, y(x));
  }
  function w(x) {
    return s = void 0, d && r ? g(x) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(IL());
  }
  function v() {
    var x = IL(), _ = b(x);
    if (r = arguments, o = this, l = x, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = O, v;
}
function RDe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(cse);
  return j0(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), BDe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function j0(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function NDe(e) {
  return !!e && typeof e == "object";
}
function FDe(e) {
  return typeof e == "symbol" || NDe(e) && jDe.call(e) == ODe;
}
function oW(e) {
  if (typeof e == "number")
    return e;
  if (FDe(e))
    return rW;
  if (j0(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = j0(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(EDe, "");
  var n = LDe.test(e);
  return n || PDe.test(e) ? _De(e.slice(2), n ? 2 : 8) : kDe.test(e) ? rW : +e;
}
var zDe = RDe, km = {};
Object.defineProperty(km, "__esModule", {
  value: !0
});
km.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), kw.has(t) || kw.set(t, /* @__PURE__ */ new Set());
  var o = kw.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
km.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), kw.get(t).delete(n.name || t);
};
var kw = /* @__PURE__ */ new Map();
Object.defineProperty(Em, "__esModule", {
  value: !0
});
var UDe = zDe, HDe = WDe(UDe), iW = km;
function WDe(e) {
  return e && e.__esModule ? e : { default: e };
}
var VDe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, HDe.default)(e, t);
}, So = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = VDe(function(r) {
        So.scrollHandler(e);
      }, t);
      return So.scrollSpyContainers.push(e), (0, iW.addPassiveEventListener)(e, "scroll", n), function() {
        (0, iW.removePassiveEventListener)(e, "scroll", n), So.scrollSpyContainers.splice(So.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return So.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = So.scrollSpyContainers[So.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(So.currentPositionX(e), So.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    So.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = So.scrollSpyContainers[So.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    So.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    So.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), So.spySetState && So.spySetState.length && So.spySetState.indexOf(e) > -1 && So.spySetState.splice(So.spySetState.indexOf(e), 1), document.removeEventListener("scroll", So.scrollHandler);
  },
  update: function() {
    return So.scrollSpyContainers.forEach(function(e) {
      return So.scrollHandler(e);
    });
  }
};
Em.default = So;
var Gd = {}, Lm = {};
Object.defineProperty(Lm, "__esModule", {
  value: !0
});
var $De = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, ZDe = function() {
  return window.location.hash.replace(/^#/, "");
}, qDe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, GDe = function(e) {
  return getComputedStyle(e).position !== "static";
}, BL = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, KDe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (GDe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = BL(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return BL(t, s).offsetTop - BL(e, s).offsetTop;
};
Lm.default = {
  updateHash: $De,
  getHash: ZDe,
  filterElementInContainer: qDe,
  scrollOffset: KDe
};
var yE = {}, oI = {};
Object.defineProperty(oI, "__esModule", {
  value: !0
});
oI.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var iI = {};
Object.defineProperty(iI, "__esModule", {
  value: !0
});
var YDe = km, XDe = ["mousedown", "wheel", "touchmove", "keydown"];
iI.default = {
  subscribe: function(e) {
    return typeof document < "u" && XDe.forEach(function(t) {
      return (0, YDe.addPassiveEventListener)(document, t, e);
    });
  }
};
var Pm = {};
Object.defineProperty(Pm, "__esModule", {
  value: !0
});
var VM = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      VM.registered[e] = t;
    },
    remove: function(e) {
      VM.registered[e] = null;
    }
  }
};
Pm.default = VM;
Object.defineProperty(yE, "__esModule", {
  value: !0
});
var JDe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, QDe = Lm;
bE(QDe);
var eTe = oI, sW = bE(eTe), tTe = iI, nTe = bE(tTe), rTe = Pm, Ra = bE(rTe);
function bE(e) {
  return e && e.__esModule ? e : { default: e };
}
var pse = function(e) {
  return sW.default[e.smooth] || sW.default.defaultEasing;
}, oTe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, iTe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, $M = function() {
  return iTe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), dse = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, fse = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, hse = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, sTe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, aTe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, lTe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Ra.default.registered.end && Ra.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    $M.call(window, i);
    return;
  }
  Ra.default.registered.end && Ra.default.registered.end(o.to, o.target, o.currentPosition);
}, sI = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, _m = function(e, t, n, r) {
  t.data = t.data || dse(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (nTe.default.subscribe(o), sI(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? fse(t) : hse(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Ra.default.registered.end && Ra.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = oTe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = pse(t), a = lTe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Ra.default.registered.begin && Ra.default.registered.begin(t.data.to, t.data.target), $M.call(window, a);
    }, t.delay);
    return;
  }
  Ra.default.registered.begin && Ra.default.registered.begin(t.data.to, t.data.target), $M.call(window, a);
}, wE = function(e) {
  return e = JDe({}, e), e.data = e.data || dse(), e.absolute = !0, e;
}, uTe = function(e) {
  _m(0, wE(e));
}, cTe = function(e, t) {
  _m(e, wE(t));
}, pTe = function(e) {
  e = wE(e), sI(e), _m(e.horizontal ? sTe(e) : aTe(e), e);
}, dTe = function(e, t) {
  t = wE(t), sI(t);
  var n = t.horizontal ? fse(t) : hse(t);
  _m(e + n, t);
};
yE.default = {
  animateTopScroll: _m,
  getAnimationType: pse,
  scrollToTop: uTe,
  scrollToBottom: pTe,
  scrollTo: cTe,
  scrollMore: dTe
};
Object.defineProperty(Gd, "__esModule", {
  value: !0
});
var fTe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, hTe = Lm, gTe = aI(hTe), mTe = yE, vTe = aI(mTe), yTe = Pm, By = aI(yTe);
function aI(e) {
  return e && e.__esModule ? e : { default: e };
}
var Ry = {}, aW = void 0;
Gd.default = {
  unmount: function() {
    Ry = {};
  },
  register: function(e, t) {
    Ry[e] = t;
  },
  unregister: function(e) {
    delete Ry[e];
  },
  get: function(e) {
    return Ry[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return aW = e;
  },
  getActiveLink: function() {
    return aW;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = fTe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = gTe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      By.default.registered.begin && By.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, By.default.registered.end && By.default.registered.end(e, n);
      return;
    }
    vTe.default.animateTopScroll(s, t, e, n);
  }
};
var ZM = { exports: {} }, RL = { exports: {} }, Qn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lW;
function bTe() {
  if (lW) return Qn;
  lW = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function O(v) {
    return M(v) === u;
  }
  return Qn.AsyncMode = l, Qn.ConcurrentMode = u, Qn.ContextConsumer = s, Qn.ContextProvider = a, Qn.Element = t, Qn.ForwardRef = c, Qn.Fragment = r, Qn.Lazy = f, Qn.Memo = g, Qn.Portal = n, Qn.Profiler = i, Qn.StrictMode = o, Qn.Suspense = p, Qn.isAsyncMode = function(v) {
    return O(v) || M(v) === l;
  }, Qn.isConcurrentMode = O, Qn.isContextConsumer = function(v) {
    return M(v) === s;
  }, Qn.isContextProvider = function(v) {
    return M(v) === a;
  }, Qn.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Qn.isForwardRef = function(v) {
    return M(v) === c;
  }, Qn.isFragment = function(v) {
    return M(v) === r;
  }, Qn.isLazy = function(v) {
    return M(v) === f;
  }, Qn.isMemo = function(v) {
    return M(v) === g;
  }, Qn.isPortal = function(v) {
    return M(v) === n;
  }, Qn.isProfiler = function(v) {
    return M(v) === i;
  }, Qn.isStrictMode = function(v) {
    return M(v) === o;
  }, Qn.isSuspense = function(v) {
    return M(v) === p;
  }, Qn.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === y);
  }, Qn.typeOf = M, Qn;
}
var cr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uW;
function wTe() {
  return uW || (uW = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === E || B.$$typeof === w || B.$$typeof === y);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, x = u, _ = s, z = a, L = t, N = c, R = r, V = f, Z = g, H = n, $ = i, K = o, X = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function F(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return O(B) === c;
    }
    function C(B) {
      return O(B) === r;
    }
    function I(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function j(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    cr.AsyncMode = v, cr.ConcurrentMode = x, cr.ContextConsumer = _, cr.ContextProvider = z, cr.Element = L, cr.ForwardRef = N, cr.Fragment = R, cr.Lazy = V, cr.Memo = Z, cr.Portal = H, cr.Profiler = $, cr.StrictMode = K, cr.Suspense = X, cr.isAsyncMode = J, cr.isConcurrentMode = P, cr.isContextConsumer = D, cr.isContextProvider = F, cr.isElement = S, cr.isForwardRef = W, cr.isFragment = C, cr.isLazy = I, cr.isMemo = U, cr.isPortal = T, cr.isProfiler = q, cr.isStrictMode = j, cr.isSuspense = Y, cr.isValidElementType = M, cr.typeOf = O;
  }()), cr;
}
var cW;
function gse() {
  return cW || (cW = 1, process.env.NODE_ENV === "production" ? RL.exports = bTe() : RL.exports = wTe()), RL.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var NL, pW;
function CTe() {
  if (pW) return NL;
  pW = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return NL = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, NL;
}
var FL, dW;
function lI() {
  if (dW) return FL;
  dW = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return FL = e, FL;
}
var fW, hW;
function mse() {
  return hW || (hW = 1, fW = Function.call.bind(Object.prototype.hasOwnProperty)), fW;
}
var zL, gW;
function xTe() {
  if (gW) return zL;
  gW = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = lI(), n = {}, r = mse();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, zL = o, zL;
}
var UL, mW;
function OTe() {
  if (mW) return UL;
  mW = 1;
  var e = gse(), t = CTe(), n = lI(), r = mse(), o = xTe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return UL = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: v(),
      instanceOf: x,
      node: N(),
      objectOf: z,
      oneOf: _,
      oneOfType: L,
      shape: V,
      exact: Z
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function y(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    y.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, F = 0;
      function S(C, I, U, T, q, j, Y) {
        if (T = T || d, j = j || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            F < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + j + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, F++);
          }
        }
        return I[U] == null ? C ? I[U] === null ? new y("The " + q + " `" + j + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new y("The " + q + " `" + j + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(I, U, T, q, j);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(P) {
      function D(F, S, W, C, I, U) {
        var T = F[S], q = K(T);
        if (q !== P) {
          var j = X(T);
          return new y(
            "Invalid " + C + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = F[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var j = P(U, q, W, C, I + "[" + q + "]", n);
          if (j instanceof Error)
            return j;
        }
        return null;
      }
      return b(D);
    }
    function O() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!s(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function v() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!e.isValidElementType(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function x(P) {
      function D(F, S, W, C, I) {
        if (!(F[S] instanceof P)) {
          var U = P.name || d, T = J(F[S]);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(F, S, W, C, I) {
        for (var U = F[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(j, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new y("Invalid " + C + " `" + I + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function z(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var j = P(U, q, W, C, I + "." + q, n);
            if (j instanceof Error)
              return j;
          }
        return null;
      }
      return b(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var F = P[D];
        if (typeof F != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(F) + " at index " + D + "."
          ), a;
      }
      function S(W, C, I, U, T) {
        for (var q = [], j = 0; j < P.length; j++) {
          var Y = P[j], B = Y(W, C, I, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new y("Invalid " + U + " `" + T + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(S);
    }
    function N() {
      function P(D, F, S, W, C) {
        return H(D[F]) ? null : new y("Invalid " + W + " `" + C + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, D, F, S, W) {
      return new y(
        (P || "React class") + ": " + D + " type `" + F + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var j = P[q];
          if (typeof j != "function")
            return R(W, C, I, q, X(j));
          var Y = j(U, q, W, C, I + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(D);
    }
    function Z(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, F[S], P);
        for (var j in q) {
          var Y = P[j];
          if (r(P, j) && typeof Y != "function")
            return R(W, C, I, j, X(Y));
          if (!Y)
            return new y(
              "Invalid " + C + " `" + I + "` key `" + j + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(F[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, j, W, C, I + "." + j, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(D);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var F = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = F.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = F.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function $(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : $(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, UL;
}
var HL, vW;
function ETe() {
  if (vW) return HL;
  vW = 1;
  var e = lI();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, HL = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, HL;
}
if (process.env.NODE_ENV !== "production") {
  var kTe = gse(), LTe = !0;
  ZM.exports = OTe()(kTe.isElement, LTe);
} else
  ZM.exports = ETe()();
var CE = ZM.exports, xE = {};
Object.defineProperty(xE, "__esModule", {
  value: !0
});
var PTe = Lm, WL = _Te(PTe);
function _Te(e) {
  return e && e.__esModule ? e : { default: e };
}
var STe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return WL.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && WL.default.getHash() !== e && WL.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
xE.default = STe;
Object.defineProperty(Om, "__esModule", {
  value: !0
});
var Ny = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, MTe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), DTe = we, yW = Sm(DTe), TTe = Em, Fy = Sm(TTe), jTe = Gd, ATe = Sm(jTe), ITe = CE, co = Sm(ITe), BTe = xE, iu = Sm(BTe);
function Sm(e) {
  return e && e.__esModule ? e : { default: e };
}
function RTe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function NTe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function FTe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var bW = {
  to: co.default.string.isRequired,
  containerId: co.default.string,
  container: co.default.object,
  activeClass: co.default.string,
  activeStyle: co.default.object,
  spy: co.default.bool,
  horizontal: co.default.bool,
  smooth: co.default.oneOfType([co.default.bool, co.default.string]),
  offset: co.default.number,
  delay: co.default.number,
  isDynamic: co.default.bool,
  onClick: co.default.func,
  duration: co.default.oneOfType([co.default.number, co.default.func]),
  absolute: co.default.bool,
  onSetActive: co.default.func,
  onSetInactive: co.default.func,
  ignoreCancelEvents: co.default.bool,
  hashSpy: co.default.bool,
  saveHashHistory: co.default.bool,
  spyThrottle: co.default.number
};
Om.default = function(e, t) {
  var n = t || ATe.default, r = function(i) {
    FTe(a, i);
    function a(s) {
      RTe(this, a);
      var l = NTe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return MTe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Fy.default.isMounted(s)) {
            var l = Fy.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (iu.default.isMounted() || iu.default.mount(n), iu.default.mapContainer(this.props.to, s)), Fy.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Fy.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Ny({}, this.props.style, this.props.activeStyle) : l = Ny({}, this.props.style);
        var u = Ny({}, this.props);
        for (var c in bW)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, yW.default.createElement(e, u);
      }
    }]), a;
  }(yW.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Ny({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(iu.default.isMounted() && !iu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, y = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, y = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(y), g = M < Math.floor(f) || M >= Math.floor(y);
        } else {
          var O = 0, v = 0, x = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            x = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            O = z.top - x + s, v = O + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(v), g = L < Math.floor(O) || L >= Math.floor(v);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && iu.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            iu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var Z = i.props.saveHashHistory, H = Z === void 0 ? !1 : Z;
          i.props.hashSpy && iu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = bW, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(rI, "__esModule", {
  value: !0
});
var zTe = we, wW = vse(zTe), UTe = Om, HTe = vse(UTe);
function vse(e) {
  return e && e.__esModule ? e : { default: e };
}
function WTe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function CW(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function VTe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var $Te = function(e) {
  VTe(t, e);
  function t() {
    var n, r, o, i;
    WTe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = CW(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return wW.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), CW(o, i);
  }
  return t;
}(wW.default.Component);
rI.default = (0, HTe.default)($Te);
var uI = {};
Object.defineProperty(uI, "__esModule", {
  value: !0
});
var ZTe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), qTe = we, xW = yse(qTe), GTe = Om, KTe = yse(GTe);
function yse(e) {
  return e && e.__esModule ? e : { default: e };
}
function YTe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function XTe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function JTe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var QTe = function(e) {
  JTe(t, e);
  function t() {
    return YTe(this, t), XTe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return ZTe(t, [{
    key: "render",
    value: function() {
      return xW.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(xW.default.Component);
uI.default = (0, KTe.default)(QTe);
var cI = {}, OE = {};
Object.defineProperty(OE, "__esModule", {
  value: !0
});
var eje = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, tje = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), nje = we, OW = EE(nje), rje = nl;
EE(rje);
var oje = Gd, EW = EE(oje), ije = CE, kW = EE(ije);
function EE(e) {
  return e && e.__esModule ? e : { default: e };
}
function sje(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function aje(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function lje(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
OE.default = function(e) {
  var t = function(n) {
    lje(r, n);
    function r(o) {
      sje(this, r);
      var i = aje(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return tje(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        EW.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        EW.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return OW.default.createElement(e, eje({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(OW.default.Component);
  return t.propTypes = {
    name: kW.default.string,
    id: kW.default.string
  }, t;
};
Object.defineProperty(cI, "__esModule", {
  value: !0
});
var LW = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, uje = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), cje = we, PW = pI(cje), pje = OE, dje = pI(pje), fje = CE, _W = pI(fje);
function pI(e) {
  return e && e.__esModule ? e : { default: e };
}
function hje(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function gje(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function mje(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var bse = function(e) {
  mje(t, e);
  function t() {
    return hje(this, t), gje(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return uje(t, [{
    key: "render",
    value: function() {
      var n = this, r = LW({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, PW.default.createElement(
        "div",
        LW({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(PW.default.Component);
bse.propTypes = {
  name: _W.default.string,
  id: _W.default.string
};
cI.default = (0, dje.default)(bse);
var VL = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, SW = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function MW(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function DW(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function TW(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var zy = we, Dc = Em, $L = Gd, No = CE, su = xE, jW = {
  to: No.string.isRequired,
  containerId: No.string,
  container: No.object,
  activeClass: No.string,
  spy: No.bool,
  smooth: No.oneOfType([No.bool, No.string]),
  offset: No.number,
  delay: No.number,
  isDynamic: No.bool,
  onClick: No.func,
  duration: No.oneOfType([No.number, No.func]),
  absolute: No.bool,
  onSetActive: No.func,
  onSetInactive: No.func,
  ignoreCancelEvents: No.bool,
  hashSpy: No.bool,
  spyThrottle: No.number
}, vje = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || $L, r = function(i) {
      TW(a, i);
      function a(s) {
        MW(this, a);
        var l = DW(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return SW(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Dc.isMounted(s) || Dc.mount(s, this.props.spyThrottle), this.props.hashSpy && (su.isMounted() || su.mount(n), su.mapContainer(this.props.to, s)), this.props.spy && Dc.addStateHandler(this.stateHandler), Dc.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Dc.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = VL({}, this.props);
          for (var u in jW)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, zy.createElement(e, l);
        }
      }]), a;
    }(zy.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, VL({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(su.isMounted() && !su.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var y = a - i.props.offset, b = y >= Math.floor(c) && y < Math.floor(p), E = y < Math.floor(c) || y >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && su.getHash() === l && su.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Dc.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && su.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Dc.updateStates();
        }
      };
    };
    return r.propTypes = jW, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      TW(r, n);
      function r(o) {
        MW(this, r);
        var i = DW(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return SW(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          $L.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          $L.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return zy.createElement(e, VL({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(zy.Component);
    return t.propTypes = {
      name: No.string,
      id: No.string
    }, t;
  }
}, yje = vje;
Object.defineProperty(ti, "__esModule", {
  value: !0
});
ti.Helpers = ti.ScrollElement = ti.ScrollLink = ti.animateScroll = ti.scrollSpy = ti.Events = ti.scroller = ti.Element = ti.Button = ti.Link = void 0;
var bje = rI, wse = rl(bje), wje = uI, Cse = rl(wje), Cje = cI, xse = rl(Cje), xje = Gd, Ose = rl(xje), Oje = Pm, Ese = rl(Oje), Eje = Em, kse = rl(Eje), kje = yE, Lse = rl(kje), Lje = Om, Pse = rl(Lje), Pje = OE, _se = rl(Pje), _je = yje, Sse = rl(_je);
function rl(e) {
  return e && e.__esModule ? e : { default: e };
}
ti.Link = wse.default;
ti.Button = Cse.default;
ti.Element = xse.default;
ti.scroller = Ose.default;
ti.Events = Ese.default;
ti.scrollSpy = kse.default;
ti.animateScroll = Lse.default;
ti.ScrollLink = Pse.default;
ti.ScrollElement = _se.default;
ti.Helpers = Sse.default;
ti.default = { Link: wse.default, Button: Cse.default, Element: xse.default, scroller: Ose.default, Events: Ese.default, scrollSpy: kse.default, animateScroll: Lse.default, ScrollLink: Pse.default, ScrollElement: _se.default, Helpers: Sse.default };
We({});
We({});
We({});
function nm(e) {
  "@babel/helpers - typeof";
  return nm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, nm(e);
}
function Sje(e, t) {
  if (nm(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (nm(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Mje(e) {
  var t = Sje(e, "string");
  return nm(t) == "symbol" ? t : t + "";
}
function De(e, t, n) {
  return (t = Mje(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Mse(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ZL, AW;
function Dje() {
  if (AW) return ZL;
  AW = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return ZL = t, ZL;
}
var Tje = Dje(), ci = /* @__PURE__ */ Mse(Tje), Ut = We(null);
function jje() {
  ci(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Ut);
  return ci(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Aje(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Ije(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Bje(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Ije(e, i), o;
}
function Rje(e, t, n) {
  var r = Aje(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function Nje(e) {
  google.maps.event.removeListener(e);
}
function In() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(Nje);
}
function En(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = Rje(o, i, n);
  return Bje(t, r, o, i), a;
}
function Fje(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: y,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [v, x] = k(null), _ = ht(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null), [j, Y] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && y && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", y)));
  }, [y]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (j !== null && google.maps.event.removeListener(j), Y(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return x(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), Bi.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: Bi.jsx(Ut.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(Fje);
function IW(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Dse(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        IW(i, r, o, a, s, "next", l);
      }
      function s(l) {
        IW(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Tse(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return ci(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var gp = typeof document < "u";
function jse(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return gp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function BW(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Ase() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return BW(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return BW(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Tf = !1;
function Ise() {
  return Bi.jsx("div", {
    children: "Loading..."
  });
}
var qM = {
  id: "script-loader",
  version: "weekly"
};
class zje extends pe {
  constructor() {
    super(...arguments), De(this, "check", null), De(this, "state", {
      loaded: !1
    }), De(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), De(this, "isCleaningUp", /* @__PURE__ */ Dse(function* () {
      function t(n) {
        if (!Tf)
          n();
        else if (gp)
          var r = window.setInterval(function() {
            Tf || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), De(this, "cleanup", () => {
      Tf = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), De(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Ase(), ci(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Tse(this.props)
      };
      jse(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), De(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (gp) {
      if (window.google && window.google.maps && !Tf) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), gp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (gp) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Tf = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Bi.jsxs(Bi.Fragment, {
      children: [Bi.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Bi.jsx(Ise, {})]
    });
  }
}
De(zje, "defaultProps", qM);
function Uje(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function dI(e, t) {
  if (e == null) return {};
  var n, r, o = Uje(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var RW;
function Hje(e) {
  var {
    id: t = qM.id,
    version: n = qM.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ht(!1), [f, y] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    gp && u && Ase();
  }, [u]), h(function() {
    f && ci(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Tse({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!gp)
      return;
    function O() {
      g.current && (y(!0), RW = w);
    }
    if (window.google && window.google.maps && RW === w) {
      O();
      return;
    }
    jse({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = ht(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var Wje = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], Vje = Bi.jsx(Ise, {});
function $je(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = dI(e, Wje), {
    isLoaded: s,
    loadError: l
  } = Hje(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || Vje;
}
me($je);
var NW;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(NW || (NW = {}));
function FW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function A0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FW(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zW = {}, UW = {
  options(e, t) {
    e.setOptions(t);
  }
};
function Zje(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Ut), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(A0(A0({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(Zje);
class qje extends pe {
  constructor() {
    super(...arguments), De(this, "state", {
      trafficLayer: null
    }), De(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), De(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(A0(A0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: UW,
      eventMap: zW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: UW,
      eventMap: zW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), In(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(qje, "contextType", Ut);
function Gje(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ut), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(Gje);
class Kje extends pe {
  constructor() {
    super(...arguments), De(this, "state", {
      bicyclingLayer: null
    }), De(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(Kje, "contextType", Ut);
function Yje(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ut), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(Yje);
class Xje extends pe {
  constructor() {
    super(...arguments), De(this, "state", {
      transitLayer: null
    }), De(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(Xje, "contextType", Ut);
function HW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function I0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HW(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WW = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, VW = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Jje(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Ut), [d, g] = k(null), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), y(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    ci(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(I0(I0({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && y(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && v(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(Jje);
class Qje extends pe {
  constructor(t) {
    super(t), De(this, "registeredEvents", []), De(this, "state", {
      drawingManager: null
    }), De(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), ci(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(I0(I0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: VW,
      eventMap: WW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: VW,
      eventMap: WW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), In(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
De(Qje, "contextType", Ut);
function $W(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $W(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $W(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ZW = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, qW = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, B0 = {};
function eAe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: y,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: v,
    onMouseOut: x,
    onMouseOver: _,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: Z,
    onDraggableChanged: H,
    onFlatChanged: $,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: F,
    onUnmount: S
  } = e, W = ge(Ut), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null), [oe, Pe] = k(null), [Ue, Ze] = k(null), [_e, rt] = k(null), [Ve, ye] = k(null), [Ge, ct] = k(null), [ve, Oe] = k(null), [qe, ze] = k(null), [Se, st] = k(null), [xe, xt] = k(null), [at, lt] = k(null), [pt, Ot] = k(null), [dt, ft] = k(null), [ot, He] = k(null), [Et, kt] = k(null), [gt, St] = k(null), [mt, Mt] = k(null), [vt, Pt] = k(null);
  h(() => {
    C !== null && C.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && C !== null && C.setOptions(n);
  }, [C, n]), h(() => {
    typeof a < "u" && C !== null && C.setDraggable(a);
  }, [C, a]), h(() => {
    t && C !== null && C.setPosition(t);
  }, [C, t]), h(() => {
    typeof s < "u" && C !== null && C.setVisible(s);
  }, [C, s]), h(() => {
    C == null || C.setAnimation(l);
  }, [C, l]), h(() => {
    C && u !== void 0 && C.setClickable(u);
  }, [C, u]), h(() => {
    C && c !== void 0 && C.setCursor(c);
  }, [C, c]), h(() => {
    C && p !== void 0 && C.setIcon(p);
  }, [C, p]), h(() => {
    C && d !== void 0 && C.setLabel(d);
  }, [C, d]), h(() => {
    C && g !== void 0 && C.setOpacity(g);
  }, [C, g]), h(() => {
    C && f !== void 0 && C.setShape(f);
  }, [C, f]), h(() => {
    C && y !== void 0 && C.setTitle(y);
  }, [C, y]), h(() => {
    C && b !== void 0 && C.setZIndex(b);
  }, [C, b]), h(() => {
    C && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(C, "dblclick", w)));
  }, [w]), h(() => {
    C && O && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(C, "dragend", O)));
  }, [O]), h(() => {
    C && v && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(C, "dragstart", v)));
  }, [v]), h(() => {
    C && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(C, "mousedown", L)));
  }, [L]), h(() => {
    C && x && (oe !== null && google.maps.event.removeListener(oe), Pe(google.maps.event.addListener(C, "mouseout", x)));
  }, [x]), h(() => {
    C && _ && (Ue !== null && google.maps.event.removeListener(Ue), Ze(google.maps.event.addListener(C, "mouseover", _)));
  }, [_]), h(() => {
    C && z && (_e !== null && google.maps.event.removeListener(_e), rt(google.maps.event.addListener(C, "mouseup", z)));
  }, [z]), h(() => {
    C && N && (Ve !== null && google.maps.event.removeListener(Ve), ye(google.maps.event.addListener(C, "rightclick", N)));
  }, [N]), h(() => {
    C && E && (Ge !== null && google.maps.event.removeListener(Ge), ct(google.maps.event.addListener(C, "click", E)));
  }, [E]), h(() => {
    C && M && (ve !== null && google.maps.event.removeListener(ve), Oe(google.maps.event.addListener(C, "drag", M)));
  }, [M]), h(() => {
    C && R && (qe !== null && google.maps.event.removeListener(qe), ze(google.maps.event.addListener(C, "clickable_changed", R)));
  }, [R]), h(() => {
    C && V && (Se !== null && google.maps.event.removeListener(Se), st(google.maps.event.addListener(C, "cursor_changed", V)));
  }, [V]), h(() => {
    C && Z && (xe !== null && google.maps.event.removeListener(xe), xt(google.maps.event.addListener(C, "animation_changed", Z)));
  }, [Z]), h(() => {
    C && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(C, "draggable_changed", H)));
  }, [H]), h(() => {
    C && $ && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(C, "flat_changed", $)));
  }, [$]), h(() => {
    C && K && (dt !== null && google.maps.event.removeListener(dt), ft(google.maps.event.addListener(C, "icon_changed", K)));
  }, [K]), h(() => {
    C && X && (ot !== null && google.maps.event.removeListener(ot), He(google.maps.event.addListener(C, "position_changed", X)));
  }, [X]), h(() => {
    C && Q && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(C, "shape_changed", Q)));
  }, [Q]), h(() => {
    C && J && (gt !== null && google.maps.event.removeListener(gt), St(google.maps.event.addListener(C, "title_changed", J)));
  }, [J]), h(() => {
    C && P && (mt !== null && google.maps.event.removeListener(mt), Mt(google.maps.event.addListener(C, "visible_changed", P)));
  }, [P]), h(() => {
    C && D && (vt !== null && google.maps.event.removeListener(vt), Pt(google.maps.event.addListener(C, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = vd(vd(vd({}, n || B0), r ? B0 : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(yt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof g < "u" && te.setOpacity(g), f && te.setShape(f), typeof y == "string" && te.setTitle(y), typeof b == "number" && te.setZIndex(b), w && T(google.maps.event.addListener(te, "dblclick", w)), O && j(google.maps.event.addListener(te, "dragend", O)), v && B(google.maps.event.addListener(te, "dragstart", v)), L && he(google.maps.event.addListener(te, "mousedown", L)), x && Pe(google.maps.event.addListener(te, "mouseout", x)), _ && Ze(google.maps.event.addListener(te, "mouseover", _)), z && rt(google.maps.event.addListener(te, "mouseup", z)), N && ye(google.maps.event.addListener(te, "rightclick", N)), E && ct(google.maps.event.addListener(te, "click", E)), M && Oe(google.maps.event.addListener(te, "drag", M)), R && ze(google.maps.event.addListener(te, "clickable_changed", R)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), Z && xt(google.maps.event.addListener(te, "animation_changed", Z)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), $ && Ot(google.maps.event.addListener(te, "flat_changed", $)), K && ft(google.maps.event.addListener(te, "icon_changed", K)), X && He(google.maps.event.addListener(te, "position_changed", X)), Q && kt(google.maps.event.addListener(te, "shape_changed", Q)), J && St(google.maps.event.addListener(te, "title_changed", J)), P && Mt(google.maps.event.addListener(te, "visible_changed", P)), D && Pt(google.maps.event.addListener(te, "zindex_changed", D)), I(te), F && F(te), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), _e !== null && google.maps.event.removeListener(_e), Ve !== null && google.maps.event.removeListener(Ve), Ge !== null && google.maps.event.removeListener(Ge), qe !== null && google.maps.event.removeListener(qe), Se !== null && google.maps.event.removeListener(Se), xe !== null && google.maps.event.removeListener(xe), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ot !== null && google.maps.event.removeListener(ot), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var jn = Ft(() => i ? ut.map(i, (yt) => {
    if (!wi(yt))
      return yt;
    var te = yt;
    return Ci(te, {
      anchor: C
    });
  }) : null, [i, C]);
  return Bi.jsx(Bi.Fragment, {
    children: jn
  }) || null;
}
me(eAe);
class tAe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Dse(function* () {
      var n = vd(vd(vd({}, t.props.options || B0), t.props.clusterer ? B0 : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = En({
        updaterMap: qW,
        eventMap: ZW,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: qW,
      eventMap: ZW,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), In(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Ci(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
De(tAe, "contextType", Ut);
var nAe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), rAe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new nAe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function oAe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var iAe = 2e3, sAe = 500, aAe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", lAe = "png", uAe = [53, 56, 66, 78, 90], cAe = "cluster", Bse = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || aAe, this.imageExtension = r.imageExtension || lAe, this.imageSizes = r.imageSizes || uAe, this.calculator = r.calculator || oAe, this.batchSize = r.batchSize || iAe, this.batchSizeIE = r.batchSizeIE || sAe, this.clusterClass = r.clusterClass || cAe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new rAe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function GW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pAe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GW(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ha = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Wn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, dAe = {};
function fAe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: y,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: v,
    onMouseOut: x,
    onLoad: _,
    onUnmount: z
  } = e, [L, N] = k(null), R = ge(Ut), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && x && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, ha.onMouseOut, x)));
  }, [x]), h(() => {
    L && v && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, ha.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(L, ha.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(L, ha.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), $(google.maps.event.addListener(L, ha.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && Wn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Wn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Wn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Wn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Wn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Wn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Wn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Wn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Wn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Wn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Wn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Wn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof y < "u" && L !== null && Wn.styles(L, y);
  }, [L, y]), h(() => {
    typeof b < "u" && L !== null && Wn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && Wn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var F = pAe({}, n || dAe), S = new Bse(R, [], F);
      return r && Wn.averageCenter(S, r), o && Wn.batchSizeIE(S, o), i && Wn.calculator(S, i), a && Wn.clusterClass(S, a), s && Wn.enableRetinaIcons(S, s), l && Wn.gridSize(S, l), u && Wn.ignoreHidden(S, u), c && Wn.imageExtension(S, c), p && Wn.imagePath(S, p), d && Wn.imageSizes(S, d), g && Wn.maxZoom(S, g), f && Wn.minimumClusterSize(S, f), y && Wn.styles(S, y), b && Wn.title(S, b), E && Wn.zoomOnClick(S, E), x && J(google.maps.event.addListener(S, ha.onMouseOut, x)), v && D(google.maps.event.addListener(S, ha.onMouseOver, v)), w && Z(google.maps.event.addListener(S, ha.onClick, w)), M && $(google.maps.event.addListener(S, ha.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, ha.onClusteringEnd, O)), N(S), _ && _(S), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), z && z(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(fAe);
class hAe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      markerClusterer: null
    }), De(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Bse(this.context, [], this.props.options);
      this.registeredEvents = En({
        updaterMap: Wn,
        eventMap: ha,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: Wn,
      eventMap: ha,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), In(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
De(hAe, "contextType", Ut);
function KW(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Rse = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || KW(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, KW));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, y = this.getProjection(), b = y.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), gAe = ["position"], mAe = ["position"];
function YW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function R0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YW(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var XW = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, JW = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, vAe = {};
function yAe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Ut), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || vAe, {
        position: V
      } = R, Z = dI(R, gAe), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var $ = new Rse(R0(R0({}, Z), H ? {
        position: H
      } : {}));
      N.current = document.createElement("div"), y($), a && E(google.maps.event.addListener($, "closeclick", a)), s && M(google.maps.event.addListener($, "domready", s)), l && v(google.maps.event.addListener($, "content_changed", l)), u && _(google.maps.event.addListener($, "position_changed", u)), c && L(google.maps.event.addListener($, "zindex_changed", c)), $.setContent(N.current), n ? $.open(g, n) : $.getPosition() ? $.open(g) : ci(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p($);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(yAe);
class bAe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "containerElement", null), De(this, "state", {
      infoBox: null
    }), De(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : ci(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), De(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = dI(t, mAe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Rse(R0(R0({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = En({
      updaterMap: JW,
      eventMap: XW,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: JW,
      eventMap: XW,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), In(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
De(bAe, "contextType", Ut);
var QW, eV;
function wAe() {
  return eV || (eV = 1, QW = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), QW;
}
var CAe = wAe(), tV = /* @__PURE__ */ Mse(CAe), nV = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], qL = 1, jf = 8;
class fI {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== qL)
      throw new Error("Got v".concat(o, " data when expected v").concat(qL, "."));
    var i = nV[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new fI(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = nV.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, jf, t), this.coords = new this.ArrayType(this.data, jf + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(jf + a + s + l), this.ids = new this.IndexArrayType(this.data, jf, t), this.coords = new this.ArrayType(this.data, jf + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (qL << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return GM(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], y = a[2 * g + 1];
          f >= t && f <= r && y >= n && y <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          rV(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, y = i[2 * f], b = i[2 * f + 1];
      rV(y, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= y : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= y : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function GM(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Nse(e, t, a, r, o, i), GM(e, t, n, r, a - 1, 1 - i), GM(e, t, n, a + 1, o, 1 - i);
  }
}
function Nse(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Nse(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, y = o;
    for (Af(e, t, r, n), t[2 * o + i] > g && Af(e, t, r, o); f < y; ) {
      for (Af(e, t, f, y), f++, y--; t[2 * f + i] < g; ) f++;
      for (; t[2 * y + i] > g; ) y--;
    }
    t[2 * r + i] === g ? Af(e, t, r, y) : (y++, Af(e, t, y, o)), y <= n && (r = y + 1), n <= y && (o = y - 1);
  }
}
function Af(e, t, n, r) {
  GL(e, n, r), GL(t, 2 * n, 2 * r), GL(t, 2 * n + 1, 2 * r + 1);
}
function GL(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function rV(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var xAe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, oV = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Tc = 2, ju = 3, KL = 4, Eu = 5, Fse = 6;
class OAe {
  constructor(t) {
    this.options = Object.assign(Object.create(xAe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = oV(Uy(u)), d = oV(Hy(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var y = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - y);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Uy(r), Hy(a), Uy(i), Hy(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Eu] > 1 ? iV(p, f, this.clusterProps) : this.points[p[f + ju]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + KL] === t && p.push(a[g + Eu] > 1 ? iV(a, g, this.clusterProps) : this.points[a[g + ju]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new fI(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Eu] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = zse(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + ju]];
        c = g.properties;
        var [f, y] = g.geometry.coordinates;
        p = Uy(f), d = Hy(y);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + ju] : E = this.points[n[l + ju]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Tc] <= n)) {
        l[p + Tc] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), y = l[p + Eu], b = y;
        for (var E of f) {
          var w = E * c;
          l[w + Tc] > n && (b += l[w + Eu]);
        }
        if (b > y && b >= a) {
          var M = d * y, O = g * y, v = void 0, x = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Tc] <= n)) {
              l[L + Tc] = n;
              var N = l[L + Eu];
              M += l[L] * N, O += l[L + 1] * N, l[L + KL] = _, i && (v || (v = this._map(l, p, !0), x = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + KL] = _, u.push(M / b, O / b, 1 / 0, _, -1, b), i && u.push(x);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var Z = V * c;
              if (!(l[Z + Tc] <= n)) {
                l[Z + Tc] = n;
                for (var H = 0; H < c; H++) u.push(l[Z + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Eu] > 1) {
      var o = this.clusterProps[t[n + Fse]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + ju]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function iV(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ju],
    properties: zse(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [EAe(e[t]), kAe(e[t + 1])]
    }
  };
}
function zse(e, t, n) {
  var r = e[t + Eu], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Fse], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + ju],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Uy(e) {
  return e / 360 + 0.5;
}
function Hy(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function EAe(e) {
  return (e - 0.5) * 360;
}
function kAe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function LAe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Us {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class KM {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Us.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Us.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Us.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
let PAe = class {
  constructor(e) {
    var {
      maxZoom: t = 16
    } = e;
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(e) {
    var {
      markers: t
    } = e;
    return _Ae(t);
  }
};
var _Ae = (e) => {
  var t = e.map((n) => new KM({
    position: Us.getPosition(n),
    markers: [n]
  }));
  return t;
};
class SAe extends PAe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = LAe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new OAe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!tV(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Us.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !tV(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new KM({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new KM({
      markers: [i],
      position: Us.getPosition(i)
    });
  }
}
class MAe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class DAe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Us.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function TAe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class hI {
  constructor() {
    TAe(hI, google.maps.OverlayView);
  }
}
var Vh;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Vh || (Vh = {}));
var jAe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class AAe extends hI {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new SAe(o),
      renderer: a = new DAe(),
      onClusterClick: s = jAe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Us.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Vh.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Us.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Us.setMap(l, null)));
      }
      google.maps.event.trigger(this, Vh.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Us.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new MAe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Us.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Vh.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Us.setMap(r.marker, n);
    });
  }
}
function sV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sV(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function IAe(e) {
  var t = jje(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new AAe(aV(aV({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function BAe(e) {
  var {
    children: t,
    options: n
  } = e, r = IAe(n);
  return r !== null ? t(r) : null;
}
me(BAe);
var lV = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, uV = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function RAe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Ut), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return y(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && v(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : ci(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(R), R.close();
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(RAe);
class NAe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "containerElement", null), De(this, "state", {
      infoWindow: null
    }), De(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : ci(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), De(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = En({
      updaterMap: uV,
      eventMap: lV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: uV,
      eventMap: lV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (In(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
De(NAe, "contextType", Ut);
function cV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function N0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cV(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pV = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, dV = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, FAe = {};
function zAe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Ut), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && y && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(O, "click", y)));
  }, [y]), h(() => {
    O && b && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(O, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(N0(N0({}, t || FAe), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && Z(google.maps.event.addListener(T, "mousedown", u)), c && $(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), y && C(google.maps.event.addListener(T, "click", y)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(zAe);
class UAe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      polyline: null
    }), De(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(N0(N0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: dV,
      eventMap: pV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: dV,
      eventMap: pV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), In(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
De(UAe, "contextType", Ut);
function fV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fV(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gV = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, mV = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function HAe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, v = ge(Ut), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    x !== null && x.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    typeof a < "u" && x !== null && x.setPaths(a);
  }, [x, a]), h(() => {
    x && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dblclick", s)));
  }, [s]), h(() => {
    x && (google.maps.event.addListener(x.getPath(), "insert_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "set_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "remove_at", () => {
      O == null || O(x);
    }));
  }, [x, O]), h(() => {
    x && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragend", l)));
  }, [l]), h(() => {
    x && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(x, "dragstart", u)));
  }, [u]), h(() => {
    x && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(x, "mousedown", c)));
  }, [c]), h(() => {
    x && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(x, "mousemove", p)));
  }, [p]), h(() => {
    x && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseout", d)));
  }, [d]), h(() => {
    x && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(x, "mouseover", g)));
  }, [g]), h(() => {
    x && typeof f == "function" && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(x, "mouseup", f)));
  }, [f]), h(() => {
    x && typeof y == "function" && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(x, "rightclick", y)));
  }, [y]), h(() => {
    x && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(x, "click", b)));
  }, [b]), h(() => {
    x && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(x, "drag", E)));
  }, [E]), h(() => {
    var j = new google.maps.Polygon(hV(hV({}, t), {}, {
      map: v
    }));
    return i && j.setPath(i), a && j.setPaths(a), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), s && L(google.maps.event.addListener(j, "dblclick", s)), l && R(google.maps.event.addListener(j, "dragend", l)), u && Z(google.maps.event.addListener(j, "dragstart", u)), c && $(google.maps.event.addListener(j, "mousedown", c)), p && X(google.maps.event.addListener(j, "mousemove", p)), d && J(google.maps.event.addListener(j, "mouseout", d)), g && D(google.maps.event.addListener(j, "mouseover", g)), f && S(google.maps.event.addListener(j, "mouseup", f)), y && C(google.maps.event.addListener(j, "rightclick", y)), b && U(google.maps.event.addListener(j, "click", b)), E && q(google.maps.event.addListener(j, "drag", E)), _(j), w && w(j), () => {
      z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), M && M(j), j.setMap(null);
    };
  }, []), null;
}
me(HAe);
class WAe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = En({
      updaterMap: mV,
      eventMap: gV,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: mV,
      eventMap: gV,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), In(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
De(WAe, "contextType", Ut);
function vV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function F0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vV(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yV = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, bV = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function VAe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(Ut), [v, x] = k(null), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null);
  return h(() => {
    v !== null && v.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(v, "click", y)));
  }, [y]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(F0(F0({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && z(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && H(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && F(google.maps.event.addListener(Y, "mouseup", g)), f && W(google.maps.event.addListener(Y, "rightclick", f)), y && I(google.maps.event.addListener(Y, "click", y)), b && T(google.maps.event.addListener(Y, "drag", b)), E && j(google.maps.event.addListener(Y, "bounds_changed", E)), x(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
me(VAe);
class $Ae extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      rectangle: null
    }), De(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(F0(F0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: bV,
      eventMap: yV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: bV,
      eventMap: yV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), In(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
De($Ae, "contextType", Ut);
function wV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function z0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wV(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var CV = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, xV = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, ZAe = {};
function qAe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: v
  } = e, x = ge(Ut), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null);
  return h(() => {
    _ !== null && _.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(_, "rightclick", y)));
  }, [y]), h(() => {
    _ && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", b)));
  }, [b]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [b]), h(() => {
    _ && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(z0(z0({}, t || ZAe), {}, {
      map: x
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && F(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), y && I(google.maps.event.addListener(oe, "rightclick", y)), b && T(google.maps.event.addListener(oe, "click", b)), E && j(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), z(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(qAe);
class GAe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      circle: null
    }), De(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(z0(z0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: xV,
      eventMap: CV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: xV,
      eventMap: CV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), In(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
De(GAe, "contextType", Ut);
function OV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function U0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OV(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var EV = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, kV = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function KAe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: y,
    onUnmount: b
  } = e, E = ge(Ut), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var j = new google.maps.Data(U0(U0({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(j, "dblclick", r)), o && _(google.maps.event.addListener(j, "mousedown", o)), i && L(google.maps.event.addListener(j, "mousemove", i)), a && R(google.maps.event.addListener(j, "mouseout", a)), s && Z(google.maps.event.addListener(j, "mouseover", s)), l && $(google.maps.event.addListener(j, "mouseup", l)), u && X(google.maps.event.addListener(j, "rightclick", u)), n && J(google.maps.event.addListener(j, "click", n)), c && D(google.maps.event.addListener(j, "addfeature", c)), p && S(google.maps.event.addListener(j, "removefeature", p)), d && C(google.maps.event.addListener(j, "removeproperty", d)), g && U(google.maps.event.addListener(j, "setgeometry", g)), f && q(google.maps.event.addListener(j, "setproperty", f)), M(j), y && y(j);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(KAe);
class YAe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      data: null
    }), De(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(U0(U0({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = En({
        updaterMap: kV,
        eventMap: EV,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: kV,
      eventMap: EV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), In(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
De(YAe, "contextType", Ut);
function LV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function PV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LV(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _V = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, SV = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class XAe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      kmlLayer: null
    }), De(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(PV(PV({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: SV,
      eventMap: _V,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: SV,
      eventMap: _V,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), In(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(XAe, "contextType", Ut);
function Use(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function JAe(e, t) {
  return new t(e.lat, e.lng);
}
function QAe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function eIe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function tIe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function nIe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function rIe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Hse(e, t, n, r) {
  return n !== void 0 ? nIe(e, t, tIe(n, google.maps.LatLngBounds, QAe)) : rIe(e, t, eIe(r, google.maps.LatLng, JAe));
}
function oIe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function MV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iIe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MV(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function sIe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = iIe({}, this.container ? Use(this.container, o) : {
        x: 0,
        y: 0
      }), u = Hse(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function DV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aIe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DV(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function TV(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function jV(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function lIe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Ut), c = Ft(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Ft(() => sIe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), xi.createPortal(l, c);
}
me(lIe);
class Kd extends pe {
  constructor(t) {
    super(t), De(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), De(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      ci(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), De(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), De(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = aIe({
        x: 0,
        y: 0
      }, this.containerRef.current ? Use(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Hse(r, o, this.props.bounds, this.props.position);
      if (!oIe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), De(this, "draw", () => {
      this.onPositionElement();
    }), De(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Br();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = TV(t.position), r = TV(this.props.position), o = jV(t.bounds), i = jV(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? xi.createPortal(Bi.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
De(Kd, "FLOAT_PANE", "floatPane");
De(Kd, "MAP_PANE", "mapPane");
De(Kd, "MARKER_LAYER", "markerLayer");
De(Kd, "OVERLAY_LAYER", "overlayLayer");
De(Kd, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
De(Kd, "contextType", Ut);
function uIe() {
}
function AV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function IV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AV(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var BV = {
  onDblClick: "dblclick",
  onClick: "click"
}, RV = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function cIe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Ut), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Ft(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(cIe);
class Wse extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      groundOverlay: null
    }), De(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    ci(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, IV(IV({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: RV,
      eventMap: BV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: RV,
      eventMap: BV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
De(Wse, "defaultProps", {
  onLoad: uIe
});
De(Wse, "contextType", Ut);
function NV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function H0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NV(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FV = {}, zV = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function pIe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Ut), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || ci(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    ci(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(H0(H0({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(pIe);
class dIe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      heatmapLayer: null
    }), De(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    ci(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), ci(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(H0(H0({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = En({
      updaterMap: zV,
      eventMap: FV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: zV,
      eventMap: FV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), In(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(dIe, "contextType", Ut);
var UV = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, HV = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class fIe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      streetViewPanorama: null
    }), De(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = En({
      updaterMap: HV,
      eventMap: UV,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: HV,
      eventMap: UV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), In(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
De(fIe, "contextType", Ut);
class hIe extends pe {
  constructor() {
    super(...arguments), De(this, "state", {
      streetViewService: null
    }), De(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
De(hIe, "contextType", Ut);
var WV = {
  onDirectionsChanged: "directions_changed"
}, VV = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class gIe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      directionsRenderer: null
    }), De(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = En({
      updaterMap: VV,
      eventMap: WV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: VV,
      eventMap: WV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), In(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
De(gIe, "contextType", Ut);
var $V = {
  onPlacesChanged: "places_changed"
}, ZV = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class mIe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "containerElement", Br()), De(this, "state", {
      searchBox: null
    }), De(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (ci(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = En({
          updaterMap: ZV,
          eventMap: $V,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: ZV,
      eventMap: $V,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), In(this.registeredEvents));
  }
  render() {
    return Bi.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
De(mIe, "contextType", Ut);
var qV = {
  onPlaceChanged: "place_changed"
}, GV = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Vse extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "containerElement", Br()), De(this, "state", {
      autocomplete: null
    }), De(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    ci(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = En({
        updaterMap: GV,
        eventMap: qV,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    In(this.registeredEvents), this.registeredEvents = En({
      updaterMap: GV,
      eventMap: qV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && In(this.registeredEvents);
  }
  render() {
    return Bi.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
De(Vse, "defaultProps", {
  className: ""
});
De(Vse, "contextType", Ut);
let vIe = { data: "" }, yIe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || vIe, bIe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, wIe = /\/\*[^]*?\*\/|  +/g, KV = /\n+/g, Vu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Vu(a, i) : i + "{" + Vu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Vu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Vu.p ? Vu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Cl = {}, $se = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + $se(e[n]);
    return t;
  }
  return e;
}, CIe = (e, t, n, r, o) => {
  let i = $se(e), a = Cl[i] || (Cl[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Cl[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = bIe.exec(u.replace(wIe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(KV, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(KV, " ").trim();
      return d[0];
    })(e);
    Cl[a] = Vu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Cl.g ? Cl.g : null;
  return n && (Cl.g = Cl[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Cl[a], t, r, s), a;
}, xIe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Vu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function kE(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return CIe(n.unshift ? n.raw ? xIe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, yIe(t.target), t.g, t.o, t.k);
}
let Zse, YM, XM;
kE.bind({ g: 1 });
let zl = kE.bind({ k: 1 });
function OIe(e, t, n, r) {
  Vu.p = t, Zse = e, YM = n, XM = r;
}
function Cc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: YM && YM() }, s), n.o = / *go\d+/.test(l), s.className = kE.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), XM && u[0] && XM(s), Zse(u, s);
    }
    return o;
  };
}
var EIe = (e) => typeof e == "function", kIe = (e, t) => EIe(e) ? e(t) : e, LIe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), PIe = zl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, _Ie = zl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, SIe = zl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, MIe = Cc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${PIe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${_Ie} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${SIe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, DIe = zl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, TIe = Cc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${DIe} 1s linear infinite;
`, jIe = zl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, AIe = zl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, IIe = Cc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${jIe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${AIe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, BIe = Cc("div")`
  position: absolute;
`, RIe = Cc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, NIe = zl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, FIe = Cc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${NIe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, zIe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Me.createElement(FIe, null, t) : t : n === "blank" ? null : Me.createElement(RIe, null, Me.createElement(TIe, { ...r }), n !== "loading" && Me.createElement(BIe, null, n === "error" ? Me.createElement(MIe, { ...r }) : Me.createElement(IIe, { ...r })));
}, UIe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, HIe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, WIe = "0%{opacity:0;} 100%{opacity:1;}", VIe = "0%{opacity:1;} 100%{opacity:0;}", $Ie = Cc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, ZIe = Cc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, qIe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = LIe() ? [WIe, VIe] : [UIe(n), HIe(n)];
  return { animation: t ? `${zl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${zl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Me.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? qIe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Me.createElement(zIe, { toast: e }), a = Me.createElement(ZIe, { ...e.ariaProps }, kIe(e.message, e));
  return Me.createElement($Ie, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Me.createElement(Me.Fragment, null, i, a));
});
OIe(Me.createElement);
kE`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
We({});
function GIe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const KIe = {
  CNPJ: "99.999.999/9999-99"
};
GIe(KIe.CNPJ).length;
yr((e, t) => /* @__PURE__ */ Ii.jsx("input", { ref: t, ...e }));
function qse(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Gse = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function YIe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function XIe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const JIe = qse(Gse.NINE).length, QIe = yr((e, t) => /* @__PURE__ */ Ii.jsx("input", { ref: t, ...e }));
yr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = qse(g.target.value);
      const y = XIe(f);
      f.length > JIe || (f = YIe(f, Gse[y]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Ii.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Ii.jsx(
      tl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: QIe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
We({});
var Xl = {};
Object.defineProperty(Xl, "__esModule", {
  value: !0
});
var eBe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), YL = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Kse = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: eBe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, gI = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Wy = 1; Wy < 20; Wy++)
  gI["f" + Wy] = 111 + Wy;
function LE(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Yse(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Xse(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function tBe(e, t) {
  return LE(e, t);
}
function nBe(e, t) {
  return LE(e, { byKey: !0 }, t);
}
function Yse(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in YL)
    r[YL[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = mI(d), y = YL[f];
      if (d.length > 1 && !y && !Kse[d] && !gI[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !y) && (n ? r.key = f : r.which = Jse(d)), y && (r[y] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Xse(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Jse(e) {
  e = mI(e);
  var t = gI[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function mI(e) {
  return e = e.toLowerCase(), e = Kse[e] || e, e;
}
Xl.default = LE;
var XL = Xl.isHotkey = LE;
Xl.isCodeHotkey = tBe;
Xl.isKeyHotkey = nBe;
Xl.parseHotkey = Yse;
Xl.compareHotkey = Xse;
Xl.toKeyCode = Jse;
Xl.toKeyName = mI;
var rBe = typeof Ar == "object" && Ar && Ar.Object === Object && Ar, oBe = rBe, iBe = oBe, sBe = typeof self == "object" && self && self.Object === Object && self, aBe = iBe || sBe || Function("return this")(), lBe = aBe, uBe = lBe, cBe = uBe.Symbol, Qse = cBe, YV = Qse;
YV && YV.toStringTag;
var XV = Qse;
XV && XV.toStringTag;
var JV;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(JV || (JV = {}));
var vI = function(e) {
  return Object.freeze(e);
}, pBe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, vI(this);
  }
  return e;
}(), dBe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, vI(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), QV = typeof window < "u" ? window : {};
/msie|trident/i.test(QV.navigator && QV.navigator.userAgent);
var JL = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new pBe((n ? t : e) || 0, (n ? e : t) || 0);
};
vI({
  devicePixelContentBoxSize: JL(),
  borderBoxSize: JL(),
  contentBoxSize: JL(),
  contentRect: new dBe(0, 0, 0, 0)
});
function rm(e) {
  "@babel/helpers - typeof";
  return rm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, rm(e);
}
function fBe(e, t) {
  if (rm(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (rm(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function hBe(e) {
  var t = fBe(e, "string");
  return rm(t) === "symbol" ? t : String(t);
}
function $h(e, t, n) {
  return t = hBe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var gBe = /* @__PURE__ */ We(null), QL, e1;
parseInt(we.version.split(".")[0], 10);
var e$ = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), t1 = typeof navigator < "u" && /Android/.test(navigator.userAgent), Vy = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), mBe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (QL = navigator.userAgent.match(/Version\/(\d+)/)) !== null && QL !== void 0 && QL[1] && parseInt((e1 = navigator.userAgent.match(/Version\/(\d+)/)) === null || e1 === void 0 ? void 0 : e1[1], 10) < 17;
var vBe = /* @__PURE__ */ new WeakMap(), yBe = /* @__PURE__ */ new WeakMap(), bBe = /* @__PURE__ */ new WeakMap(), wBe = /* @__PURE__ */ new WeakMap(), CBe = /* @__PURE__ */ new WeakMap(), t$ = /* @__PURE__ */ new WeakMap(), xBe = /* @__PURE__ */ new WeakMap(), n$ = /* @__PURE__ */ new WeakMap(), $y = /* @__PURE__ */ new WeakMap(), OBe = /* @__PURE__ */ new WeakMap(), EBe = /* @__PURE__ */ new WeakMap(), kBe = /* @__PURE__ */ new WeakMap(), eae = globalThis.Node, LBe = globalThis.Text, tae = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, PBe = (e) => W0(e) && e.nodeType === 8, qa = (e) => W0(e) && e.nodeType === 1, W0 = (e) => {
  var t = tae(e);
  return !!t && e instanceof t.Node;
}, r$ = (e) => {
  var t = e && e.anchorNode && tae(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, _Be = (e) => {
  var [t, n] = e;
  if (qa(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = nae(t, o, r ? "backward" : "forward"), r = o < n; qa(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = MBe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, SBe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, nae = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (PBe(o) || qa(o) && o.childNodes.length === 0 || qa(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, MBe = (e, t, n) => {
  var [r] = nae(e, t, n);
  return r;
}, o$ = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), rae = (e, t, n) => {
  var {
    target: r
  } = t;
  if (qa(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = vn.getWindow(e);
  if (o.contains(r))
    return vn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : rae(e, i, n);
}, i$ = (e, t) => !!(e.compareDocumentPosition(t) & eae.DOCUMENT_POSITION_PRECEDING), DBe = (e, t) => !!(e.compareDocumentPosition(t) & eae.DOCUMENT_POSITION_FOLLOWING), TBe = 0;
class jBe {
  constructor() {
    $h(this, "id", void 0), this.id = "".concat(TBe++);
  }
}
var vn = {
  androidPendingDiffs: (e) => kBe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = EBe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = vn.toDOMNode(e, e), n = vn.findDocumentOrShadowRoot(e);
    $y.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = vn.findDocumentOrShadowRoot(e), r = o$(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && k0.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = vn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = vn.toSlateNode(e, t.target), a = vn.findPath(e, i);
    if (Bl.isElement(i) && kr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = kr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? kr.before(e, u) : kr.after(e, u);
      if (c) {
        var p = kr.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = vn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var y = vn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return y;
  },
  findKey: (e, t) => {
    var n = t$.get(t);
    return n || (n = new jBe(), t$.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = yBe.get(r);
      if (o == null) {
        if (kr.isEditor(r))
          return n;
        break;
      }
      var i = vBe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Fs.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!$y.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          vn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = vn.toDOMNode(e, e), r = vn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = o$(r), i = vn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || k0.select(e, kr.start(e, [])), $y.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = bBe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = vn.toDOMNode(e, e), i;
    try {
      i = qa(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => W0(t) && vn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return kr.hasPath(e, n.path) && kr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => vn.hasEditableTarget(e, t) || vn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => W0(t) && vn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!OBe.get(e),
  isFocused: (e) => !!$y.get(e),
  isReadOnly: (e) => !!n$.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (n$.get(e)) return !1;
    var n = vn.hasTarget(e, t) && vn.toSlateNode(e, t);
    return Bl.isElement(n) && kr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = xBe.get(e), r = kr.isEditor(t) ? wBe.get(e) : n == null ? void 0 : n.get(vn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Fs.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = kr.node(e, t.path), r = vn.toDOMNode(e, n), o;
    kr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, y = a[l + 1];
        if (t.offset === f && y !== null && y !== void 0 && y.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = y.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof LBe ? E : y,
            (b = y.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Fs.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = nn.isBackward(t), i = vn.toDOMPoint(e, n), a = nn.isCollapsed(t) ? i : vn.toDOMPoint(e, r), s = vn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = qa(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), y = qa(p) ? p : p.parentElement, b = !!y.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = qa(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? CBe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : _Be(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = vn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), y = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = vn.getWindow(e), v = O.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var x = v.cloneContents(), _ = [...Array.prototype.slice.call(x.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(x.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (t1 && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = x.textContent.length, M = u;
        }
      } else if (y) {
        for (var z = y.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var N = z[L];
          if (vn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var Z, H = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = (Z = H.find((S) => DBe(E, S))) !== null && Z !== void 0 ? Z : null;
        } else {
          var $, K = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = ($ = K.findLast((S) => i$(E, S))) !== null && $ !== void 0 ? $ : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      t1 && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Vy && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (t1 && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && vn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var Q = vn.toSlateNode(e, X), {
          path: J,
          offset: P
        } = kr.start(e, vn.findPath(e, Q));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = vn.toSlateNode(e, u), F = vn.findPath(e, D);
    return {
      path: F,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = r$(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (r$(t)) {
        if (Vy && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let x = function(_) {
              return _.childElementCount > 0 ? x(_.children[0]) : _;
            };
            var f = d.startContainer, y = g.startContainer, b = x(f.children[d.startOffset]), E = x(y.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        mBe && SBe(s) || Vy ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Vy && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = vn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = i$(s, u) || s === u && c < l, O = p ? w : vn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var v = {
      anchor: w,
      focus: O
    };
    return nn.isExpanded(v) && nn.isForward(v) && qa(u) && kr.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = kr.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, ABe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, IBe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, BBe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, po = (e) => {
  var t = ABe[e], n = IBe[e], r = BBe[e], o = t && XL(t), i = n && XL(n), a = r && XL(r);
  return (s) => !!(o && o(s) || e$ && i && i(s) || !e$ && a && a(s));
};
po("bold"), po("compose"), po("moveBackward"), po("moveForward"), po("deleteBackward"), po("deleteForward"), po("deleteLineBackward"), po("deleteLineForward"), po("deleteWordBackward"), po("deleteWordForward"), po("extendBackward"), po("extendForward"), po("extendLineBackward"), po("extendLineForward"), po("italic"), po("moveLineBackward"), po("moveLineForward"), po("moveWordBackward"), po("moveWordForward"), po("redo"), po("insertSoftBreak"), po("splitBlock"), po("transposeCharacter"), po("undo");
var RBe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => rae(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, NBe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class FBe extends Kl {
  constructor() {
    super(...arguments), $h(this, "context", null), $h(this, "manager", null), $h(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, NBe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = RBe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
$h(FBe, "contextType", gBe);
We({});
We({});
We({});
var ni = {}, yI = {}, Mm = {}, Dm = {}, oae = "Expected a function", s$ = NaN, zBe = "[object Symbol]", UBe = /^\s+|\s+$/g, HBe = /^[-+]0x[0-9a-f]+$/i, WBe = /^0b[01]+$/i, VBe = /^0o[0-7]+$/i, $Be = parseInt, ZBe = typeof Ar == "object" && Ar && Ar.Object === Object && Ar, qBe = typeof self == "object" && self && self.Object === Object && self, GBe = ZBe || qBe || Function("return this")(), KBe = Object.prototype, YBe = KBe.toString, XBe = Math.max, JBe = Math.min, n1 = function() {
  return GBe.Date.now();
};
function QBe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(oae);
  t = a$(t) || 0, V0(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? XBe(a$(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(x) {
    var _ = r, z = o;
    return r = o = void 0, u = x, a = e.apply(z, _), a;
  }
  function f(x) {
    return u = x, s = setTimeout(E, t), c ? g(x) : a;
  }
  function y(x) {
    var _ = x - l, z = x - u, L = t - _;
    return p ? JBe(L, i - z) : L;
  }
  function b(x) {
    var _ = x - l, z = x - u;
    return l === void 0 || _ >= t || _ < 0 || p && z >= i;
  }
  function E() {
    var x = n1();
    if (b(x))
      return w(x);
    s = setTimeout(E, y(x));
  }
  function w(x) {
    return s = void 0, d && r ? g(x) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(n1());
  }
  function v() {
    var x = n1(), _ = b(x);
    if (r = arguments, o = this, l = x, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = O, v;
}
function eRe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(oae);
  return V0(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), QBe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function V0(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function tRe(e) {
  return !!e && typeof e == "object";
}
function nRe(e) {
  return typeof e == "symbol" || tRe(e) && YBe.call(e) == zBe;
}
function a$(e) {
  if (typeof e == "number")
    return e;
  if (nRe(e))
    return s$;
  if (V0(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = V0(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(UBe, "");
  var n = WBe.test(e);
  return n || VBe.test(e) ? $Be(e.slice(2), n ? 2 : 8) : HBe.test(e) ? s$ : +e;
}
var rRe = eRe, Tm = {};
Object.defineProperty(Tm, "__esModule", {
  value: !0
});
Tm.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Lw.has(t) || Lw.set(t, /* @__PURE__ */ new Set());
  var o = Lw.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Tm.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Lw.get(t).delete(n.name || t);
};
var Lw = /* @__PURE__ */ new Map();
Object.defineProperty(Dm, "__esModule", {
  value: !0
});
var oRe = rRe, iRe = sRe(oRe), l$ = Tm;
function sRe(e) {
  return e && e.__esModule ? e : { default: e };
}
var aRe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, iRe.default)(e, t);
}, Mo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = aRe(function(r) {
        Mo.scrollHandler(e);
      }, t);
      return Mo.scrollSpyContainers.push(e), (0, l$.addPassiveEventListener)(e, "scroll", n), function() {
        (0, l$.removePassiveEventListener)(e, "scroll", n), Mo.scrollSpyContainers.splice(Mo.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Mo.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Mo.scrollSpyContainers[Mo.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Mo.currentPositionX(e), Mo.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Mo.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Mo.scrollSpyContainers[Mo.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Mo.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Mo.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Mo.spySetState && Mo.spySetState.length && Mo.spySetState.indexOf(e) > -1 && Mo.spySetState.splice(Mo.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Mo.scrollHandler);
  },
  update: function() {
    return Mo.scrollSpyContainers.forEach(function(e) {
      return Mo.scrollHandler(e);
    });
  }
};
Dm.default = Mo;
var Yd = {}, jm = {};
Object.defineProperty(jm, "__esModule", {
  value: !0
});
var lRe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, uRe = function() {
  return window.location.hash.replace(/^#/, "");
}, cRe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, pRe = function(e) {
  return getComputedStyle(e).position !== "static";
}, r1 = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, dRe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (pRe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = r1(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return r1(t, s).offsetTop - r1(e, s).offsetTop;
};
jm.default = {
  updateHash: lRe,
  getHash: uRe,
  filterElementInContainer: cRe,
  scrollOffset: dRe
};
var PE = {}, bI = {};
Object.defineProperty(bI, "__esModule", {
  value: !0
});
bI.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var wI = {};
Object.defineProperty(wI, "__esModule", {
  value: !0
});
var fRe = Tm, hRe = ["mousedown", "wheel", "touchmove", "keydown"];
wI.default = {
  subscribe: function(e) {
    return typeof document < "u" && hRe.forEach(function(t) {
      return (0, fRe.addPassiveEventListener)(document, t, e);
    });
  }
};
var Am = {};
Object.defineProperty(Am, "__esModule", {
  value: !0
});
var JM = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      JM.registered[e] = t;
    },
    remove: function(e) {
      JM.registered[e] = null;
    }
  }
};
Am.default = JM;
Object.defineProperty(PE, "__esModule", {
  value: !0
});
var gRe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, mRe = jm;
_E(mRe);
var vRe = bI, u$ = _E(vRe), yRe = wI, bRe = _E(yRe), wRe = Am, Na = _E(wRe);
function _E(e) {
  return e && e.__esModule ? e : { default: e };
}
var iae = function(e) {
  return u$.default[e.smooth] || u$.default.defaultEasing;
}, CRe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, xRe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, QM = function() {
  return xRe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), sae = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, aae = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, lae = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, ORe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, ERe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, kRe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Na.default.registered.end && Na.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    QM.call(window, i);
    return;
  }
  Na.default.registered.end && Na.default.registered.end(o.to, o.target, o.currentPosition);
}, CI = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Im = function(e, t, n, r) {
  t.data = t.data || sae(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (bRe.default.subscribe(o), CI(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? aae(t) : lae(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Na.default.registered.end && Na.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = CRe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = iae(t), a = kRe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Na.default.registered.begin && Na.default.registered.begin(t.data.to, t.data.target), QM.call(window, a);
    }, t.delay);
    return;
  }
  Na.default.registered.begin && Na.default.registered.begin(t.data.to, t.data.target), QM.call(window, a);
}, SE = function(e) {
  return e = gRe({}, e), e.data = e.data || sae(), e.absolute = !0, e;
}, LRe = function(e) {
  Im(0, SE(e));
}, PRe = function(e, t) {
  Im(e, SE(t));
}, _Re = function(e) {
  e = SE(e), CI(e), Im(e.horizontal ? ORe(e) : ERe(e), e);
}, SRe = function(e, t) {
  t = SE(t), CI(t);
  var n = t.horizontal ? aae(t) : lae(t);
  Im(e + n, t);
};
PE.default = {
  animateTopScroll: Im,
  getAnimationType: iae,
  scrollToTop: LRe,
  scrollToBottom: _Re,
  scrollTo: PRe,
  scrollMore: SRe
};
Object.defineProperty(Yd, "__esModule", {
  value: !0
});
var MRe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, DRe = jm, TRe = xI(DRe), jRe = PE, ARe = xI(jRe), IRe = Am, Zy = xI(IRe);
function xI(e) {
  return e && e.__esModule ? e : { default: e };
}
var qy = {}, c$ = void 0;
Yd.default = {
  unmount: function() {
    qy = {};
  },
  register: function(e, t) {
    qy[e] = t;
  },
  unregister: function(e) {
    delete qy[e];
  },
  get: function(e) {
    return qy[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return c$ = e;
  },
  getActiveLink: function() {
    return c$;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = MRe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = TRe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Zy.default.registered.begin && Zy.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Zy.default.registered.end && Zy.default.registered.end(e, n);
      return;
    }
    ARe.default.animateTopScroll(s, t, e, n);
  }
};
var eD = { exports: {} }, o1 = { exports: {} }, er = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var p$;
function BRe() {
  if (p$) return er;
  p$ = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function O(v) {
    return M(v) === u;
  }
  return er.AsyncMode = l, er.ConcurrentMode = u, er.ContextConsumer = s, er.ContextProvider = a, er.Element = t, er.ForwardRef = c, er.Fragment = r, er.Lazy = f, er.Memo = g, er.Portal = n, er.Profiler = i, er.StrictMode = o, er.Suspense = p, er.isAsyncMode = function(v) {
    return O(v) || M(v) === l;
  }, er.isConcurrentMode = O, er.isContextConsumer = function(v) {
    return M(v) === s;
  }, er.isContextProvider = function(v) {
    return M(v) === a;
  }, er.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, er.isForwardRef = function(v) {
    return M(v) === c;
  }, er.isFragment = function(v) {
    return M(v) === r;
  }, er.isLazy = function(v) {
    return M(v) === f;
  }, er.isMemo = function(v) {
    return M(v) === g;
  }, er.isPortal = function(v) {
    return M(v) === n;
  }, er.isProfiler = function(v) {
    return M(v) === i;
  }, er.isStrictMode = function(v) {
    return M(v) === o;
  }, er.isSuspense = function(v) {
    return M(v) === p;
  }, er.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === y);
  }, er.typeOf = M, er;
}
var pr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var d$;
function RRe() {
  return d$ || (d$ = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === E || B.$$typeof === w || B.$$typeof === y);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, x = u, _ = s, z = a, L = t, N = c, R = r, V = f, Z = g, H = n, $ = i, K = o, X = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function F(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return O(B) === c;
    }
    function C(B) {
      return O(B) === r;
    }
    function I(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function j(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    pr.AsyncMode = v, pr.ConcurrentMode = x, pr.ContextConsumer = _, pr.ContextProvider = z, pr.Element = L, pr.ForwardRef = N, pr.Fragment = R, pr.Lazy = V, pr.Memo = Z, pr.Portal = H, pr.Profiler = $, pr.StrictMode = K, pr.Suspense = X, pr.isAsyncMode = J, pr.isConcurrentMode = P, pr.isContextConsumer = D, pr.isContextProvider = F, pr.isElement = S, pr.isForwardRef = W, pr.isFragment = C, pr.isLazy = I, pr.isMemo = U, pr.isPortal = T, pr.isProfiler = q, pr.isStrictMode = j, pr.isSuspense = Y, pr.isValidElementType = M, pr.typeOf = O;
  }()), pr;
}
var f$;
function uae() {
  return f$ || (f$ = 1, process.env.NODE_ENV === "production" ? o1.exports = BRe() : o1.exports = RRe()), o1.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var i1, h$;
function NRe() {
  if (h$) return i1;
  h$ = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return i1 = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, i1;
}
var s1, g$;
function OI() {
  if (g$) return s1;
  g$ = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return s1 = e, s1;
}
var m$, v$;
function cae() {
  return v$ || (v$ = 1, m$ = Function.call.bind(Object.prototype.hasOwnProperty)), m$;
}
var a1, y$;
function FRe() {
  if (y$) return a1;
  y$ = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = OI(), n = {}, r = cae();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, a1 = o, a1;
}
var l1, b$;
function zRe() {
  if (b$) return l1;
  b$ = 1;
  var e = uae(), t = NRe(), n = OI(), r = cae(), o = FRe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return l1 = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: v(),
      instanceOf: x,
      node: N(),
      objectOf: z,
      oneOf: _,
      oneOfType: L,
      shape: V,
      exact: Z
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function y(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    y.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, F = 0;
      function S(C, I, U, T, q, j, Y) {
        if (T = T || d, j = j || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            F < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + j + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, F++);
          }
        }
        return I[U] == null ? C ? I[U] === null ? new y("The " + q + " `" + j + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new y("The " + q + " `" + j + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(I, U, T, q, j);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(P) {
      function D(F, S, W, C, I, U) {
        var T = F[S], q = K(T);
        if (q !== P) {
          var j = X(T);
          return new y(
            "Invalid " + C + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = F[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var j = P(U, q, W, C, I + "[" + q + "]", n);
          if (j instanceof Error)
            return j;
        }
        return null;
      }
      return b(D);
    }
    function O() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!s(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function v() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!e.isValidElementType(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function x(P) {
      function D(F, S, W, C, I) {
        if (!(F[S] instanceof P)) {
          var U = P.name || d, T = J(F[S]);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(F, S, W, C, I) {
        for (var U = F[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(j, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new y("Invalid " + C + " `" + I + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function z(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var j = P(U, q, W, C, I + "." + q, n);
            if (j instanceof Error)
              return j;
          }
        return null;
      }
      return b(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var F = P[D];
        if (typeof F != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(F) + " at index " + D + "."
          ), a;
      }
      function S(W, C, I, U, T) {
        for (var q = [], j = 0; j < P.length; j++) {
          var Y = P[j], B = Y(W, C, I, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new y("Invalid " + U + " `" + T + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(S);
    }
    function N() {
      function P(D, F, S, W, C) {
        return H(D[F]) ? null : new y("Invalid " + W + " `" + C + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, D, F, S, W) {
      return new y(
        (P || "React class") + ": " + D + " type `" + F + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var j = P[q];
          if (typeof j != "function")
            return R(W, C, I, q, X(j));
          var Y = j(U, q, W, C, I + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(D);
    }
    function Z(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, F[S], P);
        for (var j in q) {
          var Y = P[j];
          if (r(P, j) && typeof Y != "function")
            return R(W, C, I, j, X(Y));
          if (!Y)
            return new y(
              "Invalid " + C + " `" + I + "` key `" + j + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(F[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, j, W, C, I + "." + j, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(D);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var F = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = F.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = F.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function $(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : $(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, l1;
}
var u1, w$;
function URe() {
  if (w$) return u1;
  w$ = 1;
  var e = OI();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, u1 = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, u1;
}
if (process.env.NODE_ENV !== "production") {
  var HRe = uae(), WRe = !0;
  eD.exports = zRe()(HRe.isElement, WRe);
} else
  eD.exports = URe()();
var ME = eD.exports, DE = {};
Object.defineProperty(DE, "__esModule", {
  value: !0
});
var VRe = jm, c1 = $Re(VRe);
function $Re(e) {
  return e && e.__esModule ? e : { default: e };
}
var ZRe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return c1.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && c1.default.getHash() !== e && c1.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
DE.default = ZRe;
Object.defineProperty(Mm, "__esModule", {
  value: !0
});
var Gy = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, qRe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), GRe = we, C$ = Bm(GRe), KRe = Dm, Ky = Bm(KRe), YRe = Yd, XRe = Bm(YRe), JRe = ME, fo = Bm(JRe), QRe = DE, au = Bm(QRe);
function Bm(e) {
  return e && e.__esModule ? e : { default: e };
}
function eNe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function tNe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function nNe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var x$ = {
  to: fo.default.string.isRequired,
  containerId: fo.default.string,
  container: fo.default.object,
  activeClass: fo.default.string,
  activeStyle: fo.default.object,
  spy: fo.default.bool,
  horizontal: fo.default.bool,
  smooth: fo.default.oneOfType([fo.default.bool, fo.default.string]),
  offset: fo.default.number,
  delay: fo.default.number,
  isDynamic: fo.default.bool,
  onClick: fo.default.func,
  duration: fo.default.oneOfType([fo.default.number, fo.default.func]),
  absolute: fo.default.bool,
  onSetActive: fo.default.func,
  onSetInactive: fo.default.func,
  ignoreCancelEvents: fo.default.bool,
  hashSpy: fo.default.bool,
  saveHashHistory: fo.default.bool,
  spyThrottle: fo.default.number
};
Mm.default = function(e, t) {
  var n = t || XRe.default, r = function(i) {
    nNe(a, i);
    function a(s) {
      eNe(this, a);
      var l = tNe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return qRe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Ky.default.isMounted(s)) {
            var l = Ky.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (au.default.isMounted() || au.default.mount(n), au.default.mapContainer(this.props.to, s)), Ky.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Ky.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Gy({}, this.props.style, this.props.activeStyle) : l = Gy({}, this.props.style);
        var u = Gy({}, this.props);
        for (var c in x$)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, C$.default.createElement(e, u);
      }
    }]), a;
  }(C$.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Gy({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(au.default.isMounted() && !au.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, y = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, y = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(y), g = M < Math.floor(f) || M >= Math.floor(y);
        } else {
          var O = 0, v = 0, x = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            x = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            O = z.top - x + s, v = O + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(v), g = L < Math.floor(O) || L >= Math.floor(v);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && au.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            au.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var Z = i.props.saveHashHistory, H = Z === void 0 ? !1 : Z;
          i.props.hashSpy && au.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = x$, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(yI, "__esModule", {
  value: !0
});
var rNe = we, O$ = pae(rNe), oNe = Mm, iNe = pae(oNe);
function pae(e) {
  return e && e.__esModule ? e : { default: e };
}
function sNe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function E$(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function aNe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var lNe = function(e) {
  aNe(t, e);
  function t() {
    var n, r, o, i;
    sNe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = E$(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return O$.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), E$(o, i);
  }
  return t;
}(O$.default.Component);
yI.default = (0, iNe.default)(lNe);
var EI = {};
Object.defineProperty(EI, "__esModule", {
  value: !0
});
var uNe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), cNe = we, k$ = dae(cNe), pNe = Mm, dNe = dae(pNe);
function dae(e) {
  return e && e.__esModule ? e : { default: e };
}
function fNe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function hNe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function gNe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var mNe = function(e) {
  gNe(t, e);
  function t() {
    return fNe(this, t), hNe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return uNe(t, [{
    key: "render",
    value: function() {
      return k$.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(k$.default.Component);
EI.default = (0, dNe.default)(mNe);
var kI = {}, TE = {};
Object.defineProperty(TE, "__esModule", {
  value: !0
});
var vNe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, yNe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), bNe = we, L$ = jE(bNe), wNe = nl;
jE(wNe);
var CNe = Yd, P$ = jE(CNe), xNe = ME, _$ = jE(xNe);
function jE(e) {
  return e && e.__esModule ? e : { default: e };
}
function ONe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ENe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function kNe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
TE.default = function(e) {
  var t = function(n) {
    kNe(r, n);
    function r(o) {
      ONe(this, r);
      var i = ENe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return yNe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        P$.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        P$.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return L$.default.createElement(e, vNe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(L$.default.Component);
  return t.propTypes = {
    name: _$.default.string,
    id: _$.default.string
  }, t;
};
Object.defineProperty(kI, "__esModule", {
  value: !0
});
var S$ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, LNe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), PNe = we, M$ = LI(PNe), _Ne = TE, SNe = LI(_Ne), MNe = ME, D$ = LI(MNe);
function LI(e) {
  return e && e.__esModule ? e : { default: e };
}
function DNe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function TNe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function jNe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var fae = function(e) {
  jNe(t, e);
  function t() {
    return DNe(this, t), TNe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return LNe(t, [{
    key: "render",
    value: function() {
      var n = this, r = S$({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, M$.default.createElement(
        "div",
        S$({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(M$.default.Component);
fae.propTypes = {
  name: D$.default.string,
  id: D$.default.string
};
kI.default = (0, SNe.default)(fae);
var p1 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, T$ = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function j$(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function A$(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function I$(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Yy = we, jc = Dm, d1 = Yd, Fo = ME, lu = DE, B$ = {
  to: Fo.string.isRequired,
  containerId: Fo.string,
  container: Fo.object,
  activeClass: Fo.string,
  spy: Fo.bool,
  smooth: Fo.oneOfType([Fo.bool, Fo.string]),
  offset: Fo.number,
  delay: Fo.number,
  isDynamic: Fo.bool,
  onClick: Fo.func,
  duration: Fo.oneOfType([Fo.number, Fo.func]),
  absolute: Fo.bool,
  onSetActive: Fo.func,
  onSetInactive: Fo.func,
  ignoreCancelEvents: Fo.bool,
  hashSpy: Fo.bool,
  spyThrottle: Fo.number
}, ANe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || d1, r = function(i) {
      I$(a, i);
      function a(s) {
        j$(this, a);
        var l = A$(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return T$(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            jc.isMounted(s) || jc.mount(s, this.props.spyThrottle), this.props.hashSpy && (lu.isMounted() || lu.mount(n), lu.mapContainer(this.props.to, s)), this.props.spy && jc.addStateHandler(this.stateHandler), jc.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          jc.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = p1({}, this.props);
          for (var u in B$)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Yy.createElement(e, l);
        }
      }]), a;
    }(Yy.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, p1({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(lu.isMounted() && !lu.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var y = a - i.props.offset, b = y >= Math.floor(c) && y < Math.floor(p), E = y < Math.floor(c) || y >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && lu.getHash() === l && lu.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), jc.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && lu.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), jc.updateStates();
        }
      };
    };
    return r.propTypes = B$, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      I$(r, n);
      function r(o) {
        j$(this, r);
        var i = A$(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return T$(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          d1.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          d1.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Yy.createElement(e, p1({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Yy.Component);
    return t.propTypes = {
      name: Fo.string,
      id: Fo.string
    }, t;
  }
}, INe = ANe;
Object.defineProperty(ni, "__esModule", {
  value: !0
});
ni.Helpers = ni.ScrollElement = ni.ScrollLink = ni.animateScroll = ni.scrollSpy = ni.Events = ni.scroller = ni.Element = ni.Button = ni.Link = void 0;
var BNe = yI, hae = ol(BNe), RNe = EI, gae = ol(RNe), NNe = kI, mae = ol(NNe), FNe = Yd, vae = ol(FNe), zNe = Am, yae = ol(zNe), UNe = Dm, bae = ol(UNe), HNe = PE, wae = ol(HNe), WNe = Mm, Cae = ol(WNe), VNe = TE, xae = ol(VNe), $Ne = INe, Oae = ol($Ne);
function ol(e) {
  return e && e.__esModule ? e : { default: e };
}
ni.Link = hae.default;
ni.Button = gae.default;
ni.Element = mae.default;
ni.scroller = vae.default;
ni.Events = yae.default;
ni.scrollSpy = bae.default;
ni.animateScroll = wae.default;
ni.ScrollLink = Cae.default;
ni.ScrollElement = xae.default;
ni.Helpers = Oae.default;
ni.default = { Link: hae.default, Button: gae.default, Element: mae.default, scroller: vae.default, Events: yae.default, scrollSpy: bae.default, animateScroll: wae.default, ScrollLink: Cae.default, ScrollElement: xae.default, Helpers: Oae.default };
We({});
We({});
We({});
function om(e) {
  "@babel/helpers - typeof";
  return om = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, om(e);
}
function ZNe(e, t) {
  if (om(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (om(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function qNe(e) {
  var t = ZNe(e, "string");
  return om(t) == "symbol" ? t : t + "";
}
function Te(e, t, n) {
  return (t = qNe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Eae(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var f1, R$;
function GNe() {
  if (R$) return f1;
  R$ = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return f1 = t, f1;
}
var KNe = GNe(), pi = /* @__PURE__ */ Eae(KNe), Ht = We(null);
function YNe() {
  pi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Ht);
  return pi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function XNe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function JNe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function QNe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return JNe(e, i), o;
}
function eFe(e, t, n) {
  var r = XNe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function tFe(e) {
  google.maps.event.removeListener(e);
}
function Bn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(tFe);
}
function kn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = eFe(o, i, n);
  return QNe(t, r, o, i), a;
}
function nFe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: y,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [v, x] = k(null), _ = ht(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null), [j, Y] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && y && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", y)));
  }, [y]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (j !== null && google.maps.event.removeListener(j), Y(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return x(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), Ii.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: Ii.jsx(Ht.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(nFe);
function N$(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function kae(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        N$(i, r, o, a, s, "next", l);
      }
      function s(l) {
        N$(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Lae(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return pi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var mp = typeof document < "u";
function Pae(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return mp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function F$(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function _ae() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return F$(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return F$(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var If = !1;
function Sae() {
  return Ii.jsx("div", {
    children: "Loading..."
  });
}
var tD = {
  id: "script-loader",
  version: "weekly"
};
class rFe extends pe {
  constructor() {
    super(...arguments), Te(this, "check", null), Te(this, "state", {
      loaded: !1
    }), Te(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Te(this, "isCleaningUp", /* @__PURE__ */ kae(function* () {
      function t(n) {
        if (!If)
          n();
        else if (mp)
          var r = window.setInterval(function() {
            If || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Te(this, "cleanup", () => {
      If = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Te(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && _ae(), pi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Lae(this.props)
      };
      Pae(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Te(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (mp) {
      if (window.google && window.google.maps && !If) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), mp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (mp) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, If = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Ii.jsxs(Ii.Fragment, {
      children: [Ii.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Ii.jsx(Sae, {})]
    });
  }
}
Te(rFe, "defaultProps", tD);
function oFe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function PI(e, t) {
  if (e == null) return {};
  var n, r, o = oFe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var z$;
function iFe(e) {
  var {
    id: t = tD.id,
    version: n = tD.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ht(!1), [f, y] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    mp && u && _ae();
  }, [u]), h(function() {
    f && pi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Lae({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!mp)
      return;
    function O() {
      g.current && (y(!0), z$ = w);
    }
    if (window.google && window.google.maps && z$ === w) {
      O();
      return;
    }
    Pae({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = ht(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var sFe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], aFe = Ii.jsx(Sae, {});
function lFe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = PI(e, sFe), {
    isLoaded: s,
    loadError: l
  } = iFe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || aFe;
}
me(lFe);
var U$;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(U$ || (U$ = {}));
function H$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? H$(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : H$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var W$ = {}, V$ = {
  options(e, t) {
    e.setOptions(t);
  }
};
function uFe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Ht), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer($0($0({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(uFe);
class cFe extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      trafficLayer: null
    }), Te(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Te(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer($0($0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: V$,
      eventMap: W$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: V$,
      eventMap: W$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Bn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(cFe, "contextType", Ht);
function pFe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ht), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(pFe);
class dFe extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      bicyclingLayer: null
    }), Te(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(dFe, "contextType", Ht);
function fFe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ht), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(fFe);
class hFe extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      transitLayer: null
    }), Te(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(hFe, "contextType", Ht);
function $$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Z0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $$(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Z$ = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, q$ = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function gFe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Ht), [d, g] = k(null), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), y(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    pi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(Z0(Z0({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && y(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && v(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(gFe);
class mFe extends pe {
  constructor(t) {
    super(t), Te(this, "registeredEvents", []), Te(this, "state", {
      drawingManager: null
    }), Te(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), pi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Z0(Z0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: q$,
      eventMap: Z$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: q$,
      eventMap: Z$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Bn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Te(mFe, "contextType", Ht);
function G$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G$(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var K$ = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, Y$ = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, q0 = {};
function vFe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: y,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: v,
    onMouseOut: x,
    onMouseOver: _,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: Z,
    onDraggableChanged: H,
    onFlatChanged: $,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: F,
    onUnmount: S
  } = e, W = ge(Ht), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null), [oe, Pe] = k(null), [Ue, Ze] = k(null), [_e, rt] = k(null), [Ve, ye] = k(null), [Ge, ct] = k(null), [ve, Oe] = k(null), [qe, ze] = k(null), [Se, st] = k(null), [xe, xt] = k(null), [at, lt] = k(null), [pt, Ot] = k(null), [dt, ft] = k(null), [ot, He] = k(null), [Et, kt] = k(null), [gt, St] = k(null), [mt, Mt] = k(null), [vt, Pt] = k(null);
  h(() => {
    C !== null && C.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && C !== null && C.setOptions(n);
  }, [C, n]), h(() => {
    typeof a < "u" && C !== null && C.setDraggable(a);
  }, [C, a]), h(() => {
    t && C !== null && C.setPosition(t);
  }, [C, t]), h(() => {
    typeof s < "u" && C !== null && C.setVisible(s);
  }, [C, s]), h(() => {
    C == null || C.setAnimation(l);
  }, [C, l]), h(() => {
    C && u !== void 0 && C.setClickable(u);
  }, [C, u]), h(() => {
    C && c !== void 0 && C.setCursor(c);
  }, [C, c]), h(() => {
    C && p !== void 0 && C.setIcon(p);
  }, [C, p]), h(() => {
    C && d !== void 0 && C.setLabel(d);
  }, [C, d]), h(() => {
    C && g !== void 0 && C.setOpacity(g);
  }, [C, g]), h(() => {
    C && f !== void 0 && C.setShape(f);
  }, [C, f]), h(() => {
    C && y !== void 0 && C.setTitle(y);
  }, [C, y]), h(() => {
    C && b !== void 0 && C.setZIndex(b);
  }, [C, b]), h(() => {
    C && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(C, "dblclick", w)));
  }, [w]), h(() => {
    C && O && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(C, "dragend", O)));
  }, [O]), h(() => {
    C && v && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(C, "dragstart", v)));
  }, [v]), h(() => {
    C && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(C, "mousedown", L)));
  }, [L]), h(() => {
    C && x && (oe !== null && google.maps.event.removeListener(oe), Pe(google.maps.event.addListener(C, "mouseout", x)));
  }, [x]), h(() => {
    C && _ && (Ue !== null && google.maps.event.removeListener(Ue), Ze(google.maps.event.addListener(C, "mouseover", _)));
  }, [_]), h(() => {
    C && z && (_e !== null && google.maps.event.removeListener(_e), rt(google.maps.event.addListener(C, "mouseup", z)));
  }, [z]), h(() => {
    C && N && (Ve !== null && google.maps.event.removeListener(Ve), ye(google.maps.event.addListener(C, "rightclick", N)));
  }, [N]), h(() => {
    C && E && (Ge !== null && google.maps.event.removeListener(Ge), ct(google.maps.event.addListener(C, "click", E)));
  }, [E]), h(() => {
    C && M && (ve !== null && google.maps.event.removeListener(ve), Oe(google.maps.event.addListener(C, "drag", M)));
  }, [M]), h(() => {
    C && R && (qe !== null && google.maps.event.removeListener(qe), ze(google.maps.event.addListener(C, "clickable_changed", R)));
  }, [R]), h(() => {
    C && V && (Se !== null && google.maps.event.removeListener(Se), st(google.maps.event.addListener(C, "cursor_changed", V)));
  }, [V]), h(() => {
    C && Z && (xe !== null && google.maps.event.removeListener(xe), xt(google.maps.event.addListener(C, "animation_changed", Z)));
  }, [Z]), h(() => {
    C && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(C, "draggable_changed", H)));
  }, [H]), h(() => {
    C && $ && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(C, "flat_changed", $)));
  }, [$]), h(() => {
    C && K && (dt !== null && google.maps.event.removeListener(dt), ft(google.maps.event.addListener(C, "icon_changed", K)));
  }, [K]), h(() => {
    C && X && (ot !== null && google.maps.event.removeListener(ot), He(google.maps.event.addListener(C, "position_changed", X)));
  }, [X]), h(() => {
    C && Q && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(C, "shape_changed", Q)));
  }, [Q]), h(() => {
    C && J && (gt !== null && google.maps.event.removeListener(gt), St(google.maps.event.addListener(C, "title_changed", J)));
  }, [J]), h(() => {
    C && P && (mt !== null && google.maps.event.removeListener(mt), Mt(google.maps.event.addListener(C, "visible_changed", P)));
  }, [P]), h(() => {
    C && D && (vt !== null && google.maps.event.removeListener(vt), Pt(google.maps.event.addListener(C, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = yd(yd(yd({}, n || q0), r ? q0 : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(yt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof g < "u" && te.setOpacity(g), f && te.setShape(f), typeof y == "string" && te.setTitle(y), typeof b == "number" && te.setZIndex(b), w && T(google.maps.event.addListener(te, "dblclick", w)), O && j(google.maps.event.addListener(te, "dragend", O)), v && B(google.maps.event.addListener(te, "dragstart", v)), L && he(google.maps.event.addListener(te, "mousedown", L)), x && Pe(google.maps.event.addListener(te, "mouseout", x)), _ && Ze(google.maps.event.addListener(te, "mouseover", _)), z && rt(google.maps.event.addListener(te, "mouseup", z)), N && ye(google.maps.event.addListener(te, "rightclick", N)), E && ct(google.maps.event.addListener(te, "click", E)), M && Oe(google.maps.event.addListener(te, "drag", M)), R && ze(google.maps.event.addListener(te, "clickable_changed", R)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), Z && xt(google.maps.event.addListener(te, "animation_changed", Z)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), $ && Ot(google.maps.event.addListener(te, "flat_changed", $)), K && ft(google.maps.event.addListener(te, "icon_changed", K)), X && He(google.maps.event.addListener(te, "position_changed", X)), Q && kt(google.maps.event.addListener(te, "shape_changed", Q)), J && St(google.maps.event.addListener(te, "title_changed", J)), P && Mt(google.maps.event.addListener(te, "visible_changed", P)), D && Pt(google.maps.event.addListener(te, "zindex_changed", D)), I(te), F && F(te), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), _e !== null && google.maps.event.removeListener(_e), Ve !== null && google.maps.event.removeListener(Ve), Ge !== null && google.maps.event.removeListener(Ge), qe !== null && google.maps.event.removeListener(qe), Se !== null && google.maps.event.removeListener(Se), xe !== null && google.maps.event.removeListener(xe), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ot !== null && google.maps.event.removeListener(ot), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var jn = Ft(() => i ? ut.map(i, (yt) => {
    if (!wi(yt))
      return yt;
    var te = yt;
    return Ci(te, {
      anchor: C
    });
  }) : null, [i, C]);
  return Ii.jsx(Ii.Fragment, {
    children: jn
  }) || null;
}
me(vFe);
class yFe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return kae(function* () {
      var n = yd(yd(yd({}, t.props.options || q0), t.props.clusterer ? q0 : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = kn({
        updaterMap: Y$,
        eventMap: K$,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: Y$,
      eventMap: K$,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Bn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Ci(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Te(yFe, "contextType", Ht);
var bFe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), wFe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new bFe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function CFe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var xFe = 2e3, OFe = 500, EFe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", kFe = "png", LFe = [53, 56, 66, 78, 90], PFe = "cluster", Mae = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || EFe, this.imageExtension = r.imageExtension || kFe, this.imageSizes = r.imageSizes || LFe, this.calculator = r.calculator || CFe, this.batchSize = r.batchSize || xFe, this.batchSizeIE = r.batchSizeIE || OFe, this.clusterClass = r.clusterClass || PFe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new wFe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function X$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _Fe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X$(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ga = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Vn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, SFe = {};
function MFe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: y,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: v,
    onMouseOut: x,
    onLoad: _,
    onUnmount: z
  } = e, [L, N] = k(null), R = ge(Ht), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && x && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, ga.onMouseOut, x)));
  }, [x]), h(() => {
    L && v && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, ga.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(L, ga.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(L, ga.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), $(google.maps.event.addListener(L, ga.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && Vn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Vn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Vn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Vn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Vn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Vn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Vn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Vn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Vn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Vn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Vn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Vn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof y < "u" && L !== null && Vn.styles(L, y);
  }, [L, y]), h(() => {
    typeof b < "u" && L !== null && Vn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && Vn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var F = _Fe({}, n || SFe), S = new Mae(R, [], F);
      return r && Vn.averageCenter(S, r), o && Vn.batchSizeIE(S, o), i && Vn.calculator(S, i), a && Vn.clusterClass(S, a), s && Vn.enableRetinaIcons(S, s), l && Vn.gridSize(S, l), u && Vn.ignoreHidden(S, u), c && Vn.imageExtension(S, c), p && Vn.imagePath(S, p), d && Vn.imageSizes(S, d), g && Vn.maxZoom(S, g), f && Vn.minimumClusterSize(S, f), y && Vn.styles(S, y), b && Vn.title(S, b), E && Vn.zoomOnClick(S, E), x && J(google.maps.event.addListener(S, ga.onMouseOut, x)), v && D(google.maps.event.addListener(S, ga.onMouseOver, v)), w && Z(google.maps.event.addListener(S, ga.onClick, w)), M && $(google.maps.event.addListener(S, ga.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, ga.onClusteringEnd, O)), N(S), _ && _(S), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), z && z(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(MFe);
class DFe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      markerClusterer: null
    }), Te(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Mae(this.context, [], this.props.options);
      this.registeredEvents = kn({
        updaterMap: Vn,
        eventMap: ga,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: Vn,
      eventMap: ga,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Bn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Te(DFe, "contextType", Ht);
function J$(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Dae = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || J$(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, J$));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, y = this.getProjection(), b = y.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), TFe = ["position"], jFe = ["position"];
function Q$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function G0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Q$(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Q$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var e3 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, t3 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, AFe = {};
function IFe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Ht), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || AFe, {
        position: V
      } = R, Z = PI(R, TFe), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var $ = new Dae(G0(G0({}, Z), H ? {
        position: H
      } : {}));
      N.current = document.createElement("div"), y($), a && E(google.maps.event.addListener($, "closeclick", a)), s && M(google.maps.event.addListener($, "domready", s)), l && v(google.maps.event.addListener($, "content_changed", l)), u && _(google.maps.event.addListener($, "position_changed", u)), c && L(google.maps.event.addListener($, "zindex_changed", c)), $.setContent(N.current), n ? $.open(g, n) : $.getPosition() ? $.open(g) : pi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p($);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(IFe);
class BFe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", null), Te(this, "state", {
      infoBox: null
    }), Te(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : pi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Te(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = PI(t, jFe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Dae(G0(G0({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = kn({
      updaterMap: t3,
      eventMap: e3,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: t3,
      eventMap: e3,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Bn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
Te(BFe, "contextType", Ht);
var n3, r3;
function RFe() {
  return r3 || (r3 = 1, n3 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), n3;
}
var NFe = RFe(), o3 = /* @__PURE__ */ Eae(NFe), i3 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], h1 = 1, Bf = 8;
class _I {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== h1)
      throw new Error("Got v".concat(o, " data when expected v").concat(h1, "."));
    var i = i3[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new _I(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = i3.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Bf, t), this.coords = new this.ArrayType(this.data, Bf + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Bf + a + s + l), this.ids = new this.IndexArrayType(this.data, Bf, t), this.coords = new this.ArrayType(this.data, Bf + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (h1 << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return nD(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], y = a[2 * g + 1];
          f >= t && f <= r && y >= n && y <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          s3(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, y = i[2 * f], b = i[2 * f + 1];
      s3(y, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= y : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= y : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function nD(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Tae(e, t, a, r, o, i), nD(e, t, n, r, a - 1, 1 - i), nD(e, t, n, a + 1, o, 1 - i);
  }
}
function Tae(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Tae(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, y = o;
    for (Rf(e, t, r, n), t[2 * o + i] > g && Rf(e, t, r, o); f < y; ) {
      for (Rf(e, t, f, y), f++, y--; t[2 * f + i] < g; ) f++;
      for (; t[2 * y + i] > g; ) y--;
    }
    t[2 * r + i] === g ? Rf(e, t, r, y) : (y++, Rf(e, t, y, o)), y <= n && (r = y + 1), n <= y && (o = y - 1);
  }
}
function Rf(e, t, n, r) {
  g1(e, n, r), g1(t, 2 * n, 2 * r), g1(t, 2 * n + 1, 2 * r + 1);
}
function g1(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function s3(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var FFe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, a3 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Ac = 2, Au = 3, m1 = 4, ku = 5, jae = 6;
class zFe {
  constructor(t) {
    this.options = Object.assign(Object.create(FFe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = a3(Xy(u)), d = a3(Jy(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var y = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - y);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Xy(r), Jy(a), Xy(i), Jy(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + ku] > 1 ? l3(p, f, this.clusterProps) : this.points[p[f + Au]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + m1] === t && p.push(a[g + ku] > 1 ? l3(a, g, this.clusterProps) : this.points[a[g + Au]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new _I(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + ku] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Aae(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Au]];
        c = g.properties;
        var [f, y] = g.geometry.coordinates;
        p = Xy(f), d = Jy(y);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Au] : E = this.points[n[l + Au]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Ac] <= n)) {
        l[p + Ac] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), y = l[p + ku], b = y;
        for (var E of f) {
          var w = E * c;
          l[w + Ac] > n && (b += l[w + ku]);
        }
        if (b > y && b >= a) {
          var M = d * y, O = g * y, v = void 0, x = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Ac] <= n)) {
              l[L + Ac] = n;
              var N = l[L + ku];
              M += l[L] * N, O += l[L + 1] * N, l[L + m1] = _, i && (v || (v = this._map(l, p, !0), x = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + m1] = _, u.push(M / b, O / b, 1 / 0, _, -1, b), i && u.push(x);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var Z = V * c;
              if (!(l[Z + Ac] <= n)) {
                l[Z + Ac] = n;
                for (var H = 0; H < c; H++) u.push(l[Z + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ku] > 1) {
      var o = this.clusterProps[t[n + jae]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Au]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function l3(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Au],
    properties: Aae(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [UFe(e[t]), HFe(e[t + 1])]
    }
  };
}
function Aae(e, t, n) {
  var r = e[t + ku], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + jae], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Au],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Xy(e) {
  return e / 360 + 0.5;
}
function Jy(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function UFe(e) {
  return (e - 0.5) * 360;
}
function HFe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function WFe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Hs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class rD {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Hs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Hs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Hs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class VFe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return $Fe(n);
  }
}
var $Fe = (e) => {
  var t = e.map((n) => new rD({
    position: Hs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class ZFe extends VFe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = WFe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new zFe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!o3(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Hs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !o3(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new rD({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new rD({
      markers: [i],
      position: Hs.getPosition(i)
    });
  }
}
class qFe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class GFe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Hs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function KFe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class SI {
  constructor() {
    KFe(SI, google.maps.OverlayView);
  }
}
var Zh;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Zh || (Zh = {}));
var YFe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class XFe extends SI {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new ZFe(o),
      renderer: a = new GFe(),
      onClusterClick: s = YFe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Hs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Zh.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Hs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Hs.setMap(l, null)));
      }
      google.maps.event.trigger(this, Zh.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Hs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new qFe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Hs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Zh.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Hs.setMap(r.marker, n);
    });
  }
}
function u3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function c3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? u3(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : u3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function JFe(e) {
  var t = YNe(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new XFe(c3(c3({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function QFe(e) {
  var {
    children: t,
    options: n
  } = e, r = JFe(n);
  return r !== null ? t(r) : null;
}
me(QFe);
var p3 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, d3 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function eze(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Ht), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return y(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && v(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : pi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(R), R.close();
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(eze);
class tze extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", null), Te(this, "state", {
      infoWindow: null
    }), Te(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : pi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Te(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = kn({
      updaterMap: d3,
      eventMap: p3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: d3,
      eventMap: p3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Bn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
Te(tze, "contextType", Ht);
function f3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function K0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? f3(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : f3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var h3 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, g3 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, nze = {};
function rze(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Ht), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && y && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(O, "click", y)));
  }, [y]), h(() => {
    O && b && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(O, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(K0(K0({}, t || nze), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && Z(google.maps.event.addListener(T, "mousedown", u)), c && $(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), y && C(google.maps.event.addListener(T, "click", y)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(rze);
class oze extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      polyline: null
    }), Te(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(K0(K0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: g3,
      eventMap: h3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: g3,
      eventMap: h3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Bn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Te(oze, "contextType", Ht);
function m3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function v3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m3(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var y3 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, b3 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function ize(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, v = ge(Ht), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    x !== null && x.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    typeof a < "u" && x !== null && x.setPaths(a);
  }, [x, a]), h(() => {
    x && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dblclick", s)));
  }, [s]), h(() => {
    x && (google.maps.event.addListener(x.getPath(), "insert_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "set_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "remove_at", () => {
      O == null || O(x);
    }));
  }, [x, O]), h(() => {
    x && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragend", l)));
  }, [l]), h(() => {
    x && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(x, "dragstart", u)));
  }, [u]), h(() => {
    x && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(x, "mousedown", c)));
  }, [c]), h(() => {
    x && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(x, "mousemove", p)));
  }, [p]), h(() => {
    x && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseout", d)));
  }, [d]), h(() => {
    x && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(x, "mouseover", g)));
  }, [g]), h(() => {
    x && typeof f == "function" && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(x, "mouseup", f)));
  }, [f]), h(() => {
    x && typeof y == "function" && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(x, "rightclick", y)));
  }, [y]), h(() => {
    x && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(x, "click", b)));
  }, [b]), h(() => {
    x && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(x, "drag", E)));
  }, [E]), h(() => {
    var j = new google.maps.Polygon(v3(v3({}, t), {}, {
      map: v
    }));
    return i && j.setPath(i), a && j.setPaths(a), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), s && L(google.maps.event.addListener(j, "dblclick", s)), l && R(google.maps.event.addListener(j, "dragend", l)), u && Z(google.maps.event.addListener(j, "dragstart", u)), c && $(google.maps.event.addListener(j, "mousedown", c)), p && X(google.maps.event.addListener(j, "mousemove", p)), d && J(google.maps.event.addListener(j, "mouseout", d)), g && D(google.maps.event.addListener(j, "mouseover", g)), f && S(google.maps.event.addListener(j, "mouseup", f)), y && C(google.maps.event.addListener(j, "rightclick", y)), b && U(google.maps.event.addListener(j, "click", b)), E && q(google.maps.event.addListener(j, "drag", E)), _(j), w && w(j), () => {
      z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), M && M(j), j.setMap(null);
    };
  }, []), null;
}
me(ize);
class sze extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = kn({
      updaterMap: b3,
      eventMap: y3,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: b3,
      eventMap: y3,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Bn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Te(sze, "contextType", Ht);
function w3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Y0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? w3(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : w3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var C3 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, x3 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function aze(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(Ht), [v, x] = k(null), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null);
  return h(() => {
    v !== null && v.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(v, "click", y)));
  }, [y]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(Y0(Y0({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && z(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && H(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && F(google.maps.event.addListener(Y, "mouseup", g)), f && W(google.maps.event.addListener(Y, "rightclick", f)), y && I(google.maps.event.addListener(Y, "click", y)), b && T(google.maps.event.addListener(Y, "drag", b)), E && j(google.maps.event.addListener(Y, "bounds_changed", E)), x(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
me(aze);
class lze extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      rectangle: null
    }), Te(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Y0(Y0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: x3,
      eventMap: C3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: x3,
      eventMap: C3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Bn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Te(lze, "contextType", Ht);
function O3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function X0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? O3(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : O3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var E3 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, k3 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, uze = {};
function cze(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: v
  } = e, x = ge(Ht), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null);
  return h(() => {
    _ !== null && _.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(_, "rightclick", y)));
  }, [y]), h(() => {
    _ && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", b)));
  }, [b]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [b]), h(() => {
    _ && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(X0(X0({}, t || uze), {}, {
      map: x
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && F(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), y && I(google.maps.event.addListener(oe, "rightclick", y)), b && T(google.maps.event.addListener(oe, "click", b)), E && j(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), z(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(cze);
class pze extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      circle: null
    }), Te(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(X0(X0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: k3,
      eventMap: E3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: k3,
      eventMap: E3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Bn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Te(pze, "contextType", Ht);
function L3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function J0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? L3(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : L3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var P3 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, _3 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function dze(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: y,
    onUnmount: b
  } = e, E = ge(Ht), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var j = new google.maps.Data(J0(J0({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(j, "dblclick", r)), o && _(google.maps.event.addListener(j, "mousedown", o)), i && L(google.maps.event.addListener(j, "mousemove", i)), a && R(google.maps.event.addListener(j, "mouseout", a)), s && Z(google.maps.event.addListener(j, "mouseover", s)), l && $(google.maps.event.addListener(j, "mouseup", l)), u && X(google.maps.event.addListener(j, "rightclick", u)), n && J(google.maps.event.addListener(j, "click", n)), c && D(google.maps.event.addListener(j, "addfeature", c)), p && S(google.maps.event.addListener(j, "removefeature", p)), d && C(google.maps.event.addListener(j, "removeproperty", d)), g && U(google.maps.event.addListener(j, "setgeometry", g)), f && q(google.maps.event.addListener(j, "setproperty", f)), M(j), y && y(j);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(dze);
class fze extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      data: null
    }), Te(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(J0(J0({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = kn({
        updaterMap: _3,
        eventMap: P3,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: _3,
      eventMap: P3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Bn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Te(fze, "contextType", Ht);
function S3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function M3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? S3(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : S3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var D3 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, T3 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class hze extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      kmlLayer: null
    }), Te(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(M3(M3({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: T3,
      eventMap: D3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: T3,
      eventMap: D3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Bn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(hze, "contextType", Ht);
function Iae(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function gze(e, t) {
  return new t(e.lat, e.lng);
}
function mze(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function vze(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function yze(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function bze(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function wze(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Bae(e, t, n, r) {
  return n !== void 0 ? bze(e, t, yze(n, google.maps.LatLngBounds, mze)) : wze(e, t, vze(r, google.maps.LatLng, gze));
}
function Cze(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function j3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xze(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? j3(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : j3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Oze(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = xze({}, this.container ? Iae(this.container, o) : {
        x: 0,
        y: 0
      }), u = Bae(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function A3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Eze(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? A3(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : A3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function I3(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function B3(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function kze(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Ht), c = Ft(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Ft(() => Oze(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), xi.createPortal(l, c);
}
me(kze);
class Xd extends pe {
  constructor(t) {
    super(t), Te(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Te(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      pi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Te(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Te(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Eze({
        x: 0,
        y: 0
      }, this.containerRef.current ? Iae(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Bae(r, o, this.props.bounds, this.props.position);
      if (!Cze(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Te(this, "draw", () => {
      this.onPositionElement();
    }), Te(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Br();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = I3(t.position), r = I3(this.props.position), o = B3(t.bounds), i = B3(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? xi.createPortal(Ii.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
Te(Xd, "FLOAT_PANE", "floatPane");
Te(Xd, "MAP_PANE", "mapPane");
Te(Xd, "MARKER_LAYER", "markerLayer");
Te(Xd, "OVERLAY_LAYER", "overlayLayer");
Te(Xd, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Te(Xd, "contextType", Ht);
function Lze() {
}
function R3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function N3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? R3(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var F3 = {
  onDblClick: "dblclick",
  onClick: "click"
}, z3 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Pze(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Ht), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Ft(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(Pze);
class Rae extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      groundOverlay: null
    }), Te(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    pi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, N3(N3({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: z3,
      eventMap: F3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: z3,
      eventMap: F3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Te(Rae, "defaultProps", {
  onLoad: Lze
});
Te(Rae, "contextType", Ht);
function U3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Q0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? U3(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : U3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var H3 = {}, W3 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function _ze(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Ht), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || pi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    pi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Q0(Q0({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(_ze);
class Sze extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      heatmapLayer: null
    }), Te(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    pi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), pi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Q0(Q0({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = kn({
      updaterMap: W3,
      eventMap: H3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: W3,
      eventMap: H3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Bn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(Sze, "contextType", Ht);
var V3 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, $3 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Mze extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      streetViewPanorama: null
    }), Te(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = kn({
      updaterMap: $3,
      eventMap: V3,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: $3,
      eventMap: V3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Bn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Te(Mze, "contextType", Ht);
class Dze extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      streetViewService: null
    }), Te(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Te(Dze, "contextType", Ht);
var Z3 = {
  onDirectionsChanged: "directions_changed"
}, q3 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Tze extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      directionsRenderer: null
    }), Te(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = kn({
      updaterMap: q3,
      eventMap: Z3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: q3,
      eventMap: Z3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Bn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(Tze, "contextType", Ht);
var G3 = {
  onPlacesChanged: "places_changed"
}, K3 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class jze extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", Br()), Te(this, "state", {
      searchBox: null
    }), Te(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (pi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = kn({
          updaterMap: K3,
          eventMap: G3,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: K3,
      eventMap: G3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Bn(this.registeredEvents));
  }
  render() {
    return Ii.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
Te(jze, "contextType", Ht);
var Y3 = {
  onPlaceChanged: "place_changed"
}, X3 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Nae extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", Br()), Te(this, "state", {
      autocomplete: null
    }), Te(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    pi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = kn({
        updaterMap: X3,
        eventMap: Y3,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Bn(this.registeredEvents), this.registeredEvents = kn({
      updaterMap: X3,
      eventMap: Y3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Bn(this.registeredEvents);
  }
  render() {
    return Ii.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
Te(Nae, "defaultProps", {
  className: ""
});
Te(Nae, "contextType", Ht);
let Aze = { data: "" }, Ize = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Aze, Bze = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Rze = /\/\*[^]*?\*\/|  +/g, J3 = /\n+/g, $u = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? $u(a, i) : i + "{" + $u(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += $u(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += $u.p ? $u.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, xl = {}, Fae = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Fae(e[n]);
    return t;
  }
  return e;
}, Nze = (e, t, n, r, o) => {
  let i = Fae(e), a = xl[i] || (xl[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!xl[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Bze.exec(u.replace(Rze, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(J3, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(J3, " ").trim();
      return d[0];
    })(e);
    xl[a] = $u(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && xl.g ? xl.g : null;
  return n && (xl.g = xl[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(xl[a], t, r, s), a;
}, Fze = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : $u(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function AE(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Nze(n.unshift ? n.raw ? Fze(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Ize(t.target), t.g, t.o, t.k);
}
let zae, oD, iD;
AE.bind({ g: 1 });
let Ul = AE.bind({ k: 1 });
function zze(e, t, n, r) {
  $u.p = t, zae = e, oD = n, iD = r;
}
function xc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: oD && oD() }, s), n.o = / *go\d+/.test(l), s.className = AE.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), iD && u[0] && iD(s), zae(u, s);
    }
    return o;
  };
}
var Uze = (e) => typeof e == "function", Hze = (e, t) => Uze(e) ? e(t) : e, Wze = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Vze = Ul`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, $ze = Ul`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Zze = Ul`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, qze = xc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Vze} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${$ze} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Zze} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Gze = Ul`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Kze = xc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Gze} 1s linear infinite;
`, Yze = Ul`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Xze = Ul`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, Jze = xc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Yze} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Xze} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Qze = xc("div")`
  position: absolute;
`, e2e = xc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, t2e = Ul`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, n2e = xc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${t2e} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, r2e = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Me.createElement(n2e, null, t) : t : n === "blank" ? null : Me.createElement(e2e, null, Me.createElement(Kze, { ...r }), n !== "loading" && Me.createElement(Qze, null, n === "error" ? Me.createElement(qze, { ...r }) : Me.createElement(Jze, { ...r })));
}, o2e = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, i2e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, s2e = "0%{opacity:0;} 100%{opacity:1;}", a2e = "0%{opacity:1;} 100%{opacity:0;}", l2e = xc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, u2e = xc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, c2e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Wze() ? [s2e, a2e] : [o2e(n), i2e(n)];
  return { animation: t ? `${Ul(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ul(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Me.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? c2e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Me.createElement(r2e, { toast: e }), a = Me.createElement(u2e, { ...e.ariaProps }, Hze(e.message, e));
  return Me.createElement(l2e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Me.createElement(Me.Fragment, null, i, a));
});
zze(Me.createElement);
AE`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
We({});
function p2e(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const d2e = {
  CNPJ: "99.999.999/9999-99"
};
p2e(d2e.CNPJ).length;
yr((e, t) => /* @__PURE__ */ Ai.jsx("input", { ref: t, ...e }));
function Uae(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Hae = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function f2e(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function h2e(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const g2e = Uae(Hae.NINE).length, m2e = yr((e, t) => /* @__PURE__ */ Ai.jsx("input", { ref: t, ...e }));
yr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = Uae(g.target.value);
      const y = h2e(f);
      f.length > g2e || (f = f2e(f, Hae[y]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Ai.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Ai.jsx(
      tl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: m2e,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
We({});
var Jl = {};
Object.defineProperty(Jl, "__esModule", {
  value: !0
});
var v2e = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), v1 = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Wae = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: v2e ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, MI = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Qy = 1; Qy < 20; Qy++)
  MI["f" + Qy] = 111 + Qy;
function IE(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Vae(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return $ae(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function y2e(e, t) {
  return IE(e, t);
}
function b2e(e, t) {
  return IE(e, { byKey: !0 }, t);
}
function Vae(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in v1)
    r[v1[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = DI(d), y = v1[f];
      if (d.length > 1 && !y && !Wae[d] && !MI[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !y) && (n ? r.key = f : r.which = Zae(d)), y && (r[y] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function $ae(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Zae(e) {
  e = DI(e);
  var t = MI[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function DI(e) {
  return e = e.toLowerCase(), e = Wae[e] || e, e;
}
Jl.default = IE;
var y1 = Jl.isHotkey = IE;
Jl.isCodeHotkey = y2e;
Jl.isKeyHotkey = b2e;
Jl.parseHotkey = Vae;
Jl.compareHotkey = $ae;
Jl.toKeyCode = Zae;
Jl.toKeyName = DI;
var w2e = typeof jr == "object" && jr && jr.Object === Object && jr, C2e = w2e, x2e = C2e, O2e = typeof self == "object" && self && self.Object === Object && self, E2e = x2e || O2e || Function("return this")(), k2e = E2e, L2e = k2e, P2e = L2e.Symbol, qae = P2e, Q3 = qae;
Q3 && Q3.toStringTag;
var e9 = qae;
e9 && e9.toStringTag;
var t9;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(t9 || (t9 = {}));
var TI = function(e) {
  return Object.freeze(e);
}, _2e = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, TI(this);
  }
  return e;
}(), S2e = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, TI(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), n9 = typeof window < "u" ? window : {};
/msie|trident/i.test(n9.navigator && n9.navigator.userAgent);
var b1 = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new _2e((n ? t : e) || 0, (n ? e : t) || 0);
};
TI({
  devicePixelContentBoxSize: b1(),
  borderBoxSize: b1(),
  contentBoxSize: b1(),
  contentRect: new S2e(0, 0, 0, 0)
});
function im(e) {
  "@babel/helpers - typeof";
  return im = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, im(e);
}
function M2e(e, t) {
  if (im(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (im(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function D2e(e) {
  var t = M2e(e, "string");
  return im(t) === "symbol" ? t : String(t);
}
function qh(e, t, n) {
  return t = D2e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var T2e = /* @__PURE__ */ We(null), w1, C1;
parseInt(we.version.split(".")[0], 10);
var r9 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), x1 = typeof navigator < "u" && /Android/.test(navigator.userAgent), eb = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), j2e = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (w1 = navigator.userAgent.match(/Version\/(\d+)/)) !== null && w1 !== void 0 && w1[1] && parseInt((C1 = navigator.userAgent.match(/Version\/(\d+)/)) === null || C1 === void 0 ? void 0 : C1[1], 10) < 17;
var A2e = /* @__PURE__ */ new WeakMap(), I2e = /* @__PURE__ */ new WeakMap(), B2e = /* @__PURE__ */ new WeakMap(), R2e = /* @__PURE__ */ new WeakMap(), N2e = /* @__PURE__ */ new WeakMap(), o9 = /* @__PURE__ */ new WeakMap(), F2e = /* @__PURE__ */ new WeakMap(), i9 = /* @__PURE__ */ new WeakMap(), tb = /* @__PURE__ */ new WeakMap(), z2e = /* @__PURE__ */ new WeakMap(), U2e = /* @__PURE__ */ new WeakMap(), H2e = /* @__PURE__ */ new WeakMap(), Gae = globalThis.Node, W2e = globalThis.Text, Kae = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, V2e = (e) => eC(e) && e.nodeType === 8, Ga = (e) => eC(e) && e.nodeType === 1, eC = (e) => {
  var t = Kae(e);
  return !!t && e instanceof t.Node;
}, s9 = (e) => {
  var t = e && e.anchorNode && Kae(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, $2e = (e) => {
  var [t, n] = e;
  if (Ga(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Yae(t, o, r ? "backward" : "forward"), r = o < n; Ga(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = q2e(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, Z2e = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Yae = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (V2e(o) || Ga(o) && o.childNodes.length === 0 || Ga(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, q2e = (e, t, n) => {
  var [r] = Yae(e, t, n);
  return r;
}, a9 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Xae = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ga(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = yn.getWindow(e);
  if (o.contains(r))
    return yn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Xae(e, i, n);
}, l9 = (e, t) => !!(e.compareDocumentPosition(t) & Gae.DOCUMENT_POSITION_PRECEDING), G2e = (e, t) => !!(e.compareDocumentPosition(t) & Gae.DOCUMENT_POSITION_FOLLOWING), K2e = 0;
class Y2e {
  constructor() {
    qh(this, "id", void 0), this.id = "".concat(K2e++);
  }
}
var yn = {
  androidPendingDiffs: (e) => H2e.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = U2e.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = yn.toDOMNode(e, e), n = yn.findDocumentOrShadowRoot(e);
    tb.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = yn.findDocumentOrShadowRoot(e), r = a9(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && w0.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = yn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = yn.toSlateNode(e, t.target), a = yn.findPath(e, i);
    if (Il.isElement(i) && Er.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Er.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Er.before(e, u) : Er.after(e, u);
      if (c) {
        var p = Er.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = yn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var y = yn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return y;
  },
  findKey: (e, t) => {
    var n = o9.get(t);
    return n || (n = new Y2e(), o9.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = I2e.get(r);
      if (o == null) {
        if (Er.isEditor(r))
          return n;
        break;
      }
      var i = A2e.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Ns.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!tb.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          yn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = yn.toDOMNode(e, e), r = yn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = a9(r), i = yn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || w0.select(e, Er.start(e, [])), tb.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = B2e.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = yn.toDOMNode(e, e), i;
    try {
      i = Ga(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => eC(t) && yn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Er.hasPath(e, n.path) && Er.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => yn.hasEditableTarget(e, t) || yn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => eC(t) && yn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!z2e.get(e),
  isFocused: (e) => !!tb.get(e),
  isReadOnly: (e) => !!i9.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (i9.get(e)) return !1;
    var n = yn.hasTarget(e, t) && yn.toSlateNode(e, t);
    return Il.isElement(n) && Er.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = F2e.get(e), r = Er.isEditor(t) ? R2e.get(e) : n == null ? void 0 : n.get(yn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Ns.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Er.node(e, t.path), r = yn.toDOMNode(e, n), o;
    Er.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, y = a[l + 1];
        if (t.offset === f && y !== null && y !== void 0 && y.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = y.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof W2e ? E : y,
            (b = y.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Ns.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = tn.isBackward(t), i = yn.toDOMPoint(e, n), a = tn.isCollapsed(t) ? i : yn.toDOMPoint(e, r), s = yn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Ga(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), y = Ga(p) ? p : p.parentElement, b = !!y.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ga(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? N2e.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : $2e(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = yn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), y = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = yn.getWindow(e), v = O.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var x = v.cloneContents(), _ = [...Array.prototype.slice.call(x.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(x.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (x1 && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = x.textContent.length, M = u;
        }
      } else if (y) {
        for (var z = y.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var N = z[L];
          if (yn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var Z, H = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = (Z = H.find((S) => G2e(E, S))) !== null && Z !== void 0 ? Z : null;
        } else {
          var $, K = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = ($ = K.findLast((S) => l9(E, S))) !== null && $ !== void 0 ? $ : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      x1 && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      eb && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (x1 && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && yn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var Q = yn.toSlateNode(e, X), {
          path: J,
          offset: P
        } = Er.start(e, yn.findPath(e, Q));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = yn.toSlateNode(e, u), F = yn.findPath(e, D);
    return {
      path: F,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = s9(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (s9(t)) {
        if (eb && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let x = function(_) {
              return _.childElementCount > 0 ? x(_.children[0]) : _;
            };
            var f = d.startContainer, y = g.startContainer, b = x(f.children[d.startOffset]), E = x(y.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        j2e && Z2e(s) || eb ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    eb && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = yn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = l9(s, u) || s === u && c < l, O = p ? w : yn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var v = {
      anchor: w,
      focus: O
    };
    return tn.isExpanded(v) && tn.isForward(v) && Ga(u) && Er.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = Er.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, X2e = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, J2e = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Q2e = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, ho = (e) => {
  var t = X2e[e], n = J2e[e], r = Q2e[e], o = t && y1(t), i = n && y1(n), a = r && y1(r);
  return (s) => !!(o && o(s) || r9 && i && i(s) || !r9 && a && a(s));
};
ho("bold"), ho("compose"), ho("moveBackward"), ho("moveForward"), ho("deleteBackward"), ho("deleteForward"), ho("deleteLineBackward"), ho("deleteLineForward"), ho("deleteWordBackward"), ho("deleteWordForward"), ho("extendBackward"), ho("extendForward"), ho("extendLineBackward"), ho("extendLineForward"), ho("italic"), ho("moveLineBackward"), ho("moveLineForward"), ho("moveWordBackward"), ho("moveWordForward"), ho("redo"), ho("insertSoftBreak"), ho("splitBlock"), ho("transposeCharacter"), ho("undo");
var eUe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Xae(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, tUe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class nUe extends Kl {
  constructor() {
    super(...arguments), qh(this, "context", null), qh(this, "manager", null), qh(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, tUe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = eUe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
qh(nUe, "contextType", T2e);
We({});
We({});
We({});
var ri = {}, jI = {}, Rm = {}, Nm = {}, Jae = "Expected a function", u9 = NaN, rUe = "[object Symbol]", oUe = /^\s+|\s+$/g, iUe = /^[-+]0x[0-9a-f]+$/i, sUe = /^0b[01]+$/i, aUe = /^0o[0-7]+$/i, lUe = parseInt, uUe = typeof jr == "object" && jr && jr.Object === Object && jr, cUe = typeof self == "object" && self && self.Object === Object && self, pUe = uUe || cUe || Function("return this")(), dUe = Object.prototype, fUe = dUe.toString, hUe = Math.max, gUe = Math.min, O1 = function() {
  return pUe.Date.now();
};
function mUe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Jae);
  t = c9(t) || 0, tC(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? hUe(c9(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(x) {
    var _ = r, z = o;
    return r = o = void 0, u = x, a = e.apply(z, _), a;
  }
  function f(x) {
    return u = x, s = setTimeout(E, t), c ? g(x) : a;
  }
  function y(x) {
    var _ = x - l, z = x - u, L = t - _;
    return p ? gUe(L, i - z) : L;
  }
  function b(x) {
    var _ = x - l, z = x - u;
    return l === void 0 || _ >= t || _ < 0 || p && z >= i;
  }
  function E() {
    var x = O1();
    if (b(x))
      return w(x);
    s = setTimeout(E, y(x));
  }
  function w(x) {
    return s = void 0, d && r ? g(x) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(O1());
  }
  function v() {
    var x = O1(), _ = b(x);
    if (r = arguments, o = this, l = x, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = O, v;
}
function vUe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Jae);
  return tC(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), mUe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function tC(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function yUe(e) {
  return !!e && typeof e == "object";
}
function bUe(e) {
  return typeof e == "symbol" || yUe(e) && fUe.call(e) == rUe;
}
function c9(e) {
  if (typeof e == "number")
    return e;
  if (bUe(e))
    return u9;
  if (tC(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = tC(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(oUe, "");
  var n = sUe.test(e);
  return n || aUe.test(e) ? lUe(e.slice(2), n ? 2 : 8) : iUe.test(e) ? u9 : +e;
}
var wUe = vUe, Fm = {};
Object.defineProperty(Fm, "__esModule", {
  value: !0
});
Fm.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Pw.has(t) || Pw.set(t, /* @__PURE__ */ new Set());
  var o = Pw.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Fm.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Pw.get(t).delete(n.name || t);
};
var Pw = /* @__PURE__ */ new Map();
Object.defineProperty(Nm, "__esModule", {
  value: !0
});
var CUe = wUe, xUe = OUe(CUe), p9 = Fm;
function OUe(e) {
  return e && e.__esModule ? e : { default: e };
}
var EUe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, xUe.default)(e, t);
}, Do = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = EUe(function(r) {
        Do.scrollHandler(e);
      }, t);
      return Do.scrollSpyContainers.push(e), (0, p9.addPassiveEventListener)(e, "scroll", n), function() {
        (0, p9.removePassiveEventListener)(e, "scroll", n), Do.scrollSpyContainers.splice(Do.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Do.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Do.scrollSpyContainers[Do.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Do.currentPositionX(e), Do.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Do.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Do.scrollSpyContainers[Do.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Do.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Do.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Do.spySetState && Do.spySetState.length && Do.spySetState.indexOf(e) > -1 && Do.spySetState.splice(Do.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Do.scrollHandler);
  },
  update: function() {
    return Do.scrollSpyContainers.forEach(function(e) {
      return Do.scrollHandler(e);
    });
  }
};
Nm.default = Do;
var Jd = {}, zm = {};
Object.defineProperty(zm, "__esModule", {
  value: !0
});
var kUe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, LUe = function() {
  return window.location.hash.replace(/^#/, "");
}, PUe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, _Ue = function(e) {
  return getComputedStyle(e).position !== "static";
}, E1 = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, SUe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (_Ue(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = E1(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return E1(t, s).offsetTop - E1(e, s).offsetTop;
};
zm.default = {
  updateHash: kUe,
  getHash: LUe,
  filterElementInContainer: PUe,
  scrollOffset: SUe
};
var BE = {}, AI = {};
Object.defineProperty(AI, "__esModule", {
  value: !0
});
AI.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var II = {};
Object.defineProperty(II, "__esModule", {
  value: !0
});
var MUe = Fm, DUe = ["mousedown", "wheel", "touchmove", "keydown"];
II.default = {
  subscribe: function(e) {
    return typeof document < "u" && DUe.forEach(function(t) {
      return (0, MUe.addPassiveEventListener)(document, t, e);
    });
  }
};
var Um = {};
Object.defineProperty(Um, "__esModule", {
  value: !0
});
var sD = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      sD.registered[e] = t;
    },
    remove: function(e) {
      sD.registered[e] = null;
    }
  }
};
Um.default = sD;
Object.defineProperty(BE, "__esModule", {
  value: !0
});
var TUe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, jUe = zm;
RE(jUe);
var AUe = AI, d9 = RE(AUe), IUe = II, BUe = RE(IUe), RUe = Um, Fa = RE(RUe);
function RE(e) {
  return e && e.__esModule ? e : { default: e };
}
var Qae = function(e) {
  return d9.default[e.smooth] || d9.default.defaultEasing;
}, NUe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, FUe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, aD = function() {
  return FUe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), ele = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, tle = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, nle = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, zUe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, UUe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, HUe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Fa.default.registered.end && Fa.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    aD.call(window, i);
    return;
  }
  Fa.default.registered.end && Fa.default.registered.end(o.to, o.target, o.currentPosition);
}, BI = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Hm = function(e, t, n, r) {
  t.data = t.data || ele(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (BUe.default.subscribe(o), BI(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? tle(t) : nle(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Fa.default.registered.end && Fa.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = NUe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Qae(t), a = HUe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Fa.default.registered.begin && Fa.default.registered.begin(t.data.to, t.data.target), aD.call(window, a);
    }, t.delay);
    return;
  }
  Fa.default.registered.begin && Fa.default.registered.begin(t.data.to, t.data.target), aD.call(window, a);
}, NE = function(e) {
  return e = TUe({}, e), e.data = e.data || ele(), e.absolute = !0, e;
}, WUe = function(e) {
  Hm(0, NE(e));
}, VUe = function(e, t) {
  Hm(e, NE(t));
}, $Ue = function(e) {
  e = NE(e), BI(e), Hm(e.horizontal ? zUe(e) : UUe(e), e);
}, ZUe = function(e, t) {
  t = NE(t), BI(t);
  var n = t.horizontal ? tle(t) : nle(t);
  Hm(e + n, t);
};
BE.default = {
  animateTopScroll: Hm,
  getAnimationType: Qae,
  scrollToTop: WUe,
  scrollToBottom: $Ue,
  scrollTo: VUe,
  scrollMore: ZUe
};
Object.defineProperty(Jd, "__esModule", {
  value: !0
});
var qUe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, GUe = zm, KUe = RI(GUe), YUe = BE, XUe = RI(YUe), JUe = Um, nb = RI(JUe);
function RI(e) {
  return e && e.__esModule ? e : { default: e };
}
var rb = {}, f9 = void 0;
Jd.default = {
  unmount: function() {
    rb = {};
  },
  register: function(e, t) {
    rb[e] = t;
  },
  unregister: function(e) {
    delete rb[e];
  },
  get: function(e) {
    return rb[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return f9 = e;
  },
  getActiveLink: function() {
    return f9;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = qUe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = KUe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      nb.default.registered.begin && nb.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, nb.default.registered.end && nb.default.registered.end(e, n);
      return;
    }
    XUe.default.animateTopScroll(s, t, e, n);
  }
};
var lD = { exports: {} }, k1 = { exports: {} }, tr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h9;
function QUe() {
  if (h9) return tr;
  h9 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function O(v) {
    return M(v) === u;
  }
  return tr.AsyncMode = l, tr.ConcurrentMode = u, tr.ContextConsumer = s, tr.ContextProvider = a, tr.Element = t, tr.ForwardRef = c, tr.Fragment = r, tr.Lazy = f, tr.Memo = g, tr.Portal = n, tr.Profiler = i, tr.StrictMode = o, tr.Suspense = p, tr.isAsyncMode = function(v) {
    return O(v) || M(v) === l;
  }, tr.isConcurrentMode = O, tr.isContextConsumer = function(v) {
    return M(v) === s;
  }, tr.isContextProvider = function(v) {
    return M(v) === a;
  }, tr.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, tr.isForwardRef = function(v) {
    return M(v) === c;
  }, tr.isFragment = function(v) {
    return M(v) === r;
  }, tr.isLazy = function(v) {
    return M(v) === f;
  }, tr.isMemo = function(v) {
    return M(v) === g;
  }, tr.isPortal = function(v) {
    return M(v) === n;
  }, tr.isProfiler = function(v) {
    return M(v) === i;
  }, tr.isStrictMode = function(v) {
    return M(v) === o;
  }, tr.isSuspense = function(v) {
    return M(v) === p;
  }, tr.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === y);
  }, tr.typeOf = M, tr;
}
var dr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var g9;
function eHe() {
  return g9 || (g9 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === E || B.$$typeof === w || B.$$typeof === y);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, x = u, _ = s, z = a, L = t, N = c, R = r, V = f, Z = g, H = n, $ = i, K = o, X = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function F(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return O(B) === c;
    }
    function C(B) {
      return O(B) === r;
    }
    function I(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function j(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    dr.AsyncMode = v, dr.ConcurrentMode = x, dr.ContextConsumer = _, dr.ContextProvider = z, dr.Element = L, dr.ForwardRef = N, dr.Fragment = R, dr.Lazy = V, dr.Memo = Z, dr.Portal = H, dr.Profiler = $, dr.StrictMode = K, dr.Suspense = X, dr.isAsyncMode = J, dr.isConcurrentMode = P, dr.isContextConsumer = D, dr.isContextProvider = F, dr.isElement = S, dr.isForwardRef = W, dr.isFragment = C, dr.isLazy = I, dr.isMemo = U, dr.isPortal = T, dr.isProfiler = q, dr.isStrictMode = j, dr.isSuspense = Y, dr.isValidElementType = M, dr.typeOf = O;
  }()), dr;
}
var m9;
function rle() {
  return m9 || (m9 = 1, process.env.NODE_ENV === "production" ? k1.exports = QUe() : k1.exports = eHe()), k1.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var L1, v9;
function tHe() {
  if (v9) return L1;
  v9 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return L1 = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, L1;
}
var P1, y9;
function NI() {
  if (y9) return P1;
  y9 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return P1 = e, P1;
}
var b9, w9;
function ole() {
  return w9 || (w9 = 1, b9 = Function.call.bind(Object.prototype.hasOwnProperty)), b9;
}
var _1, C9;
function nHe() {
  if (C9) return _1;
  C9 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = NI(), n = {}, r = ole();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, _1 = o, _1;
}
var S1, x9;
function rHe() {
  if (x9) return S1;
  x9 = 1;
  var e = rle(), t = tHe(), n = NI(), r = ole(), o = nHe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return S1 = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: v(),
      instanceOf: x,
      node: N(),
      objectOf: z,
      oneOf: _,
      oneOfType: L,
      shape: V,
      exact: Z
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function y(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    y.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, F = 0;
      function S(C, I, U, T, q, j, Y) {
        if (T = T || d, j = j || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            F < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + j + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, F++);
          }
        }
        return I[U] == null ? C ? I[U] === null ? new y("The " + q + " `" + j + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new y("The " + q + " `" + j + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(I, U, T, q, j);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(P) {
      function D(F, S, W, C, I, U) {
        var T = F[S], q = K(T);
        if (q !== P) {
          var j = X(T);
          return new y(
            "Invalid " + C + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = F[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var j = P(U, q, W, C, I + "[" + q + "]", n);
          if (j instanceof Error)
            return j;
        }
        return null;
      }
      return b(D);
    }
    function O() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!s(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function v() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!e.isValidElementType(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function x(P) {
      function D(F, S, W, C, I) {
        if (!(F[S] instanceof P)) {
          var U = P.name || d, T = J(F[S]);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(F, S, W, C, I) {
        for (var U = F[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(j, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new y("Invalid " + C + " `" + I + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function z(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var j = P(U, q, W, C, I + "." + q, n);
            if (j instanceof Error)
              return j;
          }
        return null;
      }
      return b(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var F = P[D];
        if (typeof F != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(F) + " at index " + D + "."
          ), a;
      }
      function S(W, C, I, U, T) {
        for (var q = [], j = 0; j < P.length; j++) {
          var Y = P[j], B = Y(W, C, I, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new y("Invalid " + U + " `" + T + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(S);
    }
    function N() {
      function P(D, F, S, W, C) {
        return H(D[F]) ? null : new y("Invalid " + W + " `" + C + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, D, F, S, W) {
      return new y(
        (P || "React class") + ": " + D + " type `" + F + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var j = P[q];
          if (typeof j != "function")
            return R(W, C, I, q, X(j));
          var Y = j(U, q, W, C, I + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(D);
    }
    function Z(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, F[S], P);
        for (var j in q) {
          var Y = P[j];
          if (r(P, j) && typeof Y != "function")
            return R(W, C, I, j, X(Y));
          if (!Y)
            return new y(
              "Invalid " + C + " `" + I + "` key `" + j + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(F[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, j, W, C, I + "." + j, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(D);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var F = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = F.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = F.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function $(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : $(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, S1;
}
var M1, O9;
function oHe() {
  if (O9) return M1;
  O9 = 1;
  var e = NI();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, M1 = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, M1;
}
if (process.env.NODE_ENV !== "production") {
  var iHe = rle(), sHe = !0;
  lD.exports = rHe()(iHe.isElement, sHe);
} else
  lD.exports = oHe()();
var FE = lD.exports, zE = {};
Object.defineProperty(zE, "__esModule", {
  value: !0
});
var aHe = zm, D1 = lHe(aHe);
function lHe(e) {
  return e && e.__esModule ? e : { default: e };
}
var uHe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return D1.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && D1.default.getHash() !== e && D1.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
zE.default = uHe;
Object.defineProperty(Rm, "__esModule", {
  value: !0
});
var ob = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, cHe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), pHe = we, E9 = Wm(pHe), dHe = Nm, ib = Wm(dHe), fHe = Jd, hHe = Wm(fHe), gHe = FE, go = Wm(gHe), mHe = zE, uu = Wm(mHe);
function Wm(e) {
  return e && e.__esModule ? e : { default: e };
}
function vHe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function yHe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function bHe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var k9 = {
  to: go.default.string.isRequired,
  containerId: go.default.string,
  container: go.default.object,
  activeClass: go.default.string,
  activeStyle: go.default.object,
  spy: go.default.bool,
  horizontal: go.default.bool,
  smooth: go.default.oneOfType([go.default.bool, go.default.string]),
  offset: go.default.number,
  delay: go.default.number,
  isDynamic: go.default.bool,
  onClick: go.default.func,
  duration: go.default.oneOfType([go.default.number, go.default.func]),
  absolute: go.default.bool,
  onSetActive: go.default.func,
  onSetInactive: go.default.func,
  ignoreCancelEvents: go.default.bool,
  hashSpy: go.default.bool,
  saveHashHistory: go.default.bool,
  spyThrottle: go.default.number
};
Rm.default = function(e, t) {
  var n = t || hHe.default, r = function(i) {
    bHe(a, i);
    function a(s) {
      vHe(this, a);
      var l = yHe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return cHe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!ib.default.isMounted(s)) {
            var l = ib.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (uu.default.isMounted() || uu.default.mount(n), uu.default.mapContainer(this.props.to, s)), ib.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        ib.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = ob({}, this.props.style, this.props.activeStyle) : l = ob({}, this.props.style);
        var u = ob({}, this.props);
        for (var c in k9)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, E9.default.createElement(e, u);
      }
    }]), a;
  }(E9.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, ob({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(uu.default.isMounted() && !uu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, y = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, y = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(y), g = M < Math.floor(f) || M >= Math.floor(y);
        } else {
          var O = 0, v = 0, x = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            x = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            O = z.top - x + s, v = O + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(v), g = L < Math.floor(O) || L >= Math.floor(v);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && uu.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            uu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var Z = i.props.saveHashHistory, H = Z === void 0 ? !1 : Z;
          i.props.hashSpy && uu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = k9, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(jI, "__esModule", {
  value: !0
});
var wHe = we, L9 = ile(wHe), CHe = Rm, xHe = ile(CHe);
function ile(e) {
  return e && e.__esModule ? e : { default: e };
}
function OHe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function P9(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function EHe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var kHe = function(e) {
  EHe(t, e);
  function t() {
    var n, r, o, i;
    OHe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = P9(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return L9.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), P9(o, i);
  }
  return t;
}(L9.default.Component);
jI.default = (0, xHe.default)(kHe);
var FI = {};
Object.defineProperty(FI, "__esModule", {
  value: !0
});
var LHe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), PHe = we, _9 = sle(PHe), _He = Rm, SHe = sle(_He);
function sle(e) {
  return e && e.__esModule ? e : { default: e };
}
function MHe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function DHe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function THe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var jHe = function(e) {
  THe(t, e);
  function t() {
    return MHe(this, t), DHe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return LHe(t, [{
    key: "render",
    value: function() {
      return _9.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(_9.default.Component);
FI.default = (0, SHe.default)(jHe);
var zI = {}, UE = {};
Object.defineProperty(UE, "__esModule", {
  value: !0
});
var AHe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, IHe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), BHe = we, S9 = HE(BHe), RHe = nl;
HE(RHe);
var NHe = Jd, M9 = HE(NHe), FHe = FE, D9 = HE(FHe);
function HE(e) {
  return e && e.__esModule ? e : { default: e };
}
function zHe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function UHe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function HHe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
UE.default = function(e) {
  var t = function(n) {
    HHe(r, n);
    function r(o) {
      zHe(this, r);
      var i = UHe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return IHe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        M9.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        M9.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return S9.default.createElement(e, AHe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(S9.default.Component);
  return t.propTypes = {
    name: D9.default.string,
    id: D9.default.string
  }, t;
};
Object.defineProperty(zI, "__esModule", {
  value: !0
});
var T9 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, WHe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), VHe = we, j9 = UI(VHe), $He = UE, ZHe = UI($He), qHe = FE, A9 = UI(qHe);
function UI(e) {
  return e && e.__esModule ? e : { default: e };
}
function GHe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function KHe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function YHe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ale = function(e) {
  YHe(t, e);
  function t() {
    return GHe(this, t), KHe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return WHe(t, [{
    key: "render",
    value: function() {
      var n = this, r = T9({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, j9.default.createElement(
        "div",
        T9({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(j9.default.Component);
ale.propTypes = {
  name: A9.default.string,
  id: A9.default.string
};
zI.default = (0, ZHe.default)(ale);
var T1 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, I9 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function B9(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function R9(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function N9(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var sb = we, Ic = Nm, j1 = Jd, zo = FE, cu = zE, F9 = {
  to: zo.string.isRequired,
  containerId: zo.string,
  container: zo.object,
  activeClass: zo.string,
  spy: zo.bool,
  smooth: zo.oneOfType([zo.bool, zo.string]),
  offset: zo.number,
  delay: zo.number,
  isDynamic: zo.bool,
  onClick: zo.func,
  duration: zo.oneOfType([zo.number, zo.func]),
  absolute: zo.bool,
  onSetActive: zo.func,
  onSetInactive: zo.func,
  ignoreCancelEvents: zo.bool,
  hashSpy: zo.bool,
  spyThrottle: zo.number
}, XHe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || j1, r = function(i) {
      N9(a, i);
      function a(s) {
        B9(this, a);
        var l = R9(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return I9(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Ic.isMounted(s) || Ic.mount(s, this.props.spyThrottle), this.props.hashSpy && (cu.isMounted() || cu.mount(n), cu.mapContainer(this.props.to, s)), this.props.spy && Ic.addStateHandler(this.stateHandler), Ic.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ic.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = T1({}, this.props);
          for (var u in F9)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, sb.createElement(e, l);
        }
      }]), a;
    }(sb.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, T1({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(cu.isMounted() && !cu.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var y = a - i.props.offset, b = y >= Math.floor(c) && y < Math.floor(p), E = y < Math.floor(c) || y >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && cu.getHash() === l && cu.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Ic.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && cu.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Ic.updateStates();
        }
      };
    };
    return r.propTypes = F9, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      N9(r, n);
      function r(o) {
        B9(this, r);
        var i = R9(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return I9(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          j1.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          j1.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return sb.createElement(e, T1({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(sb.Component);
    return t.propTypes = {
      name: zo.string,
      id: zo.string
    }, t;
  }
}, JHe = XHe;
Object.defineProperty(ri, "__esModule", {
  value: !0
});
ri.Helpers = ri.ScrollElement = ri.ScrollLink = ri.animateScroll = ri.scrollSpy = ri.Events = ri.scroller = ri.Element = ri.Button = ri.Link = void 0;
var QHe = jI, lle = il(QHe), eWe = FI, ule = il(eWe), tWe = zI, cle = il(tWe), nWe = Jd, ple = il(nWe), rWe = Um, dle = il(rWe), oWe = Nm, fle = il(oWe), iWe = BE, hle = il(iWe), sWe = Rm, gle = il(sWe), aWe = UE, mle = il(aWe), lWe = JHe, vle = il(lWe);
function il(e) {
  return e && e.__esModule ? e : { default: e };
}
ri.Link = lle.default;
ri.Button = ule.default;
ri.Element = cle.default;
ri.scroller = ple.default;
ri.Events = dle.default;
ri.scrollSpy = fle.default;
ri.animateScroll = hle.default;
ri.ScrollLink = gle.default;
ri.ScrollElement = mle.default;
ri.Helpers = vle.default;
ri.default = { Link: lle.default, Button: ule.default, Element: cle.default, scroller: ple.default, Events: dle.default, scrollSpy: fle.default, animateScroll: hle.default, ScrollLink: gle.default, ScrollElement: mle.default, Helpers: vle.default };
We({});
We({});
We({});
function sm(e) {
  "@babel/helpers - typeof";
  return sm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, sm(e);
}
function uWe(e, t) {
  if (sm(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (sm(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function cWe(e) {
  var t = uWe(e, "string");
  return sm(t) == "symbol" ? t : t + "";
}
function je(e, t, n) {
  return (t = cWe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function yle(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var A1, z9;
function pWe() {
  if (z9) return A1;
  z9 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return A1 = t, A1;
}
var dWe = pWe(), di = /* @__PURE__ */ yle(dWe), Wt = We(null);
function fWe() {
  di(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Wt);
  return di(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function hWe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function gWe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function mWe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return gWe(e, i), o;
}
function vWe(e, t, n) {
  var r = hWe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function yWe(e) {
  google.maps.event.removeListener(e);
}
function Rn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(yWe);
}
function Ln(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = vWe(o, i, n);
  return mWe(t, r, o, i), a;
}
function bWe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: y,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [v, x] = k(null), _ = ht(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null), [j, Y] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && y && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", y)));
  }, [y]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (j !== null && google.maps.event.removeListener(j), Y(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return x(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), Ai.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: Ai.jsx(Wt.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(bWe);
function U9(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function ble(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        U9(i, r, o, a, s, "next", l);
      }
      function s(l) {
        U9(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function wle(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return di(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var vp = typeof document < "u";
function Cle(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return vp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function H9(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function xle() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return H9(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return H9(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Nf = !1;
function Ole() {
  return Ai.jsx("div", {
    children: "Loading..."
  });
}
var uD = {
  id: "script-loader",
  version: "weekly"
};
class wWe extends pe {
  constructor() {
    super(...arguments), je(this, "check", null), je(this, "state", {
      loaded: !1
    }), je(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), je(this, "isCleaningUp", /* @__PURE__ */ ble(function* () {
      function t(n) {
        if (!Nf)
          n();
        else if (vp)
          var r = window.setInterval(function() {
            Nf || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), je(this, "cleanup", () => {
      Nf = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), je(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && xle(), di(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: wle(this.props)
      };
      Cle(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), je(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (vp) {
      if (window.google && window.google.maps && !Nf) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), vp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (vp) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Nf = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Ai.jsxs(Ai.Fragment, {
      children: [Ai.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Ai.jsx(Ole, {})]
    });
  }
}
je(wWe, "defaultProps", uD);
function CWe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function HI(e, t) {
  if (e == null) return {};
  var n, r, o = CWe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var W9;
function xWe(e) {
  var {
    id: t = uD.id,
    version: n = uD.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ht(!1), [f, y] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    vp && u && xle();
  }, [u]), h(function() {
    f && di(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = wle({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!vp)
      return;
    function O() {
      g.current && (y(!0), W9 = w);
    }
    if (window.google && window.google.maps && W9 === w) {
      O();
      return;
    }
    Cle({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = ht(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var OWe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], EWe = Ai.jsx(Ole, {});
function kWe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = HI(e, OWe), {
    isLoaded: s,
    loadError: l
  } = xWe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || EWe;
}
me(kWe);
var V9;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(V9 || (V9 = {}));
function $9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $9(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Z9 = {}, q9 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function LWe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Wt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(nC(nC({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(LWe);
class PWe extends pe {
  constructor() {
    super(...arguments), je(this, "state", {
      trafficLayer: null
    }), je(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), je(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(nC(nC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: q9,
      eventMap: Z9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: q9,
      eventMap: Z9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Rn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
je(PWe, "contextType", Wt);
function _We(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Wt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(_We);
class SWe extends pe {
  constructor() {
    super(...arguments), je(this, "state", {
      bicyclingLayer: null
    }), je(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
je(SWe, "contextType", Wt);
function MWe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Wt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(MWe);
class DWe extends pe {
  constructor() {
    super(...arguments), je(this, "state", {
      transitLayer: null
    }), je(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
je(DWe, "contextType", Wt);
function G9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G9(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var K9 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, Y9 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function TWe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Wt), [d, g] = k(null), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), y(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    di(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(rC(rC({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && y(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && v(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(TWe);
class jWe extends pe {
  constructor(t) {
    super(t), je(this, "registeredEvents", []), je(this, "state", {
      drawingManager: null
    }), je(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), di(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(rC(rC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: Y9,
      eventMap: K9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: Y9,
      eventMap: K9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Rn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
je(jWe, "contextType", Wt);
function X9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X9(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var J9 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, Q9 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, oC = {};
function AWe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: y,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: v,
    onMouseOut: x,
    onMouseOver: _,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: Z,
    onDraggableChanged: H,
    onFlatChanged: $,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: F,
    onUnmount: S
  } = e, W = ge(Wt), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null), [oe, Pe] = k(null), [Ue, Ze] = k(null), [_e, rt] = k(null), [Ve, ye] = k(null), [Ge, ct] = k(null), [ve, Oe] = k(null), [qe, ze] = k(null), [Se, st] = k(null), [xe, xt] = k(null), [at, lt] = k(null), [pt, Ot] = k(null), [dt, ft] = k(null), [ot, He] = k(null), [Et, kt] = k(null), [gt, St] = k(null), [mt, Mt] = k(null), [vt, Pt] = k(null);
  h(() => {
    C !== null && C.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && C !== null && C.setOptions(n);
  }, [C, n]), h(() => {
    typeof a < "u" && C !== null && C.setDraggable(a);
  }, [C, a]), h(() => {
    t && C !== null && C.setPosition(t);
  }, [C, t]), h(() => {
    typeof s < "u" && C !== null && C.setVisible(s);
  }, [C, s]), h(() => {
    C == null || C.setAnimation(l);
  }, [C, l]), h(() => {
    C && u !== void 0 && C.setClickable(u);
  }, [C, u]), h(() => {
    C && c !== void 0 && C.setCursor(c);
  }, [C, c]), h(() => {
    C && p !== void 0 && C.setIcon(p);
  }, [C, p]), h(() => {
    C && d !== void 0 && C.setLabel(d);
  }, [C, d]), h(() => {
    C && g !== void 0 && C.setOpacity(g);
  }, [C, g]), h(() => {
    C && f !== void 0 && C.setShape(f);
  }, [C, f]), h(() => {
    C && y !== void 0 && C.setTitle(y);
  }, [C, y]), h(() => {
    C && b !== void 0 && C.setZIndex(b);
  }, [C, b]), h(() => {
    C && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(C, "dblclick", w)));
  }, [w]), h(() => {
    C && O && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(C, "dragend", O)));
  }, [O]), h(() => {
    C && v && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(C, "dragstart", v)));
  }, [v]), h(() => {
    C && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(C, "mousedown", L)));
  }, [L]), h(() => {
    C && x && (oe !== null && google.maps.event.removeListener(oe), Pe(google.maps.event.addListener(C, "mouseout", x)));
  }, [x]), h(() => {
    C && _ && (Ue !== null && google.maps.event.removeListener(Ue), Ze(google.maps.event.addListener(C, "mouseover", _)));
  }, [_]), h(() => {
    C && z && (_e !== null && google.maps.event.removeListener(_e), rt(google.maps.event.addListener(C, "mouseup", z)));
  }, [z]), h(() => {
    C && N && (Ve !== null && google.maps.event.removeListener(Ve), ye(google.maps.event.addListener(C, "rightclick", N)));
  }, [N]), h(() => {
    C && E && (Ge !== null && google.maps.event.removeListener(Ge), ct(google.maps.event.addListener(C, "click", E)));
  }, [E]), h(() => {
    C && M && (ve !== null && google.maps.event.removeListener(ve), Oe(google.maps.event.addListener(C, "drag", M)));
  }, [M]), h(() => {
    C && R && (qe !== null && google.maps.event.removeListener(qe), ze(google.maps.event.addListener(C, "clickable_changed", R)));
  }, [R]), h(() => {
    C && V && (Se !== null && google.maps.event.removeListener(Se), st(google.maps.event.addListener(C, "cursor_changed", V)));
  }, [V]), h(() => {
    C && Z && (xe !== null && google.maps.event.removeListener(xe), xt(google.maps.event.addListener(C, "animation_changed", Z)));
  }, [Z]), h(() => {
    C && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(C, "draggable_changed", H)));
  }, [H]), h(() => {
    C && $ && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(C, "flat_changed", $)));
  }, [$]), h(() => {
    C && K && (dt !== null && google.maps.event.removeListener(dt), ft(google.maps.event.addListener(C, "icon_changed", K)));
  }, [K]), h(() => {
    C && X && (ot !== null && google.maps.event.removeListener(ot), He(google.maps.event.addListener(C, "position_changed", X)));
  }, [X]), h(() => {
    C && Q && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(C, "shape_changed", Q)));
  }, [Q]), h(() => {
    C && J && (gt !== null && google.maps.event.removeListener(gt), St(google.maps.event.addListener(C, "title_changed", J)));
  }, [J]), h(() => {
    C && P && (mt !== null && google.maps.event.removeListener(mt), Mt(google.maps.event.addListener(C, "visible_changed", P)));
  }, [P]), h(() => {
    C && D && (vt !== null && google.maps.event.removeListener(vt), Pt(google.maps.event.addListener(C, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = bd(bd(bd({}, n || oC), r ? oC : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(yt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof g < "u" && te.setOpacity(g), f && te.setShape(f), typeof y == "string" && te.setTitle(y), typeof b == "number" && te.setZIndex(b), w && T(google.maps.event.addListener(te, "dblclick", w)), O && j(google.maps.event.addListener(te, "dragend", O)), v && B(google.maps.event.addListener(te, "dragstart", v)), L && he(google.maps.event.addListener(te, "mousedown", L)), x && Pe(google.maps.event.addListener(te, "mouseout", x)), _ && Ze(google.maps.event.addListener(te, "mouseover", _)), z && rt(google.maps.event.addListener(te, "mouseup", z)), N && ye(google.maps.event.addListener(te, "rightclick", N)), E && ct(google.maps.event.addListener(te, "click", E)), M && Oe(google.maps.event.addListener(te, "drag", M)), R && ze(google.maps.event.addListener(te, "clickable_changed", R)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), Z && xt(google.maps.event.addListener(te, "animation_changed", Z)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), $ && Ot(google.maps.event.addListener(te, "flat_changed", $)), K && ft(google.maps.event.addListener(te, "icon_changed", K)), X && He(google.maps.event.addListener(te, "position_changed", X)), Q && kt(google.maps.event.addListener(te, "shape_changed", Q)), J && St(google.maps.event.addListener(te, "title_changed", J)), P && Mt(google.maps.event.addListener(te, "visible_changed", P)), D && Pt(google.maps.event.addListener(te, "zindex_changed", D)), I(te), F && F(te), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), _e !== null && google.maps.event.removeListener(_e), Ve !== null && google.maps.event.removeListener(Ve), Ge !== null && google.maps.event.removeListener(Ge), qe !== null && google.maps.event.removeListener(qe), Se !== null && google.maps.event.removeListener(Se), xe !== null && google.maps.event.removeListener(xe), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ot !== null && google.maps.event.removeListener(ot), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var jn = Ft(() => i ? ut.map(i, (yt) => {
    if (!wi(yt))
      return yt;
    var te = yt;
    return Ci(te, {
      anchor: C
    });
  }) : null, [i, C]);
  return Ai.jsx(Ai.Fragment, {
    children: jn
  }) || null;
}
me(AWe);
class IWe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return ble(function* () {
      var n = bd(bd(bd({}, t.props.options || oC), t.props.clusterer ? oC : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Ln({
        updaterMap: Q9,
        eventMap: J9,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: Q9,
      eventMap: J9,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Rn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Ci(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
je(IWe, "contextType", Wt);
var BWe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), RWe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new BWe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function NWe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var FWe = 2e3, zWe = 500, UWe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", HWe = "png", WWe = [53, 56, 66, 78, 90], VWe = "cluster", Ele = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || UWe, this.imageExtension = r.imageExtension || HWe, this.imageSizes = r.imageSizes || WWe, this.calculator = r.calculator || NWe, this.batchSize = r.batchSize || FWe, this.batchSizeIE = r.batchSizeIE || zWe, this.clusterClass = r.clusterClass || VWe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new RWe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function e6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $We(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? e6(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : e6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ma = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, $n = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, ZWe = {};
function qWe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: y,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: v,
    onMouseOut: x,
    onLoad: _,
    onUnmount: z
  } = e, [L, N] = k(null), R = ge(Wt), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && x && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, ma.onMouseOut, x)));
  }, [x]), h(() => {
    L && v && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, ma.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(L, ma.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(L, ma.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), $(google.maps.event.addListener(L, ma.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && $n.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && $n.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && $n.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && $n.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && $n.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && $n.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && $n.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && $n.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && $n.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && $n.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && $n.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && $n.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof y < "u" && L !== null && $n.styles(L, y);
  }, [L, y]), h(() => {
    typeof b < "u" && L !== null && $n.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && $n.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var F = $We({}, n || ZWe), S = new Ele(R, [], F);
      return r && $n.averageCenter(S, r), o && $n.batchSizeIE(S, o), i && $n.calculator(S, i), a && $n.clusterClass(S, a), s && $n.enableRetinaIcons(S, s), l && $n.gridSize(S, l), u && $n.ignoreHidden(S, u), c && $n.imageExtension(S, c), p && $n.imagePath(S, p), d && $n.imageSizes(S, d), g && $n.maxZoom(S, g), f && $n.minimumClusterSize(S, f), y && $n.styles(S, y), b && $n.title(S, b), E && $n.zoomOnClick(S, E), x && J(google.maps.event.addListener(S, ma.onMouseOut, x)), v && D(google.maps.event.addListener(S, ma.onMouseOver, v)), w && Z(google.maps.event.addListener(S, ma.onClick, w)), M && $(google.maps.event.addListener(S, ma.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, ma.onClusteringEnd, O)), N(S), _ && _(S), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), z && z(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(qWe);
class GWe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      markerClusterer: null
    }), je(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Ele(this.context, [], this.props.options);
      this.registeredEvents = Ln({
        updaterMap: $n,
        eventMap: ma,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: $n,
      eventMap: ma,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Rn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
je(GWe, "contextType", Wt);
function t6(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var kle = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || t6(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, t6));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, y = this.getProjection(), b = y.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), KWe = ["position"], YWe = ["position"];
function n6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? n6(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : n6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var r6 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, o6 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, XWe = {};
function JWe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Wt), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || XWe, {
        position: V
      } = R, Z = HI(R, KWe), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var $ = new kle(iC(iC({}, Z), H ? {
        position: H
      } : {}));
      N.current = document.createElement("div"), y($), a && E(google.maps.event.addListener($, "closeclick", a)), s && M(google.maps.event.addListener($, "domready", s)), l && v(google.maps.event.addListener($, "content_changed", l)), u && _(google.maps.event.addListener($, "position_changed", u)), c && L(google.maps.event.addListener($, "zindex_changed", c)), $.setContent(N.current), n ? $.open(g, n) : $.getPosition() ? $.open(g) : di(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p($);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(JWe);
class QWe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "containerElement", null), je(this, "state", {
      infoBox: null
    }), je(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : di(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), je(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = HI(t, YWe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new kle(iC(iC({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Ln({
      updaterMap: o6,
      eventMap: r6,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: o6,
      eventMap: r6,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Rn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
je(QWe, "contextType", Wt);
var i6, s6;
function eVe() {
  return s6 || (s6 = 1, i6 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), i6;
}
var tVe = eVe(), a6 = /* @__PURE__ */ yle(tVe), l6 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], I1 = 1, Ff = 8;
class WI {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== I1)
      throw new Error("Got v".concat(o, " data when expected v").concat(I1, "."));
    var i = l6[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new WI(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = l6.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Ff, t), this.coords = new this.ArrayType(this.data, Ff + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Ff + a + s + l), this.ids = new this.IndexArrayType(this.data, Ff, t), this.coords = new this.ArrayType(this.data, Ff + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (I1 << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return cD(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], y = a[2 * g + 1];
          f >= t && f <= r && y >= n && y <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          u6(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, y = i[2 * f], b = i[2 * f + 1];
      u6(y, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= y : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= y : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function cD(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Lle(e, t, a, r, o, i), cD(e, t, n, r, a - 1, 1 - i), cD(e, t, n, a + 1, o, 1 - i);
  }
}
function Lle(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Lle(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, y = o;
    for (zf(e, t, r, n), t[2 * o + i] > g && zf(e, t, r, o); f < y; ) {
      for (zf(e, t, f, y), f++, y--; t[2 * f + i] < g; ) f++;
      for (; t[2 * y + i] > g; ) y--;
    }
    t[2 * r + i] === g ? zf(e, t, r, y) : (y++, zf(e, t, y, o)), y <= n && (r = y + 1), n <= y && (o = y - 1);
  }
}
function zf(e, t, n, r) {
  B1(e, n, r), B1(t, 2 * n, 2 * r), B1(t, 2 * n + 1, 2 * r + 1);
}
function B1(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function u6(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var nVe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, c6 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Bc = 2, Iu = 3, R1 = 4, Lu = 5, Ple = 6;
class rVe {
  constructor(t) {
    this.options = Object.assign(Object.create(nVe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = c6(ab(u)), d = c6(lb(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var y = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - y);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(ab(r), lb(a), ab(i), lb(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Lu] > 1 ? p6(p, f, this.clusterProps) : this.points[p[f + Iu]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + R1] === t && p.push(a[g + Lu] > 1 ? p6(a, g, this.clusterProps) : this.points[a[g + Iu]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new WI(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Lu] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = _le(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Iu]];
        c = g.properties;
        var [f, y] = g.geometry.coordinates;
        p = ab(f), d = lb(y);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Iu] : E = this.points[n[l + Iu]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Bc] <= n)) {
        l[p + Bc] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), y = l[p + Lu], b = y;
        for (var E of f) {
          var w = E * c;
          l[w + Bc] > n && (b += l[w + Lu]);
        }
        if (b > y && b >= a) {
          var M = d * y, O = g * y, v = void 0, x = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Bc] <= n)) {
              l[L + Bc] = n;
              var N = l[L + Lu];
              M += l[L] * N, O += l[L + 1] * N, l[L + R1] = _, i && (v || (v = this._map(l, p, !0), x = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + R1] = _, u.push(M / b, O / b, 1 / 0, _, -1, b), i && u.push(x);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var Z = V * c;
              if (!(l[Z + Bc] <= n)) {
                l[Z + Bc] = n;
                for (var H = 0; H < c; H++) u.push(l[Z + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Lu] > 1) {
      var o = this.clusterProps[t[n + Ple]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Iu]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function p6(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Iu],
    properties: _le(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [oVe(e[t]), iVe(e[t + 1])]
    }
  };
}
function _le(e, t, n) {
  var r = e[t + Lu], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Ple], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Iu],
    point_count: r,
    point_count_abbreviated: o
  });
}
function ab(e) {
  return e / 360 + 0.5;
}
function lb(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function oVe(e) {
  return (e - 0.5) * 360;
}
function iVe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function sVe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ws {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class pD {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ws.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ws.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ws.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class aVe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return lVe(n);
  }
}
var lVe = (e) => {
  var t = e.map((n) => new pD({
    position: Ws.getPosition(n),
    markers: [n]
  }));
  return t;
};
class uVe extends aVe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = sVe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new rVe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!a6(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Ws.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !a6(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new pD({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new pD({
      markers: [i],
      position: Ws.getPosition(i)
    });
  }
}
class cVe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class pVe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ws.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function dVe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class VI {
  constructor() {
    dVe(VI, google.maps.OverlayView);
  }
}
var Gh;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Gh || (Gh = {}));
var fVe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class hVe extends VI {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new uVe(o),
      renderer: a = new pVe(),
      onClusterClick: s = fVe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ws.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Gh.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Ws.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Ws.setMap(l, null)));
      }
      google.maps.event.trigger(this, Gh.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ws.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new cVe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ws.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Gh.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ws.setMap(r.marker, n);
    });
  }
}
function d6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function f6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? d6(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : d6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function gVe(e) {
  var t = fWe(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new hVe(f6(f6({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function mVe(e) {
  var {
    children: t,
    options: n
  } = e, r = gVe(n);
  return r !== null ? t(r) : null;
}
me(mVe);
var h6 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, g6 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function vVe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Wt), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return y(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && v(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : di(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(R), R.close();
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(vVe);
class yVe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "containerElement", null), je(this, "state", {
      infoWindow: null
    }), je(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : di(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), je(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Ln({
      updaterMap: g6,
      eventMap: h6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: g6,
      eventMap: h6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Rn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
je(yVe, "contextType", Wt);
function m6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m6(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var v6 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, y6 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, bVe = {};
function wVe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Wt), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && y && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(O, "click", y)));
  }, [y]), h(() => {
    O && b && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(O, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(sC(sC({}, t || bVe), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && Z(google.maps.event.addListener(T, "mousedown", u)), c && $(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), y && C(google.maps.event.addListener(T, "click", y)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(wVe);
class CVe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      polyline: null
    }), je(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(sC(sC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: y6,
      eventMap: v6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: y6,
      eventMap: v6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Rn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
je(CVe, "contextType", Wt);
function b6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function w6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? b6(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : b6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var C6 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, x6 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function xVe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, v = ge(Wt), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    x !== null && x.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    typeof a < "u" && x !== null && x.setPaths(a);
  }, [x, a]), h(() => {
    x && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dblclick", s)));
  }, [s]), h(() => {
    x && (google.maps.event.addListener(x.getPath(), "insert_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "set_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "remove_at", () => {
      O == null || O(x);
    }));
  }, [x, O]), h(() => {
    x && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragend", l)));
  }, [l]), h(() => {
    x && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(x, "dragstart", u)));
  }, [u]), h(() => {
    x && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(x, "mousedown", c)));
  }, [c]), h(() => {
    x && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(x, "mousemove", p)));
  }, [p]), h(() => {
    x && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseout", d)));
  }, [d]), h(() => {
    x && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(x, "mouseover", g)));
  }, [g]), h(() => {
    x && typeof f == "function" && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(x, "mouseup", f)));
  }, [f]), h(() => {
    x && typeof y == "function" && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(x, "rightclick", y)));
  }, [y]), h(() => {
    x && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(x, "click", b)));
  }, [b]), h(() => {
    x && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(x, "drag", E)));
  }, [E]), h(() => {
    var j = new google.maps.Polygon(w6(w6({}, t), {}, {
      map: v
    }));
    return i && j.setPath(i), a && j.setPaths(a), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), s && L(google.maps.event.addListener(j, "dblclick", s)), l && R(google.maps.event.addListener(j, "dragend", l)), u && Z(google.maps.event.addListener(j, "dragstart", u)), c && $(google.maps.event.addListener(j, "mousedown", c)), p && X(google.maps.event.addListener(j, "mousemove", p)), d && J(google.maps.event.addListener(j, "mouseout", d)), g && D(google.maps.event.addListener(j, "mouseover", g)), f && S(google.maps.event.addListener(j, "mouseup", f)), y && C(google.maps.event.addListener(j, "rightclick", y)), b && U(google.maps.event.addListener(j, "click", b)), E && q(google.maps.event.addListener(j, "drag", E)), _(j), w && w(j), () => {
      z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), M && M(j), j.setMap(null);
    };
  }, []), null;
}
me(xVe);
class OVe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Ln({
      updaterMap: x6,
      eventMap: C6,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: x6,
      eventMap: C6,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Rn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
je(OVe, "contextType", Wt);
function O6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? O6(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : O6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var E6 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, k6 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function EVe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(Wt), [v, x] = k(null), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null);
  return h(() => {
    v !== null && v.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(v, "click", y)));
  }, [y]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(aC(aC({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && z(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && H(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && F(google.maps.event.addListener(Y, "mouseup", g)), f && W(google.maps.event.addListener(Y, "rightclick", f)), y && I(google.maps.event.addListener(Y, "click", y)), b && T(google.maps.event.addListener(Y, "drag", b)), E && j(google.maps.event.addListener(Y, "bounds_changed", E)), x(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
me(EVe);
class kVe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      rectangle: null
    }), je(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(aC(aC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: k6,
      eventMap: E6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: k6,
      eventMap: E6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Rn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
je(kVe, "contextType", Wt);
function L6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? L6(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : L6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var P6 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, _6 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, LVe = {};
function PVe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: v
  } = e, x = ge(Wt), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null);
  return h(() => {
    _ !== null && _.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(_, "rightclick", y)));
  }, [y]), h(() => {
    _ && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", b)));
  }, [b]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [b]), h(() => {
    _ && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(lC(lC({}, t || LVe), {}, {
      map: x
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && F(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), y && I(google.maps.event.addListener(oe, "rightclick", y)), b && T(google.maps.event.addListener(oe, "click", b)), E && j(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), z(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(PVe);
class _Ve extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      circle: null
    }), je(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(lC(lC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: _6,
      eventMap: P6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: _6,
      eventMap: P6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Rn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
je(_Ve, "contextType", Wt);
function S6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? S6(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : S6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var M6 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, D6 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function SVe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: y,
    onUnmount: b
  } = e, E = ge(Wt), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var j = new google.maps.Data(uC(uC({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(j, "dblclick", r)), o && _(google.maps.event.addListener(j, "mousedown", o)), i && L(google.maps.event.addListener(j, "mousemove", i)), a && R(google.maps.event.addListener(j, "mouseout", a)), s && Z(google.maps.event.addListener(j, "mouseover", s)), l && $(google.maps.event.addListener(j, "mouseup", l)), u && X(google.maps.event.addListener(j, "rightclick", u)), n && J(google.maps.event.addListener(j, "click", n)), c && D(google.maps.event.addListener(j, "addfeature", c)), p && S(google.maps.event.addListener(j, "removefeature", p)), d && C(google.maps.event.addListener(j, "removeproperty", d)), g && U(google.maps.event.addListener(j, "setgeometry", g)), f && q(google.maps.event.addListener(j, "setproperty", f)), M(j), y && y(j);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(SVe);
class MVe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      data: null
    }), je(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(uC(uC({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Ln({
        updaterMap: D6,
        eventMap: M6,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: D6,
      eventMap: M6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Rn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
je(MVe, "contextType", Wt);
function T6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function j6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? T6(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : T6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var A6 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, I6 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class DVe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      kmlLayer: null
    }), je(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(j6(j6({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: I6,
      eventMap: A6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: I6,
      eventMap: A6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Rn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
je(DVe, "contextType", Wt);
function Sle(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function TVe(e, t) {
  return new t(e.lat, e.lng);
}
function jVe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function AVe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function IVe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function BVe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function RVe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Mle(e, t, n, r) {
  return n !== void 0 ? BVe(e, t, IVe(n, google.maps.LatLngBounds, jVe)) : RVe(e, t, AVe(r, google.maps.LatLng, TVe));
}
function NVe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function B6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function FVe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? B6(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : B6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function zVe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = FVe({}, this.container ? Sle(this.container, o) : {
        x: 0,
        y: 0
      }), u = Mle(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function R6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function UVe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? R6(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function N6(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function F6(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function HVe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Wt), c = Ft(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Ft(() => zVe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), xi.createPortal(l, c);
}
me(HVe);
class Qd extends pe {
  constructor(t) {
    super(t), je(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), je(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      di(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), je(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), je(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = UVe({
        x: 0,
        y: 0
      }, this.containerRef.current ? Sle(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Mle(r, o, this.props.bounds, this.props.position);
      if (!NVe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), je(this, "draw", () => {
      this.onPositionElement();
    }), je(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Br();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = N6(t.position), r = N6(this.props.position), o = F6(t.bounds), i = F6(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? xi.createPortal(Ai.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
je(Qd, "FLOAT_PANE", "floatPane");
je(Qd, "MAP_PANE", "mapPane");
je(Qd, "MARKER_LAYER", "markerLayer");
je(Qd, "OVERLAY_LAYER", "overlayLayer");
je(Qd, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
je(Qd, "contextType", Wt);
function WVe() {
}
function z6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function U6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? z6(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var H6 = {
  onDblClick: "dblclick",
  onClick: "click"
}, W6 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function VVe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Wt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Ft(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(VVe);
class Dle extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      groundOverlay: null
    }), je(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    di(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, U6(U6({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: W6,
      eventMap: H6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: W6,
      eventMap: H6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
je(Dle, "defaultProps", {
  onLoad: WVe
});
je(Dle, "contextType", Wt);
function V6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? V6(Object(n), !0).forEach(function(r) {
      je(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : V6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $6 = {}, Z6 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function $Ve(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Wt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || di(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    di(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(cC(cC({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me($Ve);
class ZVe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      heatmapLayer: null
    }), je(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    di(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), di(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(cC(cC({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: Z6,
      eventMap: $6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: Z6,
      eventMap: $6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Rn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
je(ZVe, "contextType", Wt);
var q6 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, G6 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class qVe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      streetViewPanorama: null
    }), je(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Ln({
      updaterMap: G6,
      eventMap: q6,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: G6,
      eventMap: q6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Rn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
je(qVe, "contextType", Wt);
class GVe extends pe {
  constructor() {
    super(...arguments), je(this, "state", {
      streetViewService: null
    }), je(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
je(GVe, "contextType", Wt);
var K6 = {
  onDirectionsChanged: "directions_changed"
}, Y6 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class KVe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "state", {
      directionsRenderer: null
    }), je(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Ln({
      updaterMap: Y6,
      eventMap: K6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: Y6,
      eventMap: K6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Rn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
je(KVe, "contextType", Wt);
var X6 = {
  onPlacesChanged: "places_changed"
}, J6 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class YVe extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "containerElement", Br()), je(this, "state", {
      searchBox: null
    }), je(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (di(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Ln({
          updaterMap: J6,
          eventMap: X6,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: J6,
      eventMap: X6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Rn(this.registeredEvents));
  }
  render() {
    return Ai.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
je(YVe, "contextType", Wt);
var Q6 = {
  onPlaceChanged: "place_changed"
}, e8 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Tle extends pe {
  constructor() {
    super(...arguments), je(this, "registeredEvents", []), je(this, "containerElement", Br()), je(this, "state", {
      autocomplete: null
    }), je(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    di(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Ln({
        updaterMap: e8,
        eventMap: Q6,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Rn(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: e8,
      eventMap: Q6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Rn(this.registeredEvents);
  }
  render() {
    return Ai.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
je(Tle, "defaultProps", {
  className: ""
});
je(Tle, "contextType", Wt);
let XVe = { data: "" }, JVe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || XVe, QVe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, e$e = /\/\*[^]*?\*\/|  +/g, t8 = /\n+/g, Zu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Zu(a, i) : i + "{" + Zu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Zu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Zu.p ? Zu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ol = {}, jle = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + jle(e[n]);
    return t;
  }
  return e;
}, t$e = (e, t, n, r, o) => {
  let i = jle(e), a = Ol[i] || (Ol[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ol[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = QVe.exec(u.replace(e$e, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(t8, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(t8, " ").trim();
      return d[0];
    })(e);
    Ol[a] = Zu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ol.g ? Ol.g : null;
  return n && (Ol.g = Ol[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ol[a], t, r, s), a;
}, n$e = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Zu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function WE(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return t$e(n.unshift ? n.raw ? n$e(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, JVe(t.target), t.g, t.o, t.k);
}
let Ale, dD, fD;
WE.bind({ g: 1 });
let Hl = WE.bind({ k: 1 });
function r$e(e, t, n, r) {
  Zu.p = t, Ale = e, dD = n, fD = r;
}
function Oc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: dD && dD() }, s), n.o = / *go\d+/.test(l), s.className = WE.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), fD && u[0] && fD(s), Ale(u, s);
    }
    return o;
  };
}
var o$e = (e) => typeof e == "function", i$e = (e, t) => o$e(e) ? e(t) : e, s$e = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), a$e = Hl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, l$e = Hl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, u$e = Hl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, c$e = Oc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${a$e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${l$e} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${u$e} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, p$e = Hl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, d$e = Oc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${p$e} 1s linear infinite;
`, f$e = Hl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, h$e = Hl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, g$e = Oc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${f$e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${h$e} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, m$e = Oc("div")`
  position: absolute;
`, v$e = Oc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, y$e = Hl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, b$e = Oc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${y$e} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, w$e = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Me.createElement(b$e, null, t) : t : n === "blank" ? null : Me.createElement(v$e, null, Me.createElement(d$e, { ...r }), n !== "loading" && Me.createElement(m$e, null, n === "error" ? Me.createElement(c$e, { ...r }) : Me.createElement(g$e, { ...r })));
}, C$e = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, x$e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, O$e = "0%{opacity:0;} 100%{opacity:1;}", E$e = "0%{opacity:1;} 100%{opacity:0;}", k$e = Oc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, L$e = Oc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, P$e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = s$e() ? [O$e, E$e] : [C$e(n), x$e(n)];
  return { animation: t ? `${Hl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Hl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Me.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? P$e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Me.createElement(w$e, { toast: e }), a = Me.createElement(L$e, { ...e.ariaProps }, i$e(e.message, e));
  return Me.createElement(k$e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Me.createElement(Me.Fragment, null, i, a));
});
r$e(Me.createElement);
WE`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
We({});
function _$e(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const S$e = {
  CNPJ: "99.999.999/9999-99"
};
_$e(S$e.CNPJ).length;
yr((e, t) => /* @__PURE__ */ ji.jsx("input", { ref: t, ...e }));
function Ile(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Ble = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function M$e(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function D$e(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const T$e = Ile(Ble.NINE).length, j$e = yr((e, t) => /* @__PURE__ */ ji.jsx("input", { ref: t, ...e }));
yr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = Ile(g.target.value);
      const y = D$e(f);
      f.length > T$e || (f = M$e(f, Ble[y]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ ji.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ ji.jsx(
      tl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: j$e,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
We({});
var Ql = {};
Object.defineProperty(Ql, "__esModule", {
  value: !0
});
var A$e = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), N1 = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Rle = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: A$e ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, $I = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var ub = 1; ub < 20; ub++)
  $I["f" + ub] = 111 + ub;
function VE(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Nle(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Fle(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function I$e(e, t) {
  return VE(e, t);
}
function B$e(e, t) {
  return VE(e, { byKey: !0 }, t);
}
function Nle(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in N1)
    r[N1[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = ZI(d), y = N1[f];
      if (d.length > 1 && !y && !Rle[d] && !$I[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !y) && (n ? r.key = f : r.which = zle(d)), y && (r[y] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Fle(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function zle(e) {
  e = ZI(e);
  var t = $I[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function ZI(e) {
  return e = e.toLowerCase(), e = Rle[e] || e, e;
}
Ql.default = VE;
var F1 = Ql.isHotkey = VE;
Ql.isCodeHotkey = I$e;
Ql.isKeyHotkey = B$e;
Ql.parseHotkey = Nle;
Ql.compareHotkey = Fle;
Ql.toKeyCode = zle;
Ql.toKeyName = ZI;
var R$e = typeof Tr == "object" && Tr && Tr.Object === Object && Tr, N$e = R$e, F$e = N$e, z$e = typeof self == "object" && self && self.Object === Object && self, U$e = F$e || z$e || Function("return this")(), H$e = U$e, W$e = H$e, V$e = W$e.Symbol, Ule = V$e, n8 = Ule;
n8 && n8.toStringTag;
var r8 = Ule;
r8 && r8.toStringTag;
var o8;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(o8 || (o8 = {}));
var qI = function(e) {
  return Object.freeze(e);
}, $$e = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, qI(this);
  }
  return e;
}(), Z$e = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, qI(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), i8 = typeof window < "u" ? window : {};
/msie|trident/i.test(i8.navigator && i8.navigator.userAgent);
var z1 = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new $$e((n ? t : e) || 0, (n ? e : t) || 0);
};
qI({
  devicePixelContentBoxSize: z1(),
  borderBoxSize: z1(),
  contentBoxSize: z1(),
  contentRect: new Z$e(0, 0, 0, 0)
});
function am(e) {
  "@babel/helpers - typeof";
  return am = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, am(e);
}
function q$e(e, t) {
  if (am(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (am(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function G$e(e) {
  var t = q$e(e, "string");
  return am(t) === "symbol" ? t : String(t);
}
function Kh(e, t, n) {
  return t = G$e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var K$e = /* @__PURE__ */ We(null), U1, H1;
parseInt(we.version.split(".")[0], 10);
var s8 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), W1 = typeof navigator < "u" && /Android/.test(navigator.userAgent), cb = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Y$e = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (U1 = navigator.userAgent.match(/Version\/(\d+)/)) !== null && U1 !== void 0 && U1[1] && parseInt((H1 = navigator.userAgent.match(/Version\/(\d+)/)) === null || H1 === void 0 ? void 0 : H1[1], 10) < 17;
var X$e = /* @__PURE__ */ new WeakMap(), J$e = /* @__PURE__ */ new WeakMap(), Q$e = /* @__PURE__ */ new WeakMap(), e3e = /* @__PURE__ */ new WeakMap(), t3e = /* @__PURE__ */ new WeakMap(), a8 = /* @__PURE__ */ new WeakMap(), n3e = /* @__PURE__ */ new WeakMap(), l8 = /* @__PURE__ */ new WeakMap(), pb = /* @__PURE__ */ new WeakMap(), r3e = /* @__PURE__ */ new WeakMap(), o3e = /* @__PURE__ */ new WeakMap(), i3e = /* @__PURE__ */ new WeakMap(), Hle = globalThis.Node, s3e = globalThis.Text, Wle = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, a3e = (e) => pC(e) && e.nodeType === 8, Ka = (e) => pC(e) && e.nodeType === 1, pC = (e) => {
  var t = Wle(e);
  return !!t && e instanceof t.Node;
}, u8 = (e) => {
  var t = e && e.anchorNode && Wle(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, l3e = (e) => {
  var [t, n] = e;
  if (Ka(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Vle(t, o, r ? "backward" : "forward"), r = o < n; Ka(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = c3e(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, u3e = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Vle = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (a3e(o) || Ka(o) && o.childNodes.length === 0 || Ka(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, c3e = (e, t, n) => {
  var [r] = Vle(e, t, n);
  return r;
}, c8 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), $le = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ka(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = bn.getWindow(e);
  if (o.contains(r))
    return bn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : $le(e, i, n);
}, p8 = (e, t) => !!(e.compareDocumentPosition(t) & Hle.DOCUMENT_POSITION_PRECEDING), p3e = (e, t) => !!(e.compareDocumentPosition(t) & Hle.DOCUMENT_POSITION_FOLLOWING), d3e = 0;
class f3e {
  constructor() {
    Kh(this, "id", void 0), this.id = "".concat(d3e++);
  }
}
var bn = {
  androidPendingDiffs: (e) => i3e.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = o3e.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = bn.toDOMNode(e, e), n = bn.findDocumentOrShadowRoot(e);
    pb.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = bn.findDocumentOrShadowRoot(e), r = c8(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && g0.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = bn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = bn.toSlateNode(e, t.target), a = bn.findPath(e, i);
    if (Al.isElement(i) && Or.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Or.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Or.before(e, u) : Or.after(e, u);
      if (c) {
        var p = Or.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = bn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var y = bn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return y;
  },
  findKey: (e, t) => {
    var n = a8.get(t);
    return n || (n = new f3e(), a8.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = J$e.get(r);
      if (o == null) {
        if (Or.isEditor(r))
          return n;
        break;
      }
      var i = X$e.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Rs.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!pb.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          bn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = bn.toDOMNode(e, e), r = bn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = c8(r), i = bn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || g0.select(e, Or.start(e, [])), pb.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Q$e.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = bn.toDOMNode(e, e), i;
    try {
      i = Ka(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => pC(t) && bn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Or.hasPath(e, n.path) && Or.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => bn.hasEditableTarget(e, t) || bn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => pC(t) && bn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!r3e.get(e),
  isFocused: (e) => !!pb.get(e),
  isReadOnly: (e) => !!l8.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (l8.get(e)) return !1;
    var n = bn.hasTarget(e, t) && bn.toSlateNode(e, t);
    return Al.isElement(n) && Or.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = n3e.get(e), r = Or.isEditor(t) ? e3e.get(e) : n == null ? void 0 : n.get(bn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Rs.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Or.node(e, t.path), r = bn.toDOMNode(e, n), o;
    Or.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, y = a[l + 1];
        if (t.offset === f && y !== null && y !== void 0 && y.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = y.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof s3e ? E : y,
            (b = y.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Rs.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = en.isBackward(t), i = bn.toDOMPoint(e, n), a = en.isCollapsed(t) ? i : bn.toDOMPoint(e, r), s = bn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Ka(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), y = Ka(p) ? p : p.parentElement, b = !!y.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ka(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? t3e.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : l3e(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = bn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), y = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = bn.getWindow(e), v = O.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var x = v.cloneContents(), _ = [...Array.prototype.slice.call(x.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(x.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (W1 && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = x.textContent.length, M = u;
        }
      } else if (y) {
        for (var z = y.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var N = z[L];
          if (bn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var Z, H = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = (Z = H.find((S) => p3e(E, S))) !== null && Z !== void 0 ? Z : null;
        } else {
          var $, K = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = ($ = K.findLast((S) => p8(E, S))) !== null && $ !== void 0 ? $ : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      W1 && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      cb && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (W1 && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && bn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var Q = bn.toSlateNode(e, X), {
          path: J,
          offset: P
        } = Or.start(e, bn.findPath(e, Q));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = bn.toSlateNode(e, u), F = bn.findPath(e, D);
    return {
      path: F,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = u8(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (u8(t)) {
        if (cb && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let x = function(_) {
              return _.childElementCount > 0 ? x(_.children[0]) : _;
            };
            var f = d.startContainer, y = g.startContainer, b = x(f.children[d.startOffset]), E = x(y.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Y$e && u3e(s) || cb ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    cb && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = bn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = p8(s, u) || s === u && c < l, O = p ? w : bn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var v = {
      anchor: w,
      focus: O
    };
    return en.isExpanded(v) && en.isForward(v) && Ka(u) && Or.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = Or.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, h3e = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, g3e = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, m3e = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, mo = (e) => {
  var t = h3e[e], n = g3e[e], r = m3e[e], o = t && F1(t), i = n && F1(n), a = r && F1(r);
  return (s) => !!(o && o(s) || s8 && i && i(s) || !s8 && a && a(s));
};
mo("bold"), mo("compose"), mo("moveBackward"), mo("moveForward"), mo("deleteBackward"), mo("deleteForward"), mo("deleteLineBackward"), mo("deleteLineForward"), mo("deleteWordBackward"), mo("deleteWordForward"), mo("extendBackward"), mo("extendForward"), mo("extendLineBackward"), mo("extendLineForward"), mo("italic"), mo("moveLineBackward"), mo("moveLineForward"), mo("moveWordBackward"), mo("moveWordForward"), mo("redo"), mo("insertSoftBreak"), mo("splitBlock"), mo("transposeCharacter"), mo("undo");
var v3e = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => $le(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, y3e = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class b3e extends Kl {
  constructor() {
    super(...arguments), Kh(this, "context", null), Kh(this, "manager", null), Kh(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, y3e);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = v3e(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Kh(b3e, "contextType", K$e);
We({});
We({});
We({});
var oi = {}, GI = {}, Vm = {}, $m = {}, Zle = "Expected a function", d8 = NaN, w3e = "[object Symbol]", C3e = /^\s+|\s+$/g, x3e = /^[-+]0x[0-9a-f]+$/i, O3e = /^0b[01]+$/i, E3e = /^0o[0-7]+$/i, k3e = parseInt, L3e = typeof Tr == "object" && Tr && Tr.Object === Object && Tr, P3e = typeof self == "object" && self && self.Object === Object && self, _3e = L3e || P3e || Function("return this")(), S3e = Object.prototype, M3e = S3e.toString, D3e = Math.max, T3e = Math.min, V1 = function() {
  return _3e.Date.now();
};
function j3e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Zle);
  t = f8(t) || 0, dC(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? D3e(f8(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(x) {
    var _ = r, z = o;
    return r = o = void 0, u = x, a = e.apply(z, _), a;
  }
  function f(x) {
    return u = x, s = setTimeout(E, t), c ? g(x) : a;
  }
  function y(x) {
    var _ = x - l, z = x - u, L = t - _;
    return p ? T3e(L, i - z) : L;
  }
  function b(x) {
    var _ = x - l, z = x - u;
    return l === void 0 || _ >= t || _ < 0 || p && z >= i;
  }
  function E() {
    var x = V1();
    if (b(x))
      return w(x);
    s = setTimeout(E, y(x));
  }
  function w(x) {
    return s = void 0, d && r ? g(x) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(V1());
  }
  function v() {
    var x = V1(), _ = b(x);
    if (r = arguments, o = this, l = x, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = O, v;
}
function A3e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Zle);
  return dC(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), j3e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function dC(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function I3e(e) {
  return !!e && typeof e == "object";
}
function B3e(e) {
  return typeof e == "symbol" || I3e(e) && M3e.call(e) == w3e;
}
function f8(e) {
  if (typeof e == "number")
    return e;
  if (B3e(e))
    return d8;
  if (dC(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = dC(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(C3e, "");
  var n = O3e.test(e);
  return n || E3e.test(e) ? k3e(e.slice(2), n ? 2 : 8) : x3e.test(e) ? d8 : +e;
}
var R3e = A3e, Zm = {};
Object.defineProperty(Zm, "__esModule", {
  value: !0
});
Zm.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), _w.has(t) || _w.set(t, /* @__PURE__ */ new Set());
  var o = _w.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Zm.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), _w.get(t).delete(n.name || t);
};
var _w = /* @__PURE__ */ new Map();
Object.defineProperty($m, "__esModule", {
  value: !0
});
var N3e = R3e, F3e = z3e(N3e), h8 = Zm;
function z3e(e) {
  return e && e.__esModule ? e : { default: e };
}
var U3e = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, F3e.default)(e, t);
}, To = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = U3e(function(r) {
        To.scrollHandler(e);
      }, t);
      return To.scrollSpyContainers.push(e), (0, h8.addPassiveEventListener)(e, "scroll", n), function() {
        (0, h8.removePassiveEventListener)(e, "scroll", n), To.scrollSpyContainers.splice(To.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return To.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = To.scrollSpyContainers[To.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(To.currentPositionX(e), To.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    To.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = To.scrollSpyContainers[To.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    To.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    To.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), To.spySetState && To.spySetState.length && To.spySetState.indexOf(e) > -1 && To.spySetState.splice(To.spySetState.indexOf(e), 1), document.removeEventListener("scroll", To.scrollHandler);
  },
  update: function() {
    return To.scrollSpyContainers.forEach(function(e) {
      return To.scrollHandler(e);
    });
  }
};
$m.default = To;
var ef = {}, qm = {};
Object.defineProperty(qm, "__esModule", {
  value: !0
});
var H3e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, W3e = function() {
  return window.location.hash.replace(/^#/, "");
}, V3e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, $3e = function(e) {
  return getComputedStyle(e).position !== "static";
}, $1 = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, Z3e = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if ($3e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = $1(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return $1(t, s).offsetTop - $1(e, s).offsetTop;
};
qm.default = {
  updateHash: H3e,
  getHash: W3e,
  filterElementInContainer: V3e,
  scrollOffset: Z3e
};
var $E = {}, KI = {};
Object.defineProperty(KI, "__esModule", {
  value: !0
});
KI.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var YI = {};
Object.defineProperty(YI, "__esModule", {
  value: !0
});
var q3e = Zm, G3e = ["mousedown", "wheel", "touchmove", "keydown"];
YI.default = {
  subscribe: function(e) {
    return typeof document < "u" && G3e.forEach(function(t) {
      return (0, q3e.addPassiveEventListener)(document, t, e);
    });
  }
};
var Gm = {};
Object.defineProperty(Gm, "__esModule", {
  value: !0
});
var hD = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      hD.registered[e] = t;
    },
    remove: function(e) {
      hD.registered[e] = null;
    }
  }
};
Gm.default = hD;
Object.defineProperty($E, "__esModule", {
  value: !0
});
var K3e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Y3e = qm;
ZE(Y3e);
var X3e = KI, g8 = ZE(X3e), J3e = YI, Q3e = ZE(J3e), e9e = Gm, za = ZE(e9e);
function ZE(e) {
  return e && e.__esModule ? e : { default: e };
}
var qle = function(e) {
  return g8.default[e.smooth] || g8.default.defaultEasing;
}, t9e = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, n9e = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, gD = function() {
  return n9e() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Gle = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Kle = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Yle = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, r9e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, o9e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, i9e = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    za.default.registered.end && za.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    gD.call(window, i);
    return;
  }
  za.default.registered.end && za.default.registered.end(o.to, o.target, o.currentPosition);
}, XI = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Km = function(e, t, n, r) {
  t.data = t.data || Gle(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (Q3e.default.subscribe(o), XI(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Kle(t) : Yle(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    za.default.registered.end && za.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = t9e(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = qle(t), a = i9e.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      za.default.registered.begin && za.default.registered.begin(t.data.to, t.data.target), gD.call(window, a);
    }, t.delay);
    return;
  }
  za.default.registered.begin && za.default.registered.begin(t.data.to, t.data.target), gD.call(window, a);
}, qE = function(e) {
  return e = K3e({}, e), e.data = e.data || Gle(), e.absolute = !0, e;
}, s9e = function(e) {
  Km(0, qE(e));
}, a9e = function(e, t) {
  Km(e, qE(t));
}, l9e = function(e) {
  e = qE(e), XI(e), Km(e.horizontal ? r9e(e) : o9e(e), e);
}, u9e = function(e, t) {
  t = qE(t), XI(t);
  var n = t.horizontal ? Kle(t) : Yle(t);
  Km(e + n, t);
};
$E.default = {
  animateTopScroll: Km,
  getAnimationType: qle,
  scrollToTop: s9e,
  scrollToBottom: l9e,
  scrollTo: a9e,
  scrollMore: u9e
};
Object.defineProperty(ef, "__esModule", {
  value: !0
});
var c9e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, p9e = qm, d9e = JI(p9e), f9e = $E, h9e = JI(f9e), g9e = Gm, db = JI(g9e);
function JI(e) {
  return e && e.__esModule ? e : { default: e };
}
var fb = {}, m8 = void 0;
ef.default = {
  unmount: function() {
    fb = {};
  },
  register: function(e, t) {
    fb[e] = t;
  },
  unregister: function(e) {
    delete fb[e];
  },
  get: function(e) {
    return fb[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return m8 = e;
  },
  getActiveLink: function() {
    return m8;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = c9e({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = d9e.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      db.default.registered.begin && db.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, db.default.registered.end && db.default.registered.end(e, n);
      return;
    }
    h9e.default.animateTopScroll(s, t, e, n);
  }
};
var mD = { exports: {} }, Z1 = { exports: {} }, nr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var v8;
function m9e() {
  if (v8) return nr;
  v8 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function O(v) {
    return M(v) === u;
  }
  return nr.AsyncMode = l, nr.ConcurrentMode = u, nr.ContextConsumer = s, nr.ContextProvider = a, nr.Element = t, nr.ForwardRef = c, nr.Fragment = r, nr.Lazy = f, nr.Memo = g, nr.Portal = n, nr.Profiler = i, nr.StrictMode = o, nr.Suspense = p, nr.isAsyncMode = function(v) {
    return O(v) || M(v) === l;
  }, nr.isConcurrentMode = O, nr.isContextConsumer = function(v) {
    return M(v) === s;
  }, nr.isContextProvider = function(v) {
    return M(v) === a;
  }, nr.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, nr.isForwardRef = function(v) {
    return M(v) === c;
  }, nr.isFragment = function(v) {
    return M(v) === r;
  }, nr.isLazy = function(v) {
    return M(v) === f;
  }, nr.isMemo = function(v) {
    return M(v) === g;
  }, nr.isPortal = function(v) {
    return M(v) === n;
  }, nr.isProfiler = function(v) {
    return M(v) === i;
  }, nr.isStrictMode = function(v) {
    return M(v) === o;
  }, nr.isSuspense = function(v) {
    return M(v) === p;
  }, nr.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === y);
  }, nr.typeOf = M, nr;
}
var fr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var y8;
function v9e() {
  return y8 || (y8 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === E || B.$$typeof === w || B.$$typeof === y);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, x = u, _ = s, z = a, L = t, N = c, R = r, V = f, Z = g, H = n, $ = i, K = o, X = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function F(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return O(B) === c;
    }
    function C(B) {
      return O(B) === r;
    }
    function I(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function j(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    fr.AsyncMode = v, fr.ConcurrentMode = x, fr.ContextConsumer = _, fr.ContextProvider = z, fr.Element = L, fr.ForwardRef = N, fr.Fragment = R, fr.Lazy = V, fr.Memo = Z, fr.Portal = H, fr.Profiler = $, fr.StrictMode = K, fr.Suspense = X, fr.isAsyncMode = J, fr.isConcurrentMode = P, fr.isContextConsumer = D, fr.isContextProvider = F, fr.isElement = S, fr.isForwardRef = W, fr.isFragment = C, fr.isLazy = I, fr.isMemo = U, fr.isPortal = T, fr.isProfiler = q, fr.isStrictMode = j, fr.isSuspense = Y, fr.isValidElementType = M, fr.typeOf = O;
  }()), fr;
}
var b8;
function Xle() {
  return b8 || (b8 = 1, process.env.NODE_ENV === "production" ? Z1.exports = m9e() : Z1.exports = v9e()), Z1.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var q1, w8;
function y9e() {
  if (w8) return q1;
  w8 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return q1 = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, q1;
}
var G1, C8;
function QI() {
  if (C8) return G1;
  C8 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return G1 = e, G1;
}
var x8, O8;
function Jle() {
  return O8 || (O8 = 1, x8 = Function.call.bind(Object.prototype.hasOwnProperty)), x8;
}
var K1, E8;
function b9e() {
  if (E8) return K1;
  E8 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = QI(), n = {}, r = Jle();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, K1 = o, K1;
}
var Y1, k8;
function w9e() {
  if (k8) return Y1;
  k8 = 1;
  var e = Xle(), t = y9e(), n = QI(), r = Jle(), o = b9e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Y1 = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: v(),
      instanceOf: x,
      node: N(),
      objectOf: z,
      oneOf: _,
      oneOfType: L,
      shape: V,
      exact: Z
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function y(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    y.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, F = 0;
      function S(C, I, U, T, q, j, Y) {
        if (T = T || d, j = j || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            F < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + j + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, F++);
          }
        }
        return I[U] == null ? C ? I[U] === null ? new y("The " + q + " `" + j + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new y("The " + q + " `" + j + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(I, U, T, q, j);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(P) {
      function D(F, S, W, C, I, U) {
        var T = F[S], q = K(T);
        if (q !== P) {
          var j = X(T);
          return new y(
            "Invalid " + C + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = F[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var j = P(U, q, W, C, I + "[" + q + "]", n);
          if (j instanceof Error)
            return j;
        }
        return null;
      }
      return b(D);
    }
    function O() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!s(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function v() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!e.isValidElementType(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function x(P) {
      function D(F, S, W, C, I) {
        if (!(F[S] instanceof P)) {
          var U = P.name || d, T = J(F[S]);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(F, S, W, C, I) {
        for (var U = F[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(j, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new y("Invalid " + C + " `" + I + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function z(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var j = P(U, q, W, C, I + "." + q, n);
            if (j instanceof Error)
              return j;
          }
        return null;
      }
      return b(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var F = P[D];
        if (typeof F != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(F) + " at index " + D + "."
          ), a;
      }
      function S(W, C, I, U, T) {
        for (var q = [], j = 0; j < P.length; j++) {
          var Y = P[j], B = Y(W, C, I, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new y("Invalid " + U + " `" + T + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(S);
    }
    function N() {
      function P(D, F, S, W, C) {
        return H(D[F]) ? null : new y("Invalid " + W + " `" + C + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, D, F, S, W) {
      return new y(
        (P || "React class") + ": " + D + " type `" + F + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var j = P[q];
          if (typeof j != "function")
            return R(W, C, I, q, X(j));
          var Y = j(U, q, W, C, I + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(D);
    }
    function Z(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, F[S], P);
        for (var j in q) {
          var Y = P[j];
          if (r(P, j) && typeof Y != "function")
            return R(W, C, I, j, X(Y));
          if (!Y)
            return new y(
              "Invalid " + C + " `" + I + "` key `" + j + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(F[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, j, W, C, I + "." + j, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(D);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var F = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = F.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = F.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function $(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : $(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, Y1;
}
var X1, L8;
function C9e() {
  if (L8) return X1;
  L8 = 1;
  var e = QI();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, X1 = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, X1;
}
if (process.env.NODE_ENV !== "production") {
  var x9e = Xle(), O9e = !0;
  mD.exports = w9e()(x9e.isElement, O9e);
} else
  mD.exports = C9e()();
var GE = mD.exports, KE = {};
Object.defineProperty(KE, "__esModule", {
  value: !0
});
var E9e = qm, J1 = k9e(E9e);
function k9e(e) {
  return e && e.__esModule ? e : { default: e };
}
var L9e = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return J1.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && J1.default.getHash() !== e && J1.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
KE.default = L9e;
Object.defineProperty(Vm, "__esModule", {
  value: !0
});
var hb = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, P9e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), _9e = we, P8 = Ym(_9e), S9e = $m, gb = Ym(S9e), M9e = ef, D9e = Ym(M9e), T9e = GE, vo = Ym(T9e), j9e = KE, pu = Ym(j9e);
function Ym(e) {
  return e && e.__esModule ? e : { default: e };
}
function A9e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function I9e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function B9e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var _8 = {
  to: vo.default.string.isRequired,
  containerId: vo.default.string,
  container: vo.default.object,
  activeClass: vo.default.string,
  activeStyle: vo.default.object,
  spy: vo.default.bool,
  horizontal: vo.default.bool,
  smooth: vo.default.oneOfType([vo.default.bool, vo.default.string]),
  offset: vo.default.number,
  delay: vo.default.number,
  isDynamic: vo.default.bool,
  onClick: vo.default.func,
  duration: vo.default.oneOfType([vo.default.number, vo.default.func]),
  absolute: vo.default.bool,
  onSetActive: vo.default.func,
  onSetInactive: vo.default.func,
  ignoreCancelEvents: vo.default.bool,
  hashSpy: vo.default.bool,
  saveHashHistory: vo.default.bool,
  spyThrottle: vo.default.number
};
Vm.default = function(e, t) {
  var n = t || D9e.default, r = function(i) {
    B9e(a, i);
    function a(s) {
      A9e(this, a);
      var l = I9e(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return P9e(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!gb.default.isMounted(s)) {
            var l = gb.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (pu.default.isMounted() || pu.default.mount(n), pu.default.mapContainer(this.props.to, s)), gb.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        gb.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = hb({}, this.props.style, this.props.activeStyle) : l = hb({}, this.props.style);
        var u = hb({}, this.props);
        for (var c in _8)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, P8.default.createElement(e, u);
      }
    }]), a;
  }(P8.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, hb({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(pu.default.isMounted() && !pu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, y = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, y = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(y), g = M < Math.floor(f) || M >= Math.floor(y);
        } else {
          var O = 0, v = 0, x = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            x = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            O = z.top - x + s, v = O + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(v), g = L < Math.floor(O) || L >= Math.floor(v);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && pu.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            pu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var Z = i.props.saveHashHistory, H = Z === void 0 ? !1 : Z;
          i.props.hashSpy && pu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = _8, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(GI, "__esModule", {
  value: !0
});
var R9e = we, S8 = Qle(R9e), N9e = Vm, F9e = Qle(N9e);
function Qle(e) {
  return e && e.__esModule ? e : { default: e };
}
function z9e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function M8(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function U9e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var H9e = function(e) {
  U9e(t, e);
  function t() {
    var n, r, o, i;
    z9e(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = M8(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return S8.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), M8(o, i);
  }
  return t;
}(S8.default.Component);
GI.default = (0, F9e.default)(H9e);
var eB = {};
Object.defineProperty(eB, "__esModule", {
  value: !0
});
var W9e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), V9e = we, D8 = eue(V9e), $9e = Vm, Z9e = eue($9e);
function eue(e) {
  return e && e.__esModule ? e : { default: e };
}
function q9e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function G9e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function K9e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Y9e = function(e) {
  K9e(t, e);
  function t() {
    return q9e(this, t), G9e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return W9e(t, [{
    key: "render",
    value: function() {
      return D8.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(D8.default.Component);
eB.default = (0, Z9e.default)(Y9e);
var tB = {}, YE = {};
Object.defineProperty(YE, "__esModule", {
  value: !0
});
var X9e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, J9e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Q9e = we, T8 = XE(Q9e), e6e = nl;
XE(e6e);
var t6e = ef, j8 = XE(t6e), n6e = GE, A8 = XE(n6e);
function XE(e) {
  return e && e.__esModule ? e : { default: e };
}
function r6e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function o6e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function i6e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
YE.default = function(e) {
  var t = function(n) {
    i6e(r, n);
    function r(o) {
      r6e(this, r);
      var i = o6e(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return J9e(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        j8.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        j8.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return T8.default.createElement(e, X9e({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(T8.default.Component);
  return t.propTypes = {
    name: A8.default.string,
    id: A8.default.string
  }, t;
};
Object.defineProperty(tB, "__esModule", {
  value: !0
});
var I8 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, s6e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), a6e = we, B8 = nB(a6e), l6e = YE, u6e = nB(l6e), c6e = GE, R8 = nB(c6e);
function nB(e) {
  return e && e.__esModule ? e : { default: e };
}
function p6e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function d6e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function f6e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var tue = function(e) {
  f6e(t, e);
  function t() {
    return p6e(this, t), d6e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return s6e(t, [{
    key: "render",
    value: function() {
      var n = this, r = I8({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, B8.default.createElement(
        "div",
        I8({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(B8.default.Component);
tue.propTypes = {
  name: R8.default.string,
  id: R8.default.string
};
tB.default = (0, u6e.default)(tue);
var Q1 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, N8 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function F8(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function z8(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function U8(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var mb = we, Rc = $m, eP = ef, Uo = GE, du = KE, H8 = {
  to: Uo.string.isRequired,
  containerId: Uo.string,
  container: Uo.object,
  activeClass: Uo.string,
  spy: Uo.bool,
  smooth: Uo.oneOfType([Uo.bool, Uo.string]),
  offset: Uo.number,
  delay: Uo.number,
  isDynamic: Uo.bool,
  onClick: Uo.func,
  duration: Uo.oneOfType([Uo.number, Uo.func]),
  absolute: Uo.bool,
  onSetActive: Uo.func,
  onSetInactive: Uo.func,
  ignoreCancelEvents: Uo.bool,
  hashSpy: Uo.bool,
  spyThrottle: Uo.number
}, h6e = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || eP, r = function(i) {
      U8(a, i);
      function a(s) {
        F8(this, a);
        var l = z8(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return N8(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Rc.isMounted(s) || Rc.mount(s, this.props.spyThrottle), this.props.hashSpy && (du.isMounted() || du.mount(n), du.mapContainer(this.props.to, s)), this.props.spy && Rc.addStateHandler(this.stateHandler), Rc.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Rc.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = Q1({}, this.props);
          for (var u in H8)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, mb.createElement(e, l);
        }
      }]), a;
    }(mb.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, Q1({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(du.isMounted() && !du.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var y = a - i.props.offset, b = y >= Math.floor(c) && y < Math.floor(p), E = y < Math.floor(c) || y >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && du.getHash() === l && du.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Rc.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && du.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Rc.updateStates();
        }
      };
    };
    return r.propTypes = H8, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      U8(r, n);
      function r(o) {
        F8(this, r);
        var i = z8(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return N8(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          eP.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          eP.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return mb.createElement(e, Q1({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(mb.Component);
    return t.propTypes = {
      name: Uo.string,
      id: Uo.string
    }, t;
  }
}, g6e = h6e;
Object.defineProperty(oi, "__esModule", {
  value: !0
});
oi.Helpers = oi.ScrollElement = oi.ScrollLink = oi.animateScroll = oi.scrollSpy = oi.Events = oi.scroller = oi.Element = oi.Button = oi.Link = void 0;
var m6e = GI, nue = sl(m6e), v6e = eB, rue = sl(v6e), y6e = tB, oue = sl(y6e), b6e = ef, iue = sl(b6e), w6e = Gm, sue = sl(w6e), C6e = $m, aue = sl(C6e), x6e = $E, lue = sl(x6e), O6e = Vm, uue = sl(O6e), E6e = YE, cue = sl(E6e), k6e = g6e, pue = sl(k6e);
function sl(e) {
  return e && e.__esModule ? e : { default: e };
}
oi.Link = nue.default;
oi.Button = rue.default;
oi.Element = oue.default;
oi.scroller = iue.default;
oi.Events = sue.default;
oi.scrollSpy = aue.default;
oi.animateScroll = lue.default;
oi.ScrollLink = uue.default;
oi.ScrollElement = cue.default;
oi.Helpers = pue.default;
oi.default = { Link: nue.default, Button: rue.default, Element: oue.default, scroller: iue.default, Events: sue.default, scrollSpy: aue.default, animateScroll: lue.default, ScrollLink: uue.default, ScrollElement: cue.default, Helpers: pue.default };
We({});
We({});
We({});
function lm(e) {
  "@babel/helpers - typeof";
  return lm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, lm(e);
}
function L6e(e, t) {
  if (lm(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (lm(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function P6e(e) {
  var t = L6e(e, "string");
  return lm(t) == "symbol" ? t : t + "";
}
function Ae(e, t, n) {
  return (t = P6e(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function due(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var tP, W8;
function _6e() {
  if (W8) return tP;
  W8 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return tP = t, tP;
}
var S6e = _6e(), fi = /* @__PURE__ */ due(S6e), Vt = We(null);
function M6e() {
  fi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Vt);
  return fi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function D6e(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function T6e(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function j6e(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return T6e(e, i), o;
}
function A6e(e, t, n) {
  var r = D6e(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function I6e(e) {
  google.maps.event.removeListener(e);
}
function Nn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(I6e);
}
function Pn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = A6e(o, i, n);
  return j6e(t, r, o, i), a;
}
function B6e(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: y,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [v, x] = k(null), _ = ht(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null), [j, Y] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && y && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", y)));
  }, [y]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (j !== null && google.maps.event.removeListener(j), Y(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return x(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), ji.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: ji.jsx(Vt.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(B6e);
function V8(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function fue(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        V8(i, r, o, a, s, "next", l);
      }
      function s(l) {
        V8(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function hue(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return fi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var yp = typeof document < "u";
function gue(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return yp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function $8(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function mue() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return $8(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return $8(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Uf = !1;
function vue() {
  return ji.jsx("div", {
    children: "Loading..."
  });
}
var vD = {
  id: "script-loader",
  version: "weekly"
};
class R6e extends pe {
  constructor() {
    super(...arguments), Ae(this, "check", null), Ae(this, "state", {
      loaded: !1
    }), Ae(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Ae(this, "isCleaningUp", /* @__PURE__ */ fue(function* () {
      function t(n) {
        if (!Uf)
          n();
        else if (yp)
          var r = window.setInterval(function() {
            Uf || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Ae(this, "cleanup", () => {
      Uf = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Ae(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && mue(), fi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: hue(this.props)
      };
      gue(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Ae(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (yp) {
      if (window.google && window.google.maps && !Uf) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), yp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (yp) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Uf = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ji.jsxs(ji.Fragment, {
      children: [ji.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ji.jsx(vue, {})]
    });
  }
}
Ae(R6e, "defaultProps", vD);
function N6e(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function rB(e, t) {
  if (e == null) return {};
  var n, r, o = N6e(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var Z8;
function F6e(e) {
  var {
    id: t = vD.id,
    version: n = vD.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ht(!1), [f, y] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    yp && u && mue();
  }, [u]), h(function() {
    f && fi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = hue({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!yp)
      return;
    function O() {
      g.current && (y(!0), Z8 = w);
    }
    if (window.google && window.google.maps && Z8 === w) {
      O();
      return;
    }
    gue({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = ht(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var z6e = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], U6e = ji.jsx(vue, {});
function H6e(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = rB(e, z6e), {
    isLoaded: s,
    loadError: l
  } = F6e(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || U6e;
}
me(H6e);
var q8;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(q8 || (q8 = {}));
function G8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G8(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var K8 = {}, Y8 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function W6e(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Vt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(fC(fC({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(W6e);
class V6e extends pe {
  constructor() {
    super(...arguments), Ae(this, "state", {
      trafficLayer: null
    }), Ae(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Ae(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(fC(fC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: Y8,
      eventMap: K8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: Y8,
      eventMap: K8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Nn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(V6e, "contextType", Vt);
function $6e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Vt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me($6e);
class Z6e extends pe {
  constructor() {
    super(...arguments), Ae(this, "state", {
      bicyclingLayer: null
    }), Ae(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(Z6e, "contextType", Vt);
function q6e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Vt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(q6e);
class G6e extends pe {
  constructor() {
    super(...arguments), Ae(this, "state", {
      transitLayer: null
    }), Ae(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(G6e, "contextType", Vt);
function X8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X8(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var J8 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, Q8 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function K6e(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Vt), [d, g] = k(null), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), y(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    fi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(hC(hC({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && y(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && v(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(K6e);
class Y6e extends pe {
  constructor(t) {
    super(t), Ae(this, "registeredEvents", []), Ae(this, "state", {
      drawingManager: null
    }), Ae(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), fi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(hC(hC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: Q8,
      eventMap: J8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: Q8,
      eventMap: J8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Nn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(Y6e, "contextType", Vt);
function e5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? e5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : e5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var t5 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, n5 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, gC = {};
function X6e(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: y,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: v,
    onMouseOut: x,
    onMouseOver: _,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: Z,
    onDraggableChanged: H,
    onFlatChanged: $,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: F,
    onUnmount: S
  } = e, W = ge(Vt), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null), [oe, Pe] = k(null), [Ue, Ze] = k(null), [_e, rt] = k(null), [Ve, ye] = k(null), [Ge, ct] = k(null), [ve, Oe] = k(null), [qe, ze] = k(null), [Se, st] = k(null), [xe, xt] = k(null), [at, lt] = k(null), [pt, Ot] = k(null), [dt, ft] = k(null), [ot, He] = k(null), [Et, kt] = k(null), [gt, St] = k(null), [mt, Mt] = k(null), [vt, Pt] = k(null);
  h(() => {
    C !== null && C.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && C !== null && C.setOptions(n);
  }, [C, n]), h(() => {
    typeof a < "u" && C !== null && C.setDraggable(a);
  }, [C, a]), h(() => {
    t && C !== null && C.setPosition(t);
  }, [C, t]), h(() => {
    typeof s < "u" && C !== null && C.setVisible(s);
  }, [C, s]), h(() => {
    C == null || C.setAnimation(l);
  }, [C, l]), h(() => {
    C && u !== void 0 && C.setClickable(u);
  }, [C, u]), h(() => {
    C && c !== void 0 && C.setCursor(c);
  }, [C, c]), h(() => {
    C && p !== void 0 && C.setIcon(p);
  }, [C, p]), h(() => {
    C && d !== void 0 && C.setLabel(d);
  }, [C, d]), h(() => {
    C && g !== void 0 && C.setOpacity(g);
  }, [C, g]), h(() => {
    C && f !== void 0 && C.setShape(f);
  }, [C, f]), h(() => {
    C && y !== void 0 && C.setTitle(y);
  }, [C, y]), h(() => {
    C && b !== void 0 && C.setZIndex(b);
  }, [C, b]), h(() => {
    C && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(C, "dblclick", w)));
  }, [w]), h(() => {
    C && O && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(C, "dragend", O)));
  }, [O]), h(() => {
    C && v && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(C, "dragstart", v)));
  }, [v]), h(() => {
    C && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(C, "mousedown", L)));
  }, [L]), h(() => {
    C && x && (oe !== null && google.maps.event.removeListener(oe), Pe(google.maps.event.addListener(C, "mouseout", x)));
  }, [x]), h(() => {
    C && _ && (Ue !== null && google.maps.event.removeListener(Ue), Ze(google.maps.event.addListener(C, "mouseover", _)));
  }, [_]), h(() => {
    C && z && (_e !== null && google.maps.event.removeListener(_e), rt(google.maps.event.addListener(C, "mouseup", z)));
  }, [z]), h(() => {
    C && N && (Ve !== null && google.maps.event.removeListener(Ve), ye(google.maps.event.addListener(C, "rightclick", N)));
  }, [N]), h(() => {
    C && E && (Ge !== null && google.maps.event.removeListener(Ge), ct(google.maps.event.addListener(C, "click", E)));
  }, [E]), h(() => {
    C && M && (ve !== null && google.maps.event.removeListener(ve), Oe(google.maps.event.addListener(C, "drag", M)));
  }, [M]), h(() => {
    C && R && (qe !== null && google.maps.event.removeListener(qe), ze(google.maps.event.addListener(C, "clickable_changed", R)));
  }, [R]), h(() => {
    C && V && (Se !== null && google.maps.event.removeListener(Se), st(google.maps.event.addListener(C, "cursor_changed", V)));
  }, [V]), h(() => {
    C && Z && (xe !== null && google.maps.event.removeListener(xe), xt(google.maps.event.addListener(C, "animation_changed", Z)));
  }, [Z]), h(() => {
    C && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(C, "draggable_changed", H)));
  }, [H]), h(() => {
    C && $ && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(C, "flat_changed", $)));
  }, [$]), h(() => {
    C && K && (dt !== null && google.maps.event.removeListener(dt), ft(google.maps.event.addListener(C, "icon_changed", K)));
  }, [K]), h(() => {
    C && X && (ot !== null && google.maps.event.removeListener(ot), He(google.maps.event.addListener(C, "position_changed", X)));
  }, [X]), h(() => {
    C && Q && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(C, "shape_changed", Q)));
  }, [Q]), h(() => {
    C && J && (gt !== null && google.maps.event.removeListener(gt), St(google.maps.event.addListener(C, "title_changed", J)));
  }, [J]), h(() => {
    C && P && (mt !== null && google.maps.event.removeListener(mt), Mt(google.maps.event.addListener(C, "visible_changed", P)));
  }, [P]), h(() => {
    C && D && (vt !== null && google.maps.event.removeListener(vt), Pt(google.maps.event.addListener(C, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = wd(wd(wd({}, n || gC), r ? gC : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(yt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof g < "u" && te.setOpacity(g), f && te.setShape(f), typeof y == "string" && te.setTitle(y), typeof b == "number" && te.setZIndex(b), w && T(google.maps.event.addListener(te, "dblclick", w)), O && j(google.maps.event.addListener(te, "dragend", O)), v && B(google.maps.event.addListener(te, "dragstart", v)), L && he(google.maps.event.addListener(te, "mousedown", L)), x && Pe(google.maps.event.addListener(te, "mouseout", x)), _ && Ze(google.maps.event.addListener(te, "mouseover", _)), z && rt(google.maps.event.addListener(te, "mouseup", z)), N && ye(google.maps.event.addListener(te, "rightclick", N)), E && ct(google.maps.event.addListener(te, "click", E)), M && Oe(google.maps.event.addListener(te, "drag", M)), R && ze(google.maps.event.addListener(te, "clickable_changed", R)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), Z && xt(google.maps.event.addListener(te, "animation_changed", Z)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), $ && Ot(google.maps.event.addListener(te, "flat_changed", $)), K && ft(google.maps.event.addListener(te, "icon_changed", K)), X && He(google.maps.event.addListener(te, "position_changed", X)), Q && kt(google.maps.event.addListener(te, "shape_changed", Q)), J && St(google.maps.event.addListener(te, "title_changed", J)), P && Mt(google.maps.event.addListener(te, "visible_changed", P)), D && Pt(google.maps.event.addListener(te, "zindex_changed", D)), I(te), F && F(te), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), _e !== null && google.maps.event.removeListener(_e), Ve !== null && google.maps.event.removeListener(Ve), Ge !== null && google.maps.event.removeListener(Ge), qe !== null && google.maps.event.removeListener(qe), Se !== null && google.maps.event.removeListener(Se), xe !== null && google.maps.event.removeListener(xe), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ot !== null && google.maps.event.removeListener(ot), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var jn = Ft(() => i ? ut.map(i, (yt) => {
    if (!wi(yt))
      return yt;
    var te = yt;
    return Ci(te, {
      anchor: C
    });
  }) : null, [i, C]);
  return ji.jsx(ji.Fragment, {
    children: jn
  }) || null;
}
me(X6e);
class J6e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return fue(function* () {
      var n = wd(wd(wd({}, t.props.options || gC), t.props.clusterer ? gC : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Pn({
        updaterMap: n5,
        eventMap: t5,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: n5,
      eventMap: t5,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Nn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Ci(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Ae(J6e, "contextType", Vt);
var Q6e = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), e8e = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Q6e(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function t8e(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var n8e = 2e3, r8e = 500, o8e = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", i8e = "png", s8e = [53, 56, 66, 78, 90], a8e = "cluster", yue = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || o8e, this.imageExtension = r.imageExtension || i8e, this.imageSizes = r.imageSizes || s8e, this.calculator = r.calculator || t8e, this.batchSize = r.batchSize || n8e, this.batchSizeIE = r.batchSizeIE || r8e, this.clusterClass = r.clusterClass || a8e, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new e8e(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function r5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function l8e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var va = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Zn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, u8e = {};
function c8e(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: y,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: v,
    onMouseOut: x,
    onLoad: _,
    onUnmount: z
  } = e, [L, N] = k(null), R = ge(Vt), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && x && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, va.onMouseOut, x)));
  }, [x]), h(() => {
    L && v && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, va.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(L, va.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(L, va.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), $(google.maps.event.addListener(L, va.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && Zn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Zn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Zn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Zn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Zn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Zn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Zn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Zn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Zn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Zn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Zn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Zn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof y < "u" && L !== null && Zn.styles(L, y);
  }, [L, y]), h(() => {
    typeof b < "u" && L !== null && Zn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && Zn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var F = l8e({}, n || u8e), S = new yue(R, [], F);
      return r && Zn.averageCenter(S, r), o && Zn.batchSizeIE(S, o), i && Zn.calculator(S, i), a && Zn.clusterClass(S, a), s && Zn.enableRetinaIcons(S, s), l && Zn.gridSize(S, l), u && Zn.ignoreHidden(S, u), c && Zn.imageExtension(S, c), p && Zn.imagePath(S, p), d && Zn.imageSizes(S, d), g && Zn.maxZoom(S, g), f && Zn.minimumClusterSize(S, f), y && Zn.styles(S, y), b && Zn.title(S, b), E && Zn.zoomOnClick(S, E), x && J(google.maps.event.addListener(S, va.onMouseOut, x)), v && D(google.maps.event.addListener(S, va.onMouseOver, v)), w && Z(google.maps.event.addListener(S, va.onClick, w)), M && $(google.maps.event.addListener(S, va.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, va.onClusteringEnd, O)), N(S), _ && _(S), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), z && z(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(c8e);
class p8e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      markerClusterer: null
    }), Ae(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new yue(this.context, [], this.props.options);
      this.registeredEvents = Pn({
        updaterMap: Zn,
        eventMap: va,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: Zn,
      eventMap: va,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Nn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Ae(p8e, "contextType", Vt);
function o5(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var bue = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || o5(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, o5));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, y = this.getProjection(), b = y.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), d8e = ["position"], f8e = ["position"];
function i5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? i5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var s5 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, a5 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, h8e = {};
function g8e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Vt), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || h8e, {
        position: V
      } = R, Z = rB(R, d8e), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var $ = new bue(mC(mC({}, Z), H ? {
        position: H
      } : {}));
      N.current = document.createElement("div"), y($), a && E(google.maps.event.addListener($, "closeclick", a)), s && M(google.maps.event.addListener($, "domready", s)), l && v(google.maps.event.addListener($, "content_changed", l)), u && _(google.maps.event.addListener($, "position_changed", u)), c && L(google.maps.event.addListener($, "zindex_changed", c)), $.setContent(N.current), n ? $.open(g, n) : $.getPosition() ? $.open(g) : fi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p($);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(g8e);
class m8e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "containerElement", null), Ae(this, "state", {
      infoBox: null
    }), Ae(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : fi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Ae(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = rB(t, f8e), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new bue(mC(mC({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Pn({
      updaterMap: a5,
      eventMap: s5,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: a5,
      eventMap: s5,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Nn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
Ae(m8e, "contextType", Vt);
var l5, u5;
function v8e() {
  return u5 || (u5 = 1, l5 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), l5;
}
var y8e = v8e(), c5 = /* @__PURE__ */ due(y8e), p5 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], nP = 1, Hf = 8;
class oB {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== nP)
      throw new Error("Got v".concat(o, " data when expected v").concat(nP, "."));
    var i = p5[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new oB(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = p5.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Hf, t), this.coords = new this.ArrayType(this.data, Hf + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Hf + a + s + l), this.ids = new this.IndexArrayType(this.data, Hf, t), this.coords = new this.ArrayType(this.data, Hf + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (nP << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return yD(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], y = a[2 * g + 1];
          f >= t && f <= r && y >= n && y <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          d5(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, y = i[2 * f], b = i[2 * f + 1];
      d5(y, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= y : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= y : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function yD(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    wue(e, t, a, r, o, i), yD(e, t, n, r, a - 1, 1 - i), yD(e, t, n, a + 1, o, 1 - i);
  }
}
function wue(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      wue(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, y = o;
    for (Wf(e, t, r, n), t[2 * o + i] > g && Wf(e, t, r, o); f < y; ) {
      for (Wf(e, t, f, y), f++, y--; t[2 * f + i] < g; ) f++;
      for (; t[2 * y + i] > g; ) y--;
    }
    t[2 * r + i] === g ? Wf(e, t, r, y) : (y++, Wf(e, t, y, o)), y <= n && (r = y + 1), n <= y && (o = y - 1);
  }
}
function Wf(e, t, n, r) {
  rP(e, n, r), rP(t, 2 * n, 2 * r), rP(t, 2 * n + 1, 2 * r + 1);
}
function rP(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function d5(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var b8e = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, f5 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Nc = 2, Bu = 3, oP = 4, Pu = 5, Cue = 6;
class w8e {
  constructor(t) {
    this.options = Object.assign(Object.create(b8e), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = f5(vb(u)), d = f5(yb(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var y = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - y);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(vb(r), yb(a), vb(i), yb(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Pu] > 1 ? h5(p, f, this.clusterProps) : this.points[p[f + Bu]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + oP] === t && p.push(a[g + Pu] > 1 ? h5(a, g, this.clusterProps) : this.points[a[g + Bu]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new oB(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Pu] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = xue(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Bu]];
        c = g.properties;
        var [f, y] = g.geometry.coordinates;
        p = vb(f), d = yb(y);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Bu] : E = this.points[n[l + Bu]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Nc] <= n)) {
        l[p + Nc] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), y = l[p + Pu], b = y;
        for (var E of f) {
          var w = E * c;
          l[w + Nc] > n && (b += l[w + Pu]);
        }
        if (b > y && b >= a) {
          var M = d * y, O = g * y, v = void 0, x = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Nc] <= n)) {
              l[L + Nc] = n;
              var N = l[L + Pu];
              M += l[L] * N, O += l[L + 1] * N, l[L + oP] = _, i && (v || (v = this._map(l, p, !0), x = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + oP] = _, u.push(M / b, O / b, 1 / 0, _, -1, b), i && u.push(x);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var Z = V * c;
              if (!(l[Z + Nc] <= n)) {
                l[Z + Nc] = n;
                for (var H = 0; H < c; H++) u.push(l[Z + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Pu] > 1) {
      var o = this.clusterProps[t[n + Cue]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Bu]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function h5(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Bu],
    properties: xue(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [C8e(e[t]), x8e(e[t + 1])]
    }
  };
}
function xue(e, t, n) {
  var r = e[t + Pu], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Cue], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Bu],
    point_count: r,
    point_count_abbreviated: o
  });
}
function vb(e) {
  return e / 360 + 0.5;
}
function yb(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function C8e(e) {
  return (e - 0.5) * 360;
}
function x8e(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function O8e(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Vs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class bD {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Vs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Vs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Vs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class E8e {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return k8e(n);
  }
}
var k8e = (e) => {
  var t = e.map((n) => new bD({
    position: Vs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class L8e extends E8e {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = O8e(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new w8e(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!c5(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Vs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !c5(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new bD({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new bD({
      markers: [i],
      position: Vs.getPosition(i)
    });
  }
}
class P8e {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class _8e {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Vs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function S8e(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class iB {
  constructor() {
    S8e(iB, google.maps.OverlayView);
  }
}
var Yh;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Yh || (Yh = {}));
var M8e = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class D8e extends iB {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new L8e(o),
      renderer: a = new _8e(),
      onClusterClick: s = M8e
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Vs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Yh.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Vs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Vs.setMap(l, null)));
      }
      google.maps.event.trigger(this, Yh.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Vs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new P8e(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Vs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Yh.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Vs.setMap(r.marker, n);
    });
  }
}
function g5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function m5(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? g5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : g5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function T8e(e) {
  var t = M6e(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new D8e(m5(m5({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function j8e(e) {
  var {
    children: t,
    options: n
  } = e, r = T8e(n);
  return r !== null ? t(r) : null;
}
me(j8e);
var v5 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, y5 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function A8e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Vt), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return y(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && v(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : fi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(R), R.close();
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(A8e);
class I8e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "containerElement", null), Ae(this, "state", {
      infoWindow: null
    }), Ae(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : fi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Ae(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Pn({
      updaterMap: y5,
      eventMap: v5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: y5,
      eventMap: v5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Nn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
Ae(I8e, "contextType", Vt);
function b5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? b5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : b5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var w5 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, C5 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, B8e = {};
function R8e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Vt), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && y && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(O, "click", y)));
  }, [y]), h(() => {
    O && b && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(O, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(vC(vC({}, t || B8e), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && Z(google.maps.event.addListener(T, "mousedown", u)), c && $(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), y && C(google.maps.event.addListener(T, "click", y)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(R8e);
class N8e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      polyline: null
    }), Ae(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(vC(vC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: C5,
      eventMap: w5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: C5,
      eventMap: w5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Nn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(N8e, "contextType", Vt);
function x5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function O5(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? x5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : x5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var E5 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, k5 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function F8e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, v = ge(Vt), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    x !== null && x.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    typeof a < "u" && x !== null && x.setPaths(a);
  }, [x, a]), h(() => {
    x && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dblclick", s)));
  }, [s]), h(() => {
    x && (google.maps.event.addListener(x.getPath(), "insert_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "set_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "remove_at", () => {
      O == null || O(x);
    }));
  }, [x, O]), h(() => {
    x && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragend", l)));
  }, [l]), h(() => {
    x && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(x, "dragstart", u)));
  }, [u]), h(() => {
    x && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(x, "mousedown", c)));
  }, [c]), h(() => {
    x && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(x, "mousemove", p)));
  }, [p]), h(() => {
    x && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseout", d)));
  }, [d]), h(() => {
    x && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(x, "mouseover", g)));
  }, [g]), h(() => {
    x && typeof f == "function" && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(x, "mouseup", f)));
  }, [f]), h(() => {
    x && typeof y == "function" && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(x, "rightclick", y)));
  }, [y]), h(() => {
    x && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(x, "click", b)));
  }, [b]), h(() => {
    x && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(x, "drag", E)));
  }, [E]), h(() => {
    var j = new google.maps.Polygon(O5(O5({}, t), {}, {
      map: v
    }));
    return i && j.setPath(i), a && j.setPaths(a), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), s && L(google.maps.event.addListener(j, "dblclick", s)), l && R(google.maps.event.addListener(j, "dragend", l)), u && Z(google.maps.event.addListener(j, "dragstart", u)), c && $(google.maps.event.addListener(j, "mousedown", c)), p && X(google.maps.event.addListener(j, "mousemove", p)), d && J(google.maps.event.addListener(j, "mouseout", d)), g && D(google.maps.event.addListener(j, "mouseover", g)), f && S(google.maps.event.addListener(j, "mouseup", f)), y && C(google.maps.event.addListener(j, "rightclick", y)), b && U(google.maps.event.addListener(j, "click", b)), E && q(google.maps.event.addListener(j, "drag", E)), _(j), w && w(j), () => {
      z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), M && M(j), j.setMap(null);
    };
  }, []), null;
}
me(F8e);
class z8e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Pn({
      updaterMap: k5,
      eventMap: E5,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: k5,
      eventMap: E5,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Nn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(z8e, "contextType", Vt);
function L5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? L5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : L5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var P5 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, _5 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function U8e(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(Vt), [v, x] = k(null), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null);
  return h(() => {
    v !== null && v.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(v, "click", y)));
  }, [y]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(yC(yC({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && z(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && H(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && F(google.maps.event.addListener(Y, "mouseup", g)), f && W(google.maps.event.addListener(Y, "rightclick", f)), y && I(google.maps.event.addListener(Y, "click", y)), b && T(google.maps.event.addListener(Y, "drag", b)), E && j(google.maps.event.addListener(Y, "bounds_changed", E)), x(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
me(U8e);
class H8e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      rectangle: null
    }), Ae(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(yC(yC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: _5,
      eventMap: P5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: _5,
      eventMap: P5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Nn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(H8e, "contextType", Vt);
function S5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? S5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : S5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var M5 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, D5 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, W8e = {};
function V8e(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: v
  } = e, x = ge(Vt), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null);
  return h(() => {
    _ !== null && _.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(_, "rightclick", y)));
  }, [y]), h(() => {
    _ && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", b)));
  }, [b]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [b]), h(() => {
    _ && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(bC(bC({}, t || W8e), {}, {
      map: x
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && F(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), y && I(google.maps.event.addListener(oe, "rightclick", y)), b && T(google.maps.event.addListener(oe, "click", b)), E && j(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), z(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(V8e);
class $8e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      circle: null
    }), Ae(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(bC(bC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: D5,
      eventMap: M5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: D5,
      eventMap: M5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Nn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Ae($8e, "contextType", Vt);
function T5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? T5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : T5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var j5 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, A5 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Z8e(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: y,
    onUnmount: b
  } = e, E = ge(Vt), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var j = new google.maps.Data(wC(wC({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(j, "dblclick", r)), o && _(google.maps.event.addListener(j, "mousedown", o)), i && L(google.maps.event.addListener(j, "mousemove", i)), a && R(google.maps.event.addListener(j, "mouseout", a)), s && Z(google.maps.event.addListener(j, "mouseover", s)), l && $(google.maps.event.addListener(j, "mouseup", l)), u && X(google.maps.event.addListener(j, "rightclick", u)), n && J(google.maps.event.addListener(j, "click", n)), c && D(google.maps.event.addListener(j, "addfeature", c)), p && S(google.maps.event.addListener(j, "removefeature", p)), d && C(google.maps.event.addListener(j, "removeproperty", d)), g && U(google.maps.event.addListener(j, "setgeometry", g)), f && q(google.maps.event.addListener(j, "setproperty", f)), M(j), y && y(j);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(Z8e);
class q8e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      data: null
    }), Ae(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(wC(wC({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Pn({
        updaterMap: A5,
        eventMap: j5,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: A5,
      eventMap: j5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Nn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(q8e, "contextType", Vt);
function I5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function B5(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? I5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : I5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var R5 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, N5 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class G8e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      kmlLayer: null
    }), Ae(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(B5(B5({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: N5,
      eventMap: R5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: N5,
      eventMap: R5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Nn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(G8e, "contextType", Vt);
function Oue(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function K8e(e, t) {
  return new t(e.lat, e.lng);
}
function Y8e(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function X8e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function J8e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Q8e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function e5e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Eue(e, t, n, r) {
  return n !== void 0 ? Q8e(e, t, J8e(n, google.maps.LatLngBounds, Y8e)) : e5e(e, t, X8e(r, google.maps.LatLng, K8e));
}
function t5e(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function F5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function n5e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? F5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : F5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function r5e(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = n5e({}, this.container ? Oue(this.container, o) : {
        x: 0,
        y: 0
      }), u = Eue(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function z5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function o5e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? z5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function U5(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function H5(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function i5e(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Vt), c = Ft(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Ft(() => r5e(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), xi.createPortal(l, c);
}
me(i5e);
class tf extends pe {
  constructor(t) {
    super(t), Ae(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Ae(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      fi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Ae(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Ae(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = o5e({
        x: 0,
        y: 0
      }, this.containerRef.current ? Oue(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Eue(r, o, this.props.bounds, this.props.position);
      if (!t5e(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Ae(this, "draw", () => {
      this.onPositionElement();
    }), Ae(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Br();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = U5(t.position), r = U5(this.props.position), o = H5(t.bounds), i = H5(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? xi.createPortal(ji.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
Ae(tf, "FLOAT_PANE", "floatPane");
Ae(tf, "MAP_PANE", "mapPane");
Ae(tf, "MARKER_LAYER", "markerLayer");
Ae(tf, "OVERLAY_LAYER", "overlayLayer");
Ae(tf, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Ae(tf, "contextType", Vt);
function s5e() {
}
function W5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function V5(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? W5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : W5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $5 = {
  onDblClick: "dblclick",
  onClick: "click"
}, Z5 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function a5e(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Vt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Ft(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(a5e);
class kue extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      groundOverlay: null
    }), Ae(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    fi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, V5(V5({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: Z5,
      eventMap: $5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: Z5,
      eventMap: $5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(kue, "defaultProps", {
  onLoad: s5e
});
Ae(kue, "contextType", Vt);
function q5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function CC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? q5(Object(n), !0).forEach(function(r) {
      Ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : q5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var G5 = {}, K5 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function l5e(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Vt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || fi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    fi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(CC(CC({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(l5e);
class u5e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      heatmapLayer: null
    }), Ae(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    fi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), fi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(CC(CC({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Pn({
      updaterMap: K5,
      eventMap: G5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: K5,
      eventMap: G5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Nn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(u5e, "contextType", Vt);
var Y5 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, X5 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class c5e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      streetViewPanorama: null
    }), Ae(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Pn({
      updaterMap: X5,
      eventMap: Y5,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: X5,
      eventMap: Y5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Nn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Ae(c5e, "contextType", Vt);
class p5e extends pe {
  constructor() {
    super(...arguments), Ae(this, "state", {
      streetViewService: null
    }), Ae(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Ae(p5e, "contextType", Vt);
var J5 = {
  onDirectionsChanged: "directions_changed"
}, Q5 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class d5e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "state", {
      directionsRenderer: null
    }), Ae(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Pn({
      updaterMap: Q5,
      eventMap: J5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: Q5,
      eventMap: J5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Nn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Ae(d5e, "contextType", Vt);
var e4 = {
  onPlacesChanged: "places_changed"
}, t4 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class f5e extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "containerElement", Br()), Ae(this, "state", {
      searchBox: null
    }), Ae(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (fi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Pn({
          updaterMap: t4,
          eventMap: e4,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: t4,
      eventMap: e4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Nn(this.registeredEvents));
  }
  render() {
    return ji.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
Ae(f5e, "contextType", Vt);
var n4 = {
  onPlaceChanged: "place_changed"
}, r4 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Lue extends pe {
  constructor() {
    super(...arguments), Ae(this, "registeredEvents", []), Ae(this, "containerElement", Br()), Ae(this, "state", {
      autocomplete: null
    }), Ae(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    fi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Pn({
        updaterMap: r4,
        eventMap: n4,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Nn(this.registeredEvents), this.registeredEvents = Pn({
      updaterMap: r4,
      eventMap: n4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Nn(this.registeredEvents);
  }
  render() {
    return ji.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
Ae(Lue, "defaultProps", {
  className: ""
});
Ae(Lue, "contextType", Vt);
let h5e = { data: "" }, g5e = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || h5e, m5e = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, v5e = /\/\*[^]*?\*\/|  +/g, o4 = /\n+/g, qu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? qu(a, i) : i + "{" + qu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += qu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += qu.p ? qu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, El = {}, Pue = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Pue(e[n]);
    return t;
  }
  return e;
}, y5e = (e, t, n, r, o) => {
  let i = Pue(e), a = El[i] || (El[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!El[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = m5e.exec(u.replace(v5e, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(o4, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(o4, " ").trim();
      return d[0];
    })(e);
    El[a] = qu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && El.g ? El.g : null;
  return n && (El.g = El[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(El[a], t, r, s), a;
}, b5e = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : qu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function JE(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return y5e(n.unshift ? n.raw ? b5e(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, g5e(t.target), t.g, t.o, t.k);
}
let _ue, wD, CD;
JE.bind({ g: 1 });
let Wl = JE.bind({ k: 1 });
function w5e(e, t, n, r) {
  qu.p = t, _ue = e, wD = n, CD = r;
}
function Ec(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: wD && wD() }, s), n.o = / *go\d+/.test(l), s.className = JE.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), CD && u[0] && CD(s), _ue(u, s);
    }
    return o;
  };
}
var C5e = (e) => typeof e == "function", x5e = (e, t) => C5e(e) ? e(t) : e, O5e = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), E5e = Wl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, k5e = Wl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, L5e = Wl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, P5e = Ec("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${E5e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${k5e} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${L5e} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, _5e = Wl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, S5e = Ec("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${_5e} 1s linear infinite;
`, M5e = Wl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, D5e = Wl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, T5e = Ec("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${M5e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${D5e} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, j5e = Ec("div")`
  position: absolute;
`, A5e = Ec("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, I5e = Wl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, B5e = Ec("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${I5e} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, R5e = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Me.createElement(B5e, null, t) : t : n === "blank" ? null : Me.createElement(A5e, null, Me.createElement(S5e, { ...r }), n !== "loading" && Me.createElement(j5e, null, n === "error" ? Me.createElement(P5e, { ...r }) : Me.createElement(T5e, { ...r })));
}, N5e = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, F5e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, z5e = "0%{opacity:0;} 100%{opacity:1;}", U5e = "0%{opacity:1;} 100%{opacity:0;}", H5e = Ec("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, W5e = Ec("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, V5e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = O5e() ? [z5e, U5e] : [N5e(n), F5e(n)];
  return { animation: t ? `${Wl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Wl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Me.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? V5e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Me.createElement(R5e, { toast: e }), a = Me.createElement(W5e, { ...e.ariaProps }, x5e(e.message, e));
  return Me.createElement(H5e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Me.createElement(Me.Fragment, null, i, a));
});
w5e(Me.createElement);
JE`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
We({});
function $5e(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Z5e = {
  CNPJ: "99.999.999/9999-99"
};
$5e(Z5e.CNPJ).length;
yr((e, t) => /* @__PURE__ */ Ti.jsx("input", { ref: t, ...e }));
function Sue(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Mue = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function q5e(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function G5e(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const K5e = Sue(Mue.NINE).length, Y5e = yr((e, t) => /* @__PURE__ */ Ti.jsx("input", { ref: t, ...e }));
yr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = Sue(g.target.value);
      const y = G5e(f);
      f.length > K5e || (f = q5e(f, Mue[y]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Ti.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Ti.jsx(
      tl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: Y5e,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
We({});
var eu = {};
Object.defineProperty(eu, "__esModule", {
  value: !0
});
var X5e = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), iP = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Due = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: X5e ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, sB = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var bb = 1; bb < 20; bb++)
  sB["f" + bb] = 111 + bb;
function QE(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Tue(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return jue(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function J5e(e, t) {
  return QE(e, t);
}
function Q5e(e, t) {
  return QE(e, { byKey: !0 }, t);
}
function Tue(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in iP)
    r[iP[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = aB(d), y = iP[f];
      if (d.length > 1 && !y && !Due[d] && !sB[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !y) && (n ? r.key = f : r.which = Aue(d)), y && (r[y] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function jue(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Aue(e) {
  e = aB(e);
  var t = sB[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function aB(e) {
  return e = e.toLowerCase(), e = Due[e] || e, e;
}
eu.default = QE;
var sP = eu.isHotkey = QE;
eu.isCodeHotkey = J5e;
eu.isKeyHotkey = Q5e;
eu.parseHotkey = Tue;
eu.compareHotkey = jue;
eu.toKeyCode = Aue;
eu.toKeyName = aB;
var e4e = typeof Dr == "object" && Dr && Dr.Object === Object && Dr, t4e = e4e, n4e = t4e, r4e = typeof self == "object" && self && self.Object === Object && self, o4e = n4e || r4e || Function("return this")(), i4e = o4e, s4e = i4e, a4e = s4e.Symbol, Iue = a4e, i4 = Iue;
i4 && i4.toStringTag;
var s4 = Iue;
s4 && s4.toStringTag;
var a4;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(a4 || (a4 = {}));
var lB = function(e) {
  return Object.freeze(e);
}, l4e = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, lB(this);
  }
  return e;
}(), u4e = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, lB(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), l4 = typeof window < "u" ? window : {};
/msie|trident/i.test(l4.navigator && l4.navigator.userAgent);
var aP = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new l4e((n ? t : e) || 0, (n ? e : t) || 0);
};
lB({
  devicePixelContentBoxSize: aP(),
  borderBoxSize: aP(),
  contentBoxSize: aP(),
  contentRect: new u4e(0, 0, 0, 0)
});
function um(e) {
  "@babel/helpers - typeof";
  return um = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, um(e);
}
function c4e(e, t) {
  if (um(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (um(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function p4e(e) {
  var t = c4e(e, "string");
  return um(t) === "symbol" ? t : String(t);
}
function Xh(e, t, n) {
  return t = p4e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var d4e = /* @__PURE__ */ We(null), lP, uP;
parseInt(we.version.split(".")[0], 10);
var u4 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), cP = typeof navigator < "u" && /Android/.test(navigator.userAgent), wb = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), f4e = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (lP = navigator.userAgent.match(/Version\/(\d+)/)) !== null && lP !== void 0 && lP[1] && parseInt((uP = navigator.userAgent.match(/Version\/(\d+)/)) === null || uP === void 0 ? void 0 : uP[1], 10) < 17;
var h4e = /* @__PURE__ */ new WeakMap(), g4e = /* @__PURE__ */ new WeakMap(), m4e = /* @__PURE__ */ new WeakMap(), v4e = /* @__PURE__ */ new WeakMap(), y4e = /* @__PURE__ */ new WeakMap(), c4 = /* @__PURE__ */ new WeakMap(), b4e = /* @__PURE__ */ new WeakMap(), p4 = /* @__PURE__ */ new WeakMap(), Cb = /* @__PURE__ */ new WeakMap(), w4e = /* @__PURE__ */ new WeakMap(), C4e = /* @__PURE__ */ new WeakMap(), x4e = /* @__PURE__ */ new WeakMap(), Bue = globalThis.Node, O4e = globalThis.Text, Rue = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, E4e = (e) => xC(e) && e.nodeType === 8, Ya = (e) => xC(e) && e.nodeType === 1, xC = (e) => {
  var t = Rue(e);
  return !!t && e instanceof t.Node;
}, d4 = (e) => {
  var t = e && e.anchorNode && Rue(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, k4e = (e) => {
  var [t, n] = e;
  if (Ya(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Nue(t, o, r ? "backward" : "forward"), r = o < n; Ya(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = P4e(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, L4e = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Nue = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (E4e(o) || Ya(o) && o.childNodes.length === 0 || Ya(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, P4e = (e, t, n) => {
  var [r] = Nue(e, t, n);
  return r;
}, f4 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Fue = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ya(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = wn.getWindow(e);
  if (o.contains(r))
    return wn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Fue(e, i, n);
}, h4 = (e, t) => !!(e.compareDocumentPosition(t) & Bue.DOCUMENT_POSITION_PRECEDING), _4e = (e, t) => !!(e.compareDocumentPosition(t) & Bue.DOCUMENT_POSITION_FOLLOWING), S4e = 0;
class M4e {
  constructor() {
    Xh(this, "id", void 0), this.id = "".concat(S4e++);
  }
}
var wn = {
  androidPendingDiffs: (e) => x4e.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = C4e.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = wn.toDOMNode(e, e), n = wn.findDocumentOrShadowRoot(e);
    Cb.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = wn.findDocumentOrShadowRoot(e), r = f4(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && c0.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = wn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = wn.toSlateNode(e, t.target), a = wn.findPath(e, i);
    if (jl.isElement(i) && xr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = xr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? xr.before(e, u) : xr.after(e, u);
      if (c) {
        var p = xr.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = wn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var y = wn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return y;
  },
  findKey: (e, t) => {
    var n = c4.get(t);
    return n || (n = new M4e(), c4.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = g4e.get(r);
      if (o == null) {
        if (xr.isEditor(r))
          return n;
        break;
      }
      var i = h4e.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Bs.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Cb.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          wn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = wn.toDOMNode(e, e), r = wn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = f4(r), i = wn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || c0.select(e, xr.start(e, [])), Cb.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = m4e.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = wn.toDOMNode(e, e), i;
    try {
      i = Ya(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => xC(t) && wn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return xr.hasPath(e, n.path) && xr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => wn.hasEditableTarget(e, t) || wn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => xC(t) && wn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!w4e.get(e),
  isFocused: (e) => !!Cb.get(e),
  isReadOnly: (e) => !!p4.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (p4.get(e)) return !1;
    var n = wn.hasTarget(e, t) && wn.toSlateNode(e, t);
    return jl.isElement(n) && xr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = b4e.get(e), r = xr.isEditor(t) ? v4e.get(e) : n == null ? void 0 : n.get(wn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Bs.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = xr.node(e, t.path), r = wn.toDOMNode(e, n), o;
    xr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, y = a[l + 1];
        if (t.offset === f && y !== null && y !== void 0 && y.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = y.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof O4e ? E : y,
            (b = y.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Bs.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Qt.isBackward(t), i = wn.toDOMPoint(e, n), a = Qt.isCollapsed(t) ? i : wn.toDOMPoint(e, r), s = wn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Ya(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), y = Ya(p) ? p : p.parentElement, b = !!y.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ya(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? y4e.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : k4e(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = wn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), y = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = wn.getWindow(e), v = O.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var x = v.cloneContents(), _ = [...Array.prototype.slice.call(x.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(x.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (cP && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = x.textContent.length, M = u;
        }
      } else if (y) {
        for (var z = y.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var N = z[L];
          if (wn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var Z, H = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = (Z = H.find((S) => _4e(E, S))) !== null && Z !== void 0 ? Z : null;
        } else {
          var $, K = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = ($ = K.findLast((S) => h4(E, S))) !== null && $ !== void 0 ? $ : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      cP && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      wb && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (cP && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && wn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var Q = wn.toSlateNode(e, X), {
          path: J,
          offset: P
        } = xr.start(e, wn.findPath(e, Q));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = wn.toSlateNode(e, u), F = wn.findPath(e, D);
    return {
      path: F,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = d4(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (d4(t)) {
        if (wb && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let x = function(_) {
              return _.childElementCount > 0 ? x(_.children[0]) : _;
            };
            var f = d.startContainer, y = g.startContainer, b = x(f.children[d.startOffset]), E = x(y.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        f4e && L4e(s) || wb ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    wb && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = wn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = h4(s, u) || s === u && c < l, O = p ? w : wn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var v = {
      anchor: w,
      focus: O
    };
    return Qt.isExpanded(v) && Qt.isForward(v) && Ya(u) && xr.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = xr.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, D4e = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, T4e = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, j4e = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, yo = (e) => {
  var t = D4e[e], n = T4e[e], r = j4e[e], o = t && sP(t), i = n && sP(n), a = r && sP(r);
  return (s) => !!(o && o(s) || u4 && i && i(s) || !u4 && a && a(s));
};
yo("bold"), yo("compose"), yo("moveBackward"), yo("moveForward"), yo("deleteBackward"), yo("deleteForward"), yo("deleteLineBackward"), yo("deleteLineForward"), yo("deleteWordBackward"), yo("deleteWordForward"), yo("extendBackward"), yo("extendForward"), yo("extendLineBackward"), yo("extendLineForward"), yo("italic"), yo("moveLineBackward"), yo("moveLineForward"), yo("moveWordBackward"), yo("moveWordForward"), yo("redo"), yo("insertSoftBreak"), yo("splitBlock"), yo("transposeCharacter"), yo("undo");
var A4e = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Fue(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, I4e = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class B4e extends Kl {
  constructor() {
    super(...arguments), Xh(this, "context", null), Xh(this, "manager", null), Xh(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, I4e);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = A4e(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Xh(B4e, "contextType", d4e);
We({});
We({});
We({});
var ii = {}, uB = {}, Xm = {}, Jm = {}, zue = "Expected a function", g4 = NaN, R4e = "[object Symbol]", N4e = /^\s+|\s+$/g, F4e = /^[-+]0x[0-9a-f]+$/i, z4e = /^0b[01]+$/i, U4e = /^0o[0-7]+$/i, H4e = parseInt, W4e = typeof Dr == "object" && Dr && Dr.Object === Object && Dr, V4e = typeof self == "object" && self && self.Object === Object && self, $4e = W4e || V4e || Function("return this")(), Z4e = Object.prototype, q4e = Z4e.toString, G4e = Math.max, K4e = Math.min, pP = function() {
  return $4e.Date.now();
};
function Y4e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(zue);
  t = m4(t) || 0, OC(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? G4e(m4(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(x) {
    var _ = r, z = o;
    return r = o = void 0, u = x, a = e.apply(z, _), a;
  }
  function f(x) {
    return u = x, s = setTimeout(E, t), c ? g(x) : a;
  }
  function y(x) {
    var _ = x - l, z = x - u, L = t - _;
    return p ? K4e(L, i - z) : L;
  }
  function b(x) {
    var _ = x - l, z = x - u;
    return l === void 0 || _ >= t || _ < 0 || p && z >= i;
  }
  function E() {
    var x = pP();
    if (b(x))
      return w(x);
    s = setTimeout(E, y(x));
  }
  function w(x) {
    return s = void 0, d && r ? g(x) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(pP());
  }
  function v() {
    var x = pP(), _ = b(x);
    if (r = arguments, o = this, l = x, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = O, v;
}
function X4e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(zue);
  return OC(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Y4e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function OC(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function J4e(e) {
  return !!e && typeof e == "object";
}
function Q4e(e) {
  return typeof e == "symbol" || J4e(e) && q4e.call(e) == R4e;
}
function m4(e) {
  if (typeof e == "number")
    return e;
  if (Q4e(e))
    return g4;
  if (OC(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = OC(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(N4e, "");
  var n = z4e.test(e);
  return n || U4e.test(e) ? H4e(e.slice(2), n ? 2 : 8) : F4e.test(e) ? g4 : +e;
}
var eZe = X4e, Qm = {};
Object.defineProperty(Qm, "__esModule", {
  value: !0
});
Qm.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Sw.has(t) || Sw.set(t, /* @__PURE__ */ new Set());
  var o = Sw.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Qm.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Sw.get(t).delete(n.name || t);
};
var Sw = /* @__PURE__ */ new Map();
Object.defineProperty(Jm, "__esModule", {
  value: !0
});
var tZe = eZe, nZe = rZe(tZe), v4 = Qm;
function rZe(e) {
  return e && e.__esModule ? e : { default: e };
}
var oZe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, nZe.default)(e, t);
}, jo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = oZe(function(r) {
        jo.scrollHandler(e);
      }, t);
      return jo.scrollSpyContainers.push(e), (0, v4.addPassiveEventListener)(e, "scroll", n), function() {
        (0, v4.removePassiveEventListener)(e, "scroll", n), jo.scrollSpyContainers.splice(jo.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return jo.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = jo.scrollSpyContainers[jo.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(jo.currentPositionX(e), jo.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    jo.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = jo.scrollSpyContainers[jo.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    jo.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    jo.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), jo.spySetState && jo.spySetState.length && jo.spySetState.indexOf(e) > -1 && jo.spySetState.splice(jo.spySetState.indexOf(e), 1), document.removeEventListener("scroll", jo.scrollHandler);
  },
  update: function() {
    return jo.scrollSpyContainers.forEach(function(e) {
      return jo.scrollHandler(e);
    });
  }
};
Jm.default = jo;
var nf = {}, ev = {};
Object.defineProperty(ev, "__esModule", {
  value: !0
});
var iZe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, sZe = function() {
  return window.location.hash.replace(/^#/, "");
}, aZe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, lZe = function(e) {
  return getComputedStyle(e).position !== "static";
}, dP = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, uZe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (lZe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = dP(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return dP(t, s).offsetTop - dP(e, s).offsetTop;
};
ev.default = {
  updateHash: iZe,
  getHash: sZe,
  filterElementInContainer: aZe,
  scrollOffset: uZe
};
var ek = {}, cB = {};
Object.defineProperty(cB, "__esModule", {
  value: !0
});
cB.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var pB = {};
Object.defineProperty(pB, "__esModule", {
  value: !0
});
var cZe = Qm, pZe = ["mousedown", "wheel", "touchmove", "keydown"];
pB.default = {
  subscribe: function(e) {
    return typeof document < "u" && pZe.forEach(function(t) {
      return (0, cZe.addPassiveEventListener)(document, t, e);
    });
  }
};
var tv = {};
Object.defineProperty(tv, "__esModule", {
  value: !0
});
var xD = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      xD.registered[e] = t;
    },
    remove: function(e) {
      xD.registered[e] = null;
    }
  }
};
tv.default = xD;
Object.defineProperty(ek, "__esModule", {
  value: !0
});
var dZe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, fZe = ev;
tk(fZe);
var hZe = cB, y4 = tk(hZe), gZe = pB, mZe = tk(gZe), vZe = tv, Ua = tk(vZe);
function tk(e) {
  return e && e.__esModule ? e : { default: e };
}
var Uue = function(e) {
  return y4.default[e.smooth] || y4.default.defaultEasing;
}, yZe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, bZe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, OD = function() {
  return bZe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Hue = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Wue = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Vue = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, wZe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, CZe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, xZe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Ua.default.registered.end && Ua.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    OD.call(window, i);
    return;
  }
  Ua.default.registered.end && Ua.default.registered.end(o.to, o.target, o.currentPosition);
}, dB = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, nv = function(e, t, n, r) {
  t.data = t.data || Hue(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (mZe.default.subscribe(o), dB(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Wue(t) : Vue(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Ua.default.registered.end && Ua.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = yZe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Uue(t), a = xZe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Ua.default.registered.begin && Ua.default.registered.begin(t.data.to, t.data.target), OD.call(window, a);
    }, t.delay);
    return;
  }
  Ua.default.registered.begin && Ua.default.registered.begin(t.data.to, t.data.target), OD.call(window, a);
}, nk = function(e) {
  return e = dZe({}, e), e.data = e.data || Hue(), e.absolute = !0, e;
}, OZe = function(e) {
  nv(0, nk(e));
}, EZe = function(e, t) {
  nv(e, nk(t));
}, kZe = function(e) {
  e = nk(e), dB(e), nv(e.horizontal ? wZe(e) : CZe(e), e);
}, LZe = function(e, t) {
  t = nk(t), dB(t);
  var n = t.horizontal ? Wue(t) : Vue(t);
  nv(e + n, t);
};
ek.default = {
  animateTopScroll: nv,
  getAnimationType: Uue,
  scrollToTop: OZe,
  scrollToBottom: kZe,
  scrollTo: EZe,
  scrollMore: LZe
};
Object.defineProperty(nf, "__esModule", {
  value: !0
});
var PZe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, _Ze = ev, SZe = fB(_Ze), MZe = ek, DZe = fB(MZe), TZe = tv, xb = fB(TZe);
function fB(e) {
  return e && e.__esModule ? e : { default: e };
}
var Ob = {}, b4 = void 0;
nf.default = {
  unmount: function() {
    Ob = {};
  },
  register: function(e, t) {
    Ob[e] = t;
  },
  unregister: function(e) {
    delete Ob[e];
  },
  get: function(e) {
    return Ob[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return b4 = e;
  },
  getActiveLink: function() {
    return b4;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = PZe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = SZe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      xb.default.registered.begin && xb.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, xb.default.registered.end && xb.default.registered.end(e, n);
      return;
    }
    DZe.default.animateTopScroll(s, t, e, n);
  }
};
var ED = { exports: {} }, fP = { exports: {} }, rr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var w4;
function jZe() {
  if (w4) return rr;
  w4 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function O(v) {
    return M(v) === u;
  }
  return rr.AsyncMode = l, rr.ConcurrentMode = u, rr.ContextConsumer = s, rr.ContextProvider = a, rr.Element = t, rr.ForwardRef = c, rr.Fragment = r, rr.Lazy = f, rr.Memo = g, rr.Portal = n, rr.Profiler = i, rr.StrictMode = o, rr.Suspense = p, rr.isAsyncMode = function(v) {
    return O(v) || M(v) === l;
  }, rr.isConcurrentMode = O, rr.isContextConsumer = function(v) {
    return M(v) === s;
  }, rr.isContextProvider = function(v) {
    return M(v) === a;
  }, rr.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, rr.isForwardRef = function(v) {
    return M(v) === c;
  }, rr.isFragment = function(v) {
    return M(v) === r;
  }, rr.isLazy = function(v) {
    return M(v) === f;
  }, rr.isMemo = function(v) {
    return M(v) === g;
  }, rr.isPortal = function(v) {
    return M(v) === n;
  }, rr.isProfiler = function(v) {
    return M(v) === i;
  }, rr.isStrictMode = function(v) {
    return M(v) === o;
  }, rr.isSuspense = function(v) {
    return M(v) === p;
  }, rr.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === y);
  }, rr.typeOf = M, rr;
}
var hr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var C4;
function AZe() {
  return C4 || (C4 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === E || B.$$typeof === w || B.$$typeof === y);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, x = u, _ = s, z = a, L = t, N = c, R = r, V = f, Z = g, H = n, $ = i, K = o, X = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function F(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return O(B) === c;
    }
    function C(B) {
      return O(B) === r;
    }
    function I(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function j(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    hr.AsyncMode = v, hr.ConcurrentMode = x, hr.ContextConsumer = _, hr.ContextProvider = z, hr.Element = L, hr.ForwardRef = N, hr.Fragment = R, hr.Lazy = V, hr.Memo = Z, hr.Portal = H, hr.Profiler = $, hr.StrictMode = K, hr.Suspense = X, hr.isAsyncMode = J, hr.isConcurrentMode = P, hr.isContextConsumer = D, hr.isContextProvider = F, hr.isElement = S, hr.isForwardRef = W, hr.isFragment = C, hr.isLazy = I, hr.isMemo = U, hr.isPortal = T, hr.isProfiler = q, hr.isStrictMode = j, hr.isSuspense = Y, hr.isValidElementType = M, hr.typeOf = O;
  }()), hr;
}
var x4;
function $ue() {
  return x4 || (x4 = 1, process.env.NODE_ENV === "production" ? fP.exports = jZe() : fP.exports = AZe()), fP.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var hP, O4;
function IZe() {
  if (O4) return hP;
  O4 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return hP = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, hP;
}
var gP, E4;
function hB() {
  if (E4) return gP;
  E4 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return gP = e, gP;
}
var k4, L4;
function Zue() {
  return L4 || (L4 = 1, k4 = Function.call.bind(Object.prototype.hasOwnProperty)), k4;
}
var mP, P4;
function BZe() {
  if (P4) return mP;
  P4 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = hB(), n = {}, r = Zue();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, mP = o, mP;
}
var vP, _4;
function RZe() {
  if (_4) return vP;
  _4 = 1;
  var e = $ue(), t = IZe(), n = hB(), r = Zue(), o = BZe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return vP = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: v(),
      instanceOf: x,
      node: N(),
      objectOf: z,
      oneOf: _,
      oneOfType: L,
      shape: V,
      exact: Z
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function y(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    y.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, F = 0;
      function S(C, I, U, T, q, j, Y) {
        if (T = T || d, j = j || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            F < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + j + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, F++);
          }
        }
        return I[U] == null ? C ? I[U] === null ? new y("The " + q + " `" + j + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new y("The " + q + " `" + j + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(I, U, T, q, j);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(P) {
      function D(F, S, W, C, I, U) {
        var T = F[S], q = K(T);
        if (q !== P) {
          var j = X(T);
          return new y(
            "Invalid " + C + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = F[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var j = P(U, q, W, C, I + "[" + q + "]", n);
          if (j instanceof Error)
            return j;
        }
        return null;
      }
      return b(D);
    }
    function O() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!s(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function v() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!e.isValidElementType(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function x(P) {
      function D(F, S, W, C, I) {
        if (!(F[S] instanceof P)) {
          var U = P.name || d, T = J(F[S]);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(F, S, W, C, I) {
        for (var U = F[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(j, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new y("Invalid " + C + " `" + I + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function z(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var j = P(U, q, W, C, I + "." + q, n);
            if (j instanceof Error)
              return j;
          }
        return null;
      }
      return b(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var F = P[D];
        if (typeof F != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(F) + " at index " + D + "."
          ), a;
      }
      function S(W, C, I, U, T) {
        for (var q = [], j = 0; j < P.length; j++) {
          var Y = P[j], B = Y(W, C, I, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new y("Invalid " + U + " `" + T + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(S);
    }
    function N() {
      function P(D, F, S, W, C) {
        return H(D[F]) ? null : new y("Invalid " + W + " `" + C + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, D, F, S, W) {
      return new y(
        (P || "React class") + ": " + D + " type `" + F + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var j = P[q];
          if (typeof j != "function")
            return R(W, C, I, q, X(j));
          var Y = j(U, q, W, C, I + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(D);
    }
    function Z(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, F[S], P);
        for (var j in q) {
          var Y = P[j];
          if (r(P, j) && typeof Y != "function")
            return R(W, C, I, j, X(Y));
          if (!Y)
            return new y(
              "Invalid " + C + " `" + I + "` key `" + j + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(F[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, j, W, C, I + "." + j, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(D);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var F = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = F.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = F.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function $(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : $(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, vP;
}
var yP, S4;
function NZe() {
  if (S4) return yP;
  S4 = 1;
  var e = hB();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, yP = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, yP;
}
if (process.env.NODE_ENV !== "production") {
  var FZe = $ue(), zZe = !0;
  ED.exports = RZe()(FZe.isElement, zZe);
} else
  ED.exports = NZe()();
var rk = ED.exports, ok = {};
Object.defineProperty(ok, "__esModule", {
  value: !0
});
var UZe = ev, bP = HZe(UZe);
function HZe(e) {
  return e && e.__esModule ? e : { default: e };
}
var WZe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return bP.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && bP.default.getHash() !== e && bP.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
ok.default = WZe;
Object.defineProperty(Xm, "__esModule", {
  value: !0
});
var Eb = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, VZe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), $Ze = we, M4 = rv($Ze), ZZe = Jm, kb = rv(ZZe), qZe = nf, GZe = rv(qZe), KZe = rk, bo = rv(KZe), YZe = ok, fu = rv(YZe);
function rv(e) {
  return e && e.__esModule ? e : { default: e };
}
function XZe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function JZe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function QZe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var D4 = {
  to: bo.default.string.isRequired,
  containerId: bo.default.string,
  container: bo.default.object,
  activeClass: bo.default.string,
  activeStyle: bo.default.object,
  spy: bo.default.bool,
  horizontal: bo.default.bool,
  smooth: bo.default.oneOfType([bo.default.bool, bo.default.string]),
  offset: bo.default.number,
  delay: bo.default.number,
  isDynamic: bo.default.bool,
  onClick: bo.default.func,
  duration: bo.default.oneOfType([bo.default.number, bo.default.func]),
  absolute: bo.default.bool,
  onSetActive: bo.default.func,
  onSetInactive: bo.default.func,
  ignoreCancelEvents: bo.default.bool,
  hashSpy: bo.default.bool,
  saveHashHistory: bo.default.bool,
  spyThrottle: bo.default.number
};
Xm.default = function(e, t) {
  var n = t || GZe.default, r = function(i) {
    QZe(a, i);
    function a(s) {
      XZe(this, a);
      var l = JZe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return VZe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!kb.default.isMounted(s)) {
            var l = kb.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (fu.default.isMounted() || fu.default.mount(n), fu.default.mapContainer(this.props.to, s)), kb.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        kb.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Eb({}, this.props.style, this.props.activeStyle) : l = Eb({}, this.props.style);
        var u = Eb({}, this.props);
        for (var c in D4)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, M4.default.createElement(e, u);
      }
    }]), a;
  }(M4.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Eb({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(fu.default.isMounted() && !fu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, y = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, y = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(y), g = M < Math.floor(f) || M >= Math.floor(y);
        } else {
          var O = 0, v = 0, x = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            x = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            O = z.top - x + s, v = O + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(v), g = L < Math.floor(O) || L >= Math.floor(v);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && fu.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            fu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var Z = i.props.saveHashHistory, H = Z === void 0 ? !1 : Z;
          i.props.hashSpy && fu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = D4, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(uB, "__esModule", {
  value: !0
});
var eqe = we, T4 = que(eqe), tqe = Xm, nqe = que(tqe);
function que(e) {
  return e && e.__esModule ? e : { default: e };
}
function rqe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function j4(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function oqe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var iqe = function(e) {
  oqe(t, e);
  function t() {
    var n, r, o, i;
    rqe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = j4(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return T4.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), j4(o, i);
  }
  return t;
}(T4.default.Component);
uB.default = (0, nqe.default)(iqe);
var gB = {};
Object.defineProperty(gB, "__esModule", {
  value: !0
});
var sqe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), aqe = we, A4 = Gue(aqe), lqe = Xm, uqe = Gue(lqe);
function Gue(e) {
  return e && e.__esModule ? e : { default: e };
}
function cqe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function pqe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function dqe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var fqe = function(e) {
  dqe(t, e);
  function t() {
    return cqe(this, t), pqe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return sqe(t, [{
    key: "render",
    value: function() {
      return A4.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(A4.default.Component);
gB.default = (0, uqe.default)(fqe);
var mB = {}, ik = {};
Object.defineProperty(ik, "__esModule", {
  value: !0
});
var hqe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, gqe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), mqe = we, I4 = sk(mqe), vqe = nl;
sk(vqe);
var yqe = nf, B4 = sk(yqe), bqe = rk, R4 = sk(bqe);
function sk(e) {
  return e && e.__esModule ? e : { default: e };
}
function wqe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Cqe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function xqe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
ik.default = function(e) {
  var t = function(n) {
    xqe(r, n);
    function r(o) {
      wqe(this, r);
      var i = Cqe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return gqe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        B4.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        B4.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return I4.default.createElement(e, hqe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(I4.default.Component);
  return t.propTypes = {
    name: R4.default.string,
    id: R4.default.string
  }, t;
};
Object.defineProperty(mB, "__esModule", {
  value: !0
});
var N4 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Oqe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Eqe = we, F4 = vB(Eqe), kqe = ik, Lqe = vB(kqe), Pqe = rk, z4 = vB(Pqe);
function vB(e) {
  return e && e.__esModule ? e : { default: e };
}
function _qe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Sqe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Mqe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Kue = function(e) {
  Mqe(t, e);
  function t() {
    return _qe(this, t), Sqe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Oqe(t, [{
    key: "render",
    value: function() {
      var n = this, r = N4({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, F4.default.createElement(
        "div",
        N4({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(F4.default.Component);
Kue.propTypes = {
  name: z4.default.string,
  id: z4.default.string
};
mB.default = (0, Lqe.default)(Kue);
var wP = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, U4 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function H4(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function W4(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function V4(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Lb = we, Fc = Jm, CP = nf, Ho = rk, hu = ok, $4 = {
  to: Ho.string.isRequired,
  containerId: Ho.string,
  container: Ho.object,
  activeClass: Ho.string,
  spy: Ho.bool,
  smooth: Ho.oneOfType([Ho.bool, Ho.string]),
  offset: Ho.number,
  delay: Ho.number,
  isDynamic: Ho.bool,
  onClick: Ho.func,
  duration: Ho.oneOfType([Ho.number, Ho.func]),
  absolute: Ho.bool,
  onSetActive: Ho.func,
  onSetInactive: Ho.func,
  ignoreCancelEvents: Ho.bool,
  hashSpy: Ho.bool,
  spyThrottle: Ho.number
}, Dqe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || CP, r = function(i) {
      V4(a, i);
      function a(s) {
        H4(this, a);
        var l = W4(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return U4(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Fc.isMounted(s) || Fc.mount(s, this.props.spyThrottle), this.props.hashSpy && (hu.isMounted() || hu.mount(n), hu.mapContainer(this.props.to, s)), this.props.spy && Fc.addStateHandler(this.stateHandler), Fc.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Fc.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = wP({}, this.props);
          for (var u in $4)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Lb.createElement(e, l);
        }
      }]), a;
    }(Lb.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, wP({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(hu.isMounted() && !hu.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var y = a - i.props.offset, b = y >= Math.floor(c) && y < Math.floor(p), E = y < Math.floor(c) || y >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && hu.getHash() === l && hu.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Fc.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && hu.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Fc.updateStates();
        }
      };
    };
    return r.propTypes = $4, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      V4(r, n);
      function r(o) {
        H4(this, r);
        var i = W4(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return U4(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          CP.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          CP.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Lb.createElement(e, wP({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Lb.Component);
    return t.propTypes = {
      name: Ho.string,
      id: Ho.string
    }, t;
  }
}, Tqe = Dqe;
Object.defineProperty(ii, "__esModule", {
  value: !0
});
ii.Helpers = ii.ScrollElement = ii.ScrollLink = ii.animateScroll = ii.scrollSpy = ii.Events = ii.scroller = ii.Element = ii.Button = ii.Link = void 0;
var jqe = uB, Yue = al(jqe), Aqe = gB, Xue = al(Aqe), Iqe = mB, Jue = al(Iqe), Bqe = nf, Que = al(Bqe), Rqe = tv, ece = al(Rqe), Nqe = Jm, tce = al(Nqe), Fqe = ek, nce = al(Fqe), zqe = Xm, rce = al(zqe), Uqe = ik, oce = al(Uqe), Hqe = Tqe, ice = al(Hqe);
function al(e) {
  return e && e.__esModule ? e : { default: e };
}
ii.Link = Yue.default;
ii.Button = Xue.default;
ii.Element = Jue.default;
ii.scroller = Que.default;
ii.Events = ece.default;
ii.scrollSpy = tce.default;
ii.animateScroll = nce.default;
ii.ScrollLink = rce.default;
ii.ScrollElement = oce.default;
ii.Helpers = ice.default;
ii.default = { Link: Yue.default, Button: Xue.default, Element: Jue.default, scroller: Que.default, Events: ece.default, scrollSpy: tce.default, animateScroll: nce.default, ScrollLink: rce.default, ScrollElement: oce.default, Helpers: ice.default };
We({});
We({});
We({});
function cm(e) {
  "@babel/helpers - typeof";
  return cm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, cm(e);
}
function Wqe(e, t) {
  if (cm(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (cm(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Vqe(e) {
  var t = Wqe(e, "string");
  return cm(t) == "symbol" ? t : t + "";
}
function Ie(e, t, n) {
  return (t = Vqe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function sce(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var xP, Z4;
function $qe() {
  if (Z4) return xP;
  Z4 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return xP = t, xP;
}
var Zqe = $qe(), hi = /* @__PURE__ */ sce(Zqe), $t = We(null);
function qqe() {
  hi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge($t);
  return hi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Gqe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Kqe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Yqe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Kqe(e, i), o;
}
function Xqe(e, t, n) {
  var r = Gqe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function Jqe(e) {
  google.maps.event.removeListener(e);
}
function Fn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(Jqe);
}
function _n(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = Xqe(o, i, n);
  return Yqe(t, r, o, i), a;
}
function Qqe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: y,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [v, x] = k(null), _ = ht(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null), [j, Y] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && y && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", y)));
  }, [y]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (j !== null && google.maps.event.removeListener(j), Y(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return x(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), Ti.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: Ti.jsx($t.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(Qqe);
function q4(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function ace(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        q4(i, r, o, a, s, "next", l);
      }
      function s(l) {
        q4(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function lce(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return hi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var bp = typeof document < "u";
function uce(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return bp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function G4(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function cce() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return G4(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return G4(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Vf = !1;
function pce() {
  return Ti.jsx("div", {
    children: "Loading..."
  });
}
var kD = {
  id: "script-loader",
  version: "weekly"
};
class e7e extends pe {
  constructor() {
    super(...arguments), Ie(this, "check", null), Ie(this, "state", {
      loaded: !1
    }), Ie(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Ie(this, "isCleaningUp", /* @__PURE__ */ ace(function* () {
      function t(n) {
        if (!Vf)
          n();
        else if (bp)
          var r = window.setInterval(function() {
            Vf || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Ie(this, "cleanup", () => {
      Vf = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Ie(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && cce(), hi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: lce(this.props)
      };
      uce(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Ie(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (bp) {
      if (window.google && window.google.maps && !Vf) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), bp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (bp) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Vf = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Ti.jsxs(Ti.Fragment, {
      children: [Ti.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Ti.jsx(pce, {})]
    });
  }
}
Ie(e7e, "defaultProps", kD);
function t7e(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function yB(e, t) {
  if (e == null) return {};
  var n, r, o = t7e(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var K4;
function n7e(e) {
  var {
    id: t = kD.id,
    version: n = kD.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ht(!1), [f, y] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    bp && u && cce();
  }, [u]), h(function() {
    f && hi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = lce({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!bp)
      return;
    function O() {
      g.current && (y(!0), K4 = w);
    }
    if (window.google && window.google.maps && K4 === w) {
      O();
      return;
    }
    uce({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = ht(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var r7e = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], o7e = Ti.jsx(pce, {});
function i7e(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = yB(e, r7e), {
    isLoaded: s,
    loadError: l
  } = n7e(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || o7e;
}
me(i7e);
var Y4;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Y4 || (Y4 = {}));
function X4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function EC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X4(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var J4 = {}, Q4 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function s7e(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge($t), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(EC(EC({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(s7e);
class a7e extends pe {
  constructor() {
    super(...arguments), Ie(this, "state", {
      trafficLayer: null
    }), Ie(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Ie(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(EC(EC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: Q4,
      eventMap: J4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: Q4,
      eventMap: J4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Fn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(a7e, "contextType", $t);
function l7e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge($t), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(l7e);
class u7e extends pe {
  constructor() {
    super(...arguments), Ie(this, "state", {
      bicyclingLayer: null
    }), Ie(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(u7e, "contextType", $t);
function c7e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge($t), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(c7e);
class p7e extends pe {
  constructor() {
    super(...arguments), Ie(this, "state", {
      transitLayer: null
    }), Ie(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(p7e, "contextType", $t);
function eZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tZ = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, nZ = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function d7e(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge($t), [d, g] = k(null), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), y(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    hi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(kC(kC({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && y(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && v(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(d7e);
class f7e extends pe {
  constructor(t) {
    super(t), Ie(this, "registeredEvents", []), Ie(this, "state", {
      drawingManager: null
    }), Ie(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), hi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(kC(kC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: nZ,
      eventMap: tZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: nZ,
      eventMap: tZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Fn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(f7e, "contextType", $t);
function rZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oZ = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, iZ = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, LC = {};
function h7e(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: y,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: v,
    onMouseOut: x,
    onMouseOver: _,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: Z,
    onDraggableChanged: H,
    onFlatChanged: $,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: F,
    onUnmount: S
  } = e, W = ge($t), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null), [oe, Pe] = k(null), [Ue, Ze] = k(null), [_e, rt] = k(null), [Ve, ye] = k(null), [Ge, ct] = k(null), [ve, Oe] = k(null), [qe, ze] = k(null), [Se, st] = k(null), [xe, xt] = k(null), [at, lt] = k(null), [pt, Ot] = k(null), [dt, ft] = k(null), [ot, He] = k(null), [Et, kt] = k(null), [gt, St] = k(null), [mt, Mt] = k(null), [vt, Pt] = k(null);
  h(() => {
    C !== null && C.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && C !== null && C.setOptions(n);
  }, [C, n]), h(() => {
    typeof a < "u" && C !== null && C.setDraggable(a);
  }, [C, a]), h(() => {
    t && C !== null && C.setPosition(t);
  }, [C, t]), h(() => {
    typeof s < "u" && C !== null && C.setVisible(s);
  }, [C, s]), h(() => {
    C == null || C.setAnimation(l);
  }, [C, l]), h(() => {
    C && u !== void 0 && C.setClickable(u);
  }, [C, u]), h(() => {
    C && c !== void 0 && C.setCursor(c);
  }, [C, c]), h(() => {
    C && p !== void 0 && C.setIcon(p);
  }, [C, p]), h(() => {
    C && d !== void 0 && C.setLabel(d);
  }, [C, d]), h(() => {
    C && g !== void 0 && C.setOpacity(g);
  }, [C, g]), h(() => {
    C && f !== void 0 && C.setShape(f);
  }, [C, f]), h(() => {
    C && y !== void 0 && C.setTitle(y);
  }, [C, y]), h(() => {
    C && b !== void 0 && C.setZIndex(b);
  }, [C, b]), h(() => {
    C && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(C, "dblclick", w)));
  }, [w]), h(() => {
    C && O && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(C, "dragend", O)));
  }, [O]), h(() => {
    C && v && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(C, "dragstart", v)));
  }, [v]), h(() => {
    C && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(C, "mousedown", L)));
  }, [L]), h(() => {
    C && x && (oe !== null && google.maps.event.removeListener(oe), Pe(google.maps.event.addListener(C, "mouseout", x)));
  }, [x]), h(() => {
    C && _ && (Ue !== null && google.maps.event.removeListener(Ue), Ze(google.maps.event.addListener(C, "mouseover", _)));
  }, [_]), h(() => {
    C && z && (_e !== null && google.maps.event.removeListener(_e), rt(google.maps.event.addListener(C, "mouseup", z)));
  }, [z]), h(() => {
    C && N && (Ve !== null && google.maps.event.removeListener(Ve), ye(google.maps.event.addListener(C, "rightclick", N)));
  }, [N]), h(() => {
    C && E && (Ge !== null && google.maps.event.removeListener(Ge), ct(google.maps.event.addListener(C, "click", E)));
  }, [E]), h(() => {
    C && M && (ve !== null && google.maps.event.removeListener(ve), Oe(google.maps.event.addListener(C, "drag", M)));
  }, [M]), h(() => {
    C && R && (qe !== null && google.maps.event.removeListener(qe), ze(google.maps.event.addListener(C, "clickable_changed", R)));
  }, [R]), h(() => {
    C && V && (Se !== null && google.maps.event.removeListener(Se), st(google.maps.event.addListener(C, "cursor_changed", V)));
  }, [V]), h(() => {
    C && Z && (xe !== null && google.maps.event.removeListener(xe), xt(google.maps.event.addListener(C, "animation_changed", Z)));
  }, [Z]), h(() => {
    C && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(C, "draggable_changed", H)));
  }, [H]), h(() => {
    C && $ && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(C, "flat_changed", $)));
  }, [$]), h(() => {
    C && K && (dt !== null && google.maps.event.removeListener(dt), ft(google.maps.event.addListener(C, "icon_changed", K)));
  }, [K]), h(() => {
    C && X && (ot !== null && google.maps.event.removeListener(ot), He(google.maps.event.addListener(C, "position_changed", X)));
  }, [X]), h(() => {
    C && Q && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(C, "shape_changed", Q)));
  }, [Q]), h(() => {
    C && J && (gt !== null && google.maps.event.removeListener(gt), St(google.maps.event.addListener(C, "title_changed", J)));
  }, [J]), h(() => {
    C && P && (mt !== null && google.maps.event.removeListener(mt), Mt(google.maps.event.addListener(C, "visible_changed", P)));
  }, [P]), h(() => {
    C && D && (vt !== null && google.maps.event.removeListener(vt), Pt(google.maps.event.addListener(C, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = Cd(Cd(Cd({}, n || LC), r ? LC : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(yt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof g < "u" && te.setOpacity(g), f && te.setShape(f), typeof y == "string" && te.setTitle(y), typeof b == "number" && te.setZIndex(b), w && T(google.maps.event.addListener(te, "dblclick", w)), O && j(google.maps.event.addListener(te, "dragend", O)), v && B(google.maps.event.addListener(te, "dragstart", v)), L && he(google.maps.event.addListener(te, "mousedown", L)), x && Pe(google.maps.event.addListener(te, "mouseout", x)), _ && Ze(google.maps.event.addListener(te, "mouseover", _)), z && rt(google.maps.event.addListener(te, "mouseup", z)), N && ye(google.maps.event.addListener(te, "rightclick", N)), E && ct(google.maps.event.addListener(te, "click", E)), M && Oe(google.maps.event.addListener(te, "drag", M)), R && ze(google.maps.event.addListener(te, "clickable_changed", R)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), Z && xt(google.maps.event.addListener(te, "animation_changed", Z)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), $ && Ot(google.maps.event.addListener(te, "flat_changed", $)), K && ft(google.maps.event.addListener(te, "icon_changed", K)), X && He(google.maps.event.addListener(te, "position_changed", X)), Q && kt(google.maps.event.addListener(te, "shape_changed", Q)), J && St(google.maps.event.addListener(te, "title_changed", J)), P && Mt(google.maps.event.addListener(te, "visible_changed", P)), D && Pt(google.maps.event.addListener(te, "zindex_changed", D)), I(te), F && F(te), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), _e !== null && google.maps.event.removeListener(_e), Ve !== null && google.maps.event.removeListener(Ve), Ge !== null && google.maps.event.removeListener(Ge), qe !== null && google.maps.event.removeListener(qe), Se !== null && google.maps.event.removeListener(Se), xe !== null && google.maps.event.removeListener(xe), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ot !== null && google.maps.event.removeListener(ot), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var jn = Ft(() => i ? ut.map(i, (yt) => {
    if (!wi(yt))
      return yt;
    var te = yt;
    return Ci(te, {
      anchor: C
    });
  }) : null, [i, C]);
  return Ti.jsx(Ti.Fragment, {
    children: jn
  }) || null;
}
me(h7e);
class g7e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return ace(function* () {
      var n = Cd(Cd(Cd({}, t.props.options || LC), t.props.clusterer ? LC : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = _n({
        updaterMap: iZ,
        eventMap: oZ,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: iZ,
      eventMap: oZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Fn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Ci(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Ie(g7e, "contextType", $t);
var m7e = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), v7e = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new m7e(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function y7e(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var b7e = 2e3, w7e = 500, C7e = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", x7e = "png", O7e = [53, 56, 66, 78, 90], E7e = "cluster", dce = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || C7e, this.imageExtension = r.imageExtension || x7e, this.imageSizes = r.imageSizes || O7e, this.calculator = r.calculator || y7e, this.batchSize = r.batchSize || b7e, this.batchSizeIE = r.batchSizeIE || w7e, this.clusterClass = r.clusterClass || E7e, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new v7e(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function sZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function k7e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ya = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, qn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, L7e = {};
function P7e(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: y,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: v,
    onMouseOut: x,
    onLoad: _,
    onUnmount: z
  } = e, [L, N] = k(null), R = ge($t), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && x && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, ya.onMouseOut, x)));
  }, [x]), h(() => {
    L && v && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, ya.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(L, ya.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(L, ya.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), $(google.maps.event.addListener(L, ya.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && qn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && qn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && qn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && qn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && qn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && qn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && qn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && qn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && qn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && qn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && qn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && qn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof y < "u" && L !== null && qn.styles(L, y);
  }, [L, y]), h(() => {
    typeof b < "u" && L !== null && qn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && qn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var F = k7e({}, n || L7e), S = new dce(R, [], F);
      return r && qn.averageCenter(S, r), o && qn.batchSizeIE(S, o), i && qn.calculator(S, i), a && qn.clusterClass(S, a), s && qn.enableRetinaIcons(S, s), l && qn.gridSize(S, l), u && qn.ignoreHidden(S, u), c && qn.imageExtension(S, c), p && qn.imagePath(S, p), d && qn.imageSizes(S, d), g && qn.maxZoom(S, g), f && qn.minimumClusterSize(S, f), y && qn.styles(S, y), b && qn.title(S, b), E && qn.zoomOnClick(S, E), x && J(google.maps.event.addListener(S, ya.onMouseOut, x)), v && D(google.maps.event.addListener(S, ya.onMouseOver, v)), w && Z(google.maps.event.addListener(S, ya.onClick, w)), M && $(google.maps.event.addListener(S, ya.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, ya.onClusteringEnd, O)), N(S), _ && _(S), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), z && z(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(P7e);
class _7e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      markerClusterer: null
    }), Ie(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new dce(this.context, [], this.props.options);
      this.registeredEvents = _n({
        updaterMap: qn,
        eventMap: ya,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: qn,
      eventMap: ya,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Fn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Ie(_7e, "contextType", $t);
function aZ(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var fce = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || aZ(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, aZ));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, y = this.getProjection(), b = y.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), S7e = ["position"], M7e = ["position"];
function lZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function PC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uZ = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, cZ = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, D7e = {};
function T7e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge($t), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || D7e, {
        position: V
      } = R, Z = yB(R, S7e), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var $ = new fce(PC(PC({}, Z), H ? {
        position: H
      } : {}));
      N.current = document.createElement("div"), y($), a && E(google.maps.event.addListener($, "closeclick", a)), s && M(google.maps.event.addListener($, "domready", s)), l && v(google.maps.event.addListener($, "content_changed", l)), u && _(google.maps.event.addListener($, "position_changed", u)), c && L(google.maps.event.addListener($, "zindex_changed", c)), $.setContent(N.current), n ? $.open(g, n) : $.getPosition() ? $.open(g) : hi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p($);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(T7e);
class j7e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "containerElement", null), Ie(this, "state", {
      infoBox: null
    }), Ie(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : hi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Ie(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = yB(t, M7e), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new fce(PC(PC({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = _n({
      updaterMap: cZ,
      eventMap: uZ,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: cZ,
      eventMap: uZ,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Fn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
Ie(j7e, "contextType", $t);
var pZ, dZ;
function A7e() {
  return dZ || (dZ = 1, pZ = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), pZ;
}
var I7e = A7e(), fZ = /* @__PURE__ */ sce(I7e), hZ = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], OP = 1, $f = 8;
class bB {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== OP)
      throw new Error("Got v".concat(o, " data when expected v").concat(OP, "."));
    var i = hZ[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new bB(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = hZ.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, $f, t), this.coords = new this.ArrayType(this.data, $f + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer($f + a + s + l), this.ids = new this.IndexArrayType(this.data, $f, t), this.coords = new this.ArrayType(this.data, $f + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (OP << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return LD(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], y = a[2 * g + 1];
          f >= t && f <= r && y >= n && y <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          gZ(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, y = i[2 * f], b = i[2 * f + 1];
      gZ(y, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= y : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= y : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function LD(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    hce(e, t, a, r, o, i), LD(e, t, n, r, a - 1, 1 - i), LD(e, t, n, a + 1, o, 1 - i);
  }
}
function hce(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      hce(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, y = o;
    for (Zf(e, t, r, n), t[2 * o + i] > g && Zf(e, t, r, o); f < y; ) {
      for (Zf(e, t, f, y), f++, y--; t[2 * f + i] < g; ) f++;
      for (; t[2 * y + i] > g; ) y--;
    }
    t[2 * r + i] === g ? Zf(e, t, r, y) : (y++, Zf(e, t, y, o)), y <= n && (r = y + 1), n <= y && (o = y - 1);
  }
}
function Zf(e, t, n, r) {
  EP(e, n, r), EP(t, 2 * n, 2 * r), EP(t, 2 * n + 1, 2 * r + 1);
}
function EP(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function gZ(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var B7e = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, mZ = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), zc = 2, Ru = 3, kP = 4, _u = 5, gce = 6;
class R7e {
  constructor(t) {
    this.options = Object.assign(Object.create(B7e), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = mZ(Pb(u)), d = mZ(_b(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var y = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - y);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Pb(r), _b(a), Pb(i), _b(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + _u] > 1 ? vZ(p, f, this.clusterProps) : this.points[p[f + Ru]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + kP] === t && p.push(a[g + _u] > 1 ? vZ(a, g, this.clusterProps) : this.points[a[g + Ru]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new bB(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + _u] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = mce(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Ru]];
        c = g.properties;
        var [f, y] = g.geometry.coordinates;
        p = Pb(f), d = _b(y);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Ru] : E = this.points[n[l + Ru]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + zc] <= n)) {
        l[p + zc] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), y = l[p + _u], b = y;
        for (var E of f) {
          var w = E * c;
          l[w + zc] > n && (b += l[w + _u]);
        }
        if (b > y && b >= a) {
          var M = d * y, O = g * y, v = void 0, x = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + zc] <= n)) {
              l[L + zc] = n;
              var N = l[L + _u];
              M += l[L] * N, O += l[L + 1] * N, l[L + kP] = _, i && (v || (v = this._map(l, p, !0), x = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + kP] = _, u.push(M / b, O / b, 1 / 0, _, -1, b), i && u.push(x);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var Z = V * c;
              if (!(l[Z + zc] <= n)) {
                l[Z + zc] = n;
                for (var H = 0; H < c; H++) u.push(l[Z + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + _u] > 1) {
      var o = this.clusterProps[t[n + gce]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Ru]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function vZ(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Ru],
    properties: mce(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [N7e(e[t]), F7e(e[t + 1])]
    }
  };
}
function mce(e, t, n) {
  var r = e[t + _u], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + gce], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Ru],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Pb(e) {
  return e / 360 + 0.5;
}
function _b(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function N7e(e) {
  return (e - 0.5) * 360;
}
function F7e(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function z7e(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class $s {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class PD {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend($s.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => $s.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && ($s.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class U7e {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return H7e(n);
  }
}
var H7e = (e) => {
  var t = e.map((n) => new PD({
    position: $s.getPosition(n),
    markers: [n]
  }));
  return t;
};
class W7e extends U7e {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = z7e(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new R7e(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!fZ(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = $s.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !fZ(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new PD({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new PD({
      markers: [i],
      position: $s.getPosition(i)
    });
  }
}
class V7e {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class $7e {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if ($s.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function Z7e(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class wB {
  constructor() {
    Z7e(wB, google.maps.OverlayView);
  }
}
var Jh;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Jh || (Jh = {}));
var q7e = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class G7e extends wB {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new W7e(o),
      renderer: a = new $7e(),
      onClusterClick: s = q7e
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : ($s.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Jh.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || $s.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => $s.setMap(l, null)));
      }
      google.maps.event.trigger(this, Jh.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => $s.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new V7e(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => $s.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Jh.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), $s.setMap(r.marker, n);
    });
  }
}
function yZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bZ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function K7e(e) {
  var t = qqe(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new G7e(bZ(bZ({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Y7e(e) {
  var {
    children: t,
    options: n
  } = e, r = K7e(n);
  return r !== null ? t(r) : null;
}
me(Y7e);
var wZ = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, CZ = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function X7e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge($t), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return y(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && v(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : hi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(R), R.close();
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(X7e);
class J7e extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "containerElement", null), Ie(this, "state", {
      infoWindow: null
    }), Ie(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : hi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Ie(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = _n({
      updaterMap: CZ,
      eventMap: wZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: CZ,
      eventMap: wZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Fn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
Ie(J7e, "contextType", $t);
function xZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _C(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var OZ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, EZ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Q7e = {};
function eGe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge($t), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && y && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(O, "click", y)));
  }, [y]), h(() => {
    O && b && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(O, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(_C(_C({}, t || Q7e), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && Z(google.maps.event.addListener(T, "mousedown", u)), c && $(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), y && C(google.maps.event.addListener(T, "click", y)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(eGe);
class tGe extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      polyline: null
    }), Ie(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(_C(_C({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: EZ,
      eventMap: OZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: EZ,
      eventMap: OZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Fn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(tGe, "contextType", $t);
function kZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function LZ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PZ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, _Z = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function nGe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, v = ge($t), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    x !== null && x.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    typeof a < "u" && x !== null && x.setPaths(a);
  }, [x, a]), h(() => {
    x && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dblclick", s)));
  }, [s]), h(() => {
    x && (google.maps.event.addListener(x.getPath(), "insert_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "set_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "remove_at", () => {
      O == null || O(x);
    }));
  }, [x, O]), h(() => {
    x && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragend", l)));
  }, [l]), h(() => {
    x && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(x, "dragstart", u)));
  }, [u]), h(() => {
    x && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(x, "mousedown", c)));
  }, [c]), h(() => {
    x && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(x, "mousemove", p)));
  }, [p]), h(() => {
    x && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseout", d)));
  }, [d]), h(() => {
    x && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(x, "mouseover", g)));
  }, [g]), h(() => {
    x && typeof f == "function" && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(x, "mouseup", f)));
  }, [f]), h(() => {
    x && typeof y == "function" && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(x, "rightclick", y)));
  }, [y]), h(() => {
    x && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(x, "click", b)));
  }, [b]), h(() => {
    x && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(x, "drag", E)));
  }, [E]), h(() => {
    var j = new google.maps.Polygon(LZ(LZ({}, t), {}, {
      map: v
    }));
    return i && j.setPath(i), a && j.setPaths(a), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), s && L(google.maps.event.addListener(j, "dblclick", s)), l && R(google.maps.event.addListener(j, "dragend", l)), u && Z(google.maps.event.addListener(j, "dragstart", u)), c && $(google.maps.event.addListener(j, "mousedown", c)), p && X(google.maps.event.addListener(j, "mousemove", p)), d && J(google.maps.event.addListener(j, "mouseout", d)), g && D(google.maps.event.addListener(j, "mouseover", g)), f && S(google.maps.event.addListener(j, "mouseup", f)), y && C(google.maps.event.addListener(j, "rightclick", y)), b && U(google.maps.event.addListener(j, "click", b)), E && q(google.maps.event.addListener(j, "drag", E)), _(j), w && w(j), () => {
      z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), M && M(j), j.setMap(null);
    };
  }, []), null;
}
me(nGe);
class rGe extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = _n({
      updaterMap: _Z,
      eventMap: PZ,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: _Z,
      eventMap: PZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Fn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(rGe, "contextType", $t);
function SZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function SC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var MZ = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, DZ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function oGe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge($t), [v, x] = k(null), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null);
  return h(() => {
    v !== null && v.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(v, "click", y)));
  }, [y]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(SC(SC({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && z(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && H(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && F(google.maps.event.addListener(Y, "mouseup", g)), f && W(google.maps.event.addListener(Y, "rightclick", f)), y && I(google.maps.event.addListener(Y, "click", y)), b && T(google.maps.event.addListener(Y, "drag", b)), E && j(google.maps.event.addListener(Y, "bounds_changed", E)), x(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
me(oGe);
class iGe extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      rectangle: null
    }), Ie(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(SC(SC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: DZ,
      eventMap: MZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: DZ,
      eventMap: MZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Fn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(iGe, "contextType", $t);
function TZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function MC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jZ = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, AZ = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, sGe = {};
function aGe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: v
  } = e, x = ge($t), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null);
  return h(() => {
    _ !== null && _.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(_, "rightclick", y)));
  }, [y]), h(() => {
    _ && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", b)));
  }, [b]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [b]), h(() => {
    _ && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(MC(MC({}, t || sGe), {}, {
      map: x
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && F(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), y && I(google.maps.event.addListener(oe, "rightclick", y)), b && T(google.maps.event.addListener(oe, "click", b)), E && j(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), z(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(aGe);
class lGe extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      circle: null
    }), Ie(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(MC(MC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: AZ,
      eventMap: jZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: AZ,
      eventMap: jZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Fn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Ie(lGe, "contextType", $t);
function IZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function DC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var BZ = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, RZ = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function uGe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: y,
    onUnmount: b
  } = e, E = ge($t), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var j = new google.maps.Data(DC(DC({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(j, "dblclick", r)), o && _(google.maps.event.addListener(j, "mousedown", o)), i && L(google.maps.event.addListener(j, "mousemove", i)), a && R(google.maps.event.addListener(j, "mouseout", a)), s && Z(google.maps.event.addListener(j, "mouseover", s)), l && $(google.maps.event.addListener(j, "mouseup", l)), u && X(google.maps.event.addListener(j, "rightclick", u)), n && J(google.maps.event.addListener(j, "click", n)), c && D(google.maps.event.addListener(j, "addfeature", c)), p && S(google.maps.event.addListener(j, "removefeature", p)), d && C(google.maps.event.addListener(j, "removeproperty", d)), g && U(google.maps.event.addListener(j, "setgeometry", g)), f && q(google.maps.event.addListener(j, "setproperty", f)), M(j), y && y(j);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(uGe);
class cGe extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      data: null
    }), Ie(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(DC(DC({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = _n({
        updaterMap: RZ,
        eventMap: BZ,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: RZ,
      eventMap: BZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Fn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(cGe, "contextType", $t);
function NZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function FZ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zZ = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, UZ = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class pGe extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      kmlLayer: null
    }), Ie(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(FZ(FZ({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: UZ,
      eventMap: zZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: UZ,
      eventMap: zZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Fn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(pGe, "contextType", $t);
function vce(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function dGe(e, t) {
  return new t(e.lat, e.lng);
}
function fGe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function hGe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function gGe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function mGe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function vGe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function yce(e, t, n, r) {
  return n !== void 0 ? mGe(e, t, gGe(n, google.maps.LatLngBounds, fGe)) : vGe(e, t, hGe(r, google.maps.LatLng, dGe));
}
function yGe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function HZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bGe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function wGe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = bGe({}, this.container ? vce(this.container, o) : {
        x: 0,
        y: 0
      }), u = yce(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function WZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function CGe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function VZ(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function $Z(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function xGe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge($t), c = Ft(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Ft(() => wGe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), xi.createPortal(l, c);
}
me(xGe);
class rf extends pe {
  constructor(t) {
    super(t), Ie(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Ie(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      hi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Ie(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Ie(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = CGe({
        x: 0,
        y: 0
      }, this.containerRef.current ? vce(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = yce(r, o, this.props.bounds, this.props.position);
      if (!yGe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Ie(this, "draw", () => {
      this.onPositionElement();
    }), Ie(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Br();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = VZ(t.position), r = VZ(this.props.position), o = $Z(t.bounds), i = $Z(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? xi.createPortal(Ti.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
Ie(rf, "FLOAT_PANE", "floatPane");
Ie(rf, "MAP_PANE", "mapPane");
Ie(rf, "MARKER_LAYER", "markerLayer");
Ie(rf, "OVERLAY_LAYER", "overlayLayer");
Ie(rf, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Ie(rf, "contextType", $t);
function OGe() {
}
function ZZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qZ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GZ = {
  onDblClick: "dblclick",
  onClick: "click"
}, KZ = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function EGe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge($t), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Ft(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(EGe);
class bce extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      groundOverlay: null
    }), Ie(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    hi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, qZ(qZ({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: KZ,
      eventMap: GZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: KZ,
      eventMap: GZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(bce, "defaultProps", {
  onLoad: OGe
});
Ie(bce, "contextType", $t);
function YZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function TC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YZ(Object(n), !0).forEach(function(r) {
      Ie(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var XZ = {}, JZ = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function kGe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge($t), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || hi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    hi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(TC(TC({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(kGe);
class LGe extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      heatmapLayer: null
    }), Ie(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    hi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), hi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(TC(TC({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = _n({
      updaterMap: JZ,
      eventMap: XZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: JZ,
      eventMap: XZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Fn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(LGe, "contextType", $t);
var QZ = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, eq = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class PGe extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      streetViewPanorama: null
    }), Ie(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = _n({
      updaterMap: eq,
      eventMap: QZ,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: eq,
      eventMap: QZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Fn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Ie(PGe, "contextType", $t);
class _Ge extends pe {
  constructor() {
    super(...arguments), Ie(this, "state", {
      streetViewService: null
    }), Ie(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Ie(_Ge, "contextType", $t);
var tq = {
  onDirectionsChanged: "directions_changed"
}, nq = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class SGe extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "state", {
      directionsRenderer: null
    }), Ie(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = _n({
      updaterMap: nq,
      eventMap: tq,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: nq,
      eventMap: tq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Fn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Ie(SGe, "contextType", $t);
var rq = {
  onPlacesChanged: "places_changed"
}, oq = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class MGe extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "containerElement", Br()), Ie(this, "state", {
      searchBox: null
    }), Ie(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (hi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = _n({
          updaterMap: oq,
          eventMap: rq,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: oq,
      eventMap: rq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Fn(this.registeredEvents));
  }
  render() {
    return Ti.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
Ie(MGe, "contextType", $t);
var iq = {
  onPlaceChanged: "place_changed"
}, sq = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class wce extends pe {
  constructor() {
    super(...arguments), Ie(this, "registeredEvents", []), Ie(this, "containerElement", Br()), Ie(this, "state", {
      autocomplete: null
    }), Ie(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    hi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = _n({
        updaterMap: sq,
        eventMap: iq,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Fn(this.registeredEvents), this.registeredEvents = _n({
      updaterMap: sq,
      eventMap: iq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Fn(this.registeredEvents);
  }
  render() {
    return Ti.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
Ie(wce, "defaultProps", {
  className: ""
});
Ie(wce, "contextType", $t);
let DGe = { data: "" }, TGe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || DGe, jGe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, AGe = /\/\*[^]*?\*\/|  +/g, aq = /\n+/g, Gu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Gu(a, i) : i + "{" + Gu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Gu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Gu.p ? Gu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, kl = {}, Cce = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Cce(e[n]);
    return t;
  }
  return e;
}, IGe = (e, t, n, r, o) => {
  let i = Cce(e), a = kl[i] || (kl[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!kl[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = jGe.exec(u.replace(AGe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(aq, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(aq, " ").trim();
      return d[0];
    })(e);
    kl[a] = Gu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && kl.g ? kl.g : null;
  return n && (kl.g = kl[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(kl[a], t, r, s), a;
}, BGe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Gu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function ak(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return IGe(n.unshift ? n.raw ? BGe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, TGe(t.target), t.g, t.o, t.k);
}
let xce, _D, SD;
ak.bind({ g: 1 });
let Vl = ak.bind({ k: 1 });
function RGe(e, t, n, r) {
  Gu.p = t, xce = e, _D = n, SD = r;
}
function kc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: _D && _D() }, s), n.o = / *go\d+/.test(l), s.className = ak.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), SD && u[0] && SD(s), xce(u, s);
    }
    return o;
  };
}
var NGe = (e) => typeof e == "function", FGe = (e, t) => NGe(e) ? e(t) : e, zGe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), UGe = Vl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, HGe = Vl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, WGe = Vl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, VGe = kc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${UGe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${HGe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${WGe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, $Ge = Vl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, ZGe = kc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${$Ge} 1s linear infinite;
`, qGe = Vl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, GGe = Vl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, KGe = kc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${qGe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${GGe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, YGe = kc("div")`
  position: absolute;
`, XGe = kc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, JGe = Vl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, QGe = kc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${JGe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, eKe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Me.createElement(QGe, null, t) : t : n === "blank" ? null : Me.createElement(XGe, null, Me.createElement(ZGe, { ...r }), n !== "loading" && Me.createElement(YGe, null, n === "error" ? Me.createElement(VGe, { ...r }) : Me.createElement(KGe, { ...r })));
}, tKe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, nKe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, rKe = "0%{opacity:0;} 100%{opacity:1;}", oKe = "0%{opacity:1;} 100%{opacity:0;}", iKe = kc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, sKe = kc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, aKe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = zGe() ? [rKe, oKe] : [tKe(n), nKe(n)];
  return { animation: t ? `${Vl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Vl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Me.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? aKe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Me.createElement(eKe, { toast: e }), a = Me.createElement(sKe, { ...e.ariaProps }, FGe(e.message, e));
  return Me.createElement(iKe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Me.createElement(Me.Fragment, null, i, a));
});
RGe(Me.createElement);
ak`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
We({});
function lKe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const uKe = {
  CNPJ: "99.999.999/9999-99"
};
lKe(uKe.CNPJ).length;
yr((e, t) => /* @__PURE__ */ Di.jsx("input", { ref: t, ...e }));
function Oce(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Ece = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function cKe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function pKe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const dKe = Oce(Ece.NINE).length, fKe = yr((e, t) => /* @__PURE__ */ Di.jsx("input", { ref: t, ...e }));
yr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = Oce(g.target.value);
      const y = pKe(f);
      f.length > dKe || (f = cKe(f, Ece[y]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Di.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Di.jsx(
      tl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: fKe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
We({});
var tu = {};
Object.defineProperty(tu, "__esModule", {
  value: !0
});
var hKe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), LP = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, kce = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: hKe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, CB = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Sb = 1; Sb < 20; Sb++)
  CB["f" + Sb] = 111 + Sb;
function lk(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Lce(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Pce(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function gKe(e, t) {
  return lk(e, t);
}
function mKe(e, t) {
  return lk(e, { byKey: !0 }, t);
}
function Lce(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in LP)
    r[LP[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = xB(d), y = LP[f];
      if (d.length > 1 && !y && !kce[d] && !CB[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !y) && (n ? r.key = f : r.which = _ce(d)), y && (r[y] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Pce(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function _ce(e) {
  e = xB(e);
  var t = CB[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function xB(e) {
  return e = e.toLowerCase(), e = kce[e] || e, e;
}
tu.default = lk;
var PP = tu.isHotkey = lk;
tu.isCodeHotkey = gKe;
tu.isKeyHotkey = mKe;
tu.parseHotkey = Lce;
tu.compareHotkey = Pce;
tu.toKeyCode = _ce;
tu.toKeyName = xB;
var vKe = typeof Mr == "object" && Mr && Mr.Object === Object && Mr, yKe = vKe, bKe = yKe, wKe = typeof self == "object" && self && self.Object === Object && self, CKe = bKe || wKe || Function("return this")(), xKe = CKe, OKe = xKe, EKe = OKe.Symbol, Sce = EKe, lq = Sce;
lq && lq.toStringTag;
var uq = Sce;
uq && uq.toStringTag;
var cq;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(cq || (cq = {}));
var OB = function(e) {
  return Object.freeze(e);
}, kKe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, OB(this);
  }
  return e;
}(), LKe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, OB(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), pq = typeof window < "u" ? window : {};
/msie|trident/i.test(pq.navigator && pq.navigator.userAgent);
var _P = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new kKe((n ? t : e) || 0, (n ? e : t) || 0);
};
OB({
  devicePixelContentBoxSize: _P(),
  borderBoxSize: _P(),
  contentBoxSize: _P(),
  contentRect: new LKe(0, 0, 0, 0)
});
function pm(e) {
  "@babel/helpers - typeof";
  return pm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, pm(e);
}
function PKe(e, t) {
  if (pm(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (pm(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function _Ke(e) {
  var t = PKe(e, "string");
  return pm(t) === "symbol" ? t : String(t);
}
function Qh(e, t, n) {
  return t = _Ke(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var SKe = /* @__PURE__ */ We(null), SP, MP;
parseInt(we.version.split(".")[0], 10);
var dq = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), DP = typeof navigator < "u" && /Android/.test(navigator.userAgent), Mb = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), MKe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (SP = navigator.userAgent.match(/Version\/(\d+)/)) !== null && SP !== void 0 && SP[1] && parseInt((MP = navigator.userAgent.match(/Version\/(\d+)/)) === null || MP === void 0 ? void 0 : MP[1], 10) < 17;
var DKe = /* @__PURE__ */ new WeakMap(), TKe = /* @__PURE__ */ new WeakMap(), jKe = /* @__PURE__ */ new WeakMap(), AKe = /* @__PURE__ */ new WeakMap(), IKe = /* @__PURE__ */ new WeakMap(), fq = /* @__PURE__ */ new WeakMap(), BKe = /* @__PURE__ */ new WeakMap(), hq = /* @__PURE__ */ new WeakMap(), Db = /* @__PURE__ */ new WeakMap(), RKe = /* @__PURE__ */ new WeakMap(), NKe = /* @__PURE__ */ new WeakMap(), FKe = /* @__PURE__ */ new WeakMap(), Mce = globalThis.Node, zKe = globalThis.Text, Dce = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, UKe = (e) => jC(e) && e.nodeType === 8, Xa = (e) => jC(e) && e.nodeType === 1, jC = (e) => {
  var t = Dce(e);
  return !!t && e instanceof t.Node;
}, gq = (e) => {
  var t = e && e.anchorNode && Dce(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, HKe = (e) => {
  var [t, n] = e;
  if (Xa(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Tce(t, o, r ? "backward" : "forward"), r = o < n; Xa(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = VKe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, WKe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Tce = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (UKe(o) || Xa(o) && o.childNodes.length === 0 || Xa(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, VKe = (e, t, n) => {
  var [r] = Tce(e, t, n);
  return r;
}, mq = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), jce = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Xa(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Cn.getWindow(e);
  if (o.contains(r))
    return Cn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : jce(e, i, n);
}, vq = (e, t) => !!(e.compareDocumentPosition(t) & Mce.DOCUMENT_POSITION_PRECEDING), $Ke = (e, t) => !!(e.compareDocumentPosition(t) & Mce.DOCUMENT_POSITION_FOLLOWING), ZKe = 0;
class qKe {
  constructor() {
    Qh(this, "id", void 0), this.id = "".concat(ZKe++);
  }
}
var Cn = {
  androidPendingDiffs: (e) => FKe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = NKe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Cn.toDOMNode(e, e), n = Cn.findDocumentOrShadowRoot(e);
    Db.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Cn.findDocumentOrShadowRoot(e), r = mq(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && i0.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Cn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Cn.toSlateNode(e, t.target), a = Cn.findPath(e, i);
    if (Tl.isElement(i) && Cr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Cr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Cr.before(e, u) : Cr.after(e, u);
      if (c) {
        var p = Cr.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = Cn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var y = Cn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return y;
  },
  findKey: (e, t) => {
    var n = fq.get(t);
    return n || (n = new qKe(), fq.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = TKe.get(r);
      if (o == null) {
        if (Cr.isEditor(r))
          return n;
        break;
      }
      var i = DKe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Is.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Db.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Cn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Cn.toDOMNode(e, e), r = Cn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = mq(r), i = Cn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || i0.select(e, Cr.start(e, [])), Db.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = jKe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Cn.toDOMNode(e, e), i;
    try {
      i = Xa(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => jC(t) && Cn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Cr.hasPath(e, n.path) && Cr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Cn.hasEditableTarget(e, t) || Cn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => jC(t) && Cn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!RKe.get(e),
  isFocused: (e) => !!Db.get(e),
  isReadOnly: (e) => !!hq.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (hq.get(e)) return !1;
    var n = Cn.hasTarget(e, t) && Cn.toSlateNode(e, t);
    return Tl.isElement(n) && Cr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = BKe.get(e), r = Cr.isEditor(t) ? AKe.get(e) : n == null ? void 0 : n.get(Cn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Is.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Cr.node(e, t.path), r = Cn.toDOMNode(e, n), o;
    Cr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, y = a[l + 1];
        if (t.offset === f && y !== null && y !== void 0 && y.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = y.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof zKe ? E : y,
            (b = y.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Is.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Jt.isBackward(t), i = Cn.toDOMPoint(e, n), a = Jt.isCollapsed(t) ? i : Cn.toDOMPoint(e, r), s = Cn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Xa(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), y = Xa(p) ? p : p.parentElement, b = !!y.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Xa(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? IKe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : HKe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = Cn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), y = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = Cn.getWindow(e), v = O.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var x = v.cloneContents(), _ = [...Array.prototype.slice.call(x.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(x.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (DP && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = x.textContent.length, M = u;
        }
      } else if (y) {
        for (var z = y.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var N = z[L];
          if (Cn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var Z, H = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = (Z = H.find((S) => $Ke(E, S))) !== null && Z !== void 0 ? Z : null;
        } else {
          var $, K = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = ($ = K.findLast((S) => vq(E, S))) !== null && $ !== void 0 ? $ : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      DP && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Mb && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (DP && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && Cn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var Q = Cn.toSlateNode(e, X), {
          path: J,
          offset: P
        } = Cr.start(e, Cn.findPath(e, Q));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = Cn.toSlateNode(e, u), F = Cn.findPath(e, D);
    return {
      path: F,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = gq(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (gq(t)) {
        if (Mb && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let x = function(_) {
              return _.childElementCount > 0 ? x(_.children[0]) : _;
            };
            var f = d.startContainer, y = g.startContainer, b = x(f.children[d.startOffset]), E = x(y.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        MKe && WKe(s) || Mb ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Mb && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Cn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = vq(s, u) || s === u && c < l, O = p ? w : Cn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var v = {
      anchor: w,
      focus: O
    };
    return Jt.isExpanded(v) && Jt.isForward(v) && Xa(u) && Cr.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = Cr.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, GKe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, KKe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, YKe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, wo = (e) => {
  var t = GKe[e], n = KKe[e], r = YKe[e], o = t && PP(t), i = n && PP(n), a = r && PP(r);
  return (s) => !!(o && o(s) || dq && i && i(s) || !dq && a && a(s));
};
wo("bold"), wo("compose"), wo("moveBackward"), wo("moveForward"), wo("deleteBackward"), wo("deleteForward"), wo("deleteLineBackward"), wo("deleteLineForward"), wo("deleteWordBackward"), wo("deleteWordForward"), wo("extendBackward"), wo("extendForward"), wo("extendLineBackward"), wo("extendLineForward"), wo("italic"), wo("moveLineBackward"), wo("moveLineForward"), wo("moveWordBackward"), wo("moveWordForward"), wo("redo"), wo("insertSoftBreak"), wo("splitBlock"), wo("transposeCharacter"), wo("undo");
var XKe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => jce(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, JKe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class QKe extends Kl {
  constructor() {
    super(...arguments), Qh(this, "context", null), Qh(this, "manager", null), Qh(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, JKe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = XKe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Qh(QKe, "contextType", SKe);
We({});
We({});
We({});
var si = {}, EB = {}, ov = {}, iv = {}, Ace = "Expected a function", yq = NaN, eYe = "[object Symbol]", tYe = /^\s+|\s+$/g, nYe = /^[-+]0x[0-9a-f]+$/i, rYe = /^0b[01]+$/i, oYe = /^0o[0-7]+$/i, iYe = parseInt, sYe = typeof Mr == "object" && Mr && Mr.Object === Object && Mr, aYe = typeof self == "object" && self && self.Object === Object && self, lYe = sYe || aYe || Function("return this")(), uYe = Object.prototype, cYe = uYe.toString, pYe = Math.max, dYe = Math.min, TP = function() {
  return lYe.Date.now();
};
function fYe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Ace);
  t = bq(t) || 0, AC(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? pYe(bq(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(x) {
    var _ = r, z = o;
    return r = o = void 0, u = x, a = e.apply(z, _), a;
  }
  function f(x) {
    return u = x, s = setTimeout(E, t), c ? g(x) : a;
  }
  function y(x) {
    var _ = x - l, z = x - u, L = t - _;
    return p ? dYe(L, i - z) : L;
  }
  function b(x) {
    var _ = x - l, z = x - u;
    return l === void 0 || _ >= t || _ < 0 || p && z >= i;
  }
  function E() {
    var x = TP();
    if (b(x))
      return w(x);
    s = setTimeout(E, y(x));
  }
  function w(x) {
    return s = void 0, d && r ? g(x) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(TP());
  }
  function v() {
    var x = TP(), _ = b(x);
    if (r = arguments, o = this, l = x, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = O, v;
}
function hYe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Ace);
  return AC(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), fYe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function AC(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function gYe(e) {
  return !!e && typeof e == "object";
}
function mYe(e) {
  return typeof e == "symbol" || gYe(e) && cYe.call(e) == eYe;
}
function bq(e) {
  if (typeof e == "number")
    return e;
  if (mYe(e))
    return yq;
  if (AC(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = AC(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(tYe, "");
  var n = rYe.test(e);
  return n || oYe.test(e) ? iYe(e.slice(2), n ? 2 : 8) : nYe.test(e) ? yq : +e;
}
var vYe = hYe, sv = {};
Object.defineProperty(sv, "__esModule", {
  value: !0
});
sv.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Mw.has(t) || Mw.set(t, /* @__PURE__ */ new Set());
  var o = Mw.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
sv.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Mw.get(t).delete(n.name || t);
};
var Mw = /* @__PURE__ */ new Map();
Object.defineProperty(iv, "__esModule", {
  value: !0
});
var yYe = vYe, bYe = wYe(yYe), wq = sv;
function wYe(e) {
  return e && e.__esModule ? e : { default: e };
}
var CYe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, bYe.default)(e, t);
}, Ao = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = CYe(function(r) {
        Ao.scrollHandler(e);
      }, t);
      return Ao.scrollSpyContainers.push(e), (0, wq.addPassiveEventListener)(e, "scroll", n), function() {
        (0, wq.removePassiveEventListener)(e, "scroll", n), Ao.scrollSpyContainers.splice(Ao.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Ao.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Ao.scrollSpyContainers[Ao.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Ao.currentPositionX(e), Ao.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Ao.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Ao.scrollSpyContainers[Ao.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Ao.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Ao.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Ao.spySetState && Ao.spySetState.length && Ao.spySetState.indexOf(e) > -1 && Ao.spySetState.splice(Ao.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Ao.scrollHandler);
  },
  update: function() {
    return Ao.scrollSpyContainers.forEach(function(e) {
      return Ao.scrollHandler(e);
    });
  }
};
iv.default = Ao;
var of = {}, av = {};
Object.defineProperty(av, "__esModule", {
  value: !0
});
var xYe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, OYe = function() {
  return window.location.hash.replace(/^#/, "");
}, EYe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, kYe = function(e) {
  return getComputedStyle(e).position !== "static";
}, jP = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, LYe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (kYe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = jP(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return jP(t, s).offsetTop - jP(e, s).offsetTop;
};
av.default = {
  updateHash: xYe,
  getHash: OYe,
  filterElementInContainer: EYe,
  scrollOffset: LYe
};
var uk = {}, kB = {};
Object.defineProperty(kB, "__esModule", {
  value: !0
});
kB.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var LB = {};
Object.defineProperty(LB, "__esModule", {
  value: !0
});
var PYe = sv, _Ye = ["mousedown", "wheel", "touchmove", "keydown"];
LB.default = {
  subscribe: function(e) {
    return typeof document < "u" && _Ye.forEach(function(t) {
      return (0, PYe.addPassiveEventListener)(document, t, e);
    });
  }
};
var lv = {};
Object.defineProperty(lv, "__esModule", {
  value: !0
});
var MD = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      MD.registered[e] = t;
    },
    remove: function(e) {
      MD.registered[e] = null;
    }
  }
};
lv.default = MD;
Object.defineProperty(uk, "__esModule", {
  value: !0
});
var SYe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, MYe = av;
ck(MYe);
var DYe = kB, Cq = ck(DYe), TYe = LB, jYe = ck(TYe), AYe = lv, Ha = ck(AYe);
function ck(e) {
  return e && e.__esModule ? e : { default: e };
}
var Ice = function(e) {
  return Cq.default[e.smooth] || Cq.default.defaultEasing;
}, IYe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, BYe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, DD = function() {
  return BYe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Bce = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Rce = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Nce = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, RYe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, NYe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, FYe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Ha.default.registered.end && Ha.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    DD.call(window, i);
    return;
  }
  Ha.default.registered.end && Ha.default.registered.end(o.to, o.target, o.currentPosition);
}, PB = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, uv = function(e, t, n, r) {
  t.data = t.data || Bce(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (jYe.default.subscribe(o), PB(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Rce(t) : Nce(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Ha.default.registered.end && Ha.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = IYe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Ice(t), a = FYe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Ha.default.registered.begin && Ha.default.registered.begin(t.data.to, t.data.target), DD.call(window, a);
    }, t.delay);
    return;
  }
  Ha.default.registered.begin && Ha.default.registered.begin(t.data.to, t.data.target), DD.call(window, a);
}, pk = function(e) {
  return e = SYe({}, e), e.data = e.data || Bce(), e.absolute = !0, e;
}, zYe = function(e) {
  uv(0, pk(e));
}, UYe = function(e, t) {
  uv(e, pk(t));
}, HYe = function(e) {
  e = pk(e), PB(e), uv(e.horizontal ? RYe(e) : NYe(e), e);
}, WYe = function(e, t) {
  t = pk(t), PB(t);
  var n = t.horizontal ? Rce(t) : Nce(t);
  uv(e + n, t);
};
uk.default = {
  animateTopScroll: uv,
  getAnimationType: Ice,
  scrollToTop: zYe,
  scrollToBottom: HYe,
  scrollTo: UYe,
  scrollMore: WYe
};
Object.defineProperty(of, "__esModule", {
  value: !0
});
var VYe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, $Ye = av, ZYe = _B($Ye), qYe = uk, GYe = _B(qYe), KYe = lv, Tb = _B(KYe);
function _B(e) {
  return e && e.__esModule ? e : { default: e };
}
var jb = {}, xq = void 0;
of.default = {
  unmount: function() {
    jb = {};
  },
  register: function(e, t) {
    jb[e] = t;
  },
  unregister: function(e) {
    delete jb[e];
  },
  get: function(e) {
    return jb[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return xq = e;
  },
  getActiveLink: function() {
    return xq;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = VYe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = ZYe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Tb.default.registered.begin && Tb.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Tb.default.registered.end && Tb.default.registered.end(e, n);
      return;
    }
    GYe.default.animateTopScroll(s, t, e, n);
  }
};
var TD = { exports: {} }, AP = { exports: {} }, or = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Oq;
function YYe() {
  if (Oq) return or;
  Oq = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function O(v) {
    return M(v) === u;
  }
  return or.AsyncMode = l, or.ConcurrentMode = u, or.ContextConsumer = s, or.ContextProvider = a, or.Element = t, or.ForwardRef = c, or.Fragment = r, or.Lazy = f, or.Memo = g, or.Portal = n, or.Profiler = i, or.StrictMode = o, or.Suspense = p, or.isAsyncMode = function(v) {
    return O(v) || M(v) === l;
  }, or.isConcurrentMode = O, or.isContextConsumer = function(v) {
    return M(v) === s;
  }, or.isContextProvider = function(v) {
    return M(v) === a;
  }, or.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, or.isForwardRef = function(v) {
    return M(v) === c;
  }, or.isFragment = function(v) {
    return M(v) === r;
  }, or.isLazy = function(v) {
    return M(v) === f;
  }, or.isMemo = function(v) {
    return M(v) === g;
  }, or.isPortal = function(v) {
    return M(v) === n;
  }, or.isProfiler = function(v) {
    return M(v) === i;
  }, or.isStrictMode = function(v) {
    return M(v) === o;
  }, or.isSuspense = function(v) {
    return M(v) === p;
  }, or.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === y);
  }, or.typeOf = M, or;
}
var gr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Eq;
function XYe() {
  return Eq || (Eq = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === E || B.$$typeof === w || B.$$typeof === y);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, x = u, _ = s, z = a, L = t, N = c, R = r, V = f, Z = g, H = n, $ = i, K = o, X = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function F(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return O(B) === c;
    }
    function C(B) {
      return O(B) === r;
    }
    function I(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function j(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    gr.AsyncMode = v, gr.ConcurrentMode = x, gr.ContextConsumer = _, gr.ContextProvider = z, gr.Element = L, gr.ForwardRef = N, gr.Fragment = R, gr.Lazy = V, gr.Memo = Z, gr.Portal = H, gr.Profiler = $, gr.StrictMode = K, gr.Suspense = X, gr.isAsyncMode = J, gr.isConcurrentMode = P, gr.isContextConsumer = D, gr.isContextProvider = F, gr.isElement = S, gr.isForwardRef = W, gr.isFragment = C, gr.isLazy = I, gr.isMemo = U, gr.isPortal = T, gr.isProfiler = q, gr.isStrictMode = j, gr.isSuspense = Y, gr.isValidElementType = M, gr.typeOf = O;
  }()), gr;
}
var kq;
function Fce() {
  return kq || (kq = 1, process.env.NODE_ENV === "production" ? AP.exports = YYe() : AP.exports = XYe()), AP.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var IP, Lq;
function JYe() {
  if (Lq) return IP;
  Lq = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return IP = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, IP;
}
var BP, Pq;
function SB() {
  if (Pq) return BP;
  Pq = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return BP = e, BP;
}
var _q, Sq;
function zce() {
  return Sq || (Sq = 1, _q = Function.call.bind(Object.prototype.hasOwnProperty)), _q;
}
var RP, Mq;
function QYe() {
  if (Mq) return RP;
  Mq = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = SB(), n = {}, r = zce();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, RP = o, RP;
}
var NP, Dq;
function eXe() {
  if (Dq) return NP;
  Dq = 1;
  var e = Fce(), t = JYe(), n = SB(), r = zce(), o = QYe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return NP = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: v(),
      instanceOf: x,
      node: N(),
      objectOf: z,
      oneOf: _,
      oneOfType: L,
      shape: V,
      exact: Z
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function y(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    y.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, F = 0;
      function S(C, I, U, T, q, j, Y) {
        if (T = T || d, j = j || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            F < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + j + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, F++);
          }
        }
        return I[U] == null ? C ? I[U] === null ? new y("The " + q + " `" + j + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new y("The " + q + " `" + j + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(I, U, T, q, j);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(P) {
      function D(F, S, W, C, I, U) {
        var T = F[S], q = K(T);
        if (q !== P) {
          var j = X(T);
          return new y(
            "Invalid " + C + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = F[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var j = P(U, q, W, C, I + "[" + q + "]", n);
          if (j instanceof Error)
            return j;
        }
        return null;
      }
      return b(D);
    }
    function O() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!s(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function v() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!e.isValidElementType(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function x(P) {
      function D(F, S, W, C, I) {
        if (!(F[S] instanceof P)) {
          var U = P.name || d, T = J(F[S]);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(F, S, W, C, I) {
        for (var U = F[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(j, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new y("Invalid " + C + " `" + I + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function z(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var j = P(U, q, W, C, I + "." + q, n);
            if (j instanceof Error)
              return j;
          }
        return null;
      }
      return b(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var F = P[D];
        if (typeof F != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(F) + " at index " + D + "."
          ), a;
      }
      function S(W, C, I, U, T) {
        for (var q = [], j = 0; j < P.length; j++) {
          var Y = P[j], B = Y(W, C, I, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new y("Invalid " + U + " `" + T + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(S);
    }
    function N() {
      function P(D, F, S, W, C) {
        return H(D[F]) ? null : new y("Invalid " + W + " `" + C + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, D, F, S, W) {
      return new y(
        (P || "React class") + ": " + D + " type `" + F + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var j = P[q];
          if (typeof j != "function")
            return R(W, C, I, q, X(j));
          var Y = j(U, q, W, C, I + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(D);
    }
    function Z(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, F[S], P);
        for (var j in q) {
          var Y = P[j];
          if (r(P, j) && typeof Y != "function")
            return R(W, C, I, j, X(Y));
          if (!Y)
            return new y(
              "Invalid " + C + " `" + I + "` key `" + j + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(F[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, j, W, C, I + "." + j, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(D);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var F = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = F.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = F.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function $(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : $(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, NP;
}
var FP, Tq;
function tXe() {
  if (Tq) return FP;
  Tq = 1;
  var e = SB();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, FP = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, FP;
}
if (process.env.NODE_ENV !== "production") {
  var nXe = Fce(), rXe = !0;
  TD.exports = eXe()(nXe.isElement, rXe);
} else
  TD.exports = tXe()();
var dk = TD.exports, fk = {};
Object.defineProperty(fk, "__esModule", {
  value: !0
});
var oXe = av, zP = iXe(oXe);
function iXe(e) {
  return e && e.__esModule ? e : { default: e };
}
var sXe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return zP.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && zP.default.getHash() !== e && zP.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
fk.default = sXe;
Object.defineProperty(ov, "__esModule", {
  value: !0
});
var Ab = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, aXe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), lXe = we, jq = cv(lXe), uXe = iv, Ib = cv(uXe), cXe = of, pXe = cv(cXe), dXe = dk, Co = cv(dXe), fXe = fk, gu = cv(fXe);
function cv(e) {
  return e && e.__esModule ? e : { default: e };
}
function hXe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function gXe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function mXe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Aq = {
  to: Co.default.string.isRequired,
  containerId: Co.default.string,
  container: Co.default.object,
  activeClass: Co.default.string,
  activeStyle: Co.default.object,
  spy: Co.default.bool,
  horizontal: Co.default.bool,
  smooth: Co.default.oneOfType([Co.default.bool, Co.default.string]),
  offset: Co.default.number,
  delay: Co.default.number,
  isDynamic: Co.default.bool,
  onClick: Co.default.func,
  duration: Co.default.oneOfType([Co.default.number, Co.default.func]),
  absolute: Co.default.bool,
  onSetActive: Co.default.func,
  onSetInactive: Co.default.func,
  ignoreCancelEvents: Co.default.bool,
  hashSpy: Co.default.bool,
  saveHashHistory: Co.default.bool,
  spyThrottle: Co.default.number
};
ov.default = function(e, t) {
  var n = t || pXe.default, r = function(i) {
    mXe(a, i);
    function a(s) {
      hXe(this, a);
      var l = gXe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return aXe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Ib.default.isMounted(s)) {
            var l = Ib.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (gu.default.isMounted() || gu.default.mount(n), gu.default.mapContainer(this.props.to, s)), Ib.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Ib.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Ab({}, this.props.style, this.props.activeStyle) : l = Ab({}, this.props.style);
        var u = Ab({}, this.props);
        for (var c in Aq)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, jq.default.createElement(e, u);
      }
    }]), a;
  }(jq.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Ab({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(gu.default.isMounted() && !gu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, y = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, y = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(y), g = M < Math.floor(f) || M >= Math.floor(y);
        } else {
          var O = 0, v = 0, x = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            x = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            O = z.top - x + s, v = O + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(v), g = L < Math.floor(O) || L >= Math.floor(v);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && gu.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            gu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var Z = i.props.saveHashHistory, H = Z === void 0 ? !1 : Z;
          i.props.hashSpy && gu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = Aq, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(EB, "__esModule", {
  value: !0
});
var vXe = we, Iq = Uce(vXe), yXe = ov, bXe = Uce(yXe);
function Uce(e) {
  return e && e.__esModule ? e : { default: e };
}
function wXe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Bq(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function CXe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var xXe = function(e) {
  CXe(t, e);
  function t() {
    var n, r, o, i;
    wXe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = Bq(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return Iq.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), Bq(o, i);
  }
  return t;
}(Iq.default.Component);
EB.default = (0, bXe.default)(xXe);
var MB = {};
Object.defineProperty(MB, "__esModule", {
  value: !0
});
var OXe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), EXe = we, Rq = Hce(EXe), kXe = ov, LXe = Hce(kXe);
function Hce(e) {
  return e && e.__esModule ? e : { default: e };
}
function PXe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _Xe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function SXe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var MXe = function(e) {
  SXe(t, e);
  function t() {
    return PXe(this, t), _Xe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return OXe(t, [{
    key: "render",
    value: function() {
      return Rq.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(Rq.default.Component);
MB.default = (0, LXe.default)(MXe);
var DB = {}, hk = {};
Object.defineProperty(hk, "__esModule", {
  value: !0
});
var DXe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, TXe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), jXe = we, Nq = gk(jXe), AXe = nl;
gk(AXe);
var IXe = of, Fq = gk(IXe), BXe = dk, zq = gk(BXe);
function gk(e) {
  return e && e.__esModule ? e : { default: e };
}
function RXe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function NXe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function FXe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
hk.default = function(e) {
  var t = function(n) {
    FXe(r, n);
    function r(o) {
      RXe(this, r);
      var i = NXe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return TXe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        Fq.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        Fq.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return Nq.default.createElement(e, DXe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(Nq.default.Component);
  return t.propTypes = {
    name: zq.default.string,
    id: zq.default.string
  }, t;
};
Object.defineProperty(DB, "__esModule", {
  value: !0
});
var Uq = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, zXe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), UXe = we, Hq = TB(UXe), HXe = hk, WXe = TB(HXe), VXe = dk, Wq = TB(VXe);
function TB(e) {
  return e && e.__esModule ? e : { default: e };
}
function $Xe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ZXe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function qXe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Wce = function(e) {
  qXe(t, e);
  function t() {
    return $Xe(this, t), ZXe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return zXe(t, [{
    key: "render",
    value: function() {
      var n = this, r = Uq({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, Hq.default.createElement(
        "div",
        Uq({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(Hq.default.Component);
Wce.propTypes = {
  name: Wq.default.string,
  id: Wq.default.string
};
DB.default = (0, WXe.default)(Wce);
var UP = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Vq = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function $q(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Zq(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function qq(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Bb = we, Uc = iv, HP = of, Wo = dk, mu = fk, Gq = {
  to: Wo.string.isRequired,
  containerId: Wo.string,
  container: Wo.object,
  activeClass: Wo.string,
  spy: Wo.bool,
  smooth: Wo.oneOfType([Wo.bool, Wo.string]),
  offset: Wo.number,
  delay: Wo.number,
  isDynamic: Wo.bool,
  onClick: Wo.func,
  duration: Wo.oneOfType([Wo.number, Wo.func]),
  absolute: Wo.bool,
  onSetActive: Wo.func,
  onSetInactive: Wo.func,
  ignoreCancelEvents: Wo.bool,
  hashSpy: Wo.bool,
  spyThrottle: Wo.number
}, GXe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || HP, r = function(i) {
      qq(a, i);
      function a(s) {
        $q(this, a);
        var l = Zq(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return Vq(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Uc.isMounted(s) || Uc.mount(s, this.props.spyThrottle), this.props.hashSpy && (mu.isMounted() || mu.mount(n), mu.mapContainer(this.props.to, s)), this.props.spy && Uc.addStateHandler(this.stateHandler), Uc.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Uc.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = UP({}, this.props);
          for (var u in Gq)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Bb.createElement(e, l);
        }
      }]), a;
    }(Bb.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, UP({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(mu.isMounted() && !mu.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var y = a - i.props.offset, b = y >= Math.floor(c) && y < Math.floor(p), E = y < Math.floor(c) || y >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && mu.getHash() === l && mu.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Uc.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && mu.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Uc.updateStates();
        }
      };
    };
    return r.propTypes = Gq, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      qq(r, n);
      function r(o) {
        $q(this, r);
        var i = Zq(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return Vq(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          HP.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          HP.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Bb.createElement(e, UP({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Bb.Component);
    return t.propTypes = {
      name: Wo.string,
      id: Wo.string
    }, t;
  }
}, KXe = GXe;
Object.defineProperty(si, "__esModule", {
  value: !0
});
si.Helpers = si.ScrollElement = si.ScrollLink = si.animateScroll = si.scrollSpy = si.Events = si.scroller = si.Element = si.Button = si.Link = void 0;
var YXe = EB, Vce = ll(YXe), XXe = MB, $ce = ll(XXe), JXe = DB, Zce = ll(JXe), QXe = of, qce = ll(QXe), eJe = lv, Gce = ll(eJe), tJe = iv, Kce = ll(tJe), nJe = uk, Yce = ll(nJe), rJe = ov, Xce = ll(rJe), oJe = hk, Jce = ll(oJe), iJe = KXe, Qce = ll(iJe);
function ll(e) {
  return e && e.__esModule ? e : { default: e };
}
si.Link = Vce.default;
si.Button = $ce.default;
si.Element = Zce.default;
si.scroller = qce.default;
si.Events = Gce.default;
si.scrollSpy = Kce.default;
si.animateScroll = Yce.default;
si.ScrollLink = Xce.default;
si.ScrollElement = Jce.default;
si.Helpers = Qce.default;
si.default = { Link: Vce.default, Button: $ce.default, Element: Zce.default, scroller: qce.default, Events: Gce.default, scrollSpy: Kce.default, animateScroll: Yce.default, ScrollLink: Xce.default, ScrollElement: Jce.default, Helpers: Qce.default };
We({});
We({});
We({});
function dm(e) {
  "@babel/helpers - typeof";
  return dm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, dm(e);
}
function sJe(e, t) {
  if (dm(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (dm(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function aJe(e) {
  var t = sJe(e, "string");
  return dm(t) == "symbol" ? t : t + "";
}
function Be(e, t, n) {
  return (t = aJe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function epe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var WP, Kq;
function lJe() {
  if (Kq) return WP;
  Kq = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return WP = t, WP;
}
var uJe = lJe(), gi = /* @__PURE__ */ epe(uJe), Zt = We(null);
function cJe() {
  gi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Zt);
  return gi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function pJe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function dJe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function fJe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return dJe(e, i), o;
}
function hJe(e, t, n) {
  var r = pJe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function gJe(e) {
  google.maps.event.removeListener(e);
}
function zn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(gJe);
}
function Sn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = hJe(o, i, n);
  return fJe(t, r, o, i), a;
}
function mJe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: y,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [v, x] = k(null), _ = ht(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null), [j, Y] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && y && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", y)));
  }, [y]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (j !== null && google.maps.event.removeListener(j), Y(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return x(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), Di.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: Di.jsx(Zt.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(mJe);
function Yq(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function tpe(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        Yq(i, r, o, a, s, "next", l);
      }
      function s(l) {
        Yq(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function npe(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return gi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var wp = typeof document < "u";
function rpe(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return wp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function Xq(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function ope() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return Xq(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return Xq(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var qf = !1;
function ipe() {
  return Di.jsx("div", {
    children: "Loading..."
  });
}
var jD = {
  id: "script-loader",
  version: "weekly"
};
class vJe extends pe {
  constructor() {
    super(...arguments), Be(this, "check", null), Be(this, "state", {
      loaded: !1
    }), Be(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Be(this, "isCleaningUp", /* @__PURE__ */ tpe(function* () {
      function t(n) {
        if (!qf)
          n();
        else if (wp)
          var r = window.setInterval(function() {
            qf || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Be(this, "cleanup", () => {
      qf = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Be(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && ope(), gi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: npe(this.props)
      };
      rpe(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Be(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (wp) {
      if (window.google && window.google.maps && !qf) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), wp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (wp) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, qf = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Di.jsxs(Di.Fragment, {
      children: [Di.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Di.jsx(ipe, {})]
    });
  }
}
Be(vJe, "defaultProps", jD);
function yJe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function jB(e, t) {
  if (e == null) return {};
  var n, r, o = yJe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var Jq;
function bJe(e) {
  var {
    id: t = jD.id,
    version: n = jD.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ht(!1), [f, y] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    wp && u && ope();
  }, [u]), h(function() {
    f && gi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = npe({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!wp)
      return;
    function O() {
      g.current && (y(!0), Jq = w);
    }
    if (window.google && window.google.maps && Jq === w) {
      O();
      return;
    }
    rpe({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = ht(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var wJe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], CJe = Di.jsx(ipe, {});
function xJe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = jB(e, wJe), {
    isLoaded: s,
    loadError: l
  } = bJe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || CJe;
}
me(xJe);
var Qq;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Qq || (Qq = {}));
function e7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function IC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? e7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : e7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var t7 = {}, n7 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function OJe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Zt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(IC(IC({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(OJe);
class EJe extends pe {
  constructor() {
    super(...arguments), Be(this, "state", {
      trafficLayer: null
    }), Be(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Be(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(IC(IC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: n7,
      eventMap: t7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: n7,
      eventMap: t7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), zn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Be(EJe, "contextType", Zt);
function kJe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Zt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(kJe);
class LJe extends pe {
  constructor() {
    super(...arguments), Be(this, "state", {
      bicyclingLayer: null
    }), Be(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Be(LJe, "contextType", Zt);
function PJe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Zt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(PJe);
class _Je extends pe {
  constructor() {
    super(...arguments), Be(this, "state", {
      transitLayer: null
    }), Be(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Be(_Je, "contextType", Zt);
function r7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function BC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var o7 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, i7 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function SJe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Zt), [d, g] = k(null), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), y(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    gi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(BC(BC({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && y(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && v(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(SJe);
class MJe extends pe {
  constructor(t) {
    super(t), Be(this, "registeredEvents", []), Be(this, "state", {
      drawingManager: null
    }), Be(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), gi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(BC(BC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: i7,
      eventMap: o7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: i7,
      eventMap: o7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), zn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Be(MJe, "contextType", Zt);
function s7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? s7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var a7 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, l7 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, RC = {};
function DJe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: y,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: v,
    onMouseOut: x,
    onMouseOver: _,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: Z,
    onDraggableChanged: H,
    onFlatChanged: $,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: F,
    onUnmount: S
  } = e, W = ge(Zt), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null), [oe, Pe] = k(null), [Ue, Ze] = k(null), [_e, rt] = k(null), [Ve, ye] = k(null), [Ge, ct] = k(null), [ve, Oe] = k(null), [qe, ze] = k(null), [Se, st] = k(null), [xe, xt] = k(null), [at, lt] = k(null), [pt, Ot] = k(null), [dt, ft] = k(null), [ot, He] = k(null), [Et, kt] = k(null), [gt, St] = k(null), [mt, Mt] = k(null), [vt, Pt] = k(null);
  h(() => {
    C !== null && C.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && C !== null && C.setOptions(n);
  }, [C, n]), h(() => {
    typeof a < "u" && C !== null && C.setDraggable(a);
  }, [C, a]), h(() => {
    t && C !== null && C.setPosition(t);
  }, [C, t]), h(() => {
    typeof s < "u" && C !== null && C.setVisible(s);
  }, [C, s]), h(() => {
    C == null || C.setAnimation(l);
  }, [C, l]), h(() => {
    C && u !== void 0 && C.setClickable(u);
  }, [C, u]), h(() => {
    C && c !== void 0 && C.setCursor(c);
  }, [C, c]), h(() => {
    C && p !== void 0 && C.setIcon(p);
  }, [C, p]), h(() => {
    C && d !== void 0 && C.setLabel(d);
  }, [C, d]), h(() => {
    C && g !== void 0 && C.setOpacity(g);
  }, [C, g]), h(() => {
    C && f !== void 0 && C.setShape(f);
  }, [C, f]), h(() => {
    C && y !== void 0 && C.setTitle(y);
  }, [C, y]), h(() => {
    C && b !== void 0 && C.setZIndex(b);
  }, [C, b]), h(() => {
    C && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(C, "dblclick", w)));
  }, [w]), h(() => {
    C && O && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(C, "dragend", O)));
  }, [O]), h(() => {
    C && v && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(C, "dragstart", v)));
  }, [v]), h(() => {
    C && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(C, "mousedown", L)));
  }, [L]), h(() => {
    C && x && (oe !== null && google.maps.event.removeListener(oe), Pe(google.maps.event.addListener(C, "mouseout", x)));
  }, [x]), h(() => {
    C && _ && (Ue !== null && google.maps.event.removeListener(Ue), Ze(google.maps.event.addListener(C, "mouseover", _)));
  }, [_]), h(() => {
    C && z && (_e !== null && google.maps.event.removeListener(_e), rt(google.maps.event.addListener(C, "mouseup", z)));
  }, [z]), h(() => {
    C && N && (Ve !== null && google.maps.event.removeListener(Ve), ye(google.maps.event.addListener(C, "rightclick", N)));
  }, [N]), h(() => {
    C && E && (Ge !== null && google.maps.event.removeListener(Ge), ct(google.maps.event.addListener(C, "click", E)));
  }, [E]), h(() => {
    C && M && (ve !== null && google.maps.event.removeListener(ve), Oe(google.maps.event.addListener(C, "drag", M)));
  }, [M]), h(() => {
    C && R && (qe !== null && google.maps.event.removeListener(qe), ze(google.maps.event.addListener(C, "clickable_changed", R)));
  }, [R]), h(() => {
    C && V && (Se !== null && google.maps.event.removeListener(Se), st(google.maps.event.addListener(C, "cursor_changed", V)));
  }, [V]), h(() => {
    C && Z && (xe !== null && google.maps.event.removeListener(xe), xt(google.maps.event.addListener(C, "animation_changed", Z)));
  }, [Z]), h(() => {
    C && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(C, "draggable_changed", H)));
  }, [H]), h(() => {
    C && $ && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(C, "flat_changed", $)));
  }, [$]), h(() => {
    C && K && (dt !== null && google.maps.event.removeListener(dt), ft(google.maps.event.addListener(C, "icon_changed", K)));
  }, [K]), h(() => {
    C && X && (ot !== null && google.maps.event.removeListener(ot), He(google.maps.event.addListener(C, "position_changed", X)));
  }, [X]), h(() => {
    C && Q && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(C, "shape_changed", Q)));
  }, [Q]), h(() => {
    C && J && (gt !== null && google.maps.event.removeListener(gt), St(google.maps.event.addListener(C, "title_changed", J)));
  }, [J]), h(() => {
    C && P && (mt !== null && google.maps.event.removeListener(mt), Mt(google.maps.event.addListener(C, "visible_changed", P)));
  }, [P]), h(() => {
    C && D && (vt !== null && google.maps.event.removeListener(vt), Pt(google.maps.event.addListener(C, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = xd(xd(xd({}, n || RC), r ? RC : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(yt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof g < "u" && te.setOpacity(g), f && te.setShape(f), typeof y == "string" && te.setTitle(y), typeof b == "number" && te.setZIndex(b), w && T(google.maps.event.addListener(te, "dblclick", w)), O && j(google.maps.event.addListener(te, "dragend", O)), v && B(google.maps.event.addListener(te, "dragstart", v)), L && he(google.maps.event.addListener(te, "mousedown", L)), x && Pe(google.maps.event.addListener(te, "mouseout", x)), _ && Ze(google.maps.event.addListener(te, "mouseover", _)), z && rt(google.maps.event.addListener(te, "mouseup", z)), N && ye(google.maps.event.addListener(te, "rightclick", N)), E && ct(google.maps.event.addListener(te, "click", E)), M && Oe(google.maps.event.addListener(te, "drag", M)), R && ze(google.maps.event.addListener(te, "clickable_changed", R)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), Z && xt(google.maps.event.addListener(te, "animation_changed", Z)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), $ && Ot(google.maps.event.addListener(te, "flat_changed", $)), K && ft(google.maps.event.addListener(te, "icon_changed", K)), X && He(google.maps.event.addListener(te, "position_changed", X)), Q && kt(google.maps.event.addListener(te, "shape_changed", Q)), J && St(google.maps.event.addListener(te, "title_changed", J)), P && Mt(google.maps.event.addListener(te, "visible_changed", P)), D && Pt(google.maps.event.addListener(te, "zindex_changed", D)), I(te), F && F(te), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), _e !== null && google.maps.event.removeListener(_e), Ve !== null && google.maps.event.removeListener(Ve), Ge !== null && google.maps.event.removeListener(Ge), qe !== null && google.maps.event.removeListener(qe), Se !== null && google.maps.event.removeListener(Se), xe !== null && google.maps.event.removeListener(xe), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ot !== null && google.maps.event.removeListener(ot), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var jn = Ft(() => i ? ut.map(i, (yt) => {
    if (!wi(yt))
      return yt;
    var te = yt;
    return Ci(te, {
      anchor: C
    });
  }) : null, [i, C]);
  return Di.jsx(Di.Fragment, {
    children: jn
  }) || null;
}
me(DJe);
class TJe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return tpe(function* () {
      var n = xd(xd(xd({}, t.props.options || RC), t.props.clusterer ? RC : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Sn({
        updaterMap: l7,
        eventMap: a7,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: l7,
      eventMap: a7,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), zn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Ci(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Be(TJe, "contextType", Zt);
var jJe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), AJe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new jJe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function IJe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var BJe = 2e3, RJe = 500, NJe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", FJe = "png", zJe = [53, 56, 66, 78, 90], UJe = "cluster", spe = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || NJe, this.imageExtension = r.imageExtension || FJe, this.imageSizes = r.imageSizes || zJe, this.calculator = r.calculator || IJe, this.batchSize = r.batchSize || BJe, this.batchSizeIE = r.batchSizeIE || RJe, this.clusterClass = r.clusterClass || UJe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new AJe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function u7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function HJe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? u7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : u7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ba = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Gn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, WJe = {};
function VJe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: y,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: v,
    onMouseOut: x,
    onLoad: _,
    onUnmount: z
  } = e, [L, N] = k(null), R = ge(Zt), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && x && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, ba.onMouseOut, x)));
  }, [x]), h(() => {
    L && v && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, ba.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(L, ba.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(L, ba.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), $(google.maps.event.addListener(L, ba.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && Gn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Gn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Gn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Gn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Gn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Gn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Gn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Gn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Gn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Gn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Gn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Gn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof y < "u" && L !== null && Gn.styles(L, y);
  }, [L, y]), h(() => {
    typeof b < "u" && L !== null && Gn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && Gn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var F = HJe({}, n || WJe), S = new spe(R, [], F);
      return r && Gn.averageCenter(S, r), o && Gn.batchSizeIE(S, o), i && Gn.calculator(S, i), a && Gn.clusterClass(S, a), s && Gn.enableRetinaIcons(S, s), l && Gn.gridSize(S, l), u && Gn.ignoreHidden(S, u), c && Gn.imageExtension(S, c), p && Gn.imagePath(S, p), d && Gn.imageSizes(S, d), g && Gn.maxZoom(S, g), f && Gn.minimumClusterSize(S, f), y && Gn.styles(S, y), b && Gn.title(S, b), E && Gn.zoomOnClick(S, E), x && J(google.maps.event.addListener(S, ba.onMouseOut, x)), v && D(google.maps.event.addListener(S, ba.onMouseOver, v)), w && Z(google.maps.event.addListener(S, ba.onClick, w)), M && $(google.maps.event.addListener(S, ba.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, ba.onClusteringEnd, O)), N(S), _ && _(S), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), z && z(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(VJe);
class $Je extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      markerClusterer: null
    }), Be(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new spe(this.context, [], this.props.options);
      this.registeredEvents = Sn({
        updaterMap: Gn,
        eventMap: ba,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: Gn,
      eventMap: ba,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), zn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Be($Je, "contextType", Zt);
function c7(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var ape = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || c7(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, c7));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, y = this.getProjection(), b = y.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), ZJe = ["position"], qJe = ["position"];
function p7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function NC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? p7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : p7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var d7 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, f7 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, GJe = {};
function KJe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Zt), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || GJe, {
        position: V
      } = R, Z = jB(R, ZJe), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var $ = new ape(NC(NC({}, Z), H ? {
        position: H
      } : {}));
      N.current = document.createElement("div"), y($), a && E(google.maps.event.addListener($, "closeclick", a)), s && M(google.maps.event.addListener($, "domready", s)), l && v(google.maps.event.addListener($, "content_changed", l)), u && _(google.maps.event.addListener($, "position_changed", u)), c && L(google.maps.event.addListener($, "zindex_changed", c)), $.setContent(N.current), n ? $.open(g, n) : $.getPosition() ? $.open(g) : gi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p($);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(KJe);
class YJe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "containerElement", null), Be(this, "state", {
      infoBox: null
    }), Be(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : gi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Be(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = jB(t, qJe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new ape(NC(NC({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Sn({
      updaterMap: f7,
      eventMap: d7,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: f7,
      eventMap: d7,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), zn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
Be(YJe, "contextType", Zt);
var h7, g7;
function XJe() {
  return g7 || (g7 = 1, h7 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), h7;
}
var JJe = XJe(), m7 = /* @__PURE__ */ epe(JJe), v7 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], VP = 1, Gf = 8;
class AB {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== VP)
      throw new Error("Got v".concat(o, " data when expected v").concat(VP, "."));
    var i = v7[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new AB(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = v7.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Gf, t), this.coords = new this.ArrayType(this.data, Gf + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Gf + a + s + l), this.ids = new this.IndexArrayType(this.data, Gf, t), this.coords = new this.ArrayType(this.data, Gf + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (VP << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return AD(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], y = a[2 * g + 1];
          f >= t && f <= r && y >= n && y <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          y7(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, y = i[2 * f], b = i[2 * f + 1];
      y7(y, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= y : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= y : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function AD(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    lpe(e, t, a, r, o, i), AD(e, t, n, r, a - 1, 1 - i), AD(e, t, n, a + 1, o, 1 - i);
  }
}
function lpe(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      lpe(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, y = o;
    for (Kf(e, t, r, n), t[2 * o + i] > g && Kf(e, t, r, o); f < y; ) {
      for (Kf(e, t, f, y), f++, y--; t[2 * f + i] < g; ) f++;
      for (; t[2 * y + i] > g; ) y--;
    }
    t[2 * r + i] === g ? Kf(e, t, r, y) : (y++, Kf(e, t, y, o)), y <= n && (r = y + 1), n <= y && (o = y - 1);
  }
}
function Kf(e, t, n, r) {
  $P(e, n, r), $P(t, 2 * n, 2 * r), $P(t, 2 * n + 1, 2 * r + 1);
}
function $P(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function y7(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var QJe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, b7 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Hc = 2, Nu = 3, ZP = 4, Su = 5, upe = 6;
class eQe {
  constructor(t) {
    this.options = Object.assign(Object.create(QJe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = b7(Rb(u)), d = b7(Nb(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var y = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - y);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Rb(r), Nb(a), Rb(i), Nb(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Su] > 1 ? w7(p, f, this.clusterProps) : this.points[p[f + Nu]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + ZP] === t && p.push(a[g + Su] > 1 ? w7(a, g, this.clusterProps) : this.points[a[g + Nu]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new AB(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Su] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = cpe(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Nu]];
        c = g.properties;
        var [f, y] = g.geometry.coordinates;
        p = Rb(f), d = Nb(y);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Nu] : E = this.points[n[l + Nu]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Hc] <= n)) {
        l[p + Hc] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), y = l[p + Su], b = y;
        for (var E of f) {
          var w = E * c;
          l[w + Hc] > n && (b += l[w + Su]);
        }
        if (b > y && b >= a) {
          var M = d * y, O = g * y, v = void 0, x = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Hc] <= n)) {
              l[L + Hc] = n;
              var N = l[L + Su];
              M += l[L] * N, O += l[L + 1] * N, l[L + ZP] = _, i && (v || (v = this._map(l, p, !0), x = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + ZP] = _, u.push(M / b, O / b, 1 / 0, _, -1, b), i && u.push(x);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var Z = V * c;
              if (!(l[Z + Hc] <= n)) {
                l[Z + Hc] = n;
                for (var H = 0; H < c; H++) u.push(l[Z + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Su] > 1) {
      var o = this.clusterProps[t[n + upe]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Nu]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function w7(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Nu],
    properties: cpe(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [tQe(e[t]), nQe(e[t + 1])]
    }
  };
}
function cpe(e, t, n) {
  var r = e[t + Su], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + upe], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Nu],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Rb(e) {
  return e / 360 + 0.5;
}
function Nb(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function tQe(e) {
  return (e - 0.5) * 360;
}
function nQe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function rQe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Zs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class ID {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Zs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Zs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Zs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class oQe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return iQe(n);
  }
}
var iQe = (e) => {
  var t = e.map((n) => new ID({
    position: Zs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class sQe extends oQe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = rQe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new eQe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!m7(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Zs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !m7(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new ID({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new ID({
      markers: [i],
      position: Zs.getPosition(i)
    });
  }
}
class aQe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class lQe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Zs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function uQe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class IB {
  constructor() {
    uQe(IB, google.maps.OverlayView);
  }
}
var eg;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(eg || (eg = {}));
var cQe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class pQe extends IB {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new sQe(o),
      renderer: a = new lQe(),
      onClusterClick: s = cQe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Zs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, eg.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Zs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Zs.setMap(l, null)));
      }
      google.maps.event.trigger(this, eg.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Zs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new aQe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Zs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, eg.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Zs.setMap(r.marker, n);
    });
  }
}
function C7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function x7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? C7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : C7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function dQe(e) {
  var t = cJe(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new pQe(x7(x7({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function fQe(e) {
  var {
    children: t,
    options: n
  } = e, r = dQe(n);
  return r !== null ? t(r) : null;
}
me(fQe);
var O7 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, E7 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function hQe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Zt), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return y(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && v(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : gi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(R), R.close();
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(hQe);
class gQe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "containerElement", null), Be(this, "state", {
      infoWindow: null
    }), Be(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : gi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Be(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Sn({
      updaterMap: E7,
      eventMap: O7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: E7,
      eventMap: O7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (zn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
Be(gQe, "contextType", Zt);
function k7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function FC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? k7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : k7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var L7 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, P7 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, mQe = {};
function vQe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Zt), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && y && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(O, "click", y)));
  }, [y]), h(() => {
    O && b && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(O, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(FC(FC({}, t || mQe), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && Z(google.maps.event.addListener(T, "mousedown", u)), c && $(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), y && C(google.maps.event.addListener(T, "click", y)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(vQe);
class yQe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      polyline: null
    }), Be(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(FC(FC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: P7,
      eventMap: L7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: P7,
      eventMap: L7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), zn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Be(yQe, "contextType", Zt);
function _7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function S7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var M7 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, D7 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function bQe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, v = ge(Zt), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    x !== null && x.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    typeof a < "u" && x !== null && x.setPaths(a);
  }, [x, a]), h(() => {
    x && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dblclick", s)));
  }, [s]), h(() => {
    x && (google.maps.event.addListener(x.getPath(), "insert_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "set_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "remove_at", () => {
      O == null || O(x);
    }));
  }, [x, O]), h(() => {
    x && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragend", l)));
  }, [l]), h(() => {
    x && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(x, "dragstart", u)));
  }, [u]), h(() => {
    x && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(x, "mousedown", c)));
  }, [c]), h(() => {
    x && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(x, "mousemove", p)));
  }, [p]), h(() => {
    x && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseout", d)));
  }, [d]), h(() => {
    x && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(x, "mouseover", g)));
  }, [g]), h(() => {
    x && typeof f == "function" && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(x, "mouseup", f)));
  }, [f]), h(() => {
    x && typeof y == "function" && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(x, "rightclick", y)));
  }, [y]), h(() => {
    x && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(x, "click", b)));
  }, [b]), h(() => {
    x && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(x, "drag", E)));
  }, [E]), h(() => {
    var j = new google.maps.Polygon(S7(S7({}, t), {}, {
      map: v
    }));
    return i && j.setPath(i), a && j.setPaths(a), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), s && L(google.maps.event.addListener(j, "dblclick", s)), l && R(google.maps.event.addListener(j, "dragend", l)), u && Z(google.maps.event.addListener(j, "dragstart", u)), c && $(google.maps.event.addListener(j, "mousedown", c)), p && X(google.maps.event.addListener(j, "mousemove", p)), d && J(google.maps.event.addListener(j, "mouseout", d)), g && D(google.maps.event.addListener(j, "mouseover", g)), f && S(google.maps.event.addListener(j, "mouseup", f)), y && C(google.maps.event.addListener(j, "rightclick", y)), b && U(google.maps.event.addListener(j, "click", b)), E && q(google.maps.event.addListener(j, "drag", E)), _(j), w && w(j), () => {
      z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), M && M(j), j.setMap(null);
    };
  }, []), null;
}
me(bQe);
class wQe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Sn({
      updaterMap: D7,
      eventMap: M7,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: D7,
      eventMap: M7,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), zn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Be(wQe, "contextType", Zt);
function T7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? T7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : T7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var j7 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, A7 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function CQe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(Zt), [v, x] = k(null), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null);
  return h(() => {
    v !== null && v.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(v, "click", y)));
  }, [y]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(zC(zC({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && z(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && H(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && F(google.maps.event.addListener(Y, "mouseup", g)), f && W(google.maps.event.addListener(Y, "rightclick", f)), y && I(google.maps.event.addListener(Y, "click", y)), b && T(google.maps.event.addListener(Y, "drag", b)), E && j(google.maps.event.addListener(Y, "bounds_changed", E)), x(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
me(CQe);
class xQe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      rectangle: null
    }), Be(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(zC(zC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: A7,
      eventMap: j7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: A7,
      eventMap: j7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), zn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Be(xQe, "contextType", Zt);
function I7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function UC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? I7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : I7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var B7 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, R7 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, OQe = {};
function EQe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: v
  } = e, x = ge(Zt), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null);
  return h(() => {
    _ !== null && _.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(_, "rightclick", y)));
  }, [y]), h(() => {
    _ && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", b)));
  }, [b]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [b]), h(() => {
    _ && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(UC(UC({}, t || OQe), {}, {
      map: x
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && F(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), y && I(google.maps.event.addListener(oe, "rightclick", y)), b && T(google.maps.event.addListener(oe, "click", b)), E && j(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), z(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(EQe);
class kQe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      circle: null
    }), Be(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(UC(UC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: R7,
      eventMap: B7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: R7,
      eventMap: B7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), zn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Be(kQe, "contextType", Zt);
function N7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function HC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? N7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : N7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var F7 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, z7 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function LQe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: y,
    onUnmount: b
  } = e, E = ge(Zt), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var j = new google.maps.Data(HC(HC({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(j, "dblclick", r)), o && _(google.maps.event.addListener(j, "mousedown", o)), i && L(google.maps.event.addListener(j, "mousemove", i)), a && R(google.maps.event.addListener(j, "mouseout", a)), s && Z(google.maps.event.addListener(j, "mouseover", s)), l && $(google.maps.event.addListener(j, "mouseup", l)), u && X(google.maps.event.addListener(j, "rightclick", u)), n && J(google.maps.event.addListener(j, "click", n)), c && D(google.maps.event.addListener(j, "addfeature", c)), p && S(google.maps.event.addListener(j, "removefeature", p)), d && C(google.maps.event.addListener(j, "removeproperty", d)), g && U(google.maps.event.addListener(j, "setgeometry", g)), f && q(google.maps.event.addListener(j, "setproperty", f)), M(j), y && y(j);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(LQe);
class PQe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      data: null
    }), Be(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(HC(HC({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Sn({
        updaterMap: z7,
        eventMap: F7,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: z7,
      eventMap: F7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), zn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Be(PQe, "contextType", Zt);
function U7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function H7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? U7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : U7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var W7 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, V7 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class _Qe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      kmlLayer: null
    }), Be(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(H7(H7({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: V7,
      eventMap: W7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: V7,
      eventMap: W7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), zn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Be(_Qe, "contextType", Zt);
function ppe(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function SQe(e, t) {
  return new t(e.lat, e.lng);
}
function MQe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function DQe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function TQe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function jQe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function AQe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function dpe(e, t, n, r) {
  return n !== void 0 ? jQe(e, t, TQe(n, google.maps.LatLngBounds, MQe)) : AQe(e, t, DQe(r, google.maps.LatLng, SQe));
}
function IQe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function $7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function BQe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function RQe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = BQe({}, this.container ? ppe(this.container, o) : {
        x: 0,
        y: 0
      }), u = dpe(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function Z7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function NQe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Z7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Z7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function q7(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function G7(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function FQe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Zt), c = Ft(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Ft(() => RQe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), xi.createPortal(l, c);
}
me(FQe);
class sf extends pe {
  constructor(t) {
    super(t), Be(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Be(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      gi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Be(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Be(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = NQe({
        x: 0,
        y: 0
      }, this.containerRef.current ? ppe(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = dpe(r, o, this.props.bounds, this.props.position);
      if (!IQe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Be(this, "draw", () => {
      this.onPositionElement();
    }), Be(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Br();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = q7(t.position), r = q7(this.props.position), o = G7(t.bounds), i = G7(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? xi.createPortal(Di.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
Be(sf, "FLOAT_PANE", "floatPane");
Be(sf, "MAP_PANE", "mapPane");
Be(sf, "MARKER_LAYER", "markerLayer");
Be(sf, "OVERLAY_LAYER", "overlayLayer");
Be(sf, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Be(sf, "contextType", Zt);
function zQe() {
}
function K7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Y7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? K7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : K7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var X7 = {
  onDblClick: "dblclick",
  onClick: "click"
}, J7 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function UQe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Zt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Ft(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(UQe);
class fpe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      groundOverlay: null
    }), Be(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    gi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Y7(Y7({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: J7,
      eventMap: X7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: J7,
      eventMap: X7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Be(fpe, "defaultProps", {
  onLoad: zQe
});
Be(fpe, "contextType", Zt);
function Q7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function WC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Q7(Object(n), !0).forEach(function(r) {
      Be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Q7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var eG = {}, tG = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function HQe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Zt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || gi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    gi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(WC(WC({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(HQe);
class WQe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      heatmapLayer: null
    }), Be(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    gi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), gi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(WC(WC({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Sn({
      updaterMap: tG,
      eventMap: eG,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: tG,
      eventMap: eG,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), zn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Be(WQe, "contextType", Zt);
var nG = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, rG = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class VQe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      streetViewPanorama: null
    }), Be(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Sn({
      updaterMap: rG,
      eventMap: nG,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: rG,
      eventMap: nG,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), zn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Be(VQe, "contextType", Zt);
class $Qe extends pe {
  constructor() {
    super(...arguments), Be(this, "state", {
      streetViewService: null
    }), Be(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Be($Qe, "contextType", Zt);
var oG = {
  onDirectionsChanged: "directions_changed"
}, iG = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class ZQe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "state", {
      directionsRenderer: null
    }), Be(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Sn({
      updaterMap: iG,
      eventMap: oG,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: iG,
      eventMap: oG,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), zn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Be(ZQe, "contextType", Zt);
var sG = {
  onPlacesChanged: "places_changed"
}, aG = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class qQe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "containerElement", Br()), Be(this, "state", {
      searchBox: null
    }), Be(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (gi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Sn({
          updaterMap: aG,
          eventMap: sG,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: aG,
      eventMap: sG,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), zn(this.registeredEvents));
  }
  render() {
    return Di.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
Be(qQe, "contextType", Zt);
var lG = {
  onPlaceChanged: "place_changed"
}, uG = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class hpe extends pe {
  constructor() {
    super(...arguments), Be(this, "registeredEvents", []), Be(this, "containerElement", Br()), Be(this, "state", {
      autocomplete: null
    }), Be(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    gi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Sn({
        updaterMap: uG,
        eventMap: lG,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    zn(this.registeredEvents), this.registeredEvents = Sn({
      updaterMap: uG,
      eventMap: lG,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && zn(this.registeredEvents);
  }
  render() {
    return Di.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
Be(hpe, "defaultProps", {
  className: ""
});
Be(hpe, "contextType", Zt);
let GQe = { data: "" }, KQe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || GQe, YQe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, XQe = /\/\*[^]*?\*\/|  +/g, cG = /\n+/g, Ku = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Ku(a, i) : i + "{" + Ku(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Ku(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Ku.p ? Ku.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ll = {}, gpe = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + gpe(e[n]);
    return t;
  }
  return e;
}, JQe = (e, t, n, r, o) => {
  let i = gpe(e), a = Ll[i] || (Ll[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ll[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = YQe.exec(u.replace(XQe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(cG, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(cG, " ").trim();
      return d[0];
    })(e);
    Ll[a] = Ku(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ll.g ? Ll.g : null;
  return n && (Ll.g = Ll[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ll[a], t, r, s), a;
}, QQe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Ku(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function mk(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return JQe(n.unshift ? n.raw ? QQe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, KQe(t.target), t.g, t.o, t.k);
}
let mpe, BD, RD;
mk.bind({ g: 1 });
let $l = mk.bind({ k: 1 });
function eet(e, t, n, r) {
  Ku.p = t, mpe = e, BD = n, RD = r;
}
function Lc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: BD && BD() }, s), n.o = / *go\d+/.test(l), s.className = mk.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), RD && u[0] && RD(s), mpe(u, s);
    }
    return o;
  };
}
var tet = (e) => typeof e == "function", net = (e, t) => tet(e) ? e(t) : e, ret = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), oet = $l`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, iet = $l`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, set = $l`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, aet = Lc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${oet} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${iet} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${set} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, uet = $l`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, cet = Lc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${uet} 1s linear infinite;
`, pet = $l`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, det = $l`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, fet = Lc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${pet} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${det} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, het = Lc("div")`
  position: absolute;
`, get = Lc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, met = $l`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, vet = Lc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${met} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, yet = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Me.createElement(vet, null, t) : t : n === "blank" ? null : Me.createElement(get, null, Me.createElement(cet, { ...r }), n !== "loading" && Me.createElement(het, null, n === "error" ? Me.createElement(aet, { ...r }) : Me.createElement(fet, { ...r })));
}, bet = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, wet = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, Cet = "0%{opacity:0;} 100%{opacity:1;}", xet = "0%{opacity:1;} 100%{opacity:0;}", Oet = Lc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Eet = Lc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, ket = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = ret() ? [Cet, xet] : [bet(n), wet(n)];
  return { animation: t ? `${$l(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${$l(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Me.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? ket(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Me.createElement(yet, { toast: e }), a = Me.createElement(Eet, { ...e.ariaProps }, net(e.message, e));
  return Me.createElement(Oet, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Me.createElement(Me.Fragment, null, i, a));
});
eet(Me.createElement);
mk`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
We({});
function Let(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Pet = {
  CNPJ: "99.999.999/9999-99"
};
Let(Pet.CNPJ).length;
yr((e, t) => /* @__PURE__ */ Mi.jsx("input", { ref: t, ...e }));
function vpe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const ype = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function _et(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function Met(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const Det = vpe(ype.NINE).length, Tet = yr((e, t) => /* @__PURE__ */ Mi.jsx("input", { ref: t, ...e }));
yr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = vpe(g.target.value);
      const y = Met(f);
      f.length > Det || (f = _et(f, ype[y]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Mi.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Mi.jsx(
      tl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: Tet,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
We({});
var nu = {};
Object.defineProperty(nu, "__esModule", {
  value: !0
});
var jet = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), qP = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, bpe = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: jet ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, BB = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Fb = 1; Fb < 20; Fb++)
  BB["f" + Fb] = 111 + Fb;
function vk(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return wpe(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Cpe(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function Aet(e, t) {
  return vk(e, t);
}
function Iet(e, t) {
  return vk(e, { byKey: !0 }, t);
}
function wpe(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in qP)
    r[qP[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = RB(d), y = qP[f];
      if (d.length > 1 && !y && !bpe[d] && !BB[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !y) && (n ? r.key = f : r.which = xpe(d)), y && (r[y] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Cpe(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function xpe(e) {
  e = RB(e);
  var t = BB[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function RB(e) {
  return e = e.toLowerCase(), e = bpe[e] || e, e;
}
nu.default = vk;
var GP = nu.isHotkey = vk;
nu.isCodeHotkey = Aet;
nu.isKeyHotkey = Iet;
nu.parseHotkey = wpe;
nu.compareHotkey = Cpe;
nu.toKeyCode = xpe;
nu.toKeyName = RB;
var Bet = typeof Sr == "object" && Sr && Sr.Object === Object && Sr, Ret = Bet, Net = Ret, Fet = typeof self == "object" && self && self.Object === Object && self, zet = Net || Fet || Function("return this")(), Uet = zet, Het = Uet, Wet = Het.Symbol, Ope = Wet, pG = Ope;
pG && pG.toStringTag;
var dG = Ope;
dG && dG.toStringTag;
var fG;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(fG || (fG = {}));
var NB = function(e) {
  return Object.freeze(e);
}, Vet = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, NB(this);
  }
  return e;
}(), $et = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, NB(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), hG = typeof window < "u" ? window : {};
/msie|trident/i.test(hG.navigator && hG.navigator.userAgent);
var KP = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Vet((n ? t : e) || 0, (n ? e : t) || 0);
};
NB({
  devicePixelContentBoxSize: KP(),
  borderBoxSize: KP(),
  contentBoxSize: KP(),
  contentRect: new $et(0, 0, 0, 0)
});
function fm(e) {
  "@babel/helpers - typeof";
  return fm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, fm(e);
}
function Zet(e, t) {
  if (fm(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (fm(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function qet(e) {
  var t = Zet(e, "string");
  return fm(t) === "symbol" ? t : String(t);
}
function tg(e, t, n) {
  return t = qet(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Get = /* @__PURE__ */ We(null), YP, XP;
parseInt(we.version.split(".")[0], 10);
var gG = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), JP = typeof navigator < "u" && /Android/.test(navigator.userAgent), zb = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Ket = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (YP = navigator.userAgent.match(/Version\/(\d+)/)) !== null && YP !== void 0 && YP[1] && parseInt((XP = navigator.userAgent.match(/Version\/(\d+)/)) === null || XP === void 0 ? void 0 : XP[1], 10) < 17;
var Yet = /* @__PURE__ */ new WeakMap(), Xet = /* @__PURE__ */ new WeakMap(), Jet = /* @__PURE__ */ new WeakMap(), Qet = /* @__PURE__ */ new WeakMap(), ett = /* @__PURE__ */ new WeakMap(), mG = /* @__PURE__ */ new WeakMap(), ttt = /* @__PURE__ */ new WeakMap(), vG = /* @__PURE__ */ new WeakMap(), Ub = /* @__PURE__ */ new WeakMap(), ntt = /* @__PURE__ */ new WeakMap(), rtt = /* @__PURE__ */ new WeakMap(), ott = /* @__PURE__ */ new WeakMap(), Epe = globalThis.Node, itt = globalThis.Text, kpe = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, stt = (e) => VC(e) && e.nodeType === 8, Ja = (e) => VC(e) && e.nodeType === 1, VC = (e) => {
  var t = kpe(e);
  return !!t && e instanceof t.Node;
}, yG = (e) => {
  var t = e && e.anchorNode && kpe(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, att = (e) => {
  var [t, n] = e;
  if (Ja(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Lpe(t, o, r ? "backward" : "forward"), r = o < n; Ja(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = utt(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, ltt = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Lpe = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (stt(o) || Ja(o) && o.childNodes.length === 0 || Ja(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, utt = (e, t, n) => {
  var [r] = Lpe(e, t, n);
  return r;
}, bG = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Ppe = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ja(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = xn.getWindow(e);
  if (o.contains(r))
    return xn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Ppe(e, i, n);
}, wG = (e, t) => !!(e.compareDocumentPosition(t) & Epe.DOCUMENT_POSITION_PRECEDING), ctt = (e, t) => !!(e.compareDocumentPosition(t) & Epe.DOCUMENT_POSITION_FOLLOWING), ptt = 0;
class dtt {
  constructor() {
    tg(this, "id", void 0), this.id = "".concat(ptt++);
  }
}
var xn = {
  androidPendingDiffs: (e) => ott.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = rtt.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = xn.toDOMNode(e, e), n = xn.findDocumentOrShadowRoot(e);
    Ub.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = xn.findDocumentOrShadowRoot(e), r = bG(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && e0.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = xn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = xn.toSlateNode(e, t.target), a = xn.findPath(e, i);
    if (Dl.isElement(i) && wr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = wr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? wr.before(e, u) : wr.after(e, u);
      if (c) {
        var p = wr.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = xn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var y = xn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return y;
  },
  findKey: (e, t) => {
    var n = mG.get(t);
    return n || (n = new dtt(), mG.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = Xet.get(r);
      if (o == null) {
        if (wr.isEditor(r))
          return n;
        break;
      }
      var i = Yet.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(As.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Ub.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          xn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = xn.toDOMNode(e, e), r = xn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = bG(r), i = xn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || e0.select(e, wr.start(e, [])), Ub.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Jet.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = xn.toDOMNode(e, e), i;
    try {
      i = Ja(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => VC(t) && xn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return wr.hasPath(e, n.path) && wr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => xn.hasEditableTarget(e, t) || xn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => VC(t) && xn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!ntt.get(e),
  isFocused: (e) => !!Ub.get(e),
  isReadOnly: (e) => !!vG.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (vG.get(e)) return !1;
    var n = xn.hasTarget(e, t) && xn.toSlateNode(e, t);
    return Dl.isElement(n) && wr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = ttt.get(e), r = wr.isEditor(t) ? Qet.get(e) : n == null ? void 0 : n.get(xn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(As.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = wr.node(e, t.path), r = xn.toDOMNode(e, n), o;
    wr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, y = a[l + 1];
        if (t.offset === f && y !== null && y !== void 0 && y.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = y.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof itt ? E : y,
            (b = y.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(As.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Xt.isBackward(t), i = xn.toDOMPoint(e, n), a = Xt.isCollapsed(t) ? i : xn.toDOMPoint(e, r), s = xn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Ja(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), y = Ja(p) ? p : p.parentElement, b = !!y.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ja(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? ett.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : att(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = xn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), y = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = xn.getWindow(e), v = O.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var x = v.cloneContents(), _ = [...Array.prototype.slice.call(x.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(x.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (JP && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = x.textContent.length, M = u;
        }
      } else if (y) {
        for (var z = y.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var N = z[L];
          if (xn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var Z, H = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = (Z = H.find((S) => ctt(E, S))) !== null && Z !== void 0 ? Z : null;
        } else {
          var $, K = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = ($ = K.findLast((S) => wG(E, S))) !== null && $ !== void 0 ? $ : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      JP && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      zb && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (JP && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && xn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var Q = xn.toSlateNode(e, X), {
          path: J,
          offset: P
        } = wr.start(e, xn.findPath(e, Q));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = xn.toSlateNode(e, u), F = xn.findPath(e, D);
    return {
      path: F,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = yG(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (yG(t)) {
        if (zb && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let x = function(_) {
              return _.childElementCount > 0 ? x(_.children[0]) : _;
            };
            var f = d.startContainer, y = g.startContainer, b = x(f.children[d.startOffset]), E = x(y.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Ket && ltt(s) || zb ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    zb && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = xn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = wG(s, u) || s === u && c < l, O = p ? w : xn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var v = {
      anchor: w,
      focus: O
    };
    return Xt.isExpanded(v) && Xt.isForward(v) && Ja(u) && wr.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = wr.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, ftt = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, htt = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, gtt = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, xo = (e) => {
  var t = ftt[e], n = htt[e], r = gtt[e], o = t && GP(t), i = n && GP(n), a = r && GP(r);
  return (s) => !!(o && o(s) || gG && i && i(s) || !gG && a && a(s));
};
xo("bold"), xo("compose"), xo("moveBackward"), xo("moveForward"), xo("deleteBackward"), xo("deleteForward"), xo("deleteLineBackward"), xo("deleteLineForward"), xo("deleteWordBackward"), xo("deleteWordForward"), xo("extendBackward"), xo("extendForward"), xo("extendLineBackward"), xo("extendLineForward"), xo("italic"), xo("moveLineBackward"), xo("moveLineForward"), xo("moveWordBackward"), xo("moveWordForward"), xo("redo"), xo("insertSoftBreak"), xo("splitBlock"), xo("transposeCharacter"), xo("undo");
var mtt = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Ppe(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, vtt = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class ytt extends Kl {
  constructor() {
    super(...arguments), tg(this, "context", null), tg(this, "manager", null), tg(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, vtt);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = mtt(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
tg(ytt, "contextType", Get);
We({});
We({});
We({});
var ai = {}, FB = {}, pv = {}, dv = {}, _pe = "Expected a function", CG = NaN, btt = "[object Symbol]", wtt = /^\s+|\s+$/g, Ctt = /^[-+]0x[0-9a-f]+$/i, xtt = /^0b[01]+$/i, Ott = /^0o[0-7]+$/i, Ett = parseInt, ktt = typeof Sr == "object" && Sr && Sr.Object === Object && Sr, Ltt = typeof self == "object" && self && self.Object === Object && self, Ptt = ktt || Ltt || Function("return this")(), _tt = Object.prototype, Stt = _tt.toString, Mtt = Math.max, Dtt = Math.min, QP = function() {
  return Ptt.Date.now();
};
function Ttt(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(_pe);
  t = xG(t) || 0, $C(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Mtt(xG(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(x) {
    var _ = r, z = o;
    return r = o = void 0, u = x, a = e.apply(z, _), a;
  }
  function f(x) {
    return u = x, s = setTimeout(E, t), c ? g(x) : a;
  }
  function y(x) {
    var _ = x - l, z = x - u, L = t - _;
    return p ? Dtt(L, i - z) : L;
  }
  function b(x) {
    var _ = x - l, z = x - u;
    return l === void 0 || _ >= t || _ < 0 || p && z >= i;
  }
  function E() {
    var x = QP();
    if (b(x))
      return w(x);
    s = setTimeout(E, y(x));
  }
  function w(x) {
    return s = void 0, d && r ? g(x) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(QP());
  }
  function v() {
    var x = QP(), _ = b(x);
    if (r = arguments, o = this, l = x, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = O, v;
}
function jtt(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(_pe);
  return $C(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Ttt(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function $C(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Att(e) {
  return !!e && typeof e == "object";
}
function Itt(e) {
  return typeof e == "symbol" || Att(e) && Stt.call(e) == btt;
}
function xG(e) {
  if (typeof e == "number")
    return e;
  if (Itt(e))
    return CG;
  if ($C(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = $C(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(wtt, "");
  var n = xtt.test(e);
  return n || Ott.test(e) ? Ett(e.slice(2), n ? 2 : 8) : Ctt.test(e) ? CG : +e;
}
var Btt = jtt, fv = {};
Object.defineProperty(fv, "__esModule", {
  value: !0
});
fv.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Dw.has(t) || Dw.set(t, /* @__PURE__ */ new Set());
  var o = Dw.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
fv.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Dw.get(t).delete(n.name || t);
};
var Dw = /* @__PURE__ */ new Map();
Object.defineProperty(dv, "__esModule", {
  value: !0
});
var Rtt = Btt, Ntt = Ftt(Rtt), OG = fv;
function Ftt(e) {
  return e && e.__esModule ? e : { default: e };
}
var ztt = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Ntt.default)(e, t);
}, Io = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = ztt(function(r) {
        Io.scrollHandler(e);
      }, t);
      return Io.scrollSpyContainers.push(e), (0, OG.addPassiveEventListener)(e, "scroll", n), function() {
        (0, OG.removePassiveEventListener)(e, "scroll", n), Io.scrollSpyContainers.splice(Io.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Io.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Io.scrollSpyContainers[Io.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Io.currentPositionX(e), Io.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Io.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Io.scrollSpyContainers[Io.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Io.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Io.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Io.spySetState && Io.spySetState.length && Io.spySetState.indexOf(e) > -1 && Io.spySetState.splice(Io.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Io.scrollHandler);
  },
  update: function() {
    return Io.scrollSpyContainers.forEach(function(e) {
      return Io.scrollHandler(e);
    });
  }
};
dv.default = Io;
var af = {}, hv = {};
Object.defineProperty(hv, "__esModule", {
  value: !0
});
var Utt = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, Htt = function() {
  return window.location.hash.replace(/^#/, "");
}, Wtt = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Vtt = function(e) {
  return getComputedStyle(e).position !== "static";
}, e_ = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, $tt = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Vtt(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = e_(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return e_(t, s).offsetTop - e_(e, s).offsetTop;
};
hv.default = {
  updateHash: Utt,
  getHash: Htt,
  filterElementInContainer: Wtt,
  scrollOffset: $tt
};
var yk = {}, zB = {};
Object.defineProperty(zB, "__esModule", {
  value: !0
});
zB.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var UB = {};
Object.defineProperty(UB, "__esModule", {
  value: !0
});
var Ztt = fv, qtt = ["mousedown", "wheel", "touchmove", "keydown"];
UB.default = {
  subscribe: function(e) {
    return typeof document < "u" && qtt.forEach(function(t) {
      return (0, Ztt.addPassiveEventListener)(document, t, e);
    });
  }
};
var gv = {};
Object.defineProperty(gv, "__esModule", {
  value: !0
});
var ND = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      ND.registered[e] = t;
    },
    remove: function(e) {
      ND.registered[e] = null;
    }
  }
};
gv.default = ND;
Object.defineProperty(yk, "__esModule", {
  value: !0
});
var Gtt = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Ktt = hv;
bk(Ktt);
var Ytt = zB, EG = bk(Ytt), Xtt = UB, Jtt = bk(Xtt), Qtt = gv, Wa = bk(Qtt);
function bk(e) {
  return e && e.__esModule ? e : { default: e };
}
var Spe = function(e) {
  return EG.default[e.smooth] || EG.default.defaultEasing;
}, ent = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, tnt = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, FD = function() {
  return tnt() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Mpe = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Dpe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Tpe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, nnt = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, rnt = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, ont = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Wa.default.registered.end && Wa.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    FD.call(window, i);
    return;
  }
  Wa.default.registered.end && Wa.default.registered.end(o.to, o.target, o.currentPosition);
}, HB = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, mv = function(e, t, n, r) {
  t.data = t.data || Mpe(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (Jtt.default.subscribe(o), HB(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Dpe(t) : Tpe(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Wa.default.registered.end && Wa.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = ent(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Spe(t), a = ont.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Wa.default.registered.begin && Wa.default.registered.begin(t.data.to, t.data.target), FD.call(window, a);
    }, t.delay);
    return;
  }
  Wa.default.registered.begin && Wa.default.registered.begin(t.data.to, t.data.target), FD.call(window, a);
}, wk = function(e) {
  return e = Gtt({}, e), e.data = e.data || Mpe(), e.absolute = !0, e;
}, int = function(e) {
  mv(0, wk(e));
}, snt = function(e, t) {
  mv(e, wk(t));
}, ant = function(e) {
  e = wk(e), HB(e), mv(e.horizontal ? nnt(e) : rnt(e), e);
}, lnt = function(e, t) {
  t = wk(t), HB(t);
  var n = t.horizontal ? Dpe(t) : Tpe(t);
  mv(e + n, t);
};
yk.default = {
  animateTopScroll: mv,
  getAnimationType: Spe,
  scrollToTop: int,
  scrollToBottom: ant,
  scrollTo: snt,
  scrollMore: lnt
};
Object.defineProperty(af, "__esModule", {
  value: !0
});
var unt = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, cnt = hv, pnt = WB(cnt), dnt = yk, fnt = WB(dnt), hnt = gv, Hb = WB(hnt);
function WB(e) {
  return e && e.__esModule ? e : { default: e };
}
var Wb = {}, kG = void 0;
af.default = {
  unmount: function() {
    Wb = {};
  },
  register: function(e, t) {
    Wb[e] = t;
  },
  unregister: function(e) {
    delete Wb[e];
  },
  get: function(e) {
    return Wb[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return kG = e;
  },
  getActiveLink: function() {
    return kG;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = unt({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = pnt.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Hb.default.registered.begin && Hb.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Hb.default.registered.end && Hb.default.registered.end(e, n);
      return;
    }
    fnt.default.animateTopScroll(s, t, e, n);
  }
};
var zD = { exports: {} }, t_ = { exports: {} }, ir = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var LG;
function gnt() {
  if (LG) return ir;
  LG = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function O(v) {
    return M(v) === u;
  }
  return ir.AsyncMode = l, ir.ConcurrentMode = u, ir.ContextConsumer = s, ir.ContextProvider = a, ir.Element = t, ir.ForwardRef = c, ir.Fragment = r, ir.Lazy = f, ir.Memo = g, ir.Portal = n, ir.Profiler = i, ir.StrictMode = o, ir.Suspense = p, ir.isAsyncMode = function(v) {
    return O(v) || M(v) === l;
  }, ir.isConcurrentMode = O, ir.isContextConsumer = function(v) {
    return M(v) === s;
  }, ir.isContextProvider = function(v) {
    return M(v) === a;
  }, ir.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, ir.isForwardRef = function(v) {
    return M(v) === c;
  }, ir.isFragment = function(v) {
    return M(v) === r;
  }, ir.isLazy = function(v) {
    return M(v) === f;
  }, ir.isMemo = function(v) {
    return M(v) === g;
  }, ir.isPortal = function(v) {
    return M(v) === n;
  }, ir.isProfiler = function(v) {
    return M(v) === i;
  }, ir.isStrictMode = function(v) {
    return M(v) === o;
  }, ir.isSuspense = function(v) {
    return M(v) === p;
  }, ir.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === y);
  }, ir.typeOf = M, ir;
}
var mr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var PG;
function mnt() {
  return PG || (PG = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === E || B.$$typeof === w || B.$$typeof === y);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, x = u, _ = s, z = a, L = t, N = c, R = r, V = f, Z = g, H = n, $ = i, K = o, X = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function F(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return O(B) === c;
    }
    function C(B) {
      return O(B) === r;
    }
    function I(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function j(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    mr.AsyncMode = v, mr.ConcurrentMode = x, mr.ContextConsumer = _, mr.ContextProvider = z, mr.Element = L, mr.ForwardRef = N, mr.Fragment = R, mr.Lazy = V, mr.Memo = Z, mr.Portal = H, mr.Profiler = $, mr.StrictMode = K, mr.Suspense = X, mr.isAsyncMode = J, mr.isConcurrentMode = P, mr.isContextConsumer = D, mr.isContextProvider = F, mr.isElement = S, mr.isForwardRef = W, mr.isFragment = C, mr.isLazy = I, mr.isMemo = U, mr.isPortal = T, mr.isProfiler = q, mr.isStrictMode = j, mr.isSuspense = Y, mr.isValidElementType = M, mr.typeOf = O;
  }()), mr;
}
var _G;
function jpe() {
  return _G || (_G = 1, process.env.NODE_ENV === "production" ? t_.exports = gnt() : t_.exports = mnt()), t_.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var n_, SG;
function vnt() {
  if (SG) return n_;
  SG = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return n_ = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, n_;
}
var r_, MG;
function VB() {
  if (MG) return r_;
  MG = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return r_ = e, r_;
}
var DG, TG;
function Ape() {
  return TG || (TG = 1, DG = Function.call.bind(Object.prototype.hasOwnProperty)), DG;
}
var o_, jG;
function ynt() {
  if (jG) return o_;
  jG = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = VB(), n = {}, r = Ape();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, o_ = o, o_;
}
var i_, AG;
function bnt() {
  if (AG) return i_;
  AG = 1;
  var e = jpe(), t = vnt(), n = VB(), r = Ape(), o = ynt(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return i_ = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: v(),
      instanceOf: x,
      node: N(),
      objectOf: z,
      oneOf: _,
      oneOfType: L,
      shape: V,
      exact: Z
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function y(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    y.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, F = 0;
      function S(C, I, U, T, q, j, Y) {
        if (T = T || d, j = j || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            F < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + j + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, F++);
          }
        }
        return I[U] == null ? C ? I[U] === null ? new y("The " + q + " `" + j + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new y("The " + q + " `" + j + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(I, U, T, q, j);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(P) {
      function D(F, S, W, C, I, U) {
        var T = F[S], q = K(T);
        if (q !== P) {
          var j = X(T);
          return new y(
            "Invalid " + C + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = F[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var j = P(U, q, W, C, I + "[" + q + "]", n);
          if (j instanceof Error)
            return j;
        }
        return null;
      }
      return b(D);
    }
    function O() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!s(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function v() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!e.isValidElementType(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function x(P) {
      function D(F, S, W, C, I) {
        if (!(F[S] instanceof P)) {
          var U = P.name || d, T = J(F[S]);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(F, S, W, C, I) {
        for (var U = F[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(j, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new y("Invalid " + C + " `" + I + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function z(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var j = P(U, q, W, C, I + "." + q, n);
            if (j instanceof Error)
              return j;
          }
        return null;
      }
      return b(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var F = P[D];
        if (typeof F != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(F) + " at index " + D + "."
          ), a;
      }
      function S(W, C, I, U, T) {
        for (var q = [], j = 0; j < P.length; j++) {
          var Y = P[j], B = Y(W, C, I, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new y("Invalid " + U + " `" + T + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(S);
    }
    function N() {
      function P(D, F, S, W, C) {
        return H(D[F]) ? null : new y("Invalid " + W + " `" + C + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, D, F, S, W) {
      return new y(
        (P || "React class") + ": " + D + " type `" + F + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var j = P[q];
          if (typeof j != "function")
            return R(W, C, I, q, X(j));
          var Y = j(U, q, W, C, I + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(D);
    }
    function Z(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, F[S], P);
        for (var j in q) {
          var Y = P[j];
          if (r(P, j) && typeof Y != "function")
            return R(W, C, I, j, X(Y));
          if (!Y)
            return new y(
              "Invalid " + C + " `" + I + "` key `" + j + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(F[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, j, W, C, I + "." + j, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(D);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var F = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = F.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = F.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function $(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : $(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, i_;
}
var s_, IG;
function wnt() {
  if (IG) return s_;
  IG = 1;
  var e = VB();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, s_ = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, s_;
}
if (process.env.NODE_ENV !== "production") {
  var Cnt = jpe(), xnt = !0;
  zD.exports = bnt()(Cnt.isElement, xnt);
} else
  zD.exports = wnt()();
var Ck = zD.exports, xk = {};
Object.defineProperty(xk, "__esModule", {
  value: !0
});
var Ont = hv, a_ = Ent(Ont);
function Ent(e) {
  return e && e.__esModule ? e : { default: e };
}
var knt = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return a_.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && a_.default.getHash() !== e && a_.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
xk.default = knt;
Object.defineProperty(pv, "__esModule", {
  value: !0
});
var Vb = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Lnt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Pnt = we, BG = vv(Pnt), _nt = dv, $b = vv(_nt), Snt = af, Mnt = vv(Snt), Dnt = Ck, Oo = vv(Dnt), Tnt = xk, vu = vv(Tnt);
function vv(e) {
  return e && e.__esModule ? e : { default: e };
}
function jnt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ant(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Int(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var RG = {
  to: Oo.default.string.isRequired,
  containerId: Oo.default.string,
  container: Oo.default.object,
  activeClass: Oo.default.string,
  activeStyle: Oo.default.object,
  spy: Oo.default.bool,
  horizontal: Oo.default.bool,
  smooth: Oo.default.oneOfType([Oo.default.bool, Oo.default.string]),
  offset: Oo.default.number,
  delay: Oo.default.number,
  isDynamic: Oo.default.bool,
  onClick: Oo.default.func,
  duration: Oo.default.oneOfType([Oo.default.number, Oo.default.func]),
  absolute: Oo.default.bool,
  onSetActive: Oo.default.func,
  onSetInactive: Oo.default.func,
  ignoreCancelEvents: Oo.default.bool,
  hashSpy: Oo.default.bool,
  saveHashHistory: Oo.default.bool,
  spyThrottle: Oo.default.number
};
pv.default = function(e, t) {
  var n = t || Mnt.default, r = function(i) {
    Int(a, i);
    function a(s) {
      jnt(this, a);
      var l = Ant(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return Lnt(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!$b.default.isMounted(s)) {
            var l = $b.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (vu.default.isMounted() || vu.default.mount(n), vu.default.mapContainer(this.props.to, s)), $b.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        $b.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Vb({}, this.props.style, this.props.activeStyle) : l = Vb({}, this.props.style);
        var u = Vb({}, this.props);
        for (var c in RG)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, BG.default.createElement(e, u);
      }
    }]), a;
  }(BG.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Vb({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(vu.default.isMounted() && !vu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, y = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, y = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(y), g = M < Math.floor(f) || M >= Math.floor(y);
        } else {
          var O = 0, v = 0, x = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            x = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            O = z.top - x + s, v = O + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(v), g = L < Math.floor(O) || L >= Math.floor(v);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && vu.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            vu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var Z = i.props.saveHashHistory, H = Z === void 0 ? !1 : Z;
          i.props.hashSpy && vu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = RG, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(FB, "__esModule", {
  value: !0
});
var Bnt = we, NG = Ipe(Bnt), Rnt = pv, Nnt = Ipe(Rnt);
function Ipe(e) {
  return e && e.__esModule ? e : { default: e };
}
function Fnt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function FG(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function znt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Unt = function(e) {
  znt(t, e);
  function t() {
    var n, r, o, i;
    Fnt(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = FG(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return NG.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), FG(o, i);
  }
  return t;
}(NG.default.Component);
FB.default = (0, Nnt.default)(Unt);
var $B = {};
Object.defineProperty($B, "__esModule", {
  value: !0
});
var Hnt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Wnt = we, zG = Bpe(Wnt), Vnt = pv, $nt = Bpe(Vnt);
function Bpe(e) {
  return e && e.__esModule ? e : { default: e };
}
function Znt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function qnt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Gnt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Knt = function(e) {
  Gnt(t, e);
  function t() {
    return Znt(this, t), qnt(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Hnt(t, [{
    key: "render",
    value: function() {
      return zG.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(zG.default.Component);
$B.default = (0, $nt.default)(Knt);
var ZB = {}, Ok = {};
Object.defineProperty(Ok, "__esModule", {
  value: !0
});
var Ynt = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Xnt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Jnt = we, UG = Ek(Jnt), Qnt = nl;
Ek(Qnt);
var ert = af, HG = Ek(ert), trt = Ck, WG = Ek(trt);
function Ek(e) {
  return e && e.__esModule ? e : { default: e };
}
function nrt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function rrt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ort(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Ok.default = function(e) {
  var t = function(n) {
    ort(r, n);
    function r(o) {
      nrt(this, r);
      var i = rrt(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Xnt(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        HG.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        HG.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return UG.default.createElement(e, Ynt({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(UG.default.Component);
  return t.propTypes = {
    name: WG.default.string,
    id: WG.default.string
  }, t;
};
Object.defineProperty(ZB, "__esModule", {
  value: !0
});
var VG = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, irt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), srt = we, $G = qB(srt), art = Ok, lrt = qB(art), urt = Ck, ZG = qB(urt);
function qB(e) {
  return e && e.__esModule ? e : { default: e };
}
function crt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function prt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function drt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Rpe = function(e) {
  drt(t, e);
  function t() {
    return crt(this, t), prt(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return irt(t, [{
    key: "render",
    value: function() {
      var n = this, r = VG({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, $G.default.createElement(
        "div",
        VG({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}($G.default.Component);
Rpe.propTypes = {
  name: ZG.default.string,
  id: ZG.default.string
};
ZB.default = (0, lrt.default)(Rpe);
var l_ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, qG = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function GG(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function KG(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function YG(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Zb = we, Wc = dv, u_ = af, Vo = Ck, yu = xk, XG = {
  to: Vo.string.isRequired,
  containerId: Vo.string,
  container: Vo.object,
  activeClass: Vo.string,
  spy: Vo.bool,
  smooth: Vo.oneOfType([Vo.bool, Vo.string]),
  offset: Vo.number,
  delay: Vo.number,
  isDynamic: Vo.bool,
  onClick: Vo.func,
  duration: Vo.oneOfType([Vo.number, Vo.func]),
  absolute: Vo.bool,
  onSetActive: Vo.func,
  onSetInactive: Vo.func,
  ignoreCancelEvents: Vo.bool,
  hashSpy: Vo.bool,
  spyThrottle: Vo.number
}, frt = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || u_, r = function(i) {
      YG(a, i);
      function a(s) {
        GG(this, a);
        var l = KG(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return qG(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Wc.isMounted(s) || Wc.mount(s, this.props.spyThrottle), this.props.hashSpy && (yu.isMounted() || yu.mount(n), yu.mapContainer(this.props.to, s)), this.props.spy && Wc.addStateHandler(this.stateHandler), Wc.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Wc.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = l_({}, this.props);
          for (var u in XG)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Zb.createElement(e, l);
        }
      }]), a;
    }(Zb.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, l_({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(yu.isMounted() && !yu.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var y = a - i.props.offset, b = y >= Math.floor(c) && y < Math.floor(p), E = y < Math.floor(c) || y >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && yu.getHash() === l && yu.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Wc.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && yu.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Wc.updateStates();
        }
      };
    };
    return r.propTypes = XG, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      YG(r, n);
      function r(o) {
        GG(this, r);
        var i = KG(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return qG(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          u_.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          u_.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Zb.createElement(e, l_({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Zb.Component);
    return t.propTypes = {
      name: Vo.string,
      id: Vo.string
    }, t;
  }
}, hrt = frt;
Object.defineProperty(ai, "__esModule", {
  value: !0
});
ai.Helpers = ai.ScrollElement = ai.ScrollLink = ai.animateScroll = ai.scrollSpy = ai.Events = ai.scroller = ai.Element = ai.Button = ai.Link = void 0;
var grt = FB, Npe = ul(grt), mrt = $B, Fpe = ul(mrt), vrt = ZB, zpe = ul(vrt), yrt = af, Upe = ul(yrt), brt = gv, Hpe = ul(brt), wrt = dv, Wpe = ul(wrt), Crt = yk, Vpe = ul(Crt), xrt = pv, $pe = ul(xrt), Ort = Ok, Zpe = ul(Ort), Ert = hrt, qpe = ul(Ert);
function ul(e) {
  return e && e.__esModule ? e : { default: e };
}
ai.Link = Npe.default;
ai.Button = Fpe.default;
ai.Element = zpe.default;
ai.scroller = Upe.default;
ai.Events = Hpe.default;
ai.scrollSpy = Wpe.default;
ai.animateScroll = Vpe.default;
ai.ScrollLink = $pe.default;
ai.ScrollElement = Zpe.default;
ai.Helpers = qpe.default;
ai.default = { Link: Npe.default, Button: Fpe.default, Element: zpe.default, scroller: Upe.default, Events: Hpe.default, scrollSpy: Wpe.default, animateScroll: Vpe.default, ScrollLink: $pe.default, ScrollElement: Zpe.default, Helpers: qpe.default };
We({});
We({});
We({});
function hm(e) {
  "@babel/helpers - typeof";
  return hm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, hm(e);
}
function krt(e, t) {
  if (hm(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (hm(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Lrt(e) {
  var t = krt(e, "string");
  return hm(t) == "symbol" ? t : t + "";
}
function Re(e, t, n) {
  return (t = Lrt(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Gpe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var c_, JG;
function Prt() {
  if (JG) return c_;
  JG = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return c_ = t, c_;
}
var _rt = Prt(), mi = /* @__PURE__ */ Gpe(_rt), qt = We(null);
function Srt() {
  mi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(qt);
  return mi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Mrt(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Drt(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Trt(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Drt(e, i), o;
}
function jrt(e, t, n) {
  var r = Mrt(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function Art(e) {
  google.maps.event.removeListener(e);
}
function Un() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(Art);
}
function Mn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = jrt(o, i, n);
  return Trt(t, r, o, i), a;
}
function Irt(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: y,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [v, x] = k(null), _ = ht(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null), [j, Y] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && y && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", y)));
  }, [y]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (j !== null && google.maps.event.removeListener(j), Y(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return x(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), Mi.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: Mi.jsx(qt.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(Irt);
function QG(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Kpe(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        QG(i, r, o, a, s, "next", l);
      }
      function s(l) {
        QG(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Ype(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return mi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var Cp = typeof document < "u";
function Xpe(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return Cp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function eK(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Jpe() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return eK(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return eK(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Yf = !1;
function Qpe() {
  return Mi.jsx("div", {
    children: "Loading..."
  });
}
var UD = {
  id: "script-loader",
  version: "weekly"
};
class Brt extends pe {
  constructor() {
    super(...arguments), Re(this, "check", null), Re(this, "state", {
      loaded: !1
    }), Re(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Re(this, "isCleaningUp", /* @__PURE__ */ Kpe(function* () {
      function t(n) {
        if (!Yf)
          n();
        else if (Cp)
          var r = window.setInterval(function() {
            Yf || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Re(this, "cleanup", () => {
      Yf = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Re(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Jpe(), mi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Ype(this.props)
      };
      Xpe(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Re(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (Cp) {
      if (window.google && window.google.maps && !Yf) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), Cp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (Cp) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Yf = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Mi.jsxs(Mi.Fragment, {
      children: [Mi.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Mi.jsx(Qpe, {})]
    });
  }
}
Re(Brt, "defaultProps", UD);
function Rrt(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function GB(e, t) {
  if (e == null) return {};
  var n, r, o = Rrt(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var tK;
function Nrt(e) {
  var {
    id: t = UD.id,
    version: n = UD.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ht(!1), [f, y] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    Cp && u && Jpe();
  }, [u]), h(function() {
    f && mi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Ype({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!Cp)
      return;
    function O() {
      g.current && (y(!0), tK = w);
    }
    if (window.google && window.google.maps && tK === w) {
      O();
      return;
    }
    Xpe({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = ht(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var Frt = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], zrt = Mi.jsx(Qpe, {});
function Urt(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = GB(e, Frt), {
    isLoaded: s,
    loadError: l
  } = Nrt(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || zrt;
}
me(Urt);
var nK;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(nK || (nK = {}));
function rK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ZC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oK = {}, iK = {
  options(e, t) {
    e.setOptions(t);
  }
};
function Hrt(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(qt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(ZC(ZC({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(Hrt);
class Wrt extends pe {
  constructor() {
    super(...arguments), Re(this, "state", {
      trafficLayer: null
    }), Re(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Re(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(ZC(ZC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: iK,
      eventMap: oK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: iK,
      eventMap: oK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Un(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Re(Wrt, "contextType", qt);
function Vrt(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(qt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(Vrt);
class $rt extends pe {
  constructor() {
    super(...arguments), Re(this, "state", {
      bicyclingLayer: null
    }), Re(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Re($rt, "contextType", qt);
function Zrt(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(qt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(Zrt);
class qrt extends pe {
  constructor() {
    super(...arguments), Re(this, "state", {
      transitLayer: null
    }), Re(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Re(qrt, "contextType", qt);
function sK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aK = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, lK = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Grt(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(qt), [d, g] = k(null), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), y(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    mi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(qC(qC({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && y(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && v(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(Grt);
class Krt extends pe {
  constructor(t) {
    super(t), Re(this, "registeredEvents", []), Re(this, "state", {
      drawingManager: null
    }), Re(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), mi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(qC(qC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: lK,
      eventMap: aK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: lK,
      eventMap: aK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Un(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Re(Krt, "contextType", qt);
function uK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Od(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cK = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, pK = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, GC = {};
function Yrt(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: y,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: v,
    onMouseOut: x,
    onMouseOver: _,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: Z,
    onDraggableChanged: H,
    onFlatChanged: $,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: F,
    onUnmount: S
  } = e, W = ge(qt), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null), [oe, Pe] = k(null), [Ue, Ze] = k(null), [_e, rt] = k(null), [Ve, ye] = k(null), [Ge, ct] = k(null), [ve, Oe] = k(null), [qe, ze] = k(null), [Se, st] = k(null), [xe, xt] = k(null), [at, lt] = k(null), [pt, Ot] = k(null), [dt, ft] = k(null), [ot, He] = k(null), [Et, kt] = k(null), [gt, St] = k(null), [mt, Mt] = k(null), [vt, Pt] = k(null);
  h(() => {
    C !== null && C.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && C !== null && C.setOptions(n);
  }, [C, n]), h(() => {
    typeof a < "u" && C !== null && C.setDraggable(a);
  }, [C, a]), h(() => {
    t && C !== null && C.setPosition(t);
  }, [C, t]), h(() => {
    typeof s < "u" && C !== null && C.setVisible(s);
  }, [C, s]), h(() => {
    C == null || C.setAnimation(l);
  }, [C, l]), h(() => {
    C && u !== void 0 && C.setClickable(u);
  }, [C, u]), h(() => {
    C && c !== void 0 && C.setCursor(c);
  }, [C, c]), h(() => {
    C && p !== void 0 && C.setIcon(p);
  }, [C, p]), h(() => {
    C && d !== void 0 && C.setLabel(d);
  }, [C, d]), h(() => {
    C && g !== void 0 && C.setOpacity(g);
  }, [C, g]), h(() => {
    C && f !== void 0 && C.setShape(f);
  }, [C, f]), h(() => {
    C && y !== void 0 && C.setTitle(y);
  }, [C, y]), h(() => {
    C && b !== void 0 && C.setZIndex(b);
  }, [C, b]), h(() => {
    C && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(C, "dblclick", w)));
  }, [w]), h(() => {
    C && O && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(C, "dragend", O)));
  }, [O]), h(() => {
    C && v && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(C, "dragstart", v)));
  }, [v]), h(() => {
    C && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(C, "mousedown", L)));
  }, [L]), h(() => {
    C && x && (oe !== null && google.maps.event.removeListener(oe), Pe(google.maps.event.addListener(C, "mouseout", x)));
  }, [x]), h(() => {
    C && _ && (Ue !== null && google.maps.event.removeListener(Ue), Ze(google.maps.event.addListener(C, "mouseover", _)));
  }, [_]), h(() => {
    C && z && (_e !== null && google.maps.event.removeListener(_e), rt(google.maps.event.addListener(C, "mouseup", z)));
  }, [z]), h(() => {
    C && N && (Ve !== null && google.maps.event.removeListener(Ve), ye(google.maps.event.addListener(C, "rightclick", N)));
  }, [N]), h(() => {
    C && E && (Ge !== null && google.maps.event.removeListener(Ge), ct(google.maps.event.addListener(C, "click", E)));
  }, [E]), h(() => {
    C && M && (ve !== null && google.maps.event.removeListener(ve), Oe(google.maps.event.addListener(C, "drag", M)));
  }, [M]), h(() => {
    C && R && (qe !== null && google.maps.event.removeListener(qe), ze(google.maps.event.addListener(C, "clickable_changed", R)));
  }, [R]), h(() => {
    C && V && (Se !== null && google.maps.event.removeListener(Se), st(google.maps.event.addListener(C, "cursor_changed", V)));
  }, [V]), h(() => {
    C && Z && (xe !== null && google.maps.event.removeListener(xe), xt(google.maps.event.addListener(C, "animation_changed", Z)));
  }, [Z]), h(() => {
    C && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(C, "draggable_changed", H)));
  }, [H]), h(() => {
    C && $ && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(C, "flat_changed", $)));
  }, [$]), h(() => {
    C && K && (dt !== null && google.maps.event.removeListener(dt), ft(google.maps.event.addListener(C, "icon_changed", K)));
  }, [K]), h(() => {
    C && X && (ot !== null && google.maps.event.removeListener(ot), He(google.maps.event.addListener(C, "position_changed", X)));
  }, [X]), h(() => {
    C && Q && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(C, "shape_changed", Q)));
  }, [Q]), h(() => {
    C && J && (gt !== null && google.maps.event.removeListener(gt), St(google.maps.event.addListener(C, "title_changed", J)));
  }, [J]), h(() => {
    C && P && (mt !== null && google.maps.event.removeListener(mt), Mt(google.maps.event.addListener(C, "visible_changed", P)));
  }, [P]), h(() => {
    C && D && (vt !== null && google.maps.event.removeListener(vt), Pt(google.maps.event.addListener(C, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = Od(Od(Od({}, n || GC), r ? GC : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(yt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof g < "u" && te.setOpacity(g), f && te.setShape(f), typeof y == "string" && te.setTitle(y), typeof b == "number" && te.setZIndex(b), w && T(google.maps.event.addListener(te, "dblclick", w)), O && j(google.maps.event.addListener(te, "dragend", O)), v && B(google.maps.event.addListener(te, "dragstart", v)), L && he(google.maps.event.addListener(te, "mousedown", L)), x && Pe(google.maps.event.addListener(te, "mouseout", x)), _ && Ze(google.maps.event.addListener(te, "mouseover", _)), z && rt(google.maps.event.addListener(te, "mouseup", z)), N && ye(google.maps.event.addListener(te, "rightclick", N)), E && ct(google.maps.event.addListener(te, "click", E)), M && Oe(google.maps.event.addListener(te, "drag", M)), R && ze(google.maps.event.addListener(te, "clickable_changed", R)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), Z && xt(google.maps.event.addListener(te, "animation_changed", Z)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), $ && Ot(google.maps.event.addListener(te, "flat_changed", $)), K && ft(google.maps.event.addListener(te, "icon_changed", K)), X && He(google.maps.event.addListener(te, "position_changed", X)), Q && kt(google.maps.event.addListener(te, "shape_changed", Q)), J && St(google.maps.event.addListener(te, "title_changed", J)), P && Mt(google.maps.event.addListener(te, "visible_changed", P)), D && Pt(google.maps.event.addListener(te, "zindex_changed", D)), I(te), F && F(te), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), _e !== null && google.maps.event.removeListener(_e), Ve !== null && google.maps.event.removeListener(Ve), Ge !== null && google.maps.event.removeListener(Ge), qe !== null && google.maps.event.removeListener(qe), Se !== null && google.maps.event.removeListener(Se), xe !== null && google.maps.event.removeListener(xe), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ot !== null && google.maps.event.removeListener(ot), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var jn = Ft(() => i ? ut.map(i, (yt) => {
    if (!wi(yt))
      return yt;
    var te = yt;
    return Ci(te, {
      anchor: C
    });
  }) : null, [i, C]);
  return Mi.jsx(Mi.Fragment, {
    children: jn
  }) || null;
}
me(Yrt);
class Xrt extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Kpe(function* () {
      var n = Od(Od(Od({}, t.props.options || GC), t.props.clusterer ? GC : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Mn({
        updaterMap: pK,
        eventMap: cK,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: pK,
      eventMap: cK,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Un(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Ci(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Re(Xrt, "contextType", qt);
var Jrt = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), Qrt = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Jrt(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function eot(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var tot = 2e3, not = 500, rot = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", oot = "png", iot = [53, 56, 66, 78, 90], sot = "cluster", ede = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || rot, this.imageExtension = r.imageExtension || oot, this.imageSizes = r.imageSizes || iot, this.calculator = r.calculator || eot, this.batchSize = r.batchSize || tot, this.batchSizeIE = r.batchSizeIE || not, this.clusterClass = r.clusterClass || sot, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new Qrt(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function dK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aot(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wa = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Kn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, lot = {};
function uot(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: y,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: v,
    onMouseOut: x,
    onLoad: _,
    onUnmount: z
  } = e, [L, N] = k(null), R = ge(qt), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && x && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, wa.onMouseOut, x)));
  }, [x]), h(() => {
    L && v && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, wa.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(L, wa.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(L, wa.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), $(google.maps.event.addListener(L, wa.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && Kn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Kn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Kn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Kn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Kn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Kn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Kn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Kn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Kn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Kn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Kn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Kn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof y < "u" && L !== null && Kn.styles(L, y);
  }, [L, y]), h(() => {
    typeof b < "u" && L !== null && Kn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && Kn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var F = aot({}, n || lot), S = new ede(R, [], F);
      return r && Kn.averageCenter(S, r), o && Kn.batchSizeIE(S, o), i && Kn.calculator(S, i), a && Kn.clusterClass(S, a), s && Kn.enableRetinaIcons(S, s), l && Kn.gridSize(S, l), u && Kn.ignoreHidden(S, u), c && Kn.imageExtension(S, c), p && Kn.imagePath(S, p), d && Kn.imageSizes(S, d), g && Kn.maxZoom(S, g), f && Kn.minimumClusterSize(S, f), y && Kn.styles(S, y), b && Kn.title(S, b), E && Kn.zoomOnClick(S, E), x && J(google.maps.event.addListener(S, wa.onMouseOut, x)), v && D(google.maps.event.addListener(S, wa.onMouseOver, v)), w && Z(google.maps.event.addListener(S, wa.onClick, w)), M && $(google.maps.event.addListener(S, wa.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, wa.onClusteringEnd, O)), N(S), _ && _(S), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), z && z(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(uot);
class cot extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      markerClusterer: null
    }), Re(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new ede(this.context, [], this.props.options);
      this.registeredEvents = Mn({
        updaterMap: Kn,
        eventMap: wa,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: Kn,
      eventMap: wa,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Un(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Re(cot, "contextType", qt);
function fK(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var tde = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || fK(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, fK));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, y = this.getProjection(), b = y.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), pot = ["position"], dot = ["position"];
function hK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function KC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gK = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, mK = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, fot = {};
function hot(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(qt), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || fot, {
        position: V
      } = R, Z = GB(R, pot), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var $ = new tde(KC(KC({}, Z), H ? {
        position: H
      } : {}));
      N.current = document.createElement("div"), y($), a && E(google.maps.event.addListener($, "closeclick", a)), s && M(google.maps.event.addListener($, "domready", s)), l && v(google.maps.event.addListener($, "content_changed", l)), u && _(google.maps.event.addListener($, "position_changed", u)), c && L(google.maps.event.addListener($, "zindex_changed", c)), $.setContent(N.current), n ? $.open(g, n) : $.getPosition() ? $.open(g) : mi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p($);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(hot);
class got extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "containerElement", null), Re(this, "state", {
      infoBox: null
    }), Re(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : mi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Re(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = GB(t, dot), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new tde(KC(KC({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Mn({
      updaterMap: mK,
      eventMap: gK,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: mK,
      eventMap: gK,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Un(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
Re(got, "contextType", qt);
var vK, yK;
function mot() {
  return yK || (yK = 1, vK = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), vK;
}
var vot = mot(), bK = /* @__PURE__ */ Gpe(vot), wK = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], p_ = 1, Xf = 8;
class KB {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== p_)
      throw new Error("Got v".concat(o, " data when expected v").concat(p_, "."));
    var i = wK[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new KB(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = wK.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Xf, t), this.coords = new this.ArrayType(this.data, Xf + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Xf + a + s + l), this.ids = new this.IndexArrayType(this.data, Xf, t), this.coords = new this.ArrayType(this.data, Xf + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (p_ << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return HD(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], y = a[2 * g + 1];
          f >= t && f <= r && y >= n && y <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          CK(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, y = i[2 * f], b = i[2 * f + 1];
      CK(y, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= y : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= y : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function HD(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    nde(e, t, a, r, o, i), HD(e, t, n, r, a - 1, 1 - i), HD(e, t, n, a + 1, o, 1 - i);
  }
}
function nde(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      nde(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, y = o;
    for (Jf(e, t, r, n), t[2 * o + i] > g && Jf(e, t, r, o); f < y; ) {
      for (Jf(e, t, f, y), f++, y--; t[2 * f + i] < g; ) f++;
      for (; t[2 * y + i] > g; ) y--;
    }
    t[2 * r + i] === g ? Jf(e, t, r, y) : (y++, Jf(e, t, y, o)), y <= n && (r = y + 1), n <= y && (o = y - 1);
  }
}
function Jf(e, t, n, r) {
  d_(e, n, r), d_(t, 2 * n, 2 * r), d_(t, 2 * n + 1, 2 * r + 1);
}
function d_(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function CK(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var yot = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, xK = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Vc = 2, Fu = 3, f_ = 4, Mu = 5, rde = 6;
class bot {
  constructor(t) {
    this.options = Object.assign(Object.create(yot), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = xK(qb(u)), d = xK(Gb(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var y = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - y);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(qb(r), Gb(a), qb(i), Gb(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Mu] > 1 ? OK(p, f, this.clusterProps) : this.points[p[f + Fu]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + f_] === t && p.push(a[g + Mu] > 1 ? OK(a, g, this.clusterProps) : this.points[a[g + Fu]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new KB(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Mu] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = ode(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Fu]];
        c = g.properties;
        var [f, y] = g.geometry.coordinates;
        p = qb(f), d = Gb(y);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Fu] : E = this.points[n[l + Fu]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Vc] <= n)) {
        l[p + Vc] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), y = l[p + Mu], b = y;
        for (var E of f) {
          var w = E * c;
          l[w + Vc] > n && (b += l[w + Mu]);
        }
        if (b > y && b >= a) {
          var M = d * y, O = g * y, v = void 0, x = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Vc] <= n)) {
              l[L + Vc] = n;
              var N = l[L + Mu];
              M += l[L] * N, O += l[L + 1] * N, l[L + f_] = _, i && (v || (v = this._map(l, p, !0), x = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + f_] = _, u.push(M / b, O / b, 1 / 0, _, -1, b), i && u.push(x);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var Z = V * c;
              if (!(l[Z + Vc] <= n)) {
                l[Z + Vc] = n;
                for (var H = 0; H < c; H++) u.push(l[Z + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Mu] > 1) {
      var o = this.clusterProps[t[n + rde]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Fu]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function OK(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Fu],
    properties: ode(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [wot(e[t]), Cot(e[t + 1])]
    }
  };
}
function ode(e, t, n) {
  var r = e[t + Mu], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + rde], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Fu],
    point_count: r,
    point_count_abbreviated: o
  });
}
function qb(e) {
  return e / 360 + 0.5;
}
function Gb(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function wot(e) {
  return (e - 0.5) * 360;
}
function Cot(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function xot(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class qs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class WD {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(qs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => qs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (qs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Oot {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return Eot(n);
  }
}
var Eot = (e) => {
  var t = e.map((n) => new WD({
    position: qs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class kot extends Oot {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = xot(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new bot(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!bK(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = qs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !bK(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new WD({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new WD({
      markers: [i],
      position: qs.getPosition(i)
    });
  }
}
class Lot {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Pot {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (qs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function _ot(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class YB {
  constructor() {
    _ot(YB, google.maps.OverlayView);
  }
}
var ng;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(ng || (ng = {}));
var Sot = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Mot extends YB {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new kot(o),
      renderer: a = new Pot(),
      onClusterClick: s = Sot
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (qs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, ng.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || qs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => qs.setMap(l, null)));
      }
      google.maps.event.trigger(this, ng.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => qs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Lot(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => qs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, ng.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), qs.setMap(r.marker, n);
    });
  }
}
function EK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kK(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Dot(e) {
  var t = Srt(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new Mot(kK(kK({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Tot(e) {
  var {
    children: t,
    options: n
  } = e, r = Dot(n);
  return r !== null ? t(r) : null;
}
me(Tot);
var LK = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, PK = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function jot(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(qt), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return y(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && v(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : mi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(R), R.close();
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(jot);
class Aot extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "containerElement", null), Re(this, "state", {
      infoWindow: null
    }), Re(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : mi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Re(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Mn({
      updaterMap: PK,
      eventMap: LK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: PK,
      eventMap: LK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Un(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
Re(Aot, "contextType", qt);
function _K(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function YC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _K(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _K(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SK = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, MK = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Iot = {};
function Bot(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(qt), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && y && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(O, "click", y)));
  }, [y]), h(() => {
    O && b && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(O, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(YC(YC({}, t || Iot), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && Z(google.maps.event.addListener(T, "mousedown", u)), c && $(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), y && C(google.maps.event.addListener(T, "click", y)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(Bot);
class Rot extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      polyline: null
    }), Re(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(YC(YC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: MK,
      eventMap: SK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: MK,
      eventMap: SK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Un(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Re(Rot, "contextType", qt);
function DK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function TK(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jK = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, AK = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Not(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, v = ge(qt), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    x !== null && x.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    typeof a < "u" && x !== null && x.setPaths(a);
  }, [x, a]), h(() => {
    x && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dblclick", s)));
  }, [s]), h(() => {
    x && (google.maps.event.addListener(x.getPath(), "insert_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "set_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "remove_at", () => {
      O == null || O(x);
    }));
  }, [x, O]), h(() => {
    x && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragend", l)));
  }, [l]), h(() => {
    x && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(x, "dragstart", u)));
  }, [u]), h(() => {
    x && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(x, "mousedown", c)));
  }, [c]), h(() => {
    x && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(x, "mousemove", p)));
  }, [p]), h(() => {
    x && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseout", d)));
  }, [d]), h(() => {
    x && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(x, "mouseover", g)));
  }, [g]), h(() => {
    x && typeof f == "function" && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(x, "mouseup", f)));
  }, [f]), h(() => {
    x && typeof y == "function" && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(x, "rightclick", y)));
  }, [y]), h(() => {
    x && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(x, "click", b)));
  }, [b]), h(() => {
    x && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(x, "drag", E)));
  }, [E]), h(() => {
    var j = new google.maps.Polygon(TK(TK({}, t), {}, {
      map: v
    }));
    return i && j.setPath(i), a && j.setPaths(a), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), s && L(google.maps.event.addListener(j, "dblclick", s)), l && R(google.maps.event.addListener(j, "dragend", l)), u && Z(google.maps.event.addListener(j, "dragstart", u)), c && $(google.maps.event.addListener(j, "mousedown", c)), p && X(google.maps.event.addListener(j, "mousemove", p)), d && J(google.maps.event.addListener(j, "mouseout", d)), g && D(google.maps.event.addListener(j, "mouseover", g)), f && S(google.maps.event.addListener(j, "mouseup", f)), y && C(google.maps.event.addListener(j, "rightclick", y)), b && U(google.maps.event.addListener(j, "click", b)), E && q(google.maps.event.addListener(j, "drag", E)), _(j), w && w(j), () => {
      z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), M && M(j), j.setMap(null);
    };
  }, []), null;
}
me(Not);
class Fot extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Mn({
      updaterMap: AK,
      eventMap: jK,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: AK,
      eventMap: jK,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Un(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Re(Fot, "contextType", qt);
function IK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function XC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var BK = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, RK = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function zot(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(qt), [v, x] = k(null), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null);
  return h(() => {
    v !== null && v.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(v, "click", y)));
  }, [y]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(XC(XC({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && z(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && H(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && F(google.maps.event.addListener(Y, "mouseup", g)), f && W(google.maps.event.addListener(Y, "rightclick", f)), y && I(google.maps.event.addListener(Y, "click", y)), b && T(google.maps.event.addListener(Y, "drag", b)), E && j(google.maps.event.addListener(Y, "bounds_changed", E)), x(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
me(zot);
class Uot extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      rectangle: null
    }), Re(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(XC(XC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: RK,
      eventMap: BK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: RK,
      eventMap: BK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Un(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Re(Uot, "contextType", qt);
function NK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function JC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FK = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, zK = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Hot = {};
function Wot(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: v
  } = e, x = ge(qt), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null);
  return h(() => {
    _ !== null && _.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(_, "rightclick", y)));
  }, [y]), h(() => {
    _ && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", b)));
  }, [b]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [b]), h(() => {
    _ && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(JC(JC({}, t || Hot), {}, {
      map: x
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && F(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), y && I(google.maps.event.addListener(oe, "rightclick", y)), b && T(google.maps.event.addListener(oe, "click", b)), E && j(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), z(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(Wot);
class Vot extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      circle: null
    }), Re(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(JC(JC({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: zK,
      eventMap: FK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: zK,
      eventMap: FK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Un(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Re(Vot, "contextType", qt);
function UK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function QC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var HK = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, WK = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function $ot(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: y,
    onUnmount: b
  } = e, E = ge(qt), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var j = new google.maps.Data(QC(QC({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(j, "dblclick", r)), o && _(google.maps.event.addListener(j, "mousedown", o)), i && L(google.maps.event.addListener(j, "mousemove", i)), a && R(google.maps.event.addListener(j, "mouseout", a)), s && Z(google.maps.event.addListener(j, "mouseover", s)), l && $(google.maps.event.addListener(j, "mouseup", l)), u && X(google.maps.event.addListener(j, "rightclick", u)), n && J(google.maps.event.addListener(j, "click", n)), c && D(google.maps.event.addListener(j, "addfeature", c)), p && S(google.maps.event.addListener(j, "removefeature", p)), d && C(google.maps.event.addListener(j, "removeproperty", d)), g && U(google.maps.event.addListener(j, "setgeometry", g)), f && q(google.maps.event.addListener(j, "setproperty", f)), M(j), y && y(j);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me($ot);
class Zot extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      data: null
    }), Re(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(QC(QC({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Mn({
        updaterMap: WK,
        eventMap: HK,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: WK,
      eventMap: HK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Un(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Re(Zot, "contextType", qt);
function VK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $K(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ZK = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, qK = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class qot extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      kmlLayer: null
    }), Re(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer($K($K({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: qK,
      eventMap: ZK,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: qK,
      eventMap: ZK,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Un(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Re(qot, "contextType", qt);
function ide(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Got(e, t) {
  return new t(e.lat, e.lng);
}
function Kot(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Yot(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Xot(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Jot(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Qot(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function sde(e, t, n, r) {
  return n !== void 0 ? Jot(e, t, Xot(n, google.maps.LatLngBounds, Kot)) : Qot(e, t, Yot(r, google.maps.LatLng, Got));
}
function eit(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function GK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tit(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function nit(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = tit({}, this.container ? ide(this.container, o) : {
        x: 0,
        y: 0
      }), u = sde(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function KK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rit(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function YK(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function XK(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function oit(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(qt), c = Ft(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Ft(() => nit(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), xi.createPortal(l, c);
}
me(oit);
class lf extends pe {
  constructor(t) {
    super(t), Re(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Re(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      mi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Re(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Re(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = rit({
        x: 0,
        y: 0
      }, this.containerRef.current ? ide(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = sde(r, o, this.props.bounds, this.props.position);
      if (!eit(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Re(this, "draw", () => {
      this.onPositionElement();
    }), Re(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Br();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = YK(t.position), r = YK(this.props.position), o = XK(t.bounds), i = XK(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? xi.createPortal(Mi.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
Re(lf, "FLOAT_PANE", "floatPane");
Re(lf, "MAP_PANE", "mapPane");
Re(lf, "MARKER_LAYER", "markerLayer");
Re(lf, "OVERLAY_LAYER", "overlayLayer");
Re(lf, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Re(lf, "contextType", qt);
function iit() {
}
function JK(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function QK(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JK(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JK(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var eY = {
  onDblClick: "dblclick",
  onClick: "click"
}, tY = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function sit(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(qt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Ft(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(sit);
class ade extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      groundOverlay: null
    }), Re(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    mi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, QK(QK({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: tY,
      eventMap: eY,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: tY,
      eventMap: eY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Re(ade, "defaultProps", {
  onLoad: iit
});
Re(ade, "contextType", qt);
function nY(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ex(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nY(Object(n), !0).forEach(function(r) {
      Re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nY(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rY = {}, oY = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function ait(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(qt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || mi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    mi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(ex(ex({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(ait);
class lit extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      heatmapLayer: null
    }), Re(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    mi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), mi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(ex(ex({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Mn({
      updaterMap: oY,
      eventMap: rY,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: oY,
      eventMap: rY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Un(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Re(lit, "contextType", qt);
var iY = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, sY = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class uit extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      streetViewPanorama: null
    }), Re(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Mn({
      updaterMap: sY,
      eventMap: iY,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: sY,
      eventMap: iY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Un(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Re(uit, "contextType", qt);
class cit extends pe {
  constructor() {
    super(...arguments), Re(this, "state", {
      streetViewService: null
    }), Re(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Re(cit, "contextType", qt);
var aY = {
  onDirectionsChanged: "directions_changed"
}, lY = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class pit extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "state", {
      directionsRenderer: null
    }), Re(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Mn({
      updaterMap: lY,
      eventMap: aY,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: lY,
      eventMap: aY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Un(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Re(pit, "contextType", qt);
var uY = {
  onPlacesChanged: "places_changed"
}, cY = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class dit extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "containerElement", Br()), Re(this, "state", {
      searchBox: null
    }), Re(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (mi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Mn({
          updaterMap: cY,
          eventMap: uY,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: cY,
      eventMap: uY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Un(this.registeredEvents));
  }
  render() {
    return Mi.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
Re(dit, "contextType", qt);
var pY = {
  onPlaceChanged: "place_changed"
}, dY = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class lde extends pe {
  constructor() {
    super(...arguments), Re(this, "registeredEvents", []), Re(this, "containerElement", Br()), Re(this, "state", {
      autocomplete: null
    }), Re(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    mi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Mn({
        updaterMap: dY,
        eventMap: pY,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Un(this.registeredEvents), this.registeredEvents = Mn({
      updaterMap: dY,
      eventMap: pY,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Un(this.registeredEvents);
  }
  render() {
    return Mi.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
Re(lde, "defaultProps", {
  className: ""
});
Re(lde, "contextType", qt);
let fit = { data: "" }, hit = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || fit, git = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, mit = /\/\*[^]*?\*\/|  +/g, fY = /\n+/g, Yu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Yu(a, i) : i + "{" + Yu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Yu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Yu.p ? Yu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Pl = {}, ude = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + ude(e[n]);
    return t;
  }
  return e;
}, vit = (e, t, n, r, o) => {
  let i = ude(e), a = Pl[i] || (Pl[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Pl[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = git.exec(u.replace(mit, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(fY, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(fY, " ").trim();
      return d[0];
    })(e);
    Pl[a] = Yu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Pl.g ? Pl.g : null;
  return n && (Pl.g = Pl[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Pl[a], t, r, s), a;
}, yit = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Yu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function kk(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return vit(n.unshift ? n.raw ? yit(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, hit(t.target), t.g, t.o, t.k);
}
let cde, VD, $D;
kk.bind({ g: 1 });
let Zl = kk.bind({ k: 1 });
function bit(e, t, n, r) {
  Yu.p = t, cde = e, VD = n, $D = r;
}
function Pc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: VD && VD() }, s), n.o = / *go\d+/.test(l), s.className = kk.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), $D && u[0] && $D(s), cde(u, s);
    }
    return o;
  };
}
var wit = (e) => typeof e == "function", Cit = (e, t) => wit(e) ? e(t) : e, xit = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Oit = Zl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Eit = Zl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, kit = Zl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Lit = Pc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Oit} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Eit} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${kit} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Pit = Zl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, _it = Pc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Pit} 1s linear infinite;
`, Sit = Zl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Mit = Zl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, Dit = Pc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Sit} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Mit} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Tit = Pc("div")`
  position: absolute;
`, jit = Pc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Ait = Zl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Iit = Pc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Ait} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, Bit = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Me.createElement(Iit, null, t) : t : n === "blank" ? null : Me.createElement(jit, null, Me.createElement(_it, { ...r }), n !== "loading" && Me.createElement(Tit, null, n === "error" ? Me.createElement(Lit, { ...r }) : Me.createElement(Dit, { ...r })));
}, Rit = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Nit = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, Fit = "0%{opacity:0;} 100%{opacity:1;}", zit = "0%{opacity:1;} 100%{opacity:0;}", Uit = Pc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Hit = Pc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Wit = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = xit() ? [Fit, zit] : [Rit(n), Nit(n)];
  return { animation: t ? `${Zl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Zl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Me.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? Wit(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Me.createElement(Bit, { toast: e }), a = Me.createElement(Hit, { ...e.ariaProps }, Cit(e.message, e));
  return Me.createElement(Uit, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Me.createElement(Me.Fragment, null, i, a));
});
bit(Me.createElement);
kk`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function XB(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, d = { xs: 12, sm: 16, md: 20, lg: 24 }[i], g = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ Jn.jsxs("button", { className: g, disabled: l || t, ...p, children: [
    /* @__PURE__ */ Jn.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ Jn.jsx(el, { size: d, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ Jn.jsxs("div", { className: "arkynButtonContent", children: [
      $N(d, a),
      c,
      $N(d, s)
    ] })
  ] });
}
function Vit() {
  const e = CT(), t = ate(), n = xT(), [r, o] = k(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  h(() => {
    var u, c;
    let p = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, p) || Object.entries(p).length !== 0 && o(p);
  }, [n, e]), h(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
We({});
function $it(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ Jn.jsxs(
    "button",
    {
      disabled: a || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ Jn.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ Jn.jsx(el, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ Jn.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ Jn.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function Zit(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ Jn.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ Jn.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function qit(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Git = {
  CNPJ: "99.999.999/9999-99"
};
qit(Git.CNPJ).length;
yr((e, t) => /* @__PURE__ */ Jn.jsx("input", { ref: t, ...e }));
function pde(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const dde = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function Kit(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function Yit(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const Xit = pde(dde.NINE).length, Jit = yr((e, t) => /* @__PURE__ */ Jn.jsx("input", { ref: t, ...e }));
yr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = pde(g.target.value);
      const y = Yit(f);
      f.length > Xit || (f = Kit(f, dde[y]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Jn.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Jn.jsx(
      tl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: Jit,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
We({});
var ru = {};
Object.defineProperty(ru, "__esModule", {
  value: !0
});
var Qit = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), h_ = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, fde = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Qit ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, JB = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Kb = 1; Kb < 20; Kb++)
  JB["f" + Kb] = 111 + Kb;
function Lk(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return hde(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return gde(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function est(e, t) {
  return Lk(e, t);
}
function tst(e, t) {
  return Lk(e, { byKey: !0 }, t);
}
function hde(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in h_)
    r[h_[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = QB(d), y = h_[f];
      if (d.length > 1 && !y && !fde[d] && !JB[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !y) && (n ? r.key = f : r.which = mde(d)), y && (r[y] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function gde(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function mde(e) {
  e = QB(e);
  var t = JB[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function QB(e) {
  return e = e.toLowerCase(), e = fde[e] || e, e;
}
ru.default = Lk;
var g_ = ru.isHotkey = Lk;
ru.isCodeHotkey = est;
ru.isKeyHotkey = tst;
ru.parseHotkey = hde;
ru.compareHotkey = gde;
ru.toKeyCode = mde;
ru.toKeyName = QB;
var nst = typeof _r == "object" && _r && _r.Object === Object && _r, rst = nst, ost = rst, ist = typeof self == "object" && self && self.Object === Object && self, sst = ost || ist || Function("return this")(), ast = sst, lst = ast, ust = lst.Symbol, vde = ust, hY = vde;
hY && hY.toStringTag;
var gY = vde;
gY && gY.toStringTag;
var mY;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(mY || (mY = {}));
var eR = function(e) {
  return Object.freeze(e);
}, cst = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, eR(this);
  }
  return e;
}(), pst = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, eR(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), vY = typeof window < "u" ? window : {};
/msie|trident/i.test(vY.navigator && vY.navigator.userAgent);
var m_ = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new cst((n ? t : e) || 0, (n ? e : t) || 0);
};
eR({
  devicePixelContentBoxSize: m_(),
  borderBoxSize: m_(),
  contentBoxSize: m_(),
  contentRect: new pst(0, 0, 0, 0)
});
function gm(e) {
  "@babel/helpers - typeof";
  return gm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, gm(e);
}
function dst(e, t) {
  if (gm(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (gm(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function fst(e) {
  var t = dst(e, "string");
  return gm(t) === "symbol" ? t : String(t);
}
function rg(e, t, n) {
  return t = fst(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var hst = /* @__PURE__ */ We(null), v_, y_;
parseInt(we.version.split(".")[0], 10);
var yY = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), b_ = typeof navigator < "u" && /Android/.test(navigator.userAgent), Yb = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), gst = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (v_ = navigator.userAgent.match(/Version\/(\d+)/)) !== null && v_ !== void 0 && v_[1] && parseInt((y_ = navigator.userAgent.match(/Version\/(\d+)/)) === null || y_ === void 0 ? void 0 : y_[1], 10) < 17;
var mst = /* @__PURE__ */ new WeakMap(), vst = /* @__PURE__ */ new WeakMap(), yst = /* @__PURE__ */ new WeakMap(), bst = /* @__PURE__ */ new WeakMap(), wst = /* @__PURE__ */ new WeakMap(), bY = /* @__PURE__ */ new WeakMap(), Cst = /* @__PURE__ */ new WeakMap(), wY = /* @__PURE__ */ new WeakMap(), Xb = /* @__PURE__ */ new WeakMap(), xst = /* @__PURE__ */ new WeakMap(), Ost = /* @__PURE__ */ new WeakMap(), Est = /* @__PURE__ */ new WeakMap(), yde = globalThis.Node, kst = globalThis.Text, bde = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Lst = (e) => tx(e) && e.nodeType === 8, Qa = (e) => tx(e) && e.nodeType === 1, tx = (e) => {
  var t = bde(e);
  return !!t && e instanceof t.Node;
}, CY = (e) => {
  var t = e && e.anchorNode && bde(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Pst = (e) => {
  var [t, n] = e;
  if (Qa(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = wde(t, o, r ? "backward" : "forward"), r = o < n; Qa(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = Sst(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, _st = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, wde = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (Lst(o) || Qa(o) && o.childNodes.length === 0 || Qa(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, Sst = (e, t, n) => {
  var [r] = wde(e, t, n);
  return r;
}, xY = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Cde = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Qa(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = On.getWindow(e);
  if (o.contains(r))
    return On.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Cde(e, i, n);
}, OY = (e, t) => !!(e.compareDocumentPosition(t) & yde.DOCUMENT_POSITION_PRECEDING), Mst = (e, t) => !!(e.compareDocumentPosition(t) & yde.DOCUMENT_POSITION_FOLLOWING), Dst = 0;
class Tst {
  constructor() {
    rg(this, "id", void 0), this.id = "".concat(Dst++);
  }
}
var On = {
  androidPendingDiffs: (e) => Est.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = Ost.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = On.toDOMNode(e, e), n = On.findDocumentOrShadowRoot(e);
    Xb.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = On.findDocumentOrShadowRoot(e), r = xY(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Kw.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = On.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = On.toSlateNode(e, t.target), a = On.findPath(e, i);
    if (Ml.isElement(i) && br.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = br.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? br.before(e, u) : br.after(e, u);
      if (c) {
        var p = br.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = On.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var y = On.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return y;
  },
  findKey: (e, t) => {
    var n = bY.get(t);
    return n || (n = new Tst(), bY.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = vst.get(r);
      if (o == null) {
        if (br.isEditor(r))
          return n;
        break;
      }
      var i = mst.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(js.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Xb.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          On.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = On.toDOMNode(e, e), r = On.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = xY(r), i = On.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Kw.select(e, br.start(e, [])), Xb.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = yst.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = On.toDOMNode(e, e), i;
    try {
      i = Qa(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => tx(t) && On.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return br.hasPath(e, n.path) && br.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => On.hasEditableTarget(e, t) || On.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => tx(t) && On.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!xst.get(e),
  isFocused: (e) => !!Xb.get(e),
  isReadOnly: (e) => !!wY.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (wY.get(e)) return !1;
    var n = On.hasTarget(e, t) && On.toSlateNode(e, t);
    return Ml.isElement(n) && br.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Cst.get(e), r = br.isEditor(t) ? bst.get(e) : n == null ? void 0 : n.get(On.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(js.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = br.node(e, t.path), r = On.toDOMNode(e, n), o;
    br.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, y = a[l + 1];
        if (t.offset === f && y !== null && y !== void 0 && y.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = y.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof kst ? E : y,
            (b = y.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(js.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Yt.isBackward(t), i = On.toDOMPoint(e, n), a = Yt.isCollapsed(t) ? i : On.toDOMPoint(e, r), s = On.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Qa(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), y = Qa(p) ? p : p.parentElement, b = !!y.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Qa(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? wst.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : Pst(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = On.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), y = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = On.getWindow(e), v = O.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var x = v.cloneContents(), _ = [...Array.prototype.slice.call(x.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(x.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (b_ && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = x.textContent.length, M = u;
        }
      } else if (y) {
        for (var z = y.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var N = z[L];
          if (On.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var Z, H = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = (Z = H.find((S) => Mst(E, S))) !== null && Z !== void 0 ? Z : null;
        } else {
          var $, K = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = ($ = K.findLast((S) => OY(E, S))) !== null && $ !== void 0 ? $ : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      b_ && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Yb && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (b_ && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && On.hasDOMNode(e, X, {
        editable: !0
      })) {
        var Q = On.toSlateNode(e, X), {
          path: J,
          offset: P
        } = br.start(e, On.findPath(e, Q));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = On.toSlateNode(e, u), F = On.findPath(e, D);
    return {
      path: F,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = CY(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (CY(t)) {
        if (Yb && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let x = function(_) {
              return _.childElementCount > 0 ? x(_.children[0]) : _;
            };
            var f = d.startContainer, y = g.startContainer, b = x(f.children[d.startOffset]), E = x(y.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        gst && _st(s) || Yb ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Yb && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = On.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = OY(s, u) || s === u && c < l, O = p ? w : On.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var v = {
      anchor: w,
      focus: O
    };
    return Yt.isExpanded(v) && Yt.isForward(v) && Qa(u) && br.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = br.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, jst = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, Ast = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Ist = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Eo = (e) => {
  var t = jst[e], n = Ast[e], r = Ist[e], o = t && g_(t), i = n && g_(n), a = r && g_(r);
  return (s) => !!(o && o(s) || yY && i && i(s) || !yY && a && a(s));
};
Eo("bold"), Eo("compose"), Eo("moveBackward"), Eo("moveForward"), Eo("deleteBackward"), Eo("deleteForward"), Eo("deleteLineBackward"), Eo("deleteLineForward"), Eo("deleteWordBackward"), Eo("deleteWordForward"), Eo("extendBackward"), Eo("extendForward"), Eo("extendLineBackward"), Eo("extendLineForward"), Eo("italic"), Eo("moveLineBackward"), Eo("moveLineForward"), Eo("moveWordBackward"), Eo("moveWordForward"), Eo("redo"), Eo("insertSoftBreak"), Eo("splitBlock"), Eo("transposeCharacter"), Eo("undo");
var Bst = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Cde(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, Rst = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class Nst extends Kl {
  constructor() {
    super(...arguments), rg(this, "context", null), rg(this, "manager", null), rg(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, Rst);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = Bst(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
rg(Nst, "contextType", hst);
We({});
We({});
We({});
var li = {}, tR = {}, yv = {}, bv = {}, xde = "Expected a function", EY = NaN, Fst = "[object Symbol]", zst = /^\s+|\s+$/g, Ust = /^[-+]0x[0-9a-f]+$/i, Hst = /^0b[01]+$/i, Wst = /^0o[0-7]+$/i, Vst = parseInt, $st = typeof _r == "object" && _r && _r.Object === Object && _r, Zst = typeof self == "object" && self && self.Object === Object && self, qst = $st || Zst || Function("return this")(), Gst = Object.prototype, Kst = Gst.toString, Yst = Math.max, Xst = Math.min, w_ = function() {
  return qst.Date.now();
};
function Jst(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(xde);
  t = kY(t) || 0, nx(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Yst(kY(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(x) {
    var _ = r, z = o;
    return r = o = void 0, u = x, a = e.apply(z, _), a;
  }
  function f(x) {
    return u = x, s = setTimeout(E, t), c ? g(x) : a;
  }
  function y(x) {
    var _ = x - l, z = x - u, L = t - _;
    return p ? Xst(L, i - z) : L;
  }
  function b(x) {
    var _ = x - l, z = x - u;
    return l === void 0 || _ >= t || _ < 0 || p && z >= i;
  }
  function E() {
    var x = w_();
    if (b(x))
      return w(x);
    s = setTimeout(E, y(x));
  }
  function w(x) {
    return s = void 0, d && r ? g(x) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(w_());
  }
  function v() {
    var x = w_(), _ = b(x);
    if (r = arguments, o = this, l = x, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = O, v;
}
function Qst(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(xde);
  return nx(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Jst(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function nx(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function eat(e) {
  return !!e && typeof e == "object";
}
function tat(e) {
  return typeof e == "symbol" || eat(e) && Kst.call(e) == Fst;
}
function kY(e) {
  if (typeof e == "number")
    return e;
  if (tat(e))
    return EY;
  if (nx(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = nx(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(zst, "");
  var n = Hst.test(e);
  return n || Wst.test(e) ? Vst(e.slice(2), n ? 2 : 8) : Ust.test(e) ? EY : +e;
}
var nat = Qst, wv = {};
Object.defineProperty(wv, "__esModule", {
  value: !0
});
wv.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Tw.has(t) || Tw.set(t, /* @__PURE__ */ new Set());
  var o = Tw.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
wv.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Tw.get(t).delete(n.name || t);
};
var Tw = /* @__PURE__ */ new Map();
Object.defineProperty(bv, "__esModule", {
  value: !0
});
var rat = nat, oat = iat(rat), LY = wv;
function iat(e) {
  return e && e.__esModule ? e : { default: e };
}
var sat = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, oat.default)(e, t);
}, Bo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = sat(function(r) {
        Bo.scrollHandler(e);
      }, t);
      return Bo.scrollSpyContainers.push(e), (0, LY.addPassiveEventListener)(e, "scroll", n), function() {
        (0, LY.removePassiveEventListener)(e, "scroll", n), Bo.scrollSpyContainers.splice(Bo.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Bo.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Bo.scrollSpyContainers[Bo.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Bo.currentPositionX(e), Bo.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Bo.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Bo.scrollSpyContainers[Bo.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Bo.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Bo.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Bo.spySetState && Bo.spySetState.length && Bo.spySetState.indexOf(e) > -1 && Bo.spySetState.splice(Bo.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Bo.scrollHandler);
  },
  update: function() {
    return Bo.scrollSpyContainers.forEach(function(e) {
      return Bo.scrollHandler(e);
    });
  }
};
bv.default = Bo;
var uf = {}, Cv = {};
Object.defineProperty(Cv, "__esModule", {
  value: !0
});
var aat = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, lat = function() {
  return window.location.hash.replace(/^#/, "");
}, uat = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, cat = function(e) {
  return getComputedStyle(e).position !== "static";
}, C_ = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, pat = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (cat(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = C_(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return C_(t, s).offsetTop - C_(e, s).offsetTop;
};
Cv.default = {
  updateHash: aat,
  getHash: lat,
  filterElementInContainer: uat,
  scrollOffset: pat
};
var Pk = {}, nR = {};
Object.defineProperty(nR, "__esModule", {
  value: !0
});
nR.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var rR = {};
Object.defineProperty(rR, "__esModule", {
  value: !0
});
var dat = wv, fat = ["mousedown", "wheel", "touchmove", "keydown"];
rR.default = {
  subscribe: function(e) {
    return typeof document < "u" && fat.forEach(function(t) {
      return (0, dat.addPassiveEventListener)(document, t, e);
    });
  }
};
var xv = {};
Object.defineProperty(xv, "__esModule", {
  value: !0
});
var ZD = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      ZD.registered[e] = t;
    },
    remove: function(e) {
      ZD.registered[e] = null;
    }
  }
};
xv.default = ZD;
Object.defineProperty(Pk, "__esModule", {
  value: !0
});
var hat = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, gat = Cv;
_k(gat);
var mat = nR, PY = _k(mat), vat = rR, yat = _k(vat), bat = xv, Va = _k(bat);
function _k(e) {
  return e && e.__esModule ? e : { default: e };
}
var Ode = function(e) {
  return PY.default[e.smooth] || PY.default.defaultEasing;
}, wat = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Cat = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, qD = function() {
  return Cat() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Ede = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, kde = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Lde = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, xat = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, Oat = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Eat = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Va.default.registered.end && Va.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    qD.call(window, i);
    return;
  }
  Va.default.registered.end && Va.default.registered.end(o.to, o.target, o.currentPosition);
}, oR = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Ov = function(e, t, n, r) {
  t.data = t.data || Ede(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (yat.default.subscribe(o), oR(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? kde(t) : Lde(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Va.default.registered.end && Va.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = wat(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Ode(t), a = Eat.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Va.default.registered.begin && Va.default.registered.begin(t.data.to, t.data.target), qD.call(window, a);
    }, t.delay);
    return;
  }
  Va.default.registered.begin && Va.default.registered.begin(t.data.to, t.data.target), qD.call(window, a);
}, Sk = function(e) {
  return e = hat({}, e), e.data = e.data || Ede(), e.absolute = !0, e;
}, kat = function(e) {
  Ov(0, Sk(e));
}, Lat = function(e, t) {
  Ov(e, Sk(t));
}, Pat = function(e) {
  e = Sk(e), oR(e), Ov(e.horizontal ? xat(e) : Oat(e), e);
}, _at = function(e, t) {
  t = Sk(t), oR(t);
  var n = t.horizontal ? kde(t) : Lde(t);
  Ov(e + n, t);
};
Pk.default = {
  animateTopScroll: Ov,
  getAnimationType: Ode,
  scrollToTop: kat,
  scrollToBottom: Pat,
  scrollTo: Lat,
  scrollMore: _at
};
Object.defineProperty(uf, "__esModule", {
  value: !0
});
var Sat = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Mat = Cv, Dat = iR(Mat), Tat = Pk, jat = iR(Tat), Aat = xv, Jb = iR(Aat);
function iR(e) {
  return e && e.__esModule ? e : { default: e };
}
var Qb = {}, _Y = void 0;
uf.default = {
  unmount: function() {
    Qb = {};
  },
  register: function(e, t) {
    Qb[e] = t;
  },
  unregister: function(e) {
    delete Qb[e];
  },
  get: function(e) {
    return Qb[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return _Y = e;
  },
  getActiveLink: function() {
    return _Y;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Sat({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = Dat.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Jb.default.registered.begin && Jb.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Jb.default.registered.end && Jb.default.registered.end(e, n);
      return;
    }
    jat.default.animateTopScroll(s, t, e, n);
  }
};
var GD = { exports: {} }, x_ = { exports: {} }, sr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var SY;
function Iat() {
  if (SY) return sr;
  SY = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function O(v) {
    return M(v) === u;
  }
  return sr.AsyncMode = l, sr.ConcurrentMode = u, sr.ContextConsumer = s, sr.ContextProvider = a, sr.Element = t, sr.ForwardRef = c, sr.Fragment = r, sr.Lazy = f, sr.Memo = g, sr.Portal = n, sr.Profiler = i, sr.StrictMode = o, sr.Suspense = p, sr.isAsyncMode = function(v) {
    return O(v) || M(v) === l;
  }, sr.isConcurrentMode = O, sr.isContextConsumer = function(v) {
    return M(v) === s;
  }, sr.isContextProvider = function(v) {
    return M(v) === a;
  }, sr.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, sr.isForwardRef = function(v) {
    return M(v) === c;
  }, sr.isFragment = function(v) {
    return M(v) === r;
  }, sr.isLazy = function(v) {
    return M(v) === f;
  }, sr.isMemo = function(v) {
    return M(v) === g;
  }, sr.isPortal = function(v) {
    return M(v) === n;
  }, sr.isProfiler = function(v) {
    return M(v) === i;
  }, sr.isStrictMode = function(v) {
    return M(v) === o;
  }, sr.isSuspense = function(v) {
    return M(v) === p;
  }, sr.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === y);
  }, sr.typeOf = M, sr;
}
var vr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var MY;
function Bat() {
  return MY || (MY = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === E || B.$$typeof === w || B.$$typeof === y);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, x = u, _ = s, z = a, L = t, N = c, R = r, V = f, Z = g, H = n, $ = i, K = o, X = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function F(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return O(B) === c;
    }
    function C(B) {
      return O(B) === r;
    }
    function I(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function j(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    vr.AsyncMode = v, vr.ConcurrentMode = x, vr.ContextConsumer = _, vr.ContextProvider = z, vr.Element = L, vr.ForwardRef = N, vr.Fragment = R, vr.Lazy = V, vr.Memo = Z, vr.Portal = H, vr.Profiler = $, vr.StrictMode = K, vr.Suspense = X, vr.isAsyncMode = J, vr.isConcurrentMode = P, vr.isContextConsumer = D, vr.isContextProvider = F, vr.isElement = S, vr.isForwardRef = W, vr.isFragment = C, vr.isLazy = I, vr.isMemo = U, vr.isPortal = T, vr.isProfiler = q, vr.isStrictMode = j, vr.isSuspense = Y, vr.isValidElementType = M, vr.typeOf = O;
  }()), vr;
}
var DY;
function Pde() {
  return DY || (DY = 1, process.env.NODE_ENV === "production" ? x_.exports = Iat() : x_.exports = Bat()), x_.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var O_, TY;
function Rat() {
  if (TY) return O_;
  TY = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return O_ = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, O_;
}
var E_, jY;
function sR() {
  if (jY) return E_;
  jY = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return E_ = e, E_;
}
var AY, IY;
function _de() {
  return IY || (IY = 1, AY = Function.call.bind(Object.prototype.hasOwnProperty)), AY;
}
var k_, BY;
function Nat() {
  if (BY) return k_;
  BY = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = sR(), n = {}, r = _de();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, k_ = o, k_;
}
var L_, RY;
function Fat() {
  if (RY) return L_;
  RY = 1;
  var e = Pde(), t = Rat(), n = sR(), r = _de(), o = Nat(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return L_ = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: v(),
      instanceOf: x,
      node: N(),
      objectOf: z,
      oneOf: _,
      oneOfType: L,
      shape: V,
      exact: Z
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function y(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    y.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, F = 0;
      function S(C, I, U, T, q, j, Y) {
        if (T = T || d, j = j || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            F < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + j + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, F++);
          }
        }
        return I[U] == null ? C ? I[U] === null ? new y("The " + q + " `" + j + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new y("The " + q + " `" + j + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(I, U, T, q, j);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(P) {
      function D(F, S, W, C, I, U) {
        var T = F[S], q = K(T);
        if (q !== P) {
          var j = X(T);
          return new y(
            "Invalid " + C + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = F[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var j = P(U, q, W, C, I + "[" + q + "]", n);
          if (j instanceof Error)
            return j;
        }
        return null;
      }
      return b(D);
    }
    function O() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!s(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function v() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!e.isValidElementType(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function x(P) {
      function D(F, S, W, C, I) {
        if (!(F[S] instanceof P)) {
          var U = P.name || d, T = J(F[S]);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(F, S, W, C, I) {
        for (var U = F[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(j, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new y("Invalid " + C + " `" + I + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function z(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var j = P(U, q, W, C, I + "." + q, n);
            if (j instanceof Error)
              return j;
          }
        return null;
      }
      return b(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var F = P[D];
        if (typeof F != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(F) + " at index " + D + "."
          ), a;
      }
      function S(W, C, I, U, T) {
        for (var q = [], j = 0; j < P.length; j++) {
          var Y = P[j], B = Y(W, C, I, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new y("Invalid " + U + " `" + T + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(S);
    }
    function N() {
      function P(D, F, S, W, C) {
        return H(D[F]) ? null : new y("Invalid " + W + " `" + C + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, D, F, S, W) {
      return new y(
        (P || "React class") + ": " + D + " type `" + F + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var j = P[q];
          if (typeof j != "function")
            return R(W, C, I, q, X(j));
          var Y = j(U, q, W, C, I + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(D);
    }
    function Z(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, F[S], P);
        for (var j in q) {
          var Y = P[j];
          if (r(P, j) && typeof Y != "function")
            return R(W, C, I, j, X(Y));
          if (!Y)
            return new y(
              "Invalid " + C + " `" + I + "` key `" + j + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(F[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, j, W, C, I + "." + j, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(D);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var F = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = F.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = F.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function $(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : $(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, L_;
}
var P_, NY;
function zat() {
  if (NY) return P_;
  NY = 1;
  var e = sR();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, P_ = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, P_;
}
if (process.env.NODE_ENV !== "production") {
  var Uat = Pde(), Hat = !0;
  GD.exports = Fat()(Uat.isElement, Hat);
} else
  GD.exports = zat()();
var Mk = GD.exports, Dk = {};
Object.defineProperty(Dk, "__esModule", {
  value: !0
});
var Wat = Cv, __ = Vat(Wat);
function Vat(e) {
  return e && e.__esModule ? e : { default: e };
}
var $at = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return __.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && __.default.getHash() !== e && __.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Dk.default = $at;
Object.defineProperty(yv, "__esModule", {
  value: !0
});
var ew = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Zat = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), qat = we, FY = Ev(qat), Gat = bv, tw = Ev(Gat), Kat = uf, Yat = Ev(Kat), Xat = Mk, ko = Ev(Xat), Jat = Dk, bu = Ev(Jat);
function Ev(e) {
  return e && e.__esModule ? e : { default: e };
}
function Qat(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function elt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function tlt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var zY = {
  to: ko.default.string.isRequired,
  containerId: ko.default.string,
  container: ko.default.object,
  activeClass: ko.default.string,
  activeStyle: ko.default.object,
  spy: ko.default.bool,
  horizontal: ko.default.bool,
  smooth: ko.default.oneOfType([ko.default.bool, ko.default.string]),
  offset: ko.default.number,
  delay: ko.default.number,
  isDynamic: ko.default.bool,
  onClick: ko.default.func,
  duration: ko.default.oneOfType([ko.default.number, ko.default.func]),
  absolute: ko.default.bool,
  onSetActive: ko.default.func,
  onSetInactive: ko.default.func,
  ignoreCancelEvents: ko.default.bool,
  hashSpy: ko.default.bool,
  saveHashHistory: ko.default.bool,
  spyThrottle: ko.default.number
};
yv.default = function(e, t) {
  var n = t || Yat.default, r = function(i) {
    tlt(a, i);
    function a(s) {
      Qat(this, a);
      var l = elt(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return Zat(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!tw.default.isMounted(s)) {
            var l = tw.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (bu.default.isMounted() || bu.default.mount(n), bu.default.mapContainer(this.props.to, s)), tw.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        tw.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = ew({}, this.props.style, this.props.activeStyle) : l = ew({}, this.props.style);
        var u = ew({}, this.props);
        for (var c in zY)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, FY.default.createElement(e, u);
      }
    }]), a;
  }(FY.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, ew({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(bu.default.isMounted() && !bu.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, y = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, y = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(y), g = M < Math.floor(f) || M >= Math.floor(y);
        } else {
          var O = 0, v = 0, x = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            x = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            O = z.top - x + s, v = O + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(v), g = L < Math.floor(O) || L >= Math.floor(v);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && bu.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            bu.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var Z = i.props.saveHashHistory, H = Z === void 0 ? !1 : Z;
          i.props.hashSpy && bu.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = zY, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(tR, "__esModule", {
  value: !0
});
var nlt = we, UY = Sde(nlt), rlt = yv, olt = Sde(rlt);
function Sde(e) {
  return e && e.__esModule ? e : { default: e };
}
function ilt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function HY(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function slt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var alt = function(e) {
  slt(t, e);
  function t() {
    var n, r, o, i;
    ilt(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = HY(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return UY.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), HY(o, i);
  }
  return t;
}(UY.default.Component);
tR.default = (0, olt.default)(alt);
var aR = {};
Object.defineProperty(aR, "__esModule", {
  value: !0
});
var llt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ult = we, WY = Mde(ult), clt = yv, plt = Mde(clt);
function Mde(e) {
  return e && e.__esModule ? e : { default: e };
}
function dlt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function flt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function hlt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var glt = function(e) {
  hlt(t, e);
  function t() {
    return dlt(this, t), flt(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return llt(t, [{
    key: "render",
    value: function() {
      return WY.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(WY.default.Component);
aR.default = (0, plt.default)(glt);
var lR = {}, Tk = {};
Object.defineProperty(Tk, "__esModule", {
  value: !0
});
var mlt = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, vlt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ylt = we, VY = jk(ylt), blt = nl;
jk(blt);
var wlt = uf, $Y = jk(wlt), Clt = Mk, ZY = jk(Clt);
function jk(e) {
  return e && e.__esModule ? e : { default: e };
}
function xlt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Olt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Elt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Tk.default = function(e) {
  var t = function(n) {
    Elt(r, n);
    function r(o) {
      xlt(this, r);
      var i = Olt(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return vlt(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        $Y.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        $Y.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return VY.default.createElement(e, mlt({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(VY.default.Component);
  return t.propTypes = {
    name: ZY.default.string,
    id: ZY.default.string
  }, t;
};
Object.defineProperty(lR, "__esModule", {
  value: !0
});
var qY = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, klt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Llt = we, GY = uR(Llt), Plt = Tk, _lt = uR(Plt), Slt = Mk, KY = uR(Slt);
function uR(e) {
  return e && e.__esModule ? e : { default: e };
}
function Mlt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Dlt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Tlt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Dde = function(e) {
  Tlt(t, e);
  function t() {
    return Mlt(this, t), Dlt(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return klt(t, [{
    key: "render",
    value: function() {
      var n = this, r = qY({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, GY.default.createElement(
        "div",
        qY({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(GY.default.Component);
Dde.propTypes = {
  name: KY.default.string,
  id: KY.default.string
};
lR.default = (0, _lt.default)(Dde);
var S_ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, YY = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function XY(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function JY(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function QY(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var nw = we, $c = bv, M_ = uf, $o = Mk, wu = Dk, eX = {
  to: $o.string.isRequired,
  containerId: $o.string,
  container: $o.object,
  activeClass: $o.string,
  spy: $o.bool,
  smooth: $o.oneOfType([$o.bool, $o.string]),
  offset: $o.number,
  delay: $o.number,
  isDynamic: $o.bool,
  onClick: $o.func,
  duration: $o.oneOfType([$o.number, $o.func]),
  absolute: $o.bool,
  onSetActive: $o.func,
  onSetInactive: $o.func,
  ignoreCancelEvents: $o.bool,
  hashSpy: $o.bool,
  spyThrottle: $o.number
}, jlt = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || M_, r = function(i) {
      QY(a, i);
      function a(s) {
        XY(this, a);
        var l = JY(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return YY(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            $c.isMounted(s) || $c.mount(s, this.props.spyThrottle), this.props.hashSpy && (wu.isMounted() || wu.mount(n), wu.mapContainer(this.props.to, s)), this.props.spy && $c.addStateHandler(this.stateHandler), $c.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          $c.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = S_({}, this.props);
          for (var u in eX)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, nw.createElement(e, l);
        }
      }]), a;
    }(nw.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, S_({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(wu.isMounted() && !wu.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var y = a - i.props.offset, b = y >= Math.floor(c) && y < Math.floor(p), E = y < Math.floor(c) || y >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && wu.getHash() === l && wu.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), $c.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && wu.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), $c.updateStates();
        }
      };
    };
    return r.propTypes = eX, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      QY(r, n);
      function r(o) {
        XY(this, r);
        var i = JY(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return YY(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          M_.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          M_.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return nw.createElement(e, S_({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(nw.Component);
    return t.propTypes = {
      name: $o.string,
      id: $o.string
    }, t;
  }
}, Alt = jlt;
Object.defineProperty(li, "__esModule", {
  value: !0
});
li.Helpers = li.ScrollElement = li.ScrollLink = li.animateScroll = li.scrollSpy = li.Events = li.scroller = li.Element = li.Button = li.Link = void 0;
var Ilt = tR, Tde = cl(Ilt), Blt = aR, jde = cl(Blt), Rlt = lR, Ade = cl(Rlt), Nlt = uf, Ide = cl(Nlt), Flt = xv, Bde = cl(Flt), zlt = bv, Rde = cl(zlt), Ult = Pk, Nde = cl(Ult), Hlt = yv, Fde = cl(Hlt), Wlt = Tk, zde = cl(Wlt), Vlt = Alt, Ude = cl(Vlt);
function cl(e) {
  return e && e.__esModule ? e : { default: e };
}
li.Link = Tde.default;
li.Button = jde.default;
li.Element = Ade.default;
li.scroller = Ide.default;
li.Events = Bde.default;
li.scrollSpy = Rde.default;
li.animateScroll = Nde.default;
li.ScrollLink = Fde.default;
li.ScrollElement = zde.default;
li.Helpers = Ude.default;
li.default = { Link: Tde.default, Button: jde.default, Element: Ade.default, scroller: Ide.default, Events: Bde.default, scrollSpy: Rde.default, animateScroll: Nde.default, ScrollLink: Fde.default, ScrollElement: zde.default, Helpers: Ude.default };
We({});
We({});
We({});
function mm(e) {
  "@babel/helpers - typeof";
  return mm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, mm(e);
}
function $lt(e, t) {
  if (mm(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (mm(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Zlt(e) {
  var t = $lt(e, "string");
  return mm(t) == "symbol" ? t : t + "";
}
function Ne(e, t, n) {
  return (t = Zlt(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Hde(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var D_, tX;
function qlt() {
  if (tX) return D_;
  tX = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return D_ = t, D_;
}
var Glt = qlt(), vi = /* @__PURE__ */ Hde(Glt), Gt = We(null);
function Klt() {
  vi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Gt);
  return vi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Ylt(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Xlt(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Jlt(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Xlt(e, i), o;
}
function Qlt(e, t, n) {
  var r = Ylt(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function eut(e) {
  google.maps.event.removeListener(e);
}
function Hn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(eut);
}
function Dn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = Qlt(o, i, n);
  return Jlt(t, r, o, i), a;
}
function tut(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: y,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [v, x] = k(null), _ = ht(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null), [j, Y] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && y && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", y)));
  }, [y]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (j !== null && google.maps.event.removeListener(j), Y(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return x(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), Jn.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: Jn.jsx(Gt.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(tut);
function nX(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Wde(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        nX(i, r, o, a, s, "next", l);
      }
      function s(l) {
        nX(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Vde(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return vi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var xp = typeof document < "u";
function $de(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return xp ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function rX(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Zde() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return rX(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return rX(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Qf = !1;
function qde() {
  return Jn.jsx("div", {
    children: "Loading..."
  });
}
var KD = {
  id: "script-loader",
  version: "weekly"
};
class nut extends pe {
  constructor() {
    super(...arguments), Ne(this, "check", null), Ne(this, "state", {
      loaded: !1
    }), Ne(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Ne(this, "isCleaningUp", /* @__PURE__ */ Wde(function* () {
      function t(n) {
        if (!Qf)
          n();
        else if (xp)
          var r = window.setInterval(function() {
            Qf || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Ne(this, "cleanup", () => {
      Qf = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Ne(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Zde(), vi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Vde(this.props)
      };
      $de(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Ne(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (xp) {
      if (window.google && window.google.maps && !Qf) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), xp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (xp) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Qf = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Jn.jsxs(Jn.Fragment, {
      children: [Jn.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Jn.jsx(qde, {})]
    });
  }
}
Ne(nut, "defaultProps", KD);
function rut(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function cR(e, t) {
  if (e == null) return {};
  var n, r, o = rut(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var oX;
function out(e) {
  var {
    id: t = KD.id,
    version: n = KD.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ht(!1), [f, y] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    xp && u && Zde();
  }, [u]), h(function() {
    f && vi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Vde({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!xp)
      return;
    function O() {
      g.current && (y(!0), oX = w);
    }
    if (window.google && window.google.maps && oX === w) {
      O();
      return;
    }
    $de({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = ht(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var iut = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], sut = Jn.jsx(qde, {});
function aut(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = cR(e, iut), {
    isLoaded: s,
    loadError: l
  } = out(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || sut;
}
me(aut);
var iX;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(iX || (iX = {}));
function sX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aX = {}, lX = {
  options(e, t) {
    e.setOptions(t);
  }
};
function lut(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Gt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(rx(rx({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(lut);
class uut extends pe {
  constructor() {
    super(...arguments), Ne(this, "state", {
      trafficLayer: null
    }), Ne(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Ne(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(rx(rx({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: lX,
      eventMap: aX,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: lX,
      eventMap: aX,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Hn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(uut, "contextType", Gt);
function cut(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Gt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(cut);
class put extends pe {
  constructor() {
    super(...arguments), Ne(this, "state", {
      bicyclingLayer: null
    }), Ne(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(put, "contextType", Gt);
function dut(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Gt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(dut);
class fut extends pe {
  constructor() {
    super(...arguments), Ne(this, "state", {
      transitLayer: null
    }), Ne(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(fut, "contextType", Gt);
function uX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ox(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cX = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, pX = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function hut(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Gt), [d, g] = k(null), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), y(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    vi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(ox(ox({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && y(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && v(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(hut);
class gut extends pe {
  constructor(t) {
    super(t), Ne(this, "registeredEvents", []), Ne(this, "state", {
      drawingManager: null
    }), Ne(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), vi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(ox(ox({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: pX,
      eventMap: cX,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: pX,
      eventMap: cX,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Hn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(gut, "contextType", Gt);
function dX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ed(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fX = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, hX = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, ix = {};
function mut(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: y,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: v,
    onMouseOut: x,
    onMouseOver: _,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: Z,
    onDraggableChanged: H,
    onFlatChanged: $,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: F,
    onUnmount: S
  } = e, W = ge(Gt), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null), [oe, Pe] = k(null), [Ue, Ze] = k(null), [_e, rt] = k(null), [Ve, ye] = k(null), [Ge, ct] = k(null), [ve, Oe] = k(null), [qe, ze] = k(null), [Se, st] = k(null), [xe, xt] = k(null), [at, lt] = k(null), [pt, Ot] = k(null), [dt, ft] = k(null), [ot, He] = k(null), [Et, kt] = k(null), [gt, St] = k(null), [mt, Mt] = k(null), [vt, Pt] = k(null);
  h(() => {
    C !== null && C.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && C !== null && C.setOptions(n);
  }, [C, n]), h(() => {
    typeof a < "u" && C !== null && C.setDraggable(a);
  }, [C, a]), h(() => {
    t && C !== null && C.setPosition(t);
  }, [C, t]), h(() => {
    typeof s < "u" && C !== null && C.setVisible(s);
  }, [C, s]), h(() => {
    C == null || C.setAnimation(l);
  }, [C, l]), h(() => {
    C && u !== void 0 && C.setClickable(u);
  }, [C, u]), h(() => {
    C && c !== void 0 && C.setCursor(c);
  }, [C, c]), h(() => {
    C && p !== void 0 && C.setIcon(p);
  }, [C, p]), h(() => {
    C && d !== void 0 && C.setLabel(d);
  }, [C, d]), h(() => {
    C && g !== void 0 && C.setOpacity(g);
  }, [C, g]), h(() => {
    C && f !== void 0 && C.setShape(f);
  }, [C, f]), h(() => {
    C && y !== void 0 && C.setTitle(y);
  }, [C, y]), h(() => {
    C && b !== void 0 && C.setZIndex(b);
  }, [C, b]), h(() => {
    C && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(C, "dblclick", w)));
  }, [w]), h(() => {
    C && O && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(C, "dragend", O)));
  }, [O]), h(() => {
    C && v && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(C, "dragstart", v)));
  }, [v]), h(() => {
    C && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(C, "mousedown", L)));
  }, [L]), h(() => {
    C && x && (oe !== null && google.maps.event.removeListener(oe), Pe(google.maps.event.addListener(C, "mouseout", x)));
  }, [x]), h(() => {
    C && _ && (Ue !== null && google.maps.event.removeListener(Ue), Ze(google.maps.event.addListener(C, "mouseover", _)));
  }, [_]), h(() => {
    C && z && (_e !== null && google.maps.event.removeListener(_e), rt(google.maps.event.addListener(C, "mouseup", z)));
  }, [z]), h(() => {
    C && N && (Ve !== null && google.maps.event.removeListener(Ve), ye(google.maps.event.addListener(C, "rightclick", N)));
  }, [N]), h(() => {
    C && E && (Ge !== null && google.maps.event.removeListener(Ge), ct(google.maps.event.addListener(C, "click", E)));
  }, [E]), h(() => {
    C && M && (ve !== null && google.maps.event.removeListener(ve), Oe(google.maps.event.addListener(C, "drag", M)));
  }, [M]), h(() => {
    C && R && (qe !== null && google.maps.event.removeListener(qe), ze(google.maps.event.addListener(C, "clickable_changed", R)));
  }, [R]), h(() => {
    C && V && (Se !== null && google.maps.event.removeListener(Se), st(google.maps.event.addListener(C, "cursor_changed", V)));
  }, [V]), h(() => {
    C && Z && (xe !== null && google.maps.event.removeListener(xe), xt(google.maps.event.addListener(C, "animation_changed", Z)));
  }, [Z]), h(() => {
    C && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(C, "draggable_changed", H)));
  }, [H]), h(() => {
    C && $ && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(C, "flat_changed", $)));
  }, [$]), h(() => {
    C && K && (dt !== null && google.maps.event.removeListener(dt), ft(google.maps.event.addListener(C, "icon_changed", K)));
  }, [K]), h(() => {
    C && X && (ot !== null && google.maps.event.removeListener(ot), He(google.maps.event.addListener(C, "position_changed", X)));
  }, [X]), h(() => {
    C && Q && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(C, "shape_changed", Q)));
  }, [Q]), h(() => {
    C && J && (gt !== null && google.maps.event.removeListener(gt), St(google.maps.event.addListener(C, "title_changed", J)));
  }, [J]), h(() => {
    C && P && (mt !== null && google.maps.event.removeListener(mt), Mt(google.maps.event.addListener(C, "visible_changed", P)));
  }, [P]), h(() => {
    C && D && (vt !== null && google.maps.event.removeListener(vt), Pt(google.maps.event.addListener(C, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = Ed(Ed(Ed({}, n || ix), r ? ix : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(yt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof g < "u" && te.setOpacity(g), f && te.setShape(f), typeof y == "string" && te.setTitle(y), typeof b == "number" && te.setZIndex(b), w && T(google.maps.event.addListener(te, "dblclick", w)), O && j(google.maps.event.addListener(te, "dragend", O)), v && B(google.maps.event.addListener(te, "dragstart", v)), L && he(google.maps.event.addListener(te, "mousedown", L)), x && Pe(google.maps.event.addListener(te, "mouseout", x)), _ && Ze(google.maps.event.addListener(te, "mouseover", _)), z && rt(google.maps.event.addListener(te, "mouseup", z)), N && ye(google.maps.event.addListener(te, "rightclick", N)), E && ct(google.maps.event.addListener(te, "click", E)), M && Oe(google.maps.event.addListener(te, "drag", M)), R && ze(google.maps.event.addListener(te, "clickable_changed", R)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), Z && xt(google.maps.event.addListener(te, "animation_changed", Z)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), $ && Ot(google.maps.event.addListener(te, "flat_changed", $)), K && ft(google.maps.event.addListener(te, "icon_changed", K)), X && He(google.maps.event.addListener(te, "position_changed", X)), Q && kt(google.maps.event.addListener(te, "shape_changed", Q)), J && St(google.maps.event.addListener(te, "title_changed", J)), P && Mt(google.maps.event.addListener(te, "visible_changed", P)), D && Pt(google.maps.event.addListener(te, "zindex_changed", D)), I(te), F && F(te), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), _e !== null && google.maps.event.removeListener(_e), Ve !== null && google.maps.event.removeListener(Ve), Ge !== null && google.maps.event.removeListener(Ge), qe !== null && google.maps.event.removeListener(qe), Se !== null && google.maps.event.removeListener(Se), xe !== null && google.maps.event.removeListener(xe), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ot !== null && google.maps.event.removeListener(ot), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var jn = Ft(() => i ? ut.map(i, (yt) => {
    if (!wi(yt))
      return yt;
    var te = yt;
    return Ci(te, {
      anchor: C
    });
  }) : null, [i, C]);
  return Jn.jsx(Jn.Fragment, {
    children: jn
  }) || null;
}
me(mut);
class vut extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Wde(function* () {
      var n = Ed(Ed(Ed({}, t.props.options || ix), t.props.clusterer ? ix : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Dn({
        updaterMap: hX,
        eventMap: fX,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: hX,
      eventMap: fX,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Hn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Ci(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Ne(vut, "contextType", Gt);
var yut = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), but = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new yut(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function wut(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Cut = 2e3, xut = 500, Out = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Eut = "png", kut = [53, 56, 66, 78, 90], Lut = "cluster", Gde = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Out, this.imageExtension = r.imageExtension || Eut, this.imageSizes = r.imageSizes || kut, this.calculator = r.calculator || wut, this.batchSize = r.batchSize || Cut, this.batchSizeIE = r.batchSizeIE || xut, this.clusterClass = r.clusterClass || Lut, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new but(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function gX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Put(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ca = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Yn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, _ut = {};
function Sut(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: y,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: v,
    onMouseOut: x,
    onLoad: _,
    onUnmount: z
  } = e, [L, N] = k(null), R = ge(Gt), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && x && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, Ca.onMouseOut, x)));
  }, [x]), h(() => {
    L && v && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, Ca.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(L, Ca.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(L, Ca.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), $(google.maps.event.addListener(L, Ca.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && Yn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Yn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Yn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Yn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Yn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Yn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Yn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Yn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Yn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Yn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Yn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Yn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof y < "u" && L !== null && Yn.styles(L, y);
  }, [L, y]), h(() => {
    typeof b < "u" && L !== null && Yn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && Yn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var F = Put({}, n || _ut), S = new Gde(R, [], F);
      return r && Yn.averageCenter(S, r), o && Yn.batchSizeIE(S, o), i && Yn.calculator(S, i), a && Yn.clusterClass(S, a), s && Yn.enableRetinaIcons(S, s), l && Yn.gridSize(S, l), u && Yn.ignoreHidden(S, u), c && Yn.imageExtension(S, c), p && Yn.imagePath(S, p), d && Yn.imageSizes(S, d), g && Yn.maxZoom(S, g), f && Yn.minimumClusterSize(S, f), y && Yn.styles(S, y), b && Yn.title(S, b), E && Yn.zoomOnClick(S, E), x && J(google.maps.event.addListener(S, Ca.onMouseOut, x)), v && D(google.maps.event.addListener(S, Ca.onMouseOver, v)), w && Z(google.maps.event.addListener(S, Ca.onClick, w)), M && $(google.maps.event.addListener(S, Ca.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, Ca.onClusteringEnd, O)), N(S), _ && _(S), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), z && z(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(Sut);
class Mut extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      markerClusterer: null
    }), Ne(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Gde(this.context, [], this.props.options);
      this.registeredEvents = Dn({
        updaterMap: Yn,
        eventMap: Ca,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: Yn,
      eventMap: Ca,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Hn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Ne(Mut, "contextType", Gt);
function mX(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Kde = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || mX(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, mX));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, y = this.getProjection(), b = y.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Dut = ["position"], Tut = ["position"];
function vX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yX = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, bX = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, jut = {};
function Aut(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Gt), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || jut, {
        position: V
      } = R, Z = cR(R, Dut), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var $ = new Kde(sx(sx({}, Z), H ? {
        position: H
      } : {}));
      N.current = document.createElement("div"), y($), a && E(google.maps.event.addListener($, "closeclick", a)), s && M(google.maps.event.addListener($, "domready", s)), l && v(google.maps.event.addListener($, "content_changed", l)), u && _(google.maps.event.addListener($, "position_changed", u)), c && L(google.maps.event.addListener($, "zindex_changed", c)), $.setContent(N.current), n ? $.open(g, n) : $.getPosition() ? $.open(g) : vi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p($);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(Aut);
class Iut extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "containerElement", null), Ne(this, "state", {
      infoBox: null
    }), Ne(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : vi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Ne(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = cR(t, Tut), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Kde(sx(sx({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Dn({
      updaterMap: bX,
      eventMap: yX,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: bX,
      eventMap: yX,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Hn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
Ne(Iut, "contextType", Gt);
var wX, CX;
function But() {
  return CX || (CX = 1, wX = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), wX;
}
var Rut = But(), xX = /* @__PURE__ */ Hde(Rut), OX = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], T_ = 1, eh = 8;
class pR {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== T_)
      throw new Error("Got v".concat(o, " data when expected v").concat(T_, "."));
    var i = OX[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new pR(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = OX.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, eh, t), this.coords = new this.ArrayType(this.data, eh + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(eh + a + s + l), this.ids = new this.IndexArrayType(this.data, eh, t), this.coords = new this.ArrayType(this.data, eh + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (T_ << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return YD(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], y = a[2 * g + 1];
          f >= t && f <= r && y >= n && y <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          EX(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, y = i[2 * f], b = i[2 * f + 1];
      EX(y, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= y : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= y : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function YD(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Yde(e, t, a, r, o, i), YD(e, t, n, r, a - 1, 1 - i), YD(e, t, n, a + 1, o, 1 - i);
  }
}
function Yde(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Yde(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, y = o;
    for (th(e, t, r, n), t[2 * o + i] > g && th(e, t, r, o); f < y; ) {
      for (th(e, t, f, y), f++, y--; t[2 * f + i] < g; ) f++;
      for (; t[2 * y + i] > g; ) y--;
    }
    t[2 * r + i] === g ? th(e, t, r, y) : (y++, th(e, t, y, o)), y <= n && (r = y + 1), n <= y && (o = y - 1);
  }
}
function th(e, t, n, r) {
  j_(e, n, r), j_(t, 2 * n, 2 * r), j_(t, 2 * n + 1, 2 * r + 1);
}
function j_(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function EX(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Nut = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, kX = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Zc = 2, zu = 3, A_ = 4, Du = 5, Xde = 6;
class Fut {
  constructor(t) {
    this.options = Object.assign(Object.create(Nut), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = kX(rw(u)), d = kX(ow(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var y = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - y);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(rw(r), ow(a), rw(i), ow(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Du] > 1 ? LX(p, f, this.clusterProps) : this.points[p[f + zu]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + A_] === t && p.push(a[g + Du] > 1 ? LX(a, g, this.clusterProps) : this.points[a[g + zu]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new pR(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Du] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Jde(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + zu]];
        c = g.properties;
        var [f, y] = g.geometry.coordinates;
        p = rw(f), d = ow(y);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + zu] : E = this.points[n[l + zu]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Zc] <= n)) {
        l[p + Zc] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), y = l[p + Du], b = y;
        for (var E of f) {
          var w = E * c;
          l[w + Zc] > n && (b += l[w + Du]);
        }
        if (b > y && b >= a) {
          var M = d * y, O = g * y, v = void 0, x = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Zc] <= n)) {
              l[L + Zc] = n;
              var N = l[L + Du];
              M += l[L] * N, O += l[L + 1] * N, l[L + A_] = _, i && (v || (v = this._map(l, p, !0), x = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + A_] = _, u.push(M / b, O / b, 1 / 0, _, -1, b), i && u.push(x);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var Z = V * c;
              if (!(l[Z + Zc] <= n)) {
                l[Z + Zc] = n;
                for (var H = 0; H < c; H++) u.push(l[Z + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Du] > 1) {
      var o = this.clusterProps[t[n + Xde]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + zu]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function LX(e, t, n) {
  return {
    type: "Feature",
    id: e[t + zu],
    properties: Jde(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [zut(e[t]), Uut(e[t + 1])]
    }
  };
}
function Jde(e, t, n) {
  var r = e[t + Du], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Xde], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + zu],
    point_count: r,
    point_count_abbreviated: o
  });
}
function rw(e) {
  return e / 360 + 0.5;
}
function ow(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function zut(e) {
  return (e - 0.5) * 360;
}
function Uut(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Hut(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Gs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class XD {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Gs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Gs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Gs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Wut {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return Vut(n);
  }
}
var Vut = (e) => {
  var t = e.map((n) => new XD({
    position: Gs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class $ut extends Wut {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Hut(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Fut(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!xX(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Gs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !xX(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new XD({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new XD({
      markers: [i],
      position: Gs.getPosition(i)
    });
  }
}
class Zut {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class qut {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Gs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function Gut(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class dR {
  constructor() {
    Gut(dR, google.maps.OverlayView);
  }
}
var og;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(og || (og = {}));
var Kut = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Yut extends dR {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new $ut(o),
      renderer: a = new qut(),
      onClusterClick: s = Kut
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Gs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, og.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Gs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Gs.setMap(l, null)));
      }
      google.maps.event.trigger(this, og.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Gs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Zut(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Gs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, og.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Gs.setMap(r.marker, n);
    });
  }
}
function PX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _X(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Xut(e) {
  var t = Klt(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new Yut(_X(_X({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Jut(e) {
  var {
    children: t,
    options: n
  } = e, r = Xut(n);
  return r !== null ? t(r) : null;
}
me(Jut);
var SX = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, MX = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Qut(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Gt), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return y(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && v(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : vi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(R), R.close();
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(Qut);
class ect extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "containerElement", null), Ne(this, "state", {
      infoWindow: null
    }), Ne(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : vi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Ne(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Dn({
      updaterMap: MX,
      eventMap: SX,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: MX,
      eventMap: SX,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Hn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
Ne(ect, "contextType", Gt);
function DX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ax(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var TX = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, jX = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, tct = {};
function nct(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Gt), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && y && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(O, "click", y)));
  }, [y]), h(() => {
    O && b && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(O, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(ax(ax({}, t || tct), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && Z(google.maps.event.addListener(T, "mousedown", u)), c && $(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), y && C(google.maps.event.addListener(T, "click", y)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(nct);
class rct extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      polyline: null
    }), Ne(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(ax(ax({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: jX,
      eventMap: TX,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: jX,
      eventMap: TX,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Hn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(rct, "contextType", Gt);
function AX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function IX(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var BX = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, RX = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function oct(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, v = ge(Gt), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    x !== null && x.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    typeof a < "u" && x !== null && x.setPaths(a);
  }, [x, a]), h(() => {
    x && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dblclick", s)));
  }, [s]), h(() => {
    x && (google.maps.event.addListener(x.getPath(), "insert_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "set_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "remove_at", () => {
      O == null || O(x);
    }));
  }, [x, O]), h(() => {
    x && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragend", l)));
  }, [l]), h(() => {
    x && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(x, "dragstart", u)));
  }, [u]), h(() => {
    x && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(x, "mousedown", c)));
  }, [c]), h(() => {
    x && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(x, "mousemove", p)));
  }, [p]), h(() => {
    x && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseout", d)));
  }, [d]), h(() => {
    x && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(x, "mouseover", g)));
  }, [g]), h(() => {
    x && typeof f == "function" && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(x, "mouseup", f)));
  }, [f]), h(() => {
    x && typeof y == "function" && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(x, "rightclick", y)));
  }, [y]), h(() => {
    x && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(x, "click", b)));
  }, [b]), h(() => {
    x && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(x, "drag", E)));
  }, [E]), h(() => {
    var j = new google.maps.Polygon(IX(IX({}, t), {}, {
      map: v
    }));
    return i && j.setPath(i), a && j.setPaths(a), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), s && L(google.maps.event.addListener(j, "dblclick", s)), l && R(google.maps.event.addListener(j, "dragend", l)), u && Z(google.maps.event.addListener(j, "dragstart", u)), c && $(google.maps.event.addListener(j, "mousedown", c)), p && X(google.maps.event.addListener(j, "mousemove", p)), d && J(google.maps.event.addListener(j, "mouseout", d)), g && D(google.maps.event.addListener(j, "mouseover", g)), f && S(google.maps.event.addListener(j, "mouseup", f)), y && C(google.maps.event.addListener(j, "rightclick", y)), b && U(google.maps.event.addListener(j, "click", b)), E && q(google.maps.event.addListener(j, "drag", E)), _(j), w && w(j), () => {
      z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), M && M(j), j.setMap(null);
    };
  }, []), null;
}
me(oct);
class ict extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Dn({
      updaterMap: RX,
      eventMap: BX,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: RX,
      eventMap: BX,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Hn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(ict, "contextType", Gt);
function NX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FX = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, zX = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function sct(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(Gt), [v, x] = k(null), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null);
  return h(() => {
    v !== null && v.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(v, "click", y)));
  }, [y]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(lx(lx({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && z(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && H(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && F(google.maps.event.addListener(Y, "mouseup", g)), f && W(google.maps.event.addListener(Y, "rightclick", f)), y && I(google.maps.event.addListener(Y, "click", y)), b && T(google.maps.event.addListener(Y, "drag", b)), E && j(google.maps.event.addListener(Y, "bounds_changed", E)), x(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
me(sct);
class act extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      rectangle: null
    }), Ne(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(lx(lx({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: zX,
      eventMap: FX,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: zX,
      eventMap: FX,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Hn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(act, "contextType", Gt);
function UX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ux(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var HX = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, WX = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, lct = {};
function uct(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: v
  } = e, x = ge(Gt), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null);
  return h(() => {
    _ !== null && _.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(_, "rightclick", y)));
  }, [y]), h(() => {
    _ && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", b)));
  }, [b]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [b]), h(() => {
    _ && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(ux(ux({}, t || lct), {}, {
      map: x
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && F(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), y && I(google.maps.event.addListener(oe, "rightclick", y)), b && T(google.maps.event.addListener(oe, "click", b)), E && j(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), z(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(uct);
class cct extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      circle: null
    }), Ne(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(ux(ux({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: WX,
      eventMap: HX,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: WX,
      eventMap: HX,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Hn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Ne(cct, "contextType", Gt);
function VX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $X = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, ZX = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function pct(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: y,
    onUnmount: b
  } = e, E = ge(Gt), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var j = new google.maps.Data(cx(cx({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(j, "dblclick", r)), o && _(google.maps.event.addListener(j, "mousedown", o)), i && L(google.maps.event.addListener(j, "mousemove", i)), a && R(google.maps.event.addListener(j, "mouseout", a)), s && Z(google.maps.event.addListener(j, "mouseover", s)), l && $(google.maps.event.addListener(j, "mouseup", l)), u && X(google.maps.event.addListener(j, "rightclick", u)), n && J(google.maps.event.addListener(j, "click", n)), c && D(google.maps.event.addListener(j, "addfeature", c)), p && S(google.maps.event.addListener(j, "removefeature", p)), d && C(google.maps.event.addListener(j, "removeproperty", d)), g && U(google.maps.event.addListener(j, "setgeometry", g)), f && q(google.maps.event.addListener(j, "setproperty", f)), M(j), y && y(j);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(pct);
class dct extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      data: null
    }), Ne(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(cx(cx({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Dn({
        updaterMap: ZX,
        eventMap: $X,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: ZX,
      eventMap: $X,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Hn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(dct, "contextType", Gt);
function qX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function GX(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var KX = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, YX = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class fct extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      kmlLayer: null
    }), Ne(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(GX(GX({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: YX,
      eventMap: KX,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: YX,
      eventMap: KX,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Hn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(fct, "contextType", Gt);
function Qde(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function hct(e, t) {
  return new t(e.lat, e.lng);
}
function gct(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function mct(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function vct(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function yct(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function bct(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function efe(e, t, n, r) {
  return n !== void 0 ? yct(e, t, vct(n, google.maps.LatLngBounds, gct)) : bct(e, t, mct(r, google.maps.LatLng, hct));
}
function wct(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function XX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cct(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function xct(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Cct({}, this.container ? Qde(this.container, o) : {
        x: 0,
        y: 0
      }), u = efe(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function JX(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Oct(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JX(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JX(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function QX(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function eJ(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Ect(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Gt), c = Ft(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Ft(() => xct(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), xi.createPortal(l, c);
}
me(Ect);
class cf extends pe {
  constructor(t) {
    super(t), Ne(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Ne(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      vi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Ne(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Ne(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Oct({
        x: 0,
        y: 0
      }, this.containerRef.current ? Qde(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = efe(r, o, this.props.bounds, this.props.position);
      if (!wct(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Ne(this, "draw", () => {
      this.onPositionElement();
    }), Ne(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Br();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = QX(t.position), r = QX(this.props.position), o = eJ(t.bounds), i = eJ(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? xi.createPortal(Jn.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
Ne(cf, "FLOAT_PANE", "floatPane");
Ne(cf, "MAP_PANE", "mapPane");
Ne(cf, "MARKER_LAYER", "markerLayer");
Ne(cf, "OVERLAY_LAYER", "overlayLayer");
Ne(cf, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Ne(cf, "contextType", Gt);
function kct() {
}
function tJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nJ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tJ(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rJ = {
  onDblClick: "dblclick",
  onClick: "click"
}, oJ = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Lct(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Gt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Ft(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(Lct);
class tfe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      groundOverlay: null
    }), Ne(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    vi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, nJ(nJ({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: oJ,
      eventMap: rJ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: oJ,
      eventMap: rJ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(tfe, "defaultProps", {
  onLoad: kct
});
Ne(tfe, "contextType", Gt);
function iJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function px(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iJ(Object(n), !0).forEach(function(r) {
      Ne(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sJ = {}, aJ = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Pct(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Gt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || vi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    vi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(px(px({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(Pct);
class _ct extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      heatmapLayer: null
    }), Ne(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    vi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), vi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(px(px({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Dn({
      updaterMap: aJ,
      eventMap: sJ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: aJ,
      eventMap: sJ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Hn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(_ct, "contextType", Gt);
var lJ = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, uJ = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Sct extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      streetViewPanorama: null
    }), Ne(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Dn({
      updaterMap: uJ,
      eventMap: lJ,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: uJ,
      eventMap: lJ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Hn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Ne(Sct, "contextType", Gt);
class Mct extends pe {
  constructor() {
    super(...arguments), Ne(this, "state", {
      streetViewService: null
    }), Ne(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Ne(Mct, "contextType", Gt);
var cJ = {
  onDirectionsChanged: "directions_changed"
}, pJ = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Dct extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "state", {
      directionsRenderer: null
    }), Ne(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Dn({
      updaterMap: pJ,
      eventMap: cJ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: pJ,
      eventMap: cJ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Hn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Ne(Dct, "contextType", Gt);
var dJ = {
  onPlacesChanged: "places_changed"
}, fJ = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Tct extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "containerElement", Br()), Ne(this, "state", {
      searchBox: null
    }), Ne(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (vi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Dn({
          updaterMap: fJ,
          eventMap: dJ,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: fJ,
      eventMap: dJ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Hn(this.registeredEvents));
  }
  render() {
    return Jn.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
Ne(Tct, "contextType", Gt);
var hJ = {
  onPlaceChanged: "place_changed"
}, gJ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class nfe extends pe {
  constructor() {
    super(...arguments), Ne(this, "registeredEvents", []), Ne(this, "containerElement", Br()), Ne(this, "state", {
      autocomplete: null
    }), Ne(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    vi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Dn({
        updaterMap: gJ,
        eventMap: hJ,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Hn(this.registeredEvents), this.registeredEvents = Dn({
      updaterMap: gJ,
      eventMap: hJ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Hn(this.registeredEvents);
  }
  render() {
    return Jn.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
Ne(nfe, "defaultProps", {
  className: ""
});
Ne(nfe, "contextType", Gt);
let jct = { data: "" }, Act = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || jct, Ict = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Bct = /\/\*[^]*?\*\/|  +/g, mJ = /\n+/g, Xu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Xu(a, i) : i + "{" + Xu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Xu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Xu.p ? Xu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, _l = {}, rfe = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + rfe(e[n]);
    return t;
  }
  return e;
}, Rct = (e, t, n, r, o) => {
  let i = rfe(e), a = _l[i] || (_l[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!_l[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Ict.exec(u.replace(Bct, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(mJ, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(mJ, " ").trim();
      return d[0];
    })(e);
    _l[a] = Xu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && _l.g ? _l.g : null;
  return n && (_l.g = _l[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(_l[a], t, r, s), a;
}, Nct = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Xu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Ak(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Rct(n.unshift ? n.raw ? Nct(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Act(t.target), t.g, t.o, t.k);
}
let ofe, JD, QD;
Ak.bind({ g: 1 });
let ql = Ak.bind({ k: 1 });
function Fct(e, t, n, r) {
  Xu.p = t, ofe = e, JD = n, QD = r;
}
function _c(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: JD && JD() }, s), n.o = / *go\d+/.test(l), s.className = Ak.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), QD && u[0] && QD(s), ofe(u, s);
    }
    return o;
  };
}
var zct = (e) => typeof e == "function", Uct = (e, t) => zct(e) ? e(t) : e, Hct = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Wct = ql`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Vct = ql`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, $ct = ql`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Zct = _c("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Wct} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Vct} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${$ct} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, qct = ql`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Gct = _c("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${qct} 1s linear infinite;
`, Kct = ql`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Yct = ql`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, Xct = _c("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Kct} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Yct} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Jct = _c("div")`
  position: absolute;
`, Qct = _c("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, ept = ql`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, tpt = _c("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${ept} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, npt = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Me.createElement(tpt, null, t) : t : n === "blank" ? null : Me.createElement(Qct, null, Me.createElement(Gct, { ...r }), n !== "loading" && Me.createElement(Jct, null, n === "error" ? Me.createElement(Zct, { ...r }) : Me.createElement(Xct, { ...r })));
}, rpt = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, opt = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, ipt = "0%{opacity:0;} 100%{opacity:1;}", spt = "0%{opacity:1;} 100%{opacity:0;}", apt = _c("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, lpt = _c("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, upt = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Hct() ? [ipt, spt] : [rpt(n), opt(n)];
  return { animation: t ? `${ql(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ql(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Me.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? upt(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Me.createElement(npt, { toast: e }), a = Me.createElement(lpt, { ...e.ariaProps }, Uct(e.message, e));
  return Me.createElement(apt, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Me.createElement(Me.Fragment, null, i, a));
});
Fct(Me.createElement);
Ak`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function cpt(e) {
  const { error: t } = e, n = "arkynAudioUploadError";
  return t ? /* @__PURE__ */ ne.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ ne.jsx(ne.Fragment, {});
}
function ppt(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynAudioUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ ne.jsx("strong", { className: o.trim(), children: t });
}
function dpt(e) {
  const { onChange: t, value: n, disableDrag: r = !1, onDragging: o } = e, [i, a] = k(!1), s = ht(null), l = () => {
    a(!0);
  }, u = () => {
    a(!1);
  }, c = (f) => {
    if (r || !i || !s.current) return;
    const y = s.current.getBoundingClientRect(), b = f.clientX - y.left, E = Math.min(Math.max(b / y.width * 100, 0), 100);
    t(E);
  }, p = (f) => {
    if (!s.current) return;
    const y = s.current.getBoundingClientRect(), b = f.clientX - y.left, E = Math.min(Math.max(b / y.width * 100, 0), 100);
    t(E);
  };
  h(() => (i ? (o && o(!0), document.addEventListener("mousemove", c), document.addEventListener("mouseup", u)) : (o && o(!1), document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u)), () => {
    document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
  }), [i]);
  const g = `arkynSliderTrack ${i ? "isDragging" : "isNotDragging"}`;
  return /* @__PURE__ */ ne.jsxs(
    "div",
    {
      className: g,
      ref: s,
      onMouseDown: l,
      onClick: p,
      children: [
        /* @__PURE__ */ ne.jsx("div", { className: "arkynSliderFill", style: { width: `${n}%` } }),
        /* @__PURE__ */ ne.jsx("div", { className: "arkynSliderThumb", style: { left: `${n}%` } })
      ]
    }
  );
}
function fpt(e) {
  var _, z, L, N;
  const {
    filePath: t,
    disabled: n,
    acceptAudio: r,
    handleSelectFile: o,
    isLoading: i,
    reSendAudio: a,
    changeAudioButtonText: s
  } = e, [l, u] = k(0), c = ht(null), [p, d] = k(!1), [g, f] = k(!1);
  h(() => {
    const R = c.current;
    if (!R) return;
    const V = () => {
      const Z = R.duration, $ = R.currentTime / Z * 100;
      u($);
    };
    return R.addEventListener("timeupdate", V), () => {
      R.removeEventListener("timeupdate", V);
    };
  }, []);
  function y(R) {
    const V = c.current;
    if (!V) return;
    const Z = V.duration, H = R / 100 * Z;
    V.currentTime = H;
  }
  function b() {
    var R;
    (R = c.current) == null || R.play(), f(!0);
  }
  function E() {
    var R;
    (R = c.current) == null || R.pause(), f(!1);
  }
  function w() {
    g ? E() : b();
  }
  const M = (_ = c.current) == null ? void 0 : _.currentTime, O = (z = c.current) == null ? void 0 : z.duration;
  function v(R) {
    if (!R) return "00:00";
    const V = Math.floor(R / 60), Z = Math.floor(R % 60), H = String(V).padStart(2, "0"), $ = String(Z).padStart(2, "0");
    return `${H}:${$}`;
  }
  p || !g ? (L = c.current) == null || L.pause() : g && ((N = c.current) == null || N.play());
  function x() {
    if (n) return;
    const R = document.createElement("input");
    R.type = "file", R.accept = r, R.onchange = (V) => {
      var H;
      const Z = (H = V.target.files) == null ? void 0 : H[0];
      Z && o(Z);
    }, R.click();
  }
  return /* @__PURE__ */ ne.jsxs("div", { className: "arkynAudioUploadHasFileContentContainer", children: [
    /* @__PURE__ */ ne.jsx("audio", { ref: c, src: t, onEnded: E }),
    /* @__PURE__ */ ne.jsxs("div", { className: "arkynAudioUploadAudioPlayer", children: [
      /* @__PURE__ */ ne.jsxs("button", { type: "button", onClick: w, children: [
        g && /* @__PURE__ */ ne.jsx(oge, {}),
        !g && /* @__PURE__ */ ne.jsx(ige, {})
      ] }),
      /* @__PURE__ */ ne.jsx("p", { children: v(M) }),
      /* @__PURE__ */ ne.jsx(
        dpt,
        {
          value: l,
          onChange: y,
          onDragging: d
        }
      ),
      /* @__PURE__ */ ne.jsx("p", { children: v(O) })
    ] }),
    /* @__PURE__ */ ne.jsx(Gwe, {}),
    /* @__PURE__ */ ne.jsxs("div", { className: "arkynAudioUploadButtonsContainer", children: [
      !!a && /* @__PURE__ */ ne.jsx(Zit, { orientation: "bottom", text: "Reenviar áudio", children: /* @__PURE__ */ ne.jsx(
        $it,
        {
          type: "button",
          "aria-label": "resend image",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: i,
          onClick: a,
          icon: yT,
          disabled: n
        }
      ) }),
      /* @__PURE__ */ ne.jsx(
        XB,
        {
          isLoading: i,
          onClick: x,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: n,
          children: s
        }
      )
    ] })
  ] });
}
function hpt(e) {
  const {
    dropAudioText: t,
    isLoading: n,
    acceptAudio: r,
    handleSelectFile: o,
    selectAudioButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ ne.jsxs("div", { onDrop: s, className: "arkynAudioUploadNoFileContent", children: [
    /* @__PURE__ */ ne.jsx(
      XB,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ ne.jsx("p", { children: t })
  ] });
}
function Nwt(e) {
  const {
    name: t,
    label: n,
    fileName: r = "file",
    method: o = "POST",
    onUpload: i,
    fileResponseName: a = "url",
    selectAudioButtonText: s = "Selecionar arquivo de áudio",
    dropAudioText: l = "Ou arraste e solte um arquivo de áudio aqui",
    changeAudioButtonText: u = "Trocar arquivo de áudio",
    acceptAudio: c = "audio/*",
    action: p,
    defaultValue: d = "",
    showAsterisk: g = !1,
    disabled: f = !1
  } = e, b = Vit()[t], [E, w] = k(d), [M, O] = k(""), [v, x] = k(null), [_, z] = k(d), [L, N] = k(!1);
  async function R(X) {
    if (f) return;
    N(!0), x(X), O("");
    const Q = new FormData();
    Q.append(r, X), await fetch(p, { method: o, body: Q }).then(async (J) => await J.json()).then((J) => {
      J != null && J.error ? O(J.error) : w(J == null ? void 0 : J[a]), i && i(J == null ? void 0 : J[a]);
    }).catch((J) => {
      console.error(J), O("Erro ao enviar audio");
    }).finally(() => N(!1));
  }
  function V(X) {
    if (!f) {
      if (console.log(X.type), X.type.indexOf("audio") === -1) {
        O("O arquivo selecionado não é um arquivo de áudio");
        return;
      }
      z(URL.createObjectURL(X)), R(X);
    }
  }
  const Z = b || M, K = `arkynAudioUpload ${Z ? "hasError" : "noHasError"} ${_ ? "hasAudio" : "noHasAudio"}`;
  return /* @__PURE__ */ ne.jsxs("div", { className: "arkynAudioUploadContainer", children: [
    n && /* @__PURE__ */ ne.jsx(ppt, { label: n, showAsterisk: g }),
    /* @__PURE__ */ ne.jsxs("div", { className: K, children: [
      /* @__PURE__ */ ne.jsx("input", { type: "hidden", name: t, value: E || "" }),
      !_ && /* @__PURE__ */ ne.jsx(
        hpt,
        {
          disabled: f,
          isLoading: L,
          acceptAudio: c,
          dropAudioText: l,
          handleSelectFile: V,
          selectAudioButtonText: s
        }
      ),
      _ && /* @__PURE__ */ ne.jsx(
        fpt,
        {
          filePath: _,
          acceptAudio: c,
          changeAudioButtonText: u,
          disabled: f,
          handleSelectFile: V,
          isLoading: L,
          reSendAudio: Z && v ? () => R(v) : void 0
        }
      )
    ] }),
    Z && /* @__PURE__ */ ne.jsx(cpt, { error: Z })
  ] });
}
function vm(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, g = { xs: 12, sm: 16, md: 20, lg: 24 }[i], b = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ ne.jsxs("button", { className: b, disabled: l || t, ...p, children: [
    /* @__PURE__ */ ne.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ ne.jsx(el, { size: g, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ ne.jsxs("div", { className: "arkynButtonContent", children: [
      Fw(g, a),
      c,
      Fw(g, s)
    ] })
  ] });
}
function fR() {
  const e = CT(), t = ate(), n = xT(), [r, o] = k(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  h(() => {
    var c, p;
    let u = ((p = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : p.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), h(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const ife = We({});
function vJ(e) {
  var p;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = fR(), a = ht(null), s = ((p = a.current) == null ? void 0 : p.name) || "", l = (i == null ? void 0 : i[s]) || null, u = Qhe(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ ne.jsx(ife.Provider, { value: { error: l, id: u, inputRef: a }, children: /* @__PURE__ */ ne.jsx(
    "section",
    {
      id: r || s || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function fs() {
  return ge(ife);
}
function Fwt(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: a = null,
    onCheck: s,
    value: l,
    ...u
  } = e, { id: c, inputRef: p, error: d } = fs(), g = o || !!d, [f, y] = k(i || !1), b = typeof a == "boolean" ? a : f, M = `arkynCheckbox ${r} ${g ? "errorTrue" : "errorFalse"} ${b ? "checkedTrue" : "checkedFalse"} ${n}`;
  function O() {
    const v = f;
    y(!v), s && s(v ? "" : l || "checked");
  }
  return /* @__PURE__ */ ne.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: M,
      onClick: O,
      ...u,
      children: [
        /* @__PURE__ */ ne.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: p,
            value: b ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ ne.jsx(Ex, {})
      ]
    }
  );
}
function gpt(e) {
  const { error: t } = e, n = "arkynFileUploadError";
  return t ? /* @__PURE__ */ ne.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ ne.jsx(ne.Fragment, {});
}
function mpt(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynFileUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ ne.jsx("strong", { className: o.trim(), children: t });
}
function sfe(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, p = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ ne.jsxs(
    "button",
    {
      disabled: a || t,
      className: p.trim(),
      ...l,
      children: [
        /* @__PURE__ */ ne.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ ne.jsx(el, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ ne.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ ne.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function afe(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ ne.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ ne.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function vpt(e) {
  const {
    disabled: t,
    file: n,
    isLoading: r,
    acceptFile: o,
    changeFileButtonText: i,
    handleSelectFile: a,
    reSendFile: s
  } = e;
  function l() {
    if (t) return;
    const c = document.createElement("input");
    c.type = "file", c.accept = o, c.onchange = (p) => {
      var g;
      const d = (g = p.target.files) == null ? void 0 : g[0];
      d && a(d);
    }, c.click();
  }
  function u() {
    return n.type.startsWith("image/") ? /* @__PURE__ */ ne.jsx(sge, {}) : n.type.startsWith("audio/") ? /* @__PURE__ */ ne.jsx(age, {}) : n.type.startsWith("application/zip") ? /* @__PURE__ */ ne.jsx(lge, {}) : /* @__PURE__ */ ne.jsx(uge, {});
  }
  return /* @__PURE__ */ ne.jsxs("div", { className: "arkynFileUploadHasFileContent", children: [
    /* @__PURE__ */ ne.jsxs("section", { className: "arkynFileUploadFileContainer", children: [
      /* @__PURE__ */ ne.jsx(u, {}),
      /* @__PURE__ */ ne.jsx("p", { children: n.name })
    ] }),
    /* @__PURE__ */ ne.jsx(Vte, {}),
    /* @__PURE__ */ ne.jsxs("div", { className: "arkynFileUploadButtonsContainer", children: [
      !!s && /* @__PURE__ */ ne.jsx(afe, { orientation: "bottom", text: "Reenviar arquivo", children: /* @__PURE__ */ ne.jsx(
        sfe,
        {
          type: "button",
          "aria-label": "resend file",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: r,
          onClick: s,
          icon: yT,
          disabled: t
        }
      ) }),
      /* @__PURE__ */ ne.jsx(
        vm,
        {
          isLoading: r,
          onClick: l,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: t,
          children: i
        }
      )
    ] })
  ] });
}
function ypt(e) {
  const {
    dropFileText: t,
    isLoading: n,
    acceptFile: r,
    handleSelectFile: o,
    selectFileButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ ne.jsxs("div", { onDrop: s, className: "arkynFileUploadNoFileContent", children: [
    /* @__PURE__ */ ne.jsx(
      XB,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ ne.jsx("p", { children: t })
  ] });
}
function zwt(e) {
  const {
    name: t,
    label: n,
    showAsterisk: r = !1,
    action: o,
    fileName: i = "file",
    method: a = "POST",
    acceptFile: s = "*",
    fileResponseName: l = "url",
    changeFileButtonText: u = "Alterar arquivo",
    selectFileButtonText: c = "Selecionar arquivo",
    dropFileText: p = "Ou arraste e solte o arquivo aqui",
    onUpload: d,
    disabled: g = !1
  } = e, y = fR()[t], [b, E] = k(""), [w, M] = k(""), [O, v] = k(null), [x, _] = k(!1);
  async function z(H) {
    if (g) return;
    _(!0), v(H), M("");
    const $ = new FormData();
    $.append(i, H), await fetch(o, { method: a, body: $ }).then(async (K) => await K.json()).then((K) => {
      K != null && K.error ? M(K.error) : E(K == null ? void 0 : K[l]), d && d(K == null ? void 0 : K[l]);
    }).catch((K) => {
      console.error(K), M("Erro ao enviar o arquivo");
    }).finally(() => _(!1));
  }
  function L(H) {
    g || z(H);
  }
  const N = y || w, Z = `arkynFileUpload ${N ? "hasError" : "noHasError"} ${O ? "hasFile" : "noHasFile"}`;
  return /* @__PURE__ */ ne.jsxs("div", { className: "arkynFileUploadContainer", children: [
    n && /* @__PURE__ */ ne.jsx(mpt, { label: n, showAsterisk: r }),
    /* @__PURE__ */ ne.jsxs("div", { className: Z, children: [
      /* @__PURE__ */ ne.jsx("input", { type: "hidden", name: t, value: b || "" }),
      !O && /* @__PURE__ */ ne.jsx(
        ypt,
        {
          disabled: g,
          isLoading: x,
          acceptFile: s,
          dropFileText: p,
          handleSelectFile: L,
          selectFileButtonText: c
        }
      ),
      O && /* @__PURE__ */ ne.jsx(
        vpt,
        {
          disabled: g,
          isLoading: x,
          acceptFile: s,
          file: O,
          handleSelectFile: L,
          changeFileButtonText: u,
          reSendFile: N && O ? () => z(O) : void 0
        }
      )
    ] }),
    N && /* @__PURE__ */ ne.jsx(gpt, { error: N })
  ] });
}
function Uwt(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = fs();
  return t ? /* @__PURE__ */ ne.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ ne.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ ne.jsx(ne.Fragment, {});
}
function yJ(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = fs(), a = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ ne.jsx("label", { className: a.trim(), htmlFor: o, ...r });
}
function bpt(e) {
  const {
    disabled: t,
    filePath: n,
    isLoading: r,
    acceptImage: o,
    changeImageButtonText: i,
    handleSelectFile: a,
    reSendImage: s
  } = e;
  function l() {
    if (t) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = o, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && a(p);
    }, u.click();
  }
  return /* @__PURE__ */ ne.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${n}")` },
      children: [
        s && /* @__PURE__ */ ne.jsx(afe, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ ne.jsx(
          sfe,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: r,
            onClick: s,
            icon: yT,
            disabled: t
          }
        ) }),
        /* @__PURE__ */ ne.jsx(
          vm,
          {
            isLoading: r,
            onClick: l,
            variant: "outline",
            size: "sm",
            type: "button",
            disabled: t,
            children: i
          }
        )
      ]
    }
  );
}
function wpt(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ ne.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ ne.jsx(ne.Fragment, {});
}
function Cpt(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ ne.jsx("strong", { className: o.trim(), children: t });
}
function xpt(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ ne.jsxs("div", { onDrop: s, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ ne.jsx(
      vm,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ ne.jsx("p", { children: t })
  ] });
}
function Opt(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: a = "file",
    method: s = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: p = "Selecionar imagem",
    dropImageText: d = "Ou arraste e solte a imagem aqui",
    onUpload: g,
    disabled: f = !1
  } = e, b = fR()[t], [E, w] = k(n), [M, O] = k(""), [v, x] = k(null), [_, z] = k(n), [L, N] = k(!1);
  async function R(X) {
    if (f) return;
    N(!0), x(X), O("");
    const Q = new FormData();
    Q.append(a, X), await fetch(i, { method: s, body: Q }).then(async (J) => await J.json()).then((J) => {
      J != null && J.error ? O(J.error) : w(J == null ? void 0 : J[u]), g && g(J == null ? void 0 : J[u]);
    }).catch((J) => {
      console.error(J), O("Erro ao enviar imagem");
    }).finally(() => N(!1));
  }
  function V(X) {
    f || (z(URL.createObjectURL(X)), R(X));
  }
  const Z = b || M, K = `arkynImageUpload ${Z ? "hasError" : "noHasError"} ${_ ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ ne.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ ne.jsx(Cpt, { label: r, showAsterisk: o }),
    /* @__PURE__ */ ne.jsxs("div", { className: K, children: [
      /* @__PURE__ */ ne.jsx("input", { type: "hidden", name: t, value: E || "" }),
      !_ && /* @__PURE__ */ ne.jsx(
        xpt,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          dropImageText: d,
          handleSelectFile: V,
          selectImageButtonText: p
        }
      ),
      _ && /* @__PURE__ */ ne.jsx(
        bpt,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          filePath: _,
          handleSelectFile: V,
          changeImageButtonText: c,
          reSendImage: Z && v ? () => R(v) : void 0
        }
      )
    ] }),
    Z && /* @__PURE__ */ ne.jsx(wpt, { error: Z })
  ] });
}
function tc(e, t, n) {
  if (!e) return /* @__PURE__ */ ne.jsx(ne.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ ne.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ ne.jsx("p", { className: n, children: /* @__PURE__ */ ne.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function hR(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function lfe(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function ufe(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const gR = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, cfe = hR(gR.CNPJ).length;
function Ept(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    defaultValue: d,
    readOnly: g,
    onFocus: f,
    onBlur: y,
    title: b,
    style: E,
    onChange: w,
    ...M
  } = e;
  function O(H) {
    let $ = hR(H);
    const K = ufe($);
    if (!($.length > cfe))
      return $ = lfe($, gR[K]), $;
  }
  const v = c ? "right" : "left", R = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || g || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, Z = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: R,
    prefix: tc(s, Z, "prefix"),
    sufix: tc(l, Z, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: O(d || ""),
    disabled: p,
    readOnly: g,
    onFocus: f,
    onBlur: y,
    title: b,
    style: E,
    onChange: w,
    loadingPosition: v,
    iconSize: Z,
    Spinner: /* @__PURE__ */ ne.jsx(el, { className: "spinner", size: Z, strokeWidth: 2.5 }),
    ...M
  };
}
function kpt(e) {
  const [t, n] = k(!1), r = ht(null), { inputRef: o, id: i, error: a } = fs(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: f,
    iconSize: y,
    loadingPosition: b,
    isLoading: E,
    LeftIcon: w,
    readOnly: M,
    onFocus: O,
    onBlur: v,
    RightIcon: x,
    Spinner: _,
    onChange: z,
    value: L,
    defaultValue: N,
    ...R
  } = Ept({ ...e, id: i, isError: l }, t), [V, Z] = k(N), H = w && !E, $ = x && !E, K = b === "left" && E, X = b === "right" && E;
  function Q() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function J(F) {
    let S = hR(F.target.value);
    const W = ufe(S);
    S.length > cfe || (S = lfe(S, gR[W]), F.target.value = S, Z(S), z && z(F));
  }
  function P(F) {
    n(!0), O && O(F);
  }
  function D(F) {
    n(!1), v && v(F);
  }
  return /* @__PURE__ */ ne.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: Q,
      className: d,
      children: [
        g,
        K && _,
        H && /* @__PURE__ */ ne.jsx(w, { size: y, strokeWidth: 2.5 }),
        /* @__PURE__ */ ne.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: M,
            ref: s,
            value: L || V,
            onFocus: P,
            onChange: J,
            onBlur: D,
            ...R
          }
        ),
        $ && /* @__PURE__ */ ne.jsx(x, { size: y, strokeWidth: 2.5 }),
        X && _,
        f
      ]
    }
  );
}
const Lpt = 3, Ppt = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? Lpt : 0), iw = 2, bJ = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), eT = (e) => {
  let t = e;
  return typeof e == "string" ? (t = bJ(e), t % 1 !== 0 && (t = t.toFixed(iw))) : t = Number.isInteger(e) ? Number(e) * 10 ** iw : e.toFixed(iw), bJ(t) / 10 ** iw;
}, wJ = (e, t, n) => {
  if (!t) return [0, ""];
  const r = eT(t), o = Ppt(e, r, n);
  return [r, o];
};
function _pt(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: y,
    style: b,
    // showCents = false,
    max: E = 1e9,
    locale: w = "pt-BR",
    currency: M = "BRL",
    ...O
  } = e, v = c ? "right" : "left", R = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, Z = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: R,
    prefix: tc(s, Z, "prefix"),
    sufix: tc(l, Z, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    locale: w,
    currency: M,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: y,
    style: b,
    max: E,
    // showCents,
    loadingPosition: v,
    iconSize: Z,
    Spinner: /* @__PURE__ */ ne.jsx(el, { className: "spinner", size: Z, strokeWidth: 2.5 }),
    ...O
  };
}
function Spt(e) {
  const [t, n] = k(!1), [r, o] = k("0"), i = ht(null), { inputRef: a, id: s, error: l } = fs(), u = a || i, c = e.isError || !!l, {
    disabled: p,
    title: d,
    style: g,
    className: f,
    prefix: y,
    sufix: b,
    iconSize: E,
    loadingPosition: w,
    isLoading: M,
    LeftIcon: O,
    readOnly: v,
    onFocus: x,
    onBlur: _,
    RightIcon: z,
    Spinner: L,
    value: N,
    max: R,
    onChangeValue: V,
    onKeyPress: Z,
    currency: H,
    locale: $,
    name: K,
    defaultValue: X,
    ...Q
  } = _pt({ ...e, id: s, isError: c }, t), J = O && !M, P = z && !M, D = w === "left" && M, F = w === "right" && M;
  function S() {
    p || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function W(q) {
    n(!0), x && x(q);
  }
  function C(q) {
    n(!1), _ && _(q);
  }
  const I = (q) => {
    const [j, Y] = wJ(
      $,
      q,
      H
    );
    return !R || j <= R ? (o(Y), [j, Y]) : [eT(r), r];
  }, U = (q) => {
    q.preventDefault();
    const [j, Y] = I(q.target.value);
    V && V(q, String(j), String(Y));
  }, T = (q) => Z && Z(q, q.key, q.key);
  return h(() => {
    const q = N || +X || void 0, [, j] = wJ($, q, H);
    o(j);
  }, [H, X, N]), /* @__PURE__ */ ne.jsxs(
    "section",
    {
      title: d,
      style: g,
      onClick: S,
      className: f,
      children: [
        y,
        D && L,
        J && /* @__PURE__ */ ne.jsx(O, { size: E, strokeWidth: 2.5 }),
        /* @__PURE__ */ ne.jsx(
          "input",
          {
            value: r,
            onChange: U,
            onBlur: C,
            onFocus: W,
            onKeyUp: T,
            disabled: p || M,
            readOnly: v,
            ...Q
          }
        ),
        /* @__PURE__ */ ne.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: K,
            value: eT(r)
          }
        ),
        F && L,
        P && /* @__PURE__ */ ne.jsx(z, { size: E, strokeWidth: 2.5 }),
        b
      ]
    }
  );
}
function Mpt(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: y,
    style: b,
    onChange: E,
    showMask: w = !1,
    type: M,
    ...O
  } = e, v = c ? "right" : "left", R = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, Z = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: R,
    prefix: tc(s, Z, "prefix"),
    sufix: tc(l, Z, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: y,
    style: b,
    onChange: E,
    loadingPosition: v,
    iconSize: Z,
    showMask: w,
    Spinner: /* @__PURE__ */ ne.jsx(el, { className: "spinner", size: Z, strokeWidth: 2.5 }),
    ...O
  };
}
const Dpt = yr((e, t) => /* @__PURE__ */ ne.jsx("input", { ref: t, ...e }));
function Tpt(e) {
  const [t, n] = k(!1), r = ht(null), { inputRef: o, id: i, error: a } = fs(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: f,
    iconSize: y,
    loadingPosition: b,
    isLoading: E,
    LeftIcon: w,
    readOnly: M,
    onFocus: O,
    onBlur: v,
    RightIcon: x,
    Spinner: _,
    ...z
  } = Mpt({ ...e, id: i, isError: l }, t), L = w && !E, N = x && !E, R = b === "left" && E, V = b === "right" && E;
  function Z() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function H(K) {
    n(!0), O && O(K);
  }
  function $(K) {
    n(!1), v && v(K);
  }
  return /* @__PURE__ */ ne.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: Z,
      className: d,
      children: [
        g,
        R && _,
        L && /* @__PURE__ */ ne.jsx(w, { size: y, strokeWidth: 2.5 }),
        /* @__PURE__ */ ne.jsx(
          tl,
          {
            component: Dpt,
            ref: s,
            onFocus: H,
            onBlur: $,
            disabled: u,
            ...z
          }
        ),
        N && /* @__PURE__ */ ne.jsx(x, { size: y, strokeWidth: 2.5 }),
        V && _,
        f
      ]
    }
  );
}
function jpt(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: y,
    style: b,
    onChange: E,
    ...w
  } = e, M = c ? "right" : "left", L = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, R = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: L,
    prefix: tc(s, R, "prefix"),
    sufix: tc(l, R, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: y,
    style: b,
    onChange: E,
    loadingPosition: M,
    iconSize: R,
    Spinner: /* @__PURE__ */ ne.jsx(el, { className: "spinner", size: R, strokeWidth: 2.5 }),
    ...w
  };
}
function Apt(e) {
  const [t, n] = k(!1), r = ht(null), { inputRef: o, id: i, error: a } = fs(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: f,
    iconSize: y,
    loadingPosition: b,
    isLoading: E,
    LeftIcon: w,
    readOnly: M,
    onFocus: O,
    onBlur: v,
    RightIcon: x,
    type: _,
    Spinner: z,
    ...L
  } = jpt({ ...e, id: i, isError: l }, t), N = w && !E, R = x && !E, V = b === "left" && E, Z = b === "right" && E;
  function H() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function $(X) {
    n(!0), O && O(X);
  }
  function K(X) {
    n(!1), v && v(X);
  }
  return _ === "hidden" ? /* @__PURE__ */ ne.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: s,
      ...L
    }
  ) : /* @__PURE__ */ ne.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: H,
      className: d,
      children: [
        g,
        V && z,
        N && /* @__PURE__ */ ne.jsx(w, { size: y, strokeWidth: 2.5 }),
        /* @__PURE__ */ ne.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: M,
            ref: s,
            onFocus: $,
            onBlur: K,
            type: _,
            ...L
          }
        ),
        R && /* @__PURE__ */ ne.jsx(x, { size: y, strokeWidth: 2.5 }),
        Z && z,
        f
      ]
    }
  );
}
function Ik(e) {
  return e.type === "currency" ? /* @__PURE__ */ ne.jsx(Spt, { ...e }) : e.type === "masked" ? /* @__PURE__ */ ne.jsx(Tpt, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ ne.jsx(kpt, { ...e }) : /* @__PURE__ */ ne.jsx(Apt, { ...e });
}
function Ipt(e) {
  const { iconSize: t, isLoading: n, disabled: r, readOnly: o, isFocused: i } = e, l = `arkynMultiSelectChevron ${r || o ? "notAnimate" : ""} ${i ? "focused" : ""}`;
  return n ? /* @__PURE__ */ ne.jsx(ne.Fragment, {}) : /* @__PURE__ */ ne.jsx(bT, { className: l, size: t, strokeWidth: 2.5 });
}
function Bpt(e) {
  const {
    children: t,
    handleContainerFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s,
    readOnly: l,
    variant: u,
    size: c,
    id: p,
    prefixExists: d
  } = e, g = d ? "hasPrefix" : "", f = o ? "errored" : "", y = r || l || i ? "opacity" : "", b = a ? "focused" : "";
  return /* @__PURE__ */ ne.jsx(
    "section",
    {
      id: p,
      className: `arkynMultiSelectContainer ${g} ${u} ${c} ${y} ${f} ${b} ${s}`,
      onClick: n,
      children: t
    }
  );
}
function Rpt(e) {
  const { children: t, size: n } = e, r = `arkynMultiSelectContent ${n}`;
  return /* @__PURE__ */ ne.jsx("div", { className: r, children: t });
}
function Npt(e) {
  const { label: t, value: n, handleChangeValue: r } = e;
  return /* @__PURE__ */ ne.jsxs("div", { className: "arkynMultiSelectMark", children: [
    t,
    /* @__PURE__ */ ne.jsx(
      "button",
      {
        type: "button",
        onClick: (o) => {
          o.stopPropagation(), r(n);
        },
        children: /* @__PURE__ */ ne.jsx(wT, {})
      }
    )
  ] });
}
function Fpt(e) {
  const { label: t, optionHasSelected: n, handleChangeValue: r, value: o, size: i } = e, a = n(o) ? "active" : "", s = `arkynMultiSelectOption ${i} ${a}`;
  return /* @__PURE__ */ ne.jsxs("div", { onClick: () => r(o), className: s, children: [
    t,
    " ",
    /* @__PURE__ */ ne.jsx(Ex, {})
  ] });
}
function zpt(e) {
  const { children: t, isFocused: n, isSearchable: r, onSearch: o } = e;
  function i(a) {
    r && o(a.target.value);
  }
  return n ? /* @__PURE__ */ ne.jsxs("div", { className: "arkynMultiSelectOptionsContainer", children: [
    r && /* @__PURE__ */ ne.jsx(
      Ik,
      {
        type: "search",
        name: "search-select",
        variant: "underline",
        leftIcon: ste,
        onChange: i
      }
    ),
    t
  ] }) : /* @__PURE__ */ ne.jsx(ne.Fragment, {});
}
function Upt(e) {
  const { isFocused: t, handleBlur: n } = e;
  return t ? /* @__PURE__ */ ne.jsx("aside", { className: "arkynMultiSelectOverlay", onClick: n }) : /* @__PURE__ */ ne.jsx(ne.Fragment, {});
}
function Hpt(e) {
  const { iconSize: t, isLoading: n } = e;
  return n ? /* @__PURE__ */ ne.jsx(
    el,
    {
      className: "arkynMultiSelectSpinner",
      size: t,
      strokeWidth: 2.5
    }
  ) : /* @__PURE__ */ ne.jsx(ne.Fragment, {});
}
function Hwt(e) {
  const {
    name: t,
    options: n,
    className: r = "",
    placeholder: o = "Selecione...",
    closeOnSelect: i = !1,
    defaultValue: a = [],
    isError: s,
    isLoading: l = !1,
    readOnly: u = !1,
    isSearchable: c = !1,
    leftIcon: p,
    onSearch: d,
    onSelect: g,
    onBlur: f,
    notFoundText: y = "Sem opções disponíveis",
    onFocus: b,
    disabled: E = !1,
    prefix: w,
    size: M = "md",
    value: O,
    variant: v = "solid"
  } = e, x = fs(), _ = ht(null), z = x.inputRef || _, L = x.id, N = s || !!x.error, V = { md: 20, lg: 20 }[M], Z = Wte(w, V, "prefix"), [H, $] = k(""), [K, X] = k(!1), [Q, J] = k(a), P = O || Q;
  function D(T) {
    return P.includes(T);
  }
  function F(T) {
    const q = n.find((j) => j.value === T);
    return (q == null ? void 0 : q.label) || "";
  }
  function S() {
    E || !(z != null && z.current) || K || (X(!0), z.current.focus(), b && b());
  }
  function W() {
    X(!1), f && z.current && z.current.blur();
  }
  function C(T) {
    $(T), d && d(T);
  }
  function I(T) {
    D(T) ? J(Q.filter((q) => q !== T)) : J([...Q, T]), g && g(Q), i && W();
  }
  const U = n.filter((T) => !!(e.onSearch || !e.isSearchable || T.label.toLowerCase().includes(H.toLowerCase())));
  return /* @__PURE__ */ ne.jsxs(
    Bpt,
    {
      handleContainerFocus: S,
      disabled: E,
      isError: N,
      isFocused: K,
      isLoading: l,
      readOnly: u,
      size: M,
      variant: v,
      className: r,
      prefixExists: !!w,
      id: L,
      children: [
        /* @__PURE__ */ ne.jsx(
          "input",
          {
            ref: z,
            name: t,
            value: JSON.stringify(P),
            type: "hidden"
          }
        ),
        Z,
        p && /* @__PURE__ */ ne.jsx(p, { size: V, strokeWidth: 2.5 }),
        /* @__PURE__ */ ne.jsxs(Rpt, { size: M, children: [
          P.map((T) => /* @__PURE__ */ ne.jsx(
            Npt,
            {
              label: F(T),
              value: T,
              handleChangeValue: I
            },
            T
          )),
          P.length <= 0 && /* @__PURE__ */ ne.jsx("p", { children: o })
        ] }),
        /* @__PURE__ */ ne.jsxs(
          zpt,
          {
            isFocused: K,
            isSearchable: c,
            onSearch: C,
            children: [
              U.map(({ label: T, value: q }) => /* @__PURE__ */ ne.jsx(
                Fpt,
                {
                  label: T,
                  value: q,
                  size: M,
                  handleChangeValue: I,
                  optionHasSelected: D
                },
                q
              )),
              U.length <= 0 && /* @__PURE__ */ ne.jsx("p", { children: y })
            ]
          }
        ),
        /* @__PURE__ */ ne.jsx(
          Ipt,
          {
            disabled: E,
            isFocused: K,
            readOnly: u,
            iconSize: V,
            isLoading: l
          }
        ),
        /* @__PURE__ */ ne.jsx(Hpt, { iconSize: V, isLoading: l }),
        /* @__PURE__ */ ne.jsx(Upt, { handleBlur: W, isFocused: K })
      ]
    }
  );
}
const gd = [
  {
    name: "Afghanistan",
    code: "+93",
    prefix: null,
    iso: "AF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/af.svg",
    mask: "__-___-____"
  },
  {
    name: "Aland Islands",
    code: "+358",
    prefix: null,
    iso: "AX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ax.svg",
    mask: "(___)___-__-__"
  },
  {
    name: "Albania",
    code: "+355",
    prefix: null,
    iso: "AL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/al.svg",
    mask: "(___)___-___"
  },
  {
    name: "Algeria",
    code: "+213",
    prefix: null,
    iso: "DZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dz.svg",
    mask: "__-___-____"
  },
  {
    name: "American Samoa",
    code: "+1",
    prefix: "684",
    iso: "AS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/as.svg",
    mask: "(684)___-____"
  },
  {
    name: "Andorra",
    code: "+376",
    prefix: null,
    iso: "AD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ad.svg",
    mask: "___-___"
  },
  {
    name: "Angola",
    code: "+244",
    prefix: null,
    iso: "AO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ao.svg",
    mask: "(___)___-___"
  },
  {
    name: "Anguilla",
    code: "+1",
    prefix: "264",
    iso: "AI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ai.svg",
    mask: "(264)___-____"
  },
  {
    name: "Antarctica",
    code: "+672",
    prefix: "1",
    iso: "AQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/aq.svg",
    mask: "1__-___"
  },
  {
    name: "Antigua and Barbuda",
    code: "+1",
    prefix: "268",
    iso: "AG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ag.svg",
    mask: "(268)___-____"
  },
  {
    name: "Argentina",
    code: "+54",
    prefix: null,
    iso: "AR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ar.svg",
    mask: "(___)___-____"
  },
  {
    name: "Armenia",
    code: "+374",
    prefix: null,
    iso: "AM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/am.svg",
    mask: "__-___-___"
  },
  {
    name: "Aruba",
    code: "+297",
    prefix: null,
    iso: "AW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/aw.svg",
    mask: "___-____"
  },
  {
    name: "Ascension Island",
    code: "+247",
    prefix: null,
    iso: "AC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sh.svg",
    mask: "____"
  },
  {
    name: "Australia",
    code: "+61",
    prefix: null,
    iso: "AU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/au.svg",
    mask: "_-____-____"
  },
  {
    name: "Austria",
    code: "+43",
    prefix: null,
    iso: "AT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/at.svg",
    mask: "(___)___-____"
  },
  {
    name: "Azerbaijan",
    code: "+994",
    prefix: null,
    iso: "AZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/az.svg",
    mask: "__-___-__-__"
  },
  {
    name: "Bahamas",
    code: "+1",
    prefix: "242",
    iso: "BS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bs.svg",
    mask: "(242)___-____"
  },
  {
    name: "Bahrain",
    code: "+973",
    prefix: null,
    iso: "BH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bh.svg",
    mask: "____-____"
  },
  {
    name: "Bangladesh",
    code: "+880",
    prefix: "1",
    iso: "BD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bd.svg",
    mask: "1___-______"
  },
  {
    name: "Barbados",
    code: "+1",
    prefix: "246",
    iso: "BB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bb.svg",
    mask: "(246)___-____"
  },
  {
    name: "Belarus",
    code: "+375",
    prefix: null,
    iso: "BY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/by.svg",
    mask: "(__)___-__-__"
  },
  {
    name: "Belgium",
    code: "+32",
    prefix: null,
    iso: "BE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/be.svg",
    mask: "(___)___-___"
  },
  {
    name: "Belize",
    code: "+501",
    prefix: null,
    iso: "BZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bz.svg",
    mask: "___-____"
  },
  {
    name: "Benin",
    code: "+229",
    prefix: null,
    iso: "BJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bj.svg",
    mask: "__-__-____"
  },
  {
    name: "Bermuda",
    code: "+1",
    prefix: "441",
    iso: "BM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bm.svg",
    mask: "(441)___-____"
  },
  {
    name: "Bhutan",
    code: "+975",
    prefix: null,
    iso: "BT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bt.svg",
    mask: "_-___-___"
  },
  {
    name: "Bolivia",
    code: "+591",
    prefix: null,
    iso: "BO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bo.svg",
    mask: "_-___-____"
  },
  {
    name: "Bosnia and Herzegovina",
    code: "+387",
    prefix: null,
    iso: "BA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ba.svg",
    mask: "__-_____"
  },
  {
    name: "Botswana",
    code: "+267",
    prefix: null,
    iso: "BW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bw.svg",
    mask: "__-___-___"
  },
  {
    name: "Brasil",
    code: "+55",
    prefix: null,
    iso: "BR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/br.svg",
    mask: "(__) _____-____"
  },
  {
    name: "British Indian Ocean Territory",
    code: "+246",
    prefix: null,
    iso: "IO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/io.svg",
    mask: "___-____"
  },
  {
    name: "Brunei Darussalam",
    code: "+673",
    prefix: null,
    iso: "BN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bn.svg",
    mask: "___-____"
  },
  {
    name: "Bulgaria",
    code: "+359",
    prefix: null,
    iso: "BG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bg.svg",
    mask: "(___)___-___"
  },
  {
    name: "Burkina Faso",
    code: "+226",
    prefix: null,
    iso: "BF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bf.svg",
    mask: "__-__-____"
  },
  {
    name: "Burundi",
    code: "+257",
    prefix: null,
    iso: "BI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bi.svg",
    mask: "__-__-____"
  },
  {
    name: "Cambodia",
    code: "+855",
    prefix: null,
    iso: "KH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kh.svg",
    mask: "__-___-___"
  },
  {
    name: "Cameroon",
    code: "+237",
    prefix: null,
    iso: "CM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cm.svg",
    mask: "____-____"
  },
  {
    name: "Canada",
    code: "+1",
    prefix: null,
    iso: "CA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ca.svg",
    mask: "(___)___-____"
  },
  {
    name: "Cape Verde",
    code: "+238",
    prefix: null,
    iso: "CV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cv.svg",
    mask: "(___)__-__"
  },
  {
    name: "Cayman Islands",
    code: "+1",
    prefix: "345",
    iso: "KY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ky.svg",
    mask: "(345)___-____"
  },
  {
    name: "Central African Republic",
    code: "+236",
    prefix: null,
    iso: "CF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cf.svg",
    mask: "__-__-____"
  },
  {
    name: "Chad",
    code: "+235",
    prefix: null,
    iso: "TD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/td.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Chile",
    code: "+56",
    prefix: null,
    iso: "CL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cl.svg",
    mask: "_-____-____"
  },
  {
    name: "China",
    code: "+86",
    prefix: null,
    iso: "CN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cn.svg",
    mask: "__-_____-_____"
  },
  {
    name: "Christmas Island",
    code: "+61",
    prefix: null,
    iso: "CX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cx.svg",
    mask: "_-____-____"
  },
  {
    name: "Cocos (Keeling) Islands",
    code: "+61",
    prefix: null,
    iso: "CC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cc.svg",
    mask: "_-____-____"
  },
  {
    name: "Colombia",
    code: "+57",
    prefix: null,
    iso: "CO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/co.svg",
    mask: "(___)___-____"
  },
  {
    name: "Comoros",
    code: "+269",
    prefix: null,
    iso: "KM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/km.svg",
    mask: "__-_____"
  },
  {
    name: "Congo",
    code: "+242",
    prefix: null,
    iso: "CG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cg.svg",
    mask: "__-_____"
  },
  {
    name: "Cook Islands",
    code: "+682",
    prefix: null,
    iso: "CK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ck.svg",
    mask: "__-___"
  },
  {
    name: "Costa Rica",
    code: "+506",
    prefix: null,
    iso: "CR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cr.svg",
    mask: "____-____"
  },
  {
    name: "Croatia",
    code: "+385",
    prefix: null,
    iso: "HR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hr.svg",
    mask: "__-___-___"
  },
  {
    name: "Cuba",
    code: "+53",
    prefix: null,
    iso: "CU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cu.svg",
    mask: "_-___-____"
  },
  {
    name: "Cyprus",
    code: "+357",
    prefix: null,
    iso: "CY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cy.svg",
    mask: "__-___-___"
  },
  {
    name: "Czech Republic",
    code: "+420",
    prefix: null,
    iso: "CZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cz.svg",
    mask: "(___)___-___"
  },
  {
    name: "Democratic Republic of the Congo",
    code: "+243",
    prefix: null,
    iso: "CD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cd.svg",
    mask: "(___)___-___"
  },
  {
    name: "Denmark",
    code: "+45",
    prefix: null,
    iso: "DK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dk.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Djibouti",
    code: "+253",
    prefix: null,
    iso: "DJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dj.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Dominica",
    code: "+1",
    prefix: "767",
    iso: "DM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dm.svg",
    mask: "(767)___-____"
  },
  {
    name: "Dominican Republic",
    code: "+1",
    prefix: "849",
    iso: "DO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/do.svg",
    mask: "(894)___-____"
  },
  {
    name: "Ecuador",
    code: "+593",
    prefix: null,
    iso: "EC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ec.svg",
    mask: "__-___-____"
  },
  {
    name: "Egypt",
    code: "+20",
    prefix: null,
    iso: "EG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/eg.svg",
    mask: "(___)___-____"
  },
  {
    name: "El Salvador",
    code: "+503",
    prefix: null,
    iso: "SV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sv.svg",
    mask: "__-__-____"
  },
  {
    name: "Equatorial Guinea",
    code: "+240",
    prefix: null,
    iso: "GQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gq.svg",
    mask: "__-___-____"
  },
  {
    name: "Eritrea",
    code: "+291",
    prefix: null,
    iso: "ER",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/er.svg",
    mask: "_-___-___"
  },
  {
    name: "Estonia",
    code: "+372",
    prefix: null,
    iso: "EE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ee.svg",
    mask: "____-____"
  },
  {
    name: "Eswatini",
    code: "+268",
    prefix: null,
    iso: "SZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sz.svg",
    mask: "__-__-____"
  },
  {
    name: "Ethiopia",
    code: "+251",
    prefix: null,
    iso: "ET",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/et.svg",
    mask: "__-___-____"
  },
  {
    name: "Falkland Islands (Malvinas)",
    code: "+500",
    prefix: null,
    iso: "FK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fk.svg",
    mask: "_____"
  },
  {
    name: "Faroe Islands",
    code: "+298",
    prefix: null,
    iso: "FO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fo.svg",
    mask: "__ __ __"
  },
  {
    name: "Fiji",
    code: "+679",
    prefix: null,
    iso: "FJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fj.svg",
    mask: "__-_____"
  },
  {
    name: "Finland",
    code: "+358",
    prefix: null,
    iso: "FI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fi.svg",
    mask: "__ ___ ____"
  },
  {
    name: "France",
    code: "+33",
    prefix: null,
    iso: "FR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fr.svg",
    mask: "_ __ __ __ __"
  },
  {
    name: "French Guiana",
    code: "+594",
    prefix: null,
    iso: "GF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gf.svg",
    mask: "___ __ __ __"
  },
  {
    name: "French Polynesia",
    code: "+689",
    prefix: null,
    iso: "PF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pf.svg",
    mask: "__ __ __ __"
  },
  {
    name: "Gabon",
    code: "+241",
    prefix: null,
    iso: "GA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ga.svg",
    mask: "_ __ __ __"
  },
  {
    name: "Gambia",
    code: "+220",
    prefix: null,
    iso: "GM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gm.svg",
    mask: "___ ____"
  },
  {
    name: "Georgia",
    code: "+995",
    prefix: null,
    iso: "GE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ge.svg",
    mask: "(___)___-___"
  },
  {
    name: "Germany",
    code: "+49",
    prefix: "3",
    iso: "DE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/de.svg",
    mask: "(3____) __-____"
  },
  {
    name: "Ghana",
    code: "+233",
    prefix: "03",
    iso: "GH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gh.svg",
    mask: "03_ ___ ____"
  },
  {
    name: "Gibraltar",
    code: "+350",
    prefix: null,
    iso: "GI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gi.svg",
    mask: "___-_____"
  },
  {
    name: "Greece",
    code: "+30",
    prefix: null,
    iso: "GR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gr.svg",
    mask: "(___)___-____"
  },
  {
    name: "Greenland",
    code: "+299",
    prefix: null,
    iso: "GL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gl.svg",
    mask: "__-__-__"
  },
  {
    name: "Grenada",
    code: "+1",
    prefix: "473",
    iso: "GD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gd.svg",
    mask: "(473)___-____"
  },
  {
    name: "Guadeloupe",
    code: "+590",
    prefix: null,
    iso: "GP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gp.svg",
    mask: "___ __ __ __"
  },
  {
    name: "Guam",
    code: "+1",
    prefix: "671",
    iso: "GU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gu.svg",
    mask: "671 ___ ____"
  },
  {
    name: "Guatemala",
    code: "+502",
    prefix: null,
    iso: "GT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gt.svg",
    mask: "_-___-____"
  },
  {
    name: "Guernsey",
    code: "+44",
    prefix: null,
    iso: "GG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gg.svg",
    mask: "(____)______"
  },
  {
    name: "Guinea",
    code: "+224",
    prefix: null,
    iso: "GN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gn.svg",
    mask: "__-___-___"
  },
  {
    name: "Guinea-Bissau",
    code: "+245",
    prefix: null,
    iso: "GW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gw.svg",
    mask: "_-______"
  },
  {
    name: "Guyana",
    code: "+592",
    prefix: null,
    iso: "GY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gy.svg",
    mask: "___-____"
  },
  {
    name: "Haiti",
    code: "+509",
    prefix: null,
    iso: "HT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ht.svg",
    mask: "__-__-____"
  },
  {
    name: "Holy See (Vatican City State)",
    code: "+39",
    prefix: "06698",
    iso: "VA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/va.svg",
    mask: "06 698_____"
  },
  {
    name: "Honduras",
    code: "+504",
    prefix: null,
    iso: "HN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hn.svg",
    mask: "____-____"
  },
  {
    name: "Hong Kong",
    code: "+852",
    prefix: null,
    iso: "HK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hk.svg",
    mask: "____-____"
  },
  {
    name: "Hungary",
    code: "+36",
    prefix: null,
    iso: "HU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hu.svg",
    mask: "__ ___ ____"
  },
  {
    name: "Iceland",
    code: "+354",
    prefix: null,
    iso: "IS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/is.svg",
    mask: "___-____"
  },
  {
    name: "India",
    code: "+91",
    prefix: null,
    iso: "IN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/in.svg",
    mask: "(____)___-___"
  },
  {
    name: "Indonesia",
    code: "+62",
    prefix: "8",
    iso: "ID",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/id.svg",
    mask: "(8__)___-__-___"
  },
  {
    name: "Iran",
    code: "+98",
    prefix: null,
    iso: "IR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ir.svg",
    mask: "(___)___-____"
  },
  {
    name: "Iraq",
    code: "+964",
    prefix: null,
    iso: "IQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/iq.svg",
    mask: "(___)___-____"
  },
  {
    name: "Ireland",
    code: "+353",
    prefix: null,
    iso: "IE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ie.svg",
    mask: "(___)___-___"
  },
  {
    name: "Isle of Man",
    code: "+44",
    prefix: null,
    iso: "IM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/im.svg",
    mask: "(____)______"
  },
  {
    name: "Israel",
    code: "+972",
    prefix: "5",
    iso: "IL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/il.svg",
    mask: "__-___-____"
  },
  {
    name: "Italy",
    code: "+39",
    prefix: null,
    iso: "IT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/it.svg",
    mask: "(___)____-___"
  },
  {
    name: "Ivory Coast / Cote d'Ivoire",
    code: "+225",
    prefix: null,
    iso: "CI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ci.svg",
    mask: "__-___-___"
  },
  {
    name: "Jamaica",
    code: "+1",
    prefix: "876",
    iso: "JM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jm.svg",
    mask: "(876)___-____"
  },
  {
    name: "Japan",
    code: "+81",
    prefix: null,
    iso: "JP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jp.svg",
    mask: "__-____-____"
  },
  {
    name: "Jersey",
    code: "+44",
    prefix: null,
    iso: "JE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/je.svg",
    mask: "(____)____-______"
  },
  {
    name: "Jordan",
    code: "+962",
    prefix: null,
    iso: "JO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jo.svg",
    mask: "_-____-____"
  },
  {
    name: "Kazakhstan",
    code: "+77",
    prefix: null,
    iso: "KZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kz.svg",
    mask: "(_____) _ __ __"
  },
  {
    name: "Kenya",
    code: "+254",
    prefix: null,
    iso: "KE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ke.svg",
    mask: "___-______"
  },
  {
    name: "Kiribati",
    code: "+686",
    prefix: null,
    iso: "KI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ki.svg",
    mask: "__-___"
  },
  {
    name: "Korea, Democratic People's Republic of Korea",
    code: "+850",
    prefix: null,
    iso: "KP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kp.svg",
    mask: "____-_____________"
  },
  {
    name: "Korea, Republic of South Korea",
    code: "+82",
    prefix: null,
    iso: "KR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kr.svg",
    mask: "__-___-____"
  },
  {
    name: "Kosovo",
    code: "+383",
    prefix: null,
    iso: "XK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/xk.svg",
    mask: "___-___-___"
  },
  {
    name: "Kuwait",
    code: "+965",
    prefix: null,
    iso: "KW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kw.svg",
    mask: "____-____"
  },
  {
    name: "Kyrgyzstan",
    code: "+996",
    prefix: null,
    iso: "KG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kg.svg",
    mask: "(___)___-___"
  },
  {
    name: "Laos",
    code: "+856",
    prefix: "20",
    iso: "LA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/la.svg",
    mask: "(20__)___-___"
  },
  {
    name: "Latvia",
    code: "+371",
    prefix: null,
    iso: "LV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lv.svg",
    mask: "__-___-___"
  },
  {
    name: "Lebanon",
    code: "+961",
    prefix: null,
    iso: "LB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lb.svg",
    mask: "__-___-___"
  },
  {
    name: "Lesotho",
    code: "+266",
    prefix: null,
    iso: "LS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ls.svg",
    mask: "_-___-____"
  },
  {
    name: "Liberia",
    code: "+231",
    prefix: null,
    iso: "LR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lr.svg",
    mask: "__-___-___"
  },
  {
    name: "Libya",
    code: "+218",
    prefix: "21",
    iso: "LY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ly.svg",
    mask: "21-___-____"
  },
  {
    name: "Liechtenstein",
    code: "+423",
    prefix: null,
    iso: "LI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/li.svg",
    mask: "(___)___-____"
  },
  {
    name: "Lithuania",
    code: "+370",
    prefix: null,
    iso: "LT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lt.svg",
    mask: "(___)__-___"
  },
  {
    name: "Luxembourg",
    code: "+352",
    prefix: null,
    iso: "LU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lu.svg",
    mask: "(___)___-___"
  },
  {
    name: "Macau",
    code: "+853",
    prefix: null,
    iso: "MO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mo.svg",
    mask: "____-____"
  },
  {
    name: "Madagascar",
    code: "+261",
    prefix: null,
    iso: "MG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mg.svg",
    mask: "__-__-_____"
  },
  {
    name: "Malawi",
    code: "+265",
    prefix: null,
    iso: "MW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mw.svg",
    mask: "_-____-____"
  },
  {
    name: "Malaysia",
    code: "+60",
    prefix: null,
    iso: "MY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/my.svg",
    mask: "__-___-____"
  },
  {
    name: "Maldives",
    code: "+960",
    prefix: null,
    iso: "MV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mv.svg",
    mask: "___-____"
  },
  {
    name: "Mali",
    code: "+223",
    prefix: null,
    iso: "ML",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ml.svg",
    mask: "__-__-____"
  },
  {
    name: "Malta",
    code: "+356",
    prefix: null,
    iso: "MT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mt.svg",
    mask: "____-____"
  },
  {
    name: "Marshall Islands",
    code: "+692",
    prefix: null,
    iso: "MH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mh.svg",
    mask: "___-____"
  },
  {
    name: "Martinique",
    code: "+596",
    prefix: null,
    iso: "MQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mq.svg",
    mask: "(___)__-__-__"
  },
  {
    name: "Mauritania",
    code: "+222",
    prefix: null,
    iso: "MR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mr.svg",
    mask: "__-__-____"
  },
  {
    name: "Mauritius",
    code: "+230",
    prefix: null,
    iso: "MU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mu.svg",
    mask: "___-____"
  },
  {
    name: "Mayotte",
    code: "+262",
    prefix: null,
    iso: "YT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/yt.svg",
    mask: "_____-____"
  },
  {
    name: "Mexico",
    code: "+52",
    prefix: null,
    iso: "MX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mx.svg",
    mask: "(___)___-____"
  },
  {
    name: "Micronesia, Federated States of Micronesia",
    code: "+691",
    prefix: null,
    iso: "FM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fm.svg",
    mask: "___-____"
  },
  {
    name: "Moldova",
    code: "+373",
    prefix: null,
    iso: "MD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/md.svg",
    mask: "____-____"
  },
  {
    name: "Monaco",
    code: "+377",
    prefix: null,
    iso: "MC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mc.svg",
    mask: "(___)___-___"
  },
  {
    name: "Mongolia",
    code: "+976",
    prefix: null,
    iso: "MN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mn.svg",
    mask: "__-__-____"
  },
  {
    name: "Montenegro",
    code: "+382",
    prefix: null,
    iso: "ME",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/me.svg",
    mask: "__-___-___"
  },
  {
    name: "Montserrat",
    code: "+1",
    prefix: "664",
    iso: "MS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ms.svg",
    mask: "(664)___-____"
  },
  {
    name: "Morocco",
    code: "+212",
    prefix: null,
    iso: "MA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ma.svg",
    mask: "__-____-___"
  },
  {
    name: "Mozambique",
    code: "+258",
    prefix: null,
    iso: "MZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mz.svg",
    mask: "__-___-___"
  },
  {
    name: "Myanmar",
    code: "+95",
    prefix: null,
    iso: "MM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mm.svg",
    mask: "__-___-___"
  },
  {
    name: "Namibia",
    code: "+264",
    prefix: null,
    iso: "NA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/na.svg",
    mask: "__-___-____"
  },
  {
    name: "Nauru",
    code: "+674",
    prefix: null,
    iso: "NR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nr.svg",
    mask: "___-____"
  },
  {
    name: "Nepal",
    code: "+977",
    prefix: null,
    iso: "NP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/np.svg",
    mask: "__-___-___"
  },
  {
    name: "Netherlands",
    code: "+31",
    prefix: null,
    iso: "NL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nl.svg",
    mask: "__-___-____"
  },
  {
    name: "New Caledonia",
    code: "+687",
    prefix: null,
    iso: "NC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nc.svg",
    mask: "__-____"
  },
  {
    name: "New Zealand",
    code: "+64",
    prefix: null,
    iso: "NZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nz.svg",
    mask: "(___)___-____"
  },
  {
    name: "Nicaragua",
    code: "+505",
    prefix: null,
    iso: "NI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ni.svg",
    mask: "____-____"
  },
  {
    name: "Niger",
    code: "+227",
    prefix: null,
    iso: "NE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ne.svg",
    mask: "__-__-____"
  },
  {
    name: "Nigeria",
    code: "+234",
    prefix: null,
    iso: "NG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ng.svg",
    mask: "(___)___-____"
  },
  {
    name: "Niue",
    code: "+683",
    prefix: null,
    iso: "NU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nu.svg",
    mask: "____"
  },
  {
    name: "Norfolk Island",
    code: "+672",
    prefix: "3",
    iso: "NF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nf.svg",
    mask: "3__-___"
  },
  {
    name: "North Macedonia",
    code: "+389",
    prefix: null,
    iso: "MK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mk.svg",
    mask: "__-___-___"
  },
  {
    name: "Northern Mariana Islands",
    code: "+1",
    prefix: "670",
    iso: "MP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mp.svg",
    mask: "(670)___-____"
  },
  {
    name: "Norway",
    code: "+47",
    prefix: null,
    iso: "NO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/no.svg",
    mask: "(___)__-___"
  },
  {
    name: "Oman",
    code: "+968",
    prefix: null,
    iso: "OM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/om.svg",
    mask: "__-___-___"
  },
  {
    name: "Pakistan",
    code: "+92",
    prefix: null,
    iso: "PK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pk.svg",
    mask: "(___)___-____"
  },
  {
    name: "Palau",
    code: "+680",
    prefix: null,
    iso: "PW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pw.svg",
    mask: "___-____"
  },
  {
    name: "Palestine",
    code: "+970",
    prefix: null,
    iso: "PS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ps.svg",
    mask: "__-___-____"
  },
  {
    name: "Panama",
    code: "+507",
    prefix: null,
    iso: "PA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pa.svg",
    mask: "___-____"
  },
  {
    name: "Papua New Guinea",
    code: "+675",
    prefix: null,
    iso: "PG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pg.svg",
    mask: "(___)__-___"
  },
  {
    name: "Paraguay",
    code: "+595",
    prefix: null,
    iso: "PY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/py.svg",
    mask: "(___)___-___"
  },
  {
    name: "Peru",
    code: "+51",
    prefix: null,
    iso: "PE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pe.svg",
    mask: "(___)___-___"
  },
  {
    name: "Philippines",
    code: "+63",
    prefix: null,
    iso: "PH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ph.svg",
    mask: "(___)___-____"
  },
  {
    name: "Pitcairn",
    code: "+870",
    prefix: null,
    iso: "PN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pn.svg",
    mask: "___-___-___"
  },
  {
    name: "Poland",
    code: "+48",
    prefix: null,
    iso: "PL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pl.svg",
    mask: "(___)___-___"
  },
  {
    name: "Portugal",
    code: "+351",
    prefix: null,
    iso: "PT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pt.svg",
    mask: "__-___-____"
  },
  {
    name: "Puerto Rico",
    code: "+1",
    prefix: null,
    iso: "PR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pr.svg",
    mask: "(___) ___ ____"
  },
  {
    name: "Qatar",
    code: "+974",
    prefix: null,
    iso: "QA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/qa.svg",
    mask: "____-____"
  },
  {
    name: "Reunion",
    code: "+262",
    prefix: null,
    iso: "RE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/re.svg",
    mask: "_____-____"
  },
  {
    name: "Romania",
    code: "+40",
    prefix: null,
    iso: "RO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ro.svg",
    mask: "__-___-____"
  },
  {
    name: "Russia",
    code: "+7",
    prefix: null,
    iso: "RU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ru.svg",
    mask: "(___)___-__-__"
  },
  {
    name: "Rwanda",
    code: "+250",
    prefix: null,
    iso: "RW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/rw.svg",
    mask: "(___)___-___"
  },
  {
    name: "Saint Barthelemy",
    code: "+590",
    prefix: null,
    iso: "BL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bl.svg",
    mask: "___-__-__-__"
  },
  {
    name: "Saint Helena, Ascension and Tristan Da Cunha",
    code: "+290",
    prefix: null,
    iso: "SH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sh.svg",
    mask: "____"
  },
  {
    name: "Saint Kitts and Nevis",
    code: "+1",
    prefix: null,
    iso: "KN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kn.svg",
    mask: "(869)___-____"
  },
  {
    name: "Saint Lucia",
    code: "+1",
    prefix: "758",
    iso: "LC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lc.svg",
    mask: "(758)___-____"
  },
  {
    name: "Saint Martin",
    code: "+590",
    prefix: null,
    iso: "MF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mf.svg",
    mask: "(___)___-___"
  },
  {
    name: "Saint Pierre and Miquelon",
    code: "+508",
    prefix: null,
    iso: "PM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pm.svg",
    mask: "__-____"
  },
  {
    name: "Saint Vincent and the Grenadines",
    code: "+1",
    prefix: "784",
    iso: "VC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vc.svg",
    mask: "(784)___-____"
  },
  {
    name: "Samoa",
    code: "+685",
    prefix: null,
    iso: "WS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ws.svg",
    mask: "__-____"
  },
  {
    name: "San Marino",
    code: "+378",
    prefix: null,
    iso: "SM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sm.svg",
    mask: "____-______"
  },
  {
    name: "Sao Tome and Principe",
    code: "+239",
    prefix: null,
    iso: "ST",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/st.svg",
    mask: "__-_____"
  },
  {
    name: "Saudi Arabia",
    code: "+966",
    prefix: null,
    iso: "SA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sa.svg",
    mask: "_-____-____"
  },
  {
    name: "Senegal",
    code: "+221",
    prefix: null,
    iso: "SN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sn.svg",
    mask: "__-___-____"
  },
  {
    name: "Serbia",
    code: "+381",
    prefix: null,
    iso: "RS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/rs.svg",
    mask: "__-___-____"
  },
  {
    name: "Seychelles",
    code: "+248",
    prefix: null,
    iso: "SC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sc.svg",
    mask: "_-___-___"
  },
  {
    name: "Sierra Leone",
    code: "+232",
    prefix: null,
    iso: "SL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sl.svg",
    mask: "__-______"
  },
  {
    name: "Singapore",
    code: "+65",
    prefix: null,
    iso: "SG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sg.svg",
    mask: "____-____"
  },
  {
    name: "Sint Maarten",
    code: "+1",
    prefix: "721",
    iso: "SX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sx.svg",
    mask: "(721)___-____"
  },
  {
    name: "Slovakia",
    code: "+421",
    prefix: null,
    iso: "SK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sk.svg",
    mask: "(___)___-___"
  },
  {
    name: "Slovenia",
    code: "+386",
    prefix: null,
    iso: "SI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/si.svg",
    mask: "__-___-___"
  },
  {
    name: "Solomon Islands",
    code: "+677",
    prefix: null,
    iso: "SB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sb.svg",
    mask: "___-____"
  },
  {
    name: "Somalia",
    code: "+252",
    prefix: null,
    iso: "SO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/so.svg",
    mask: "__-___-___"
  },
  {
    name: "South Africa",
    code: "+27",
    prefix: null,
    iso: "ZA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/za.svg",
    mask: "__-___-____"
  },
  {
    name: "South Georgia and the South Sandwich Islands",
    code: "+500",
    prefix: null,
    iso: "GS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gs.svg",
    mask: "_____"
  },
  {
    name: "South Sudan",
    code: "+211",
    prefix: null,
    iso: "SS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ss.svg",
    mask: "__-___-____"
  },
  {
    name: "Spain",
    code: "+34",
    prefix: null,
    iso: "ES",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/es.svg",
    mask: "(___)___-___"
  },
  {
    name: "Sri Lanka",
    code: "+94",
    prefix: null,
    iso: "LK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lk.svg",
    mask: "__-___-____"
  },
  {
    name: "Sudan",
    code: "+249",
    prefix: null,
    iso: "SD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sd.svg",
    mask: "__-___-____"
  },
  {
    name: "Suriname",
    code: "+597",
    prefix: null,
    iso: "SR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sr.svg",
    mask: "___-____"
  },
  {
    name: "Svalbard and Jan Mayen",
    code: "+47",
    prefix: null,
    iso: "SJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sj.svg",
    mask: "(___)__-___"
  },
  {
    name: "Sweden",
    code: "+46",
    prefix: null,
    iso: "SE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/se.svg",
    mask: "__-___-____"
  },
  {
    name: "Switzerland",
    code: "+41",
    prefix: null,
    iso: "CH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ch.svg",
    mask: "__-___-____"
  },
  {
    name: "Syrian Arab Republic",
    code: "+963",
    prefix: null,
    iso: "SY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sy.svg",
    mask: "__-____-___"
  },
  {
    name: "Taiwan",
    code: "+886",
    prefix: null,
    iso: "TW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tw.svg",
    mask: "_-____-____"
  },
  {
    name: "Tajikistan",
    code: "+992",
    prefix: null,
    iso: "TJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tj.svg",
    mask: "__-___-____"
  },
  {
    name: "United Republic of Tanzania",
    code: "+255",
    prefix: null,
    iso: "TZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tz.svg",
    mask: "__-___-____"
  },
  {
    name: "Thailand",
    code: "+66",
    prefix: null,
    iso: "TH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/th.svg",
    mask: "__-___-____"
  },
  {
    name: "Timor-Leste",
    code: "+670",
    prefix: null,
    iso: "TL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tl.svg",
    mask: "___-_____"
  },
  {
    name: "Togo",
    code: "+228",
    prefix: null,
    iso: "TG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tg.svg",
    mask: "__-___-___"
  },
  {
    name: "Tokelau",
    code: "+690",
    prefix: null,
    iso: "TK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tk.svg",
    mask: "____"
  },
  {
    name: "Tonga",
    code: "+676",
    prefix: null,
    iso: "TO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/to.svg",
    mask: "_____"
  },
  {
    name: "Trinidad and Tobago",
    code: "+1",
    prefix: "868",
    iso: "TT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tt.svg",
    mask: "(868)___-____"
  },
  {
    name: "Tunisia",
    code: "+216",
    prefix: null,
    iso: "TN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tn.svg",
    mask: "__-___-___"
  },
  {
    name: "Turkey",
    code: "+90",
    prefix: null,
    iso: "TR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tr.svg",
    mask: "(___)___-____"
  },
  {
    name: "Turkmenistan",
    code: "+993",
    prefix: null,
    iso: "TM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tm.svg",
    mask: "_-___-____"
  },
  {
    name: "Turks and Caicos Islands",
    code: "+1",
    prefix: "249",
    iso: "TC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tc.svg",
    mask: "(249)___-___"
  },
  {
    name: "Tuvalu",
    code: "+688",
    prefix: null,
    iso: "TV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tv.svg",
    mask: "______"
  },
  {
    name: "Uganda",
    code: "+256",
    prefix: null,
    iso: "UG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ug.svg",
    mask: "(___)___-___"
  },
  {
    name: "Ukraine",
    code: "+380",
    prefix: null,
    iso: "UA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ua.svg",
    mask: "(__)___-__-__"
  },
  {
    name: "United Arab Emirates",
    code: "+971",
    prefix: null,
    iso: "AE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ae.svg",
    mask: "_-___-____"
  },
  {
    name: "United Kingdom",
    code: "+44",
    prefix: null,
    iso: "GB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gb.svg",
    mask: "__-____-____"
  },
  {
    name: "United States",
    code: "+1",
    prefix: "408",
    iso: "US",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/us.svg",
    mask: "(408)___-____"
  },
  {
    name: "Uruguay",
    code: "+598",
    prefix: null,
    iso: "UY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/uy.svg",
    mask: "_-___-__-__"
  },
  {
    name: "Uzbekistan",
    code: "+998",
    prefix: null,
    iso: "UZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/uz.svg",
    mask: "__-___-____"
  },
  {
    name: "Vanuatu",
    code: "+678",
    prefix: null,
    iso: "VU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vu.svg",
    mask: "__-_____"
  },
  {
    name: "Venezuela, Bolivarian Republic of Venezuela",
    code: "+58",
    prefix: null,
    iso: "VE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ve.svg",
    mask: "(___)___-____"
  },
  {
    name: "Vietnam",
    code: "+84",
    prefix: null,
    iso: "VN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vn.svg",
    mask: "(___)____-___"
  },
  {
    name: "Virgin Islands, British",
    code: "+1",
    prefix: "284",
    iso: "VG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vg.svg",
    mask: "(284)___-____"
  },
  {
    name: "Virgin Islands, U.S.",
    code: "+1",
    prefix: "340",
    iso: "VI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vi.svg",
    mask: "(340)___-____"
  },
  {
    name: "Wallis and Futuna",
    code: "+681",
    prefix: null,
    iso: "WF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/wf.svg",
    mask: "__-____"
  },
  {
    name: "Yemen",
    code: "+967",
    prefix: null,
    iso: "YE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ye.svg",
    mask: "___-___-___"
  },
  {
    name: "Zambia",
    code: "+260",
    prefix: null,
    iso: "ZM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/zm.svg",
    mask: "__-___-____"
  },
  {
    name: "Zimbabwe",
    code: "+263",
    prefix: null,
    iso: "ZW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/zw.svg",
    mask: "_-______"
  }
];
function Wpt(e) {
  const {
    children: t,
    onFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s = "",
    readOnly: l,
    variant: u,
    size: c,
    id: p
  } = e, y = `arkynPhoneInputContainer ${u} ${c} ${r || l || i ? "opacity" : ""} ${o ? "errored" : ""} ${a ? "focused" : ""} ${s}`;
  return /* @__PURE__ */ ne.jsx("section", { id: p, className: y.trim(), onClick: n, children: t });
}
function Vpt(e) {
  const { isOpen: t, onClick: n } = e;
  return t ? /* @__PURE__ */ ne.jsx("aside", { className: "arkynPhoneInputCountriesOverlay", onClick: n }) : /* @__PURE__ */ ne.jsx(ne.Fragment, {});
}
function $pt(e) {
  const { country: t, isActive: n, handleChangeValue: r, size: o } = e, a = `arkynPhoneInputCountryOption ${o} ${n ? "active" : ""}`;
  return /* @__PURE__ */ ne.jsxs("div", { onClick: () => r(t), className: a, children: [
    /* @__PURE__ */ ne.jsx("img", { src: t.flag, alt: t.name, className: "flag" }),
    t.name,
    " ",
    /* @__PURE__ */ ne.jsx("span", { children: t.code }),
    /* @__PURE__ */ ne.jsx(Ex, { className: "check" })
  ] });
}
function Zpt(e) {
  const { children: t, isOpen: n, onSearch: r, search: o, placeholder: i } = e;
  function a(s) {
    r(s.target.value);
  }
  return n ? /* @__PURE__ */ ne.jsxs("div", { className: "arkynPhoneInputCountryOptionsContainer", children: [
    /* @__PURE__ */ ne.jsx(
      "input",
      {
        type: "search",
        name: "search-select",
        className: "arkynPhoneInputCountryOptionsContainerSearchSelect",
        value: o,
        id: "input-search",
        placeholder: i,
        onChange: a
      }
    ),
    t
  ] }) : /* @__PURE__ */ ne.jsx(ne.Fragment, {});
}
function qpt(e) {
  const { currentCountry: t, onClick: n } = e;
  return /* @__PURE__ */ ne.jsxs("div", { className: "phoneInputSelectCountry", onClick: n, children: [
    /* @__PURE__ */ ne.jsx(
      "img",
      {
        className: "flag",
        src: t.flag,
        alt: t.name
      }
    ),
    /* @__PURE__ */ ne.jsx(bT, { className: "chevronDown", strokeWidth: 2.5 }),
    /* @__PURE__ */ ne.jsx(Vte, { orientation: "vertical" })
  ] });
}
function mR(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const vR = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function pfe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function dfe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const ffe = mR(vR.NINE).length, Gpt = yr((e, t) => /* @__PURE__ */ ne.jsx("input", { ref: t, ...e })), Kpt = yr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = mR(g.target.value);
      const y = dfe(f);
      f.length > ffe || (f = pfe(f, vR[y]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ ne.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ ne.jsx(
      tl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: Gpt,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
function CJ(e, t) {
  if (t.code === "+55") {
    let o = mR(e);
    const i = dfe(o);
    return o.length > ffe ? void 0 : (o = pfe(o, vR[i]), o);
  }
  let r = t.mask;
  if (t.prefix) {
    const o = /\$+/g;
    r = r.replace(o, t.prefix);
  }
  for (let o = 0, i = 0; o < r.length && i < e.length; o++)
    r[o] === "_" && (r = r.substring(0, o) + e[i] + r.substring(o + 1), i++);
  return r;
}
function Ypt(e, t) {
  const n = gd.find(
    (r) => r.code === e && r.prefix === t
  );
  return n || null;
}
function Xpt(e) {
  const t = gd.find((n) => n.code === e);
  return t || null;
}
function Jpt(e) {
  const t = e.split(" ")[0].split("-")[0], n = e.split(" ")[0].split("-")[1], r = e.split(" ")[1];
  if (!t || !r)
    return { country: null, formattedNumber: "" };
  if (n) {
    const s = Ypt(t, n);
    if (!s) return { country: null, formattedNumber: "" };
    const l = CJ(r, s);
    return { country: s, formattedNumber: l };
  }
  const o = Xpt(t);
  if (!o) return { country: null, formattedNumber: "" };
  const i = CJ(r, o);
  return { country: o, formattedNumber: i };
}
function Wwt(e) {
  const {
    defaultCountry: t,
    className: n = "",
    disabled: r = !1,
    isError: o = !1,
    isLoading: i = !1,
    readOnly: a = !1,
    size: s = "md",
    defaultValue: l = "",
    variant: u = "solid",
    name: c,
    onChange: p,
    searchCountryPlaceholder: d = "Pesquisar país",
    notFoundCountryText: g = "Nenhum país encontrado",
    ...f
  } = e, y = Jpt(l), [b, E] = k(!1), [w, M] = k(""), [O, v] = k(!1), [x, _] = k(y.formattedNumber || ""), [z, L] = k(() => {
    if (y.country) return y.country;
    const S = gd.find((W) => W.iso === t);
    return S || gd[30];
  }), { id: N, inputRef: R, error: V } = fs(), Z = o || !!V, H = ht(null);
  function $() {
    b || O || (E(!0), H.current && H.current.focus());
  }
  function K() {
    v(!0), E(!0);
  }
  function X() {
    v(!1), E(!1);
  }
  function Q() {
    E(!0);
  }
  function J() {
    E(!1);
  }
  function P(S) {
    return S.name.toLowerCase().includes(w.toLowerCase());
  }
  function D(S) {
    return z.prefix ? S.replace(z.prefix, "").replaceAll(" ", "").replaceAll("-", "").replaceAll("(", "").replaceAll(")", "").trim() : S.replaceAll(" ", "").replaceAll("-", "").replaceAll("(", "").replaceAll(")", "").trim();
  }
  function F(S) {
    let W = z.code;
    return z.prefix && (W += `-${z.prefix}`), W += " ", W += D(S || x), W;
  }
  return /* @__PURE__ */ ne.jsxs(
    Wpt,
    {
      id: N,
      disabled: r,
      isError: Z,
      isLoading: i,
      isFocused: b,
      readOnly: a,
      size: s,
      variant: u,
      className: n,
      onFocus: $,
      children: [
        /* @__PURE__ */ ne.jsx(
          qpt,
          {
            currentCountry: z,
            onClick: K,
            size: s
          }
        ),
        /* @__PURE__ */ ne.jsxs(
          Zpt,
          {
            isOpen: O,
            search: w,
            placeholder: d,
            onSearch: M,
            children: [
              gd.filter((S) => P(S)).map((S) => /* @__PURE__ */ ne.jsx(
                $pt,
                {
                  country: S,
                  handleChangeValue: () => {
                    L(S), v(!1), _(S.mask);
                  },
                  isActive: S.iso === z.iso,
                  size: s
                },
                S.iso
              )),
              gd.filter((S) => P(S)).length === 0 && /* @__PURE__ */ ne.jsx("p", { children: g })
            ]
          }
        ),
        /* @__PURE__ */ ne.jsx(
          Vpt,
          {
            isOpen: O,
            onClick: X
          }
        ),
        /* @__PURE__ */ ne.jsx(
          Kpt,
          {
            ref: H,
            currentCountry: z,
            value: x,
            onChange: (S) => {
              _(S), p && p(F(S));
            },
            disabled: r,
            onBlur: J,
            onFocus: Q,
            size: s
          }
        ),
        /* @__PURE__ */ ne.jsx("input", { ref: R, type: "hidden", name: c, value: F() })
      ]
    }
  );
}
const hfe = We({});
function Qpt() {
  return ge(hfe);
}
function Vwt(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: a = "",
    ...s
  } = e, [l, u] = k(t || ""), { inputRef: c, id: p } = fs();
  function d(f) {
    u(f), o && o(f);
  }
  const g = `arkynRadioGroup ${i} ${a}`;
  return /* @__PURE__ */ ne.jsxs(
    hfe.Provider,
    {
      value: { onChange: d, value: r || l, size: i },
      children: [
        /* @__PURE__ */ ne.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: p,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ ne.jsx("div", { className: g.trim(), ...s })
      ]
    }
  );
}
function $wt(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...a
  } = e, { onChange: s, size: l, value: u } = Qpt(), { error: c } = fs(), y = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ ne.jsxs("label", { className: y.trim(), children: [
    /* @__PURE__ */ ne.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => s(t),
        onFocus: () => s(t),
        ...a
      }
    ),
    o
  ] });
}
var ou = {};
Object.defineProperty(ou, "__esModule", {
  value: !0
});
var edt = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), I_ = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, gfe = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: edt ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, yR = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var sw = 1; sw < 20; sw++)
  yR["f" + sw] = 111 + sw;
function Bk(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return mfe(a, t);
  }), o = function(s) {
    return r.some(function(l) {
      return vfe(l, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function tdt(e, t) {
  return Bk(e, t);
}
function ndt(e, t) {
  return Bk(e, { byKey: !0 }, t);
}
function mfe(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in I_)
    r[I_[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = bR(d), y = I_[f];
      if (d.length > 1 && !y && !gfe[d] && !yR[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !y) && (n ? r.key = f : r.which = yfe(d)), y && (r[y] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function vfe(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function yfe(e) {
  e = bR(e);
  var t = yR[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function bR(e) {
  return e = e.toLowerCase(), e = gfe[e] || e, e;
}
var rdt = ou.default = Bk, B_ = ou.isHotkey = Bk;
ou.isCodeHotkey = tdt;
ou.isKeyHotkey = ndt;
ou.parseHotkey = mfe;
ou.compareHotkey = vfe;
ou.toKeyCode = yfe;
ou.toKeyName = bR;
var odt = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return Si(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || Qu.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || Qu.isOperationList(e.undos[0].operations));
  }
}, R_ = /* @__PURE__ */ new WeakMap(), nh = /* @__PURE__ */ new WeakMap(), Op = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return odt.isHistory(e.history) && re.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return nh.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return R_.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = Op.isMerging(e);
    nh.set(e, !0), t(), nh.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = Op.isMerging(e);
    nh.set(e, !1), t(), nh.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = Op.isSaving(e);
    R_.set(e, !1), t(), R_.set(e, n);
  }
}, idt = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && $e.setSelection(t, i.selectionBefore), Op.withoutSaving(t, () => {
        re.withoutNormalizing(t, () => {
          for (var a of i.operations)
            t.apply(a);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      Op.withoutSaving(t, () => {
        re.withoutNormalizing(t, () => {
          var a = i.operations.map(Qu.inverse).reverse();
          for (var s of a)
            t.apply(s);
          i.selectionBefore && $e.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: a
    } = i, s = a[a.length - 1], l = s && s.operations[s.operations.length - 1], u = Op.isSaving(t), c = Op.isMerging(t);
    if (u == null && (u = adt(r)), u) {
      if (c == null && (s == null ? c = !1 : o.length !== 0 ? c = !0 : c = sdt(r, l)), s && c)
        s.operations.push(r);
      else {
        var p = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", p);
      }
      for (; a.length > 100; )
        a.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, sdt = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && ce.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && ce.equals(e.path, t.path)), adt = (e, t) => e.type !== "set_selection", ldt = pdt, bfe = "֑-߿יִ-﷽ﹰ-ﻼ", wfe = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", udt = new RegExp("^[^" + wfe + "]*[" + bfe + "]"), cdt = new RegExp("^[^" + bfe + "]*[" + wfe + "]");
function pdt(e) {
  return e = String(e || ""), udt.test(e) ? "rtl" : cdt.test(e) ? "ltr" : "neutral";
}
const Cfe = /* @__PURE__ */ kx(ldt);
function ddt(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var wR = ddt, fdt = typeof Pr == "object" && Pr && Pr.Object === Object && Pr, hdt = fdt, gdt = hdt, mdt = typeof self == "object" && self && self.Object === Object && self, vdt = gdt || mdt || Function("return this")(), xfe = vdt, ydt = xfe, bdt = function() {
  return ydt.Date.now();
}, wdt = bdt, Cdt = /\s/;
function xdt(e) {
  for (var t = e.length; t-- && Cdt.test(e.charAt(t)); )
    ;
  return t;
}
var Odt = xdt, Edt = Odt, kdt = /^\s+/;
function Ldt(e) {
  return e && e.slice(0, Edt(e) + 1).replace(kdt, "");
}
var Pdt = Ldt, _dt = xfe, Sdt = _dt.Symbol, Ofe = Sdt, xJ = Ofe, Efe = Object.prototype, Mdt = Efe.hasOwnProperty, Ddt = Efe.toString, rh = xJ ? xJ.toStringTag : void 0;
function Tdt(e) {
  var t = Mdt.call(e, rh), n = e[rh];
  try {
    e[rh] = void 0;
    var r = !0;
  } catch {
  }
  var o = Ddt.call(e);
  return r && (t ? e[rh] = n : delete e[rh]), o;
}
var jdt = Tdt, Adt = Object.prototype, Idt = Adt.toString;
function Bdt(e) {
  return Idt.call(e);
}
var Rdt = Bdt, OJ = Ofe, Ndt = jdt, Fdt = Rdt, zdt = "[object Null]", Udt = "[object Undefined]", EJ = OJ ? OJ.toStringTag : void 0;
function Hdt(e) {
  return e == null ? e === void 0 ? Udt : zdt : EJ && EJ in Object(e) ? Ndt(e) : Fdt(e);
}
var Wdt = Hdt;
function Vdt(e) {
  return e != null && typeof e == "object";
}
var $dt = Vdt, Zdt = Wdt, qdt = $dt, Gdt = "[object Symbol]";
function Kdt(e) {
  return typeof e == "symbol" || qdt(e) && Zdt(e) == Gdt;
}
var Ydt = Kdt, Xdt = Pdt, kJ = wR, Jdt = Ydt, LJ = NaN, Qdt = /^[-+]0x[0-9a-f]+$/i, eft = /^0b[01]+$/i, tft = /^0o[0-7]+$/i, nft = parseInt;
function rft(e) {
  if (typeof e == "number")
    return e;
  if (Jdt(e))
    return LJ;
  if (kJ(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = kJ(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = Xdt(e);
  var n = eft.test(e);
  return n || tft.test(e) ? nft(e.slice(2), n ? 2 : 8) : Qdt.test(e) ? LJ : +e;
}
var oft = rft, ift = wR, N_ = wdt, PJ = oft, sft = "Expected a function", aft = Math.max, lft = Math.min;
function uft(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(sft);
  t = PJ(t) || 0, ift(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? aft(PJ(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(x) {
    var _ = r, z = o;
    return r = o = void 0, u = x, a = e.apply(z, _), a;
  }
  function f(x) {
    return u = x, s = setTimeout(E, t), c ? g(x) : a;
  }
  function y(x) {
    var _ = x - l, z = x - u, L = t - _;
    return p ? lft(L, i - z) : L;
  }
  function b(x) {
    var _ = x - l, z = x - u;
    return l === void 0 || _ >= t || _ < 0 || p && z >= i;
  }
  function E() {
    var x = N_();
    if (b(x))
      return w(x);
    s = setTimeout(E, y(x));
  }
  function w(x) {
    return s = void 0, d && r ? g(x) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(N_());
  }
  function v() {
    var x = N_(), _ = b(x);
    if (r = arguments, o = this, l = x, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return clearTimeout(s), s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = O, v;
}
var kfe = uft;
const cft = /* @__PURE__ */ kx(kfe);
var pft = kfe, dft = wR, fft = "Expected a function";
function hft(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(fft);
  return dft(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), pft(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var gft = hft;
const mft = /* @__PURE__ */ kx(gft), _J = (e) => typeof e == "object" && e != null && e.nodeType === 1, SJ = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", aw = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return SJ(n.overflowY, t) || SJ(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, lw = (e, t, n, r, o, i, a, s) => i < e && a > t || i > e && a < t ? 0 : i <= e && s <= n || a >= t && s >= n ? i - e - r : a > t && s < n || i < e && s > n ? a - t + o : 0, vft = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, MJ = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: a, block: s, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, p = typeof u == "function" ? u : (K) => K !== u;
  if (!_J(e)) throw new TypeError("Invalid target");
  const d = document.scrollingElement || document.documentElement, g = [];
  let f = e;
  for (; _J(f) && p(f); ) {
    if (f = vft(f), f === d) {
      g.push(f);
      break;
    }
    f != null && f === document.body && aw(f) && !aw(document.documentElement) || f != null && aw(f, c) && g.push(f);
  }
  const y = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, b = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: E, scrollY: w } = window, { height: M, width: O, top: v, right: x, bottom: _, left: z } = e.getBoundingClientRect(), { top: L, right: N, bottom: R, left: V } = ((K) => {
    const X = window.getComputedStyle(K);
    return { top: parseFloat(X.scrollMarginTop) || 0, right: parseFloat(X.scrollMarginRight) || 0, bottom: parseFloat(X.scrollMarginBottom) || 0, left: parseFloat(X.scrollMarginLeft) || 0 };
  })(e);
  let Z = s === "start" || s === "nearest" ? v - L : s === "end" ? _ + R : v + M / 2 - L + R, H = l === "center" ? z + O / 2 - V + N : l === "end" ? x + N : z - V;
  const $ = [];
  for (let K = 0; K < g.length; K++) {
    const X = g[K], { height: Q, width: J, top: P, right: D, bottom: F, left: S } = X.getBoundingClientRect();
    if (a === "if-needed" && v >= 0 && z >= 0 && _ <= b && x <= y && (X === d && !aw(X) || v >= P && _ <= F && z >= S && x <= D)) return $;
    const W = getComputedStyle(X), C = parseInt(W.borderLeftWidth, 10), I = parseInt(W.borderTopWidth, 10), U = parseInt(W.borderRightWidth, 10), T = parseInt(W.borderBottomWidth, 10);
    let q = 0, j = 0;
    const Y = "offsetWidth" in X ? X.offsetWidth - X.clientWidth - C - U : 0, B = "offsetHeight" in X ? X.offsetHeight - X.clientHeight - I - T : 0, le = "offsetWidth" in X ? X.offsetWidth === 0 ? 0 : J / X.offsetWidth : 0, he = "offsetHeight" in X ? X.offsetHeight === 0 ? 0 : Q / X.offsetHeight : 0;
    if (d === X) q = s === "start" ? Z : s === "end" ? Z - b : s === "nearest" ? lw(w, w + b, b, I, T, w + Z, w + Z + M, M) : Z - b / 2, j = l === "start" ? H : l === "center" ? H - y / 2 : l === "end" ? H - y : lw(E, E + y, y, C, U, E + H, E + H + O, O), q = Math.max(0, q + w), j = Math.max(0, j + E);
    else {
      q = s === "start" ? Z - P - I : s === "end" ? Z - F + T + B : s === "nearest" ? lw(P, F, Q, I, T + B, Z, Z + M, M) : Z - (P + Q / 2) + B / 2, j = l === "start" ? H - S - C : l === "center" ? H - (S + J / 2) + Y / 2 : l === "end" ? H - D + U + Y : lw(S, D, J, C, U + Y, H, H + O, O);
      const { scrollLeft: oe, scrollTop: Pe } = X;
      q = he === 0 ? 0 : Math.max(0, Math.min(Pe + q / he, X.scrollHeight - Q / he + B)), j = le === 0 ? 0 : Math.max(0, Math.min(oe + j / le, X.scrollWidth - J / le + Y)), Z += Pe - q, H += oe - j;
    }
    $.push({ el: X, top: q, left: j });
  }
  return $;
}, yft = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function bft(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(MJ(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: a } of MJ(e, yft(t))) {
    const s = i - n.top + n.bottom, l = a - n.left + n.right;
    o.scroll({ top: s, left: l, behavior: r });
  }
}
var Pp = [], wft = function() {
  return Pp.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Cft = function() {
  return Pp.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, DJ = "ResizeObserver loop completed with undelivered notifications.", xft = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: DJ
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = DJ), window.dispatchEvent(e);
}, ym;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(ym || (ym = {}));
var _p = function(e) {
  return Object.freeze(e);
}, Oft = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, _p(this);
  }
  return e;
}(), Lfe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, _p(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), CR = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, Pfe = function(e) {
  if (CR(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, a = o.offsetHeight;
  return !(i || a || e.getClientRects().length);
}, TJ = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, Eft = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, ig = typeof window < "u" ? window : {}, uw = /* @__PURE__ */ new WeakMap(), jJ = /auto|scroll/, kft = /^tb|vertical/, Lft = /msie|trident/i.test(ig.navigator && ig.navigator.userAgent), Ia = function(e) {
  return parseFloat(e || "0");
}, kd = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Oft((n ? t : e) || 0, (n ? e : t) || 0);
}, AJ = _p({
  devicePixelContentBoxSize: kd(),
  borderBoxSize: kd(),
  contentBoxSize: kd(),
  contentRect: new Lfe(0, 0, 0, 0)
}), _fe = function(e, t) {
  if (t === void 0 && (t = !1), uw.has(e) && !t)
    return uw.get(e);
  if (Pfe(e))
    return uw.set(e, AJ), AJ;
  var n = getComputedStyle(e), r = CR(e) && e.ownerSVGElement && e.getBBox(), o = !Lft && n.boxSizing === "border-box", i = kft.test(n.writingMode || ""), a = !r && jJ.test(n.overflowY || ""), s = !r && jJ.test(n.overflowX || ""), l = r ? 0 : Ia(n.paddingTop), u = r ? 0 : Ia(n.paddingRight), c = r ? 0 : Ia(n.paddingBottom), p = r ? 0 : Ia(n.paddingLeft), d = r ? 0 : Ia(n.borderTopWidth), g = r ? 0 : Ia(n.borderRightWidth), f = r ? 0 : Ia(n.borderBottomWidth), y = r ? 0 : Ia(n.borderLeftWidth), b = p + u, E = l + c, w = y + g, M = d + f, O = s ? e.offsetHeight - M - e.clientHeight : 0, v = a ? e.offsetWidth - w - e.clientWidth : 0, x = o ? b + w : 0, _ = o ? E + M : 0, z = r ? r.width : Ia(n.width) - x - v, L = r ? r.height : Ia(n.height) - _ - O, N = z + b + v + w, R = L + E + O + M, V = _p({
    devicePixelContentBoxSize: kd(Math.round(z * devicePixelRatio), Math.round(L * devicePixelRatio), i),
    borderBoxSize: kd(N, R, i),
    contentBoxSize: kd(z, L, i),
    contentRect: new Lfe(p, l, z, L)
  });
  return uw.set(e, V), V;
}, Sfe = function(e, t, n) {
  var r = _fe(e, n), o = r.borderBoxSize, i = r.contentBoxSize, a = r.devicePixelContentBoxSize;
  switch (t) {
    case ym.DEVICE_PIXEL_CONTENT_BOX:
      return a;
    case ym.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, Pft = /* @__PURE__ */ function() {
  function e(t) {
    var n = _fe(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = _p([n.borderBoxSize]), this.contentBoxSize = _p([n.contentBoxSize]), this.devicePixelContentBoxSize = _p([n.devicePixelContentBoxSize]);
  }
  return e;
}(), Mfe = function(e) {
  if (Pfe(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, _ft = function() {
  var e = 1 / 0, t = [];
  Pp.forEach(function(a) {
    if (a.activeTargets.length !== 0) {
      var s = [];
      a.activeTargets.forEach(function(u) {
        var c = new Pft(u.target), p = Mfe(u.target);
        s.push(c), u.lastReportedSize = Sfe(u.target, u.observedBox), p < e && (e = p);
      }), t.push(function() {
        a.callback.call(a.observer, s, a.observer);
      }), a.activeTargets.splice(0, a.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, IJ = function(e) {
  Pp.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (Mfe(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, Sft = function() {
  var e = 0;
  for (IJ(e); wft(); )
    e = _ft(), IJ(e);
  return Cft() && xft(), e > 0;
}, F_, Dfe = [], Mft = function() {
  return Dfe.splice(0).forEach(function(e) {
    return e();
  });
}, Dft = function(e) {
  if (!F_) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return Mft();
    }).observe(n, r), F_ = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  Dfe.push(e), F_();
}, Tft = function(e) {
  Dft(function() {
    requestAnimationFrame(e);
  });
}, jw = 0, jft = function() {
  return !!jw;
}, Aft = 250, Ift = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, BJ = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], RJ = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, z_ = !1, Bft = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = Aft), !z_) {
      z_ = !0;
      var r = RJ(t);
      Tft(function() {
        var o = !1;
        try {
          o = Sft();
        } finally {
          if (z_ = !1, t = r - RJ(), !jft())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, Ift);
    };
    document.body ? n() : ig.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), BJ.forEach(function(n) {
      return ig.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), BJ.forEach(function(n) {
      return ig.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), tT = new Bft(), NJ = function(e) {
  !jw && e > 0 && tT.start(), jw += e, !jw && tT.stop();
}, Rft = function(e) {
  return !CR(e) && !Eft(e) && getComputedStyle(e).display === "inline";
}, Nft = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || ym.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = Sfe(this.target, this.observedBox, !0);
    return Rft(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), Fft = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), cw = /* @__PURE__ */ new WeakMap(), FJ = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, pw = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new Fft(t, n);
    cw.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = cw.get(t), i = o.observationTargets.length === 0;
    FJ(o.observationTargets, n) < 0 && (i && Pp.push(o), o.observationTargets.push(new Nft(n, r && r.box)), NJ(1), tT.schedule());
  }, e.unobserve = function(t, n) {
    var r = cw.get(t), o = FJ(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && Pp.splice(Pp.indexOf(r), 1), r.observationTargets.splice(o, 1), NJ(-1));
  }, e.disconnect = function(t) {
    var n = this, r = cw.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), zft = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    pw.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!TJ(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    pw.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!TJ(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    pw.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    pw.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function Uft(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Rd(e, t) {
  if (e == null) return {};
  var n = Uft(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function bm(e) {
  "@babel/helpers - typeof";
  return bm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, bm(e);
}
function Hft(e, t) {
  if (bm(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (bm(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Wft(e) {
  var t = Hft(e, "string");
  return bm(t) === "symbol" ? t : String(t);
}
function Ea(e, t, n) {
  return t = Wft(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var xR = /* @__PURE__ */ We(null), Sc = () => {
  var e = ge(xR);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, U_, H_, Tfe = parseInt(we.version.split(".")[0], 10), jfe = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, zJ = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), ns = typeof navigator < "u" && /Android/.test(navigator.userAgent), md = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), ip = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), Vft = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), Afe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), $ft = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), Zft = ns && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), qft = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), Gft = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), Kft = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), Aw = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((U_ = navigator.userAgent.match(/Version\/(\d+)/)) !== null && U_ !== void 0 && U_[1] && parseInt((H_ = navigator.userAgent.match(/Version\/(\d+)/)) === null || H_ === void 0 ? void 0 : H_[1], 10) < 17);
var Cu = (!$ft || !Zft) && !Vft && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", Ld = /* @__PURE__ */ new WeakMap(), OR = /* @__PURE__ */ new WeakMap(), ER = /* @__PURE__ */ new WeakMap(), Ife = /* @__PURE__ */ new WeakMap(), Iw = /* @__PURE__ */ new WeakMap(), nT = /* @__PURE__ */ new WeakMap(), wm = /* @__PURE__ */ new WeakMap(), Sp = /* @__PURE__ */ new WeakMap(), dx = /* @__PURE__ */ new WeakMap(), Rk = /* @__PURE__ */ new WeakMap(), rT = /* @__PURE__ */ new WeakMap(), ec = /* @__PURE__ */ new WeakMap(), Ep = /* @__PURE__ */ new WeakMap(), sg = /* @__PURE__ */ new WeakMap(), oT = /* @__PURE__ */ new WeakMap(), kR = /* @__PURE__ */ new WeakMap(), ka = /* @__PURE__ */ new WeakMap(), Nl = /* @__PURE__ */ new WeakMap(), hs = /* @__PURE__ */ new WeakMap(), Uu = /* @__PURE__ */ new WeakMap(), Hu = /* @__PURE__ */ new WeakMap(), Bfe = /* @__PURE__ */ new WeakMap(), Nd = Symbol("placeholder"), Rfe = Symbol("mark-placeholder"), Nfe = globalThis.Node, Yft = globalThis.Text, LR = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Xft = (e) => nc(e) && e.nodeType === 8, Oa = (e) => nc(e) && e.nodeType === 1, nc = (e) => {
  var t = LR(e);
  return !!t && e instanceof t.Node;
}, iT = (e) => {
  var t = e && e.anchorNode && LR(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Ffe = (e) => nc(e) && e.nodeType === 3, Jft = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, Qft = (e) => {
  var [t, n] = e;
  if (Oa(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = zfe(t, o, r ? "backward" : "forward"), r = o < n; Oa(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = tht(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, eht = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, zfe = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (Xft(o) || Oa(o) && o.childNodes.length === 0 || Oa(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, tht = (e, t, n) => {
  var [r] = zfe(e, t, n);
  return r;
}, Ufe = (e) => {
  var t = "";
  if (Ffe(e) && e.nodeValue)
    return e.nodeValue;
  if (Oa(e)) {
    for (var n of Array.from(e.childNodes))
      t += Ufe(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, nht = /data-slate-fragment="(.+?)"/m, rht = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(nht) || [];
  return n;
}, ag = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), PR = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Oa(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Le.getWindow(e);
  if (o.contains(r))
    return Le.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : PR(e, i, n);
}, oht = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, UJ = (e, t) => !!(e.compareDocumentPosition(t) & Nfe.DOCUMENT_POSITION_PRECEDING), iht = (e, t) => !!(e.compareDocumentPosition(t) & Nfe.DOCUMENT_POSITION_FOLLOWING), sht = 0;
class aht {
  constructor() {
    Ea(this, "id", void 0), this.id = "".concat(sht++);
  }
}
var Le = {
  androidPendingDiffs: (e) => hs.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = kR.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Le.toDOMNode(e, e), n = Le.findDocumentOrShadowRoot(e);
    ec.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Le.findDocumentOrShadowRoot(e), r = ag(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && $e.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Le.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Le.toSlateNode(e, t.target), a = Le.findPath(e, i);
    if (wt.isElement(i) && re.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = re.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? re.before(e, u) : re.after(e, u);
      if (c) {
        var p = re.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = Le.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var y = Le.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return y;
  },
  findKey: (e, t) => {
    var n = dx.get(t);
    return n || (n = new aht(), dx.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = ER.get(r);
      if (o == null) {
        if (re.isEditor(r))
          return n;
        break;
      }
      var i = OR.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(bi.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!ec.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          Le.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = Le.toDOMNode(t, t), o = Le.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = ag(o), a = Le.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(a);
        }
        t.selection || $e.select(t, re.start(t, [])), ec.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Ife.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = Le.toDOMNode(t, t), a;
    try {
      a = Oa(n) ? n : n.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return a ? a.closest("[data-slate-editor]") === i && (!o || a.isContentEditable ? !0 : typeof a.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    a.closest('[contenteditable="false"]') === i || !!a.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => nc(t) && Le.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return re.hasPath(e, n.path) && re.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Le.hasEditableTarget(e, t) || Le.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => nc(t) && Le.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Ep.get(e),
  isFocused: (e) => !!ec.get(e),
  isReadOnly: (e) => !!rT.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (rT.get(e)) return !1;
    var n = Le.hasTarget(e, t) && Le.toSlateNode(e, t);
    return wt.isElement(n) && re.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Rk.get(e), r = re.isEditor(t) ? Iw.get(e) : n == null ? void 0 : n.get(Le.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(bi.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = re.node(e, t.path), r = Le.toDOMNode(e, n), o;
    re.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, y = a[l + 1];
        if (t.offset === f && y !== null && y !== void 0 && y.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = y.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof Yft ? E : y,
            (b = y.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(bi.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Ce.isBackward(t), i = Le.toDOMPoint(e, n), a = Ce.isCollapsed(t) ? i : Le.toDOMPoint(e, r), s = Le.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Oa(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), y = Oa(p) ? p : p.parentElement, b = !!y.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Oa(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? wm.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : Qft(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = Le.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), y = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = Le.getWindow(e), v = O.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var x = v.cloneContents(), _ = [...Array.prototype.slice.call(x.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(x.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (ns && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = x.textContent.length, M = u;
        }
      } else if (y) {
        for (var z = y.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var N = z[L];
          if (Le.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var Z, H = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = (Z = H.find((S) => iht(E, S))) !== null && Z !== void 0 ? Z : null;
        } else {
          var $, K = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = ($ = K.findLast((S) => UJ(E, S))) !== null && $ !== void 0 ? $ : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      ns && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      md && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (ns && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && Le.hasDOMNode(e, X, {
        editable: !0
      })) {
        var Q = Le.toSlateNode(e, X), {
          path: J,
          offset: P
        } = re.start(e, Le.findPath(e, Q));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = Le.toSlateNode(e, u), F = Le.findPath(e, D);
    return {
      path: F,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = iT(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (iT(t)) {
        if (md && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let x = function(_) {
              return _.childElementCount > 0 ? x(_.children[0]) : _;
            };
            var f = d.startContainer, y = g.startContainer, b = x(f.children[d.startOffset]), E = x(y.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Afe && eht(s) || md ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    md && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Le.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = UJ(s, u) || s === u && c < l, O = p ? w : Le.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var v = {
      anchor: w,
      focus: O
    };
    return Ce.isExpanded(v) && Ce.isForward(v) && Oa(u) && re.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = re.unhangRange(e, v, {
      voids: !0
    })), v;
  }
};
function lht(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!re.hasPath(e, n))
    return !1;
  var o = it.get(e, n);
  if (!Ct.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = ce.next(n);
  if (!re.hasPath(e, i))
    return !1;
  var a = it.get(e, i);
  return Ct.isText(a) && a.text.startsWith(r.text);
}
function Hfe(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function uht(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function cht(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function Wfe(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), a = uht(i, o), s = Math.min(i.length - a, o.length - a), l = cht(i, o, s), u = {
    start: n + a,
    end: r - l,
    text: o.slice(a, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function pht(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = Hfe(e, t, n), a = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), s = i.slice(r, a), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return Wfe(e, {
    start: r,
    end: l,
    text: s
  });
}
function dht(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function sT(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!re.hasPath(e, n))
    return null;
  var o = it.get(e, n);
  if (!Ct.isText(o))
    return null;
  var i = re.above(e, {
    match: (s) => wt.isElement(s) && re.isBlock(e, s),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var a = re.next(e, {
      at: n,
      match: Ct.isText
    });
    if (!a || !ce.isDescendant(a[1], i[1]))
      return null;
    r -= o.text.length, o = a[0], n = a[1];
  }
  return {
    path: n,
    offset: r
  };
}
function HJ(e, t) {
  var n = sT(e, t.anchor);
  if (!n)
    return null;
  if (Ce.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = sT(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function aT(e, t, n) {
  var r = hs.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: p
    } = c;
    return ce.equals(p, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return Kt.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var a = {
      path: t.path,
      offset: i.start
    }, s = Kt.transform(a, n, {
      affinity: "backward"
    });
    return s ? {
      path: s.path,
      offset: s.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = Kt.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && ce.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function WJ(e, t, n) {
  var r = aT(e, t.anchor, n);
  if (!r)
    return null;
  if (Ce.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = aT(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function fht(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !ce.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !ce.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !ce.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: ce.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: ce.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return ce.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: ce.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: ce.transform(n, t)
      };
  }
  var i = ce.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function VJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VJ(Object(n), !0).forEach(function(r) {
      Ea(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hht = 25, ght = 200, mht = function() {
}, vht = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function yht(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, a = null, s = null, l = 0, u = !1, c = () => {
    var V = Hu.get(t);
    if (Hu.delete(t), V) {
      var {
        selection: Z
      } = t, H = HJ(t, V);
      H && (!Z || !Ce.equals(H, Z)) && $e.select(t, H);
    }
  }, p = () => {
    var V = Uu.get(t);
    if (Uu.delete(t), !!V) {
      if (V.at) {
        var Z = Kt.isPoint(V.at) ? sT(t, V.at) : HJ(t, V.at);
        if (!Z)
          return;
        var H = re.range(t, Z);
        (!t.selection || !Ce.equals(t.selection, H)) && $e.select(t, Z);
      }
      V.run();
    }
  }, d = () => {
    if (a && (clearTimeout(a), a = null), s && (clearTimeout(s), s = null), !O() && !M()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), M() && (o = "action");
    var V = t.selection && re.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    Nl.set(t, t.marks), mht("flush", Uu.get(t), hs.get(t));
    for (var Z = O(), H; H = ($ = hs.get(t)) === null || $ === void 0 ? void 0 : $[0]; ) {
      var $, K, X = ka.get(t);
      X !== void 0 && (ka.delete(t), t.marks = X), X && u === !1 && (u = null);
      var Q = dht(H);
      (!t.selection || !Ce.equals(t.selection, Q)) && $e.select(t, Q), H.diff.text ? re.insertText(t, H.diff.text) : re.deleteFragment(t), hs.set(t, (K = hs.get(t)) === null || K === void 0 ? void 0 : K.filter((D) => {
        var {
          id: F
        } = D;
        return F !== H.id;
      })), lht(t, H) || (Z = !1, Uu.delete(t), Nl.delete(t), o = "action", Hu.delete(t), n.cancel(), r.cancel(), V == null || V.unref());
    }
    var J = V == null ? void 0 : V.unref();
    if (J && !Hu.get(t) && (!t.selection || !Ce.equals(J, t.selection)) && $e.select(t, J), M()) {
      p();
      return;
    }
    Z && n(), n.flush(), r.flush(), c();
    var P = Nl.get(t);
    Nl.delete(t), P !== void 0 && (t.marks = P, t.onChange());
  }, g = (V) => {
    i && clearTimeout(i), i = setTimeout(() => {
      Ep.set(t, !1), d();
    }, hht);
  }, f = (V) => {
    Ep.set(t, !0), i && (clearTimeout(i), i = null);
  }, y = function() {
    var Z = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, H = nT.get(t);
    if (H) {
      if (O() || Z) {
        H.style.display = "none";
        return;
      }
      H.style.removeProperty("display");
    }
  }, b = (V, Z) => {
    var H, $ = (H = hs.get(t)) !== null && H !== void 0 ? H : [];
    hs.set(t, $);
    var K = it.leaf(t, V), X = $.findIndex((P) => ce.equals(P.path, V));
    if (X < 0) {
      var Q = Wfe(K.text, Z);
      Q && $.push({
        path: V,
        diff: Z,
        id: l++
      }), y();
      return;
    }
    var J = pht(K.text, $[X].diff, Z);
    if (!J) {
      $.splice(X, 1), y();
      return;
    }
    $[X] = dw(dw({}, $[X]), {}, {
      diff: J
    });
  }, E = function(Z) {
    var {
      at: H
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, Hu.delete(t), n.cancel(), r.cancel(), M() && d(), Uu.set(t, {
      at: H,
      run: Z
    }), s = setTimeout(d);
  }, w = (V) => {
    var Z;
    if (a && (clearTimeout(a), a = null), !Ld.get(t)) {
      var {
        inputType: H
      } = V, $ = null, K = V.dataTransfer || V.data || void 0;
      u !== !1 && H !== "insertText" && H !== "insertCompositionText" && (u = !1);
      var [X] = V.getTargetRanges();
      X && ($ = Le.toSlateRange(t, X, {
        exactMatch: !1,
        suppressThrow: !0
      }));
      var Q = Le.getWindow(t), J = Q.getSelection();
      if (!$ && J && (X = J, $ = Le.toSlateRange(t, J, {
        exactMatch: !1,
        suppressThrow: !0
      })), $ = (Z = $) !== null && Z !== void 0 ? Z : t.selection, !!$) {
        var P = !0;
        if (H.startsWith("delete")) {
          if (Ce.isExpanded($)) {
            var [D, F] = Ce.edges($), S = it.leaf(t, D.path);
            if (S.text.length === D.offset && F.offset === 0) {
              var W = re.next(t, {
                at: D.path,
                match: Ct.isText
              });
              W && ce.equals(W[1], F.path) && ($ = {
                anchor: F,
                focus: F
              });
            }
          }
          var C = H.endsWith("Backward") ? "backward" : "forward", [I, U] = Ce.edges($), [T, q] = re.leaf(t, I.path), j = {
            text: "",
            start: I.offset,
            end: U.offset
          }, Y = hs.get(t), B = Y == null ? void 0 : Y.find((ze) => ce.equals(ze.path, q)), le = B ? [B.diff, j] : [j], he = Hfe(T.text, ...le);
          if (he.length === 0 && (P = !1), Ce.isExpanded($)) {
            if (P && ce.equals($.anchor.path, $.focus.path)) {
              var oe = {
                path: $.anchor.path,
                offset: I.offset
              }, Pe = re.range(t, oe, oe);
              return _(Pe), b($.anchor.path, {
                text: "",
                end: U.offset,
                start: I.offset
              });
            }
            return E(() => re.deleteFragment(t, {
              direction: C
            }), {
              at: $
            });
          }
        }
        switch (H) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            return E(() => re.deleteFragment(t), {
              at: $
            });
          case "deleteContent":
          case "deleteContentForward": {
            var {
              anchor: Ue
            } = $;
            if (P && Ce.isCollapsed($)) {
              var Ze = it.leaf(t, Ue.path);
              if (Ue.offset < Ze.text.length)
                return b(Ue.path, {
                  text: "",
                  start: Ue.offset,
                  end: Ue.offset + 1
                });
            }
            return E(() => re.deleteForward(t), {
              at: $
            });
          }
          case "deleteContentBackward": {
            var _e, {
              anchor: rt
            } = $, Ve = iT(X) ? X.isCollapsed : !!((_e = X) !== null && _e !== void 0 && _e.collapsed);
            return P && Ve && Ce.isCollapsed($) && rt.offset > 0 ? b(rt.path, {
              text: "",
              start: rt.offset - 1,
              end: rt.offset
            }) : E(() => re.deleteBackward(t), {
              at: $
            });
          }
          case "deleteEntireSoftLine":
            return E(() => {
              re.deleteBackward(t, {
                unit: "line"
              }), re.deleteForward(t, {
                unit: "line"
              });
            }, {
              at: $
            });
          case "deleteHardLineBackward":
            return E(() => re.deleteBackward(t, {
              unit: "block"
            }), {
              at: $
            });
          case "deleteSoftLineBackward":
            return E(() => re.deleteBackward(t, {
              unit: "line"
            }), {
              at: $
            });
          case "deleteHardLineForward":
            return E(() => re.deleteForward(t, {
              unit: "block"
            }), {
              at: $
            });
          case "deleteSoftLineForward":
            return E(() => re.deleteForward(t, {
              unit: "line"
            }), {
              at: $
            });
          case "deleteWordBackward":
            return E(() => re.deleteBackward(t, {
              unit: "word"
            }), {
              at: $
            });
          case "deleteWordForward":
            return E(() => re.deleteForward(t, {
              unit: "word"
            }), {
              at: $
            });
          case "insertLineBreak":
            return E(() => re.insertSoftBreak(t), {
              at: $
            });
          case "insertParagraph":
            return E(() => re.insertBreak(t), {
              at: $
            });
          case "insertCompositionText":
          case "deleteCompositionText":
          case "insertFromComposition":
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText": {
            if (vht(K))
              return E(() => Le.insertData(t, K), {
                at: $
              });
            var ye = K ?? "";
            if (ka.get(t) && (ye = ye.replace("\uFEFF", "")), H === "insertText" && /.*\n.*\n$/.test(ye) && (ye = ye.slice(0, -1)), ye.includes(`
`))
              return E(() => {
                var ze = ye.split(`
`);
                ze.forEach((Se, st) => {
                  Se && re.insertText(t, Se), st !== ze.length - 1 && re.insertSoftBreak(t);
                });
              }, {
                at: $
              });
            if (ce.equals($.anchor.path, $.focus.path)) {
              var [Ge, ct] = Ce.edges($), ve = {
                start: Ge.offset,
                end: ct.offset,
                text: ye
              };
              if (ye && u && H === "insertCompositionText") {
                var Oe = u.start + u.text.search(/\S|$/), qe = ve.start + ve.text.search(/\S|$/);
                qe === Oe + 1 && ve.end === u.start + u.text.length ? (ve.start -= 1, u = null, N()) : u = !1;
              } else H === "insertText" ? u === null ? u = ve : u && Ce.isCollapsed($) && u.end + u.text.length === Ge.offset ? u = dw(dw({}, u), {}, {
                text: u.text + ye
              }) : u = !1 : u = !1;
              if (P) {
                b(Ge.path, ve);
                return;
              }
            }
            return E(() => re.insertText(t, ye), {
              at: $
            });
          }
        }
      }
    }
  }, M = () => !!Uu.get(t), O = () => {
    var V;
    return !!((V = hs.get(t)) !== null && V !== void 0 && V.length);
  }, v = () => M() || O(), x = () => o, _ = (V) => {
    Hu.set(t, V), a && (clearTimeout(a), a = null);
    var {
      selection: Z
    } = t;
    if (V) {
      var H = !Z || !ce.equals(Z.anchor.path, V.anchor.path), $ = !Z || !ce.equals(Z.anchor.path.slice(0, -1), V.anchor.path.slice(0, -1));
      (H && u || $) && (u = !1), (H || O()) && (a = setTimeout(d, ght));
    }
  }, z = () => {
    (M() || !O()) && d();
  }, L = (V) => {
    O() || (y(!0), setTimeout(y));
  }, N = () => {
    M() || (s = setTimeout(d));
  }, R = (V) => {
    if (!(O() || M()) && V.some((H) => PR(t, H, V))) {
      var Z;
      (Z = Bfe.get(t)) === null || Z === void 0 || Z();
    }
  };
  return {
    flush: d,
    scheduleFlush: N,
    hasPendingDiffs: O,
    hasPendingAction: M,
    hasPendingChanges: v,
    isFlushing: x,
    handleUserSelect: _,
    handleCompositionEnd: g,
    handleCompositionStart: f,
    handleDOMBeforeInput: w,
    handleKeyDown: L,
    handleDomMutations: R,
    handleInput: z
  };
}
function bht() {
  var e = ht(!1);
  return h(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var Cm = Aw ? ege : h;
function wht(e, t, n) {
  var [r] = k(() => new MutationObserver(t));
  Cm(() => {
    r.takeRecords();
  }), h(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var Cht = ["node"];
function $J(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xht(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $J(Object(n), !0).forEach(function(r) {
      Ea(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $J(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Oht = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, Eht = ns ? (e) => {
  var {
    node: t
  } = e, n = Rd(e, Cht);
  if (!ns)
    return null;
  var r = Sc(), o = bht(), [i] = k(() => yht(xht({
    editor: r
  }, n)));
  return wht(t, i.handleDomMutations, Oht), kR.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, kht = ["anchor", "focus"], Lht = ["anchor", "focus"], Pht = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), Vfe = (e, t) => {
  var n = Rd(e, kht), r = Rd(t, Lht);
  return e[Nd] === t[Nd] && Pht(n, r);
}, _ht = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!Ce.equals(r, o) || !Vfe(r, o))
      return !1;
  }
  return !0;
}, Sht = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !Vfe(r, o))
      return !1;
  }
  return !0;
};
function ZJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mht(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZJ(Object(n), !0).forEach(function(r) {
      Ea(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Dht = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = Sc(), a = Le.findPath(i, o), s = ce.parent(a), l = !!n[Rfe];
  return i.isVoid(r) ? /* @__PURE__ */ we.createElement(W_, {
    length: it.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && re.string(i, s) === "" ? /* @__PURE__ */ we.createElement(W_, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ we.createElement(W_, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ we.createElement(qJ, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ we.createElement(qJ, {
    text: n.text
  });
}, qJ = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = ht(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = k(o);
  return Cm(() => {
    var a = o();
    r.current && r.current.textContent !== a && (r.current.textContent = a);
  }), /* @__PURE__ */ we.createElement(Tht, {
    ref: r
  }, i);
}, Tht = /* @__PURE__ */ me(/* @__PURE__ */ yr((e, t) => /* @__PURE__ */ we.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), W_ = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ we.createElement("span", Mht({}, o), !(ns || jfe) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ we.createElement("br", null) : null);
};
function GJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $fe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GJ(Object(n), !0).forEach(function(r) {
      Ea(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jht = ns ? 300 : 0;
function Aht(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function KJ(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var Iht = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: a = (w) => /* @__PURE__ */ we.createElement(Rht, $fe({}, w))
  } = e, s = Sc(), l = ht(null), u = ht(null), [c, p] = k(!1), d = ht(null), g = ur((w) => {
    if (Aht(l, w == null), w == null) {
      var M;
      nT.delete(s), (M = t.onPlaceholderResize) === null || M === void 0 || M.call(t, null);
    } else {
      if (nT.set(s, w), !l.current) {
        var O = window.ResizeObserver || zft;
        l.current = new O(() => {
          var v;
          (v = t.onPlaceholderResize) === null || v === void 0 || v.call(t, w);
        });
      }
      l.current.observe(w), u.current = w;
    }
  }, [u, t, s]), f = /* @__PURE__ */ we.createElement(Dht, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), y = !!t[Nd];
  if (h(() => (y ? d.current || (d.current = setTimeout(() => {
    p(!0), d.current = null;
  }, jht)) : (KJ(d), p(!1)), () => KJ(d)), [y, p]), y && c) {
    var b = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: ip ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: g
      }
    };
    f = /* @__PURE__ */ we.createElement(we.Fragment, null, i(b), f);
  }
  var E = {
    "data-slate-leaf": !0
  };
  return a({
    attributes: E,
    children: f,
    leaf: t,
    text: r
  });
}, Bht = /* @__PURE__ */ we.memo(Iht, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && Ct.equals(t.leaf, e.leaf) && t.leaf[Nd] === e.leaf[Nd]), Rht = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ we.createElement("span", $fe({}, t), n);
}, Nht = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: a
  } = e, s = Sc(), l = ht(null), u = Ct.decorations(a, t), c = Le.findKey(s, a), p = [], d = 0; d < u.length; d++) {
    var g = u[d];
    p.push(/* @__PURE__ */ we.createElement(Bht, {
      isLast: n && d === u.length - 1,
      key: "".concat(c.id, "-").concat(d),
      renderPlaceholder: o,
      leaf: g,
      text: a,
      parent: r,
      renderLeaf: i
    }));
  }
  var f = ur((y) => {
    var b = Rk.get(s);
    y ? (b == null || b.set(c, y), Sp.set(a, y), wm.set(y, a)) : (b == null || b.delete(c), Sp.delete(a), l.current && wm.delete(l.current)), l.current = y;
  }, [l, s, c, a]);
  return /* @__PURE__ */ we.createElement("span", {
    "data-slate-node": "text",
    ref: f
  }, p);
}, Zfe = /* @__PURE__ */ we.memo(Nht, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && Sht(t.decorations, e.decorations));
function YJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YJ(Object(n), !0).forEach(function(r) {
      Ea(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fht = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (w) => /* @__PURE__ */ we.createElement(Uht, lT({}, w)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = Sc(), l = Vht(), u = s.isInline(n), c = Le.findKey(s, n), p = ur((w) => {
    var M = Rk.get(s);
    w ? (M == null || M.set(c, w), Sp.set(n, w), wm.set(w, n)) : (M == null || M.delete(c), Sp.delete(n));
  }, [s, c, n]), d = Gfe({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  }), g = {
    "data-slate-node": "element",
    ref: p
  };
  if (u && (g["data-slate-inline"] = !0), !u && re.hasInlines(s, n)) {
    var f = it.string(n), y = Cfe(f);
    y === "rtl" && (g.dir = y);
  }
  if (re.isVoid(s, n)) {
    g["data-slate-void"] = !0, !l && u && (g.contentEditable = !1);
    var b = u ? "span" : "div", [[E]] = it.texts(n);
    d = /* @__PURE__ */ we.createElement(b, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ we.createElement(Zfe, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: E
    })), OR.set(E, 0), ER.set(E, n);
  }
  return r({
    attributes: g,
    children: d,
    element: n
  });
}, zht = /* @__PURE__ */ we.memo(Fht, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && _ht(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && Ce.equals(e.selection, t.selection))), Uht = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = Sc(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ we.createElement(i, lT(lT({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, qfe = /* @__PURE__ */ We(() => []), Hht = () => ge(qfe), Wht = /* @__PURE__ */ We(!1), Gfe = (e) => {
  var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = Hht(), l = Sc();
  Ld.set(l, !1);
  for (var u = Le.findPath(l, n), c = [], p = wt.isElement(n) && !l.isInline(n) && re.hasInlines(l, n), d = 0; d < n.children.length; d++) {
    var g = u.concat(d), f = n.children[d], y = Le.findKey(l, f), b = re.range(l, g), E = a && Ce.intersection(b, a), w = s([f, g]);
    for (var M of t) {
      var O = Ce.intersection(M, b);
      O && w.push(O);
    }
    wt.isElement(f) ? c.push(/* @__PURE__ */ we.createElement(Wht.Provider, {
      key: "provider-".concat(y.id),
      value: !!E
    }, /* @__PURE__ */ we.createElement(zht, {
      decorations: w,
      element: f,
      key: y.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: E
    }))) : c.push(/* @__PURE__ */ we.createElement(Zfe, {
      decorations: w,
      key: y.id,
      isLast: p && d === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: f
    })), OR.set(f, d), ER.set(f, n);
  }
  return c;
}, Kfe = /* @__PURE__ */ We(!1), Vht = () => ge(Kfe), Yfe = /* @__PURE__ */ We(null), Nk = () => {
  var e = ge(Yfe);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function $ht() {
  var e = Sc(), t = ht(!1), n = ht(0), r = ur(() => {
    if (!t.current) {
      t.current = !0;
      var o = Le.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return h(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var Zht = 3, qht = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, Ght = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Kht = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Lo = (e) => {
  var t = qht[e], n = Ght[e], r = Kht[e], o = t && B_(t), i = n && B_(n), a = r && B_(r);
  return (s) => !!(o && o(s) || zJ && i && i(s) || !zJ && a && a(s));
}, _o = {
  isBold: Lo("bold"),
  isCompose: Lo("compose"),
  isMoveBackward: Lo("moveBackward"),
  isMoveForward: Lo("moveForward"),
  isDeleteBackward: Lo("deleteBackward"),
  isDeleteForward: Lo("deleteForward"),
  isDeleteLineBackward: Lo("deleteLineBackward"),
  isDeleteLineForward: Lo("deleteLineForward"),
  isDeleteWordBackward: Lo("deleteWordBackward"),
  isDeleteWordForward: Lo("deleteWordForward"),
  isExtendBackward: Lo("extendBackward"),
  isExtendForward: Lo("extendForward"),
  isExtendLineBackward: Lo("extendLineBackward"),
  isExtendLineForward: Lo("extendLineForward"),
  isItalic: Lo("italic"),
  isMoveLineBackward: Lo("moveLineBackward"),
  isMoveLineForward: Lo("moveLineForward"),
  isMoveWordBackward: Lo("moveWordBackward"),
  isMoveWordForward: Lo("moveWordForward"),
  isRedo: Lo("redo"),
  isSoftBreak: Lo("insertSoftBreak"),
  isSplitBlock: Lo("splitBlock"),
  isTransposeCharacter: Lo("transposeCharacter"),
  isUndo: Lo("undo")
}, Yht = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => PR(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, Xht = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class Xfe extends Kl {
  constructor() {
    super(...arguments), Ea(this, "context", null), Ea(this, "manager", null), Ea(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, Xht);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = Yht(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Ea(Xfe, "contextType", xR);
var Jht = ns ? Xfe : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ we.createElement(we.Fragment, null, t);
}, Qht = /* @__PURE__ */ We(!1), egt = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], tgt = ["text"];
function XJ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ba(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XJ(Object(n), !0).forEach(function(r) {
      Ea(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XJ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ngt = (e) => /* @__PURE__ */ we.createElement(we.Fragment, null, Gfe(e)), rgt = /* @__PURE__ */ yr((e, t) => {
  var n = ur((I) => /* @__PURE__ */ we.createElement(ogt, Ba({}, I)), []), {
    autoFocus: r,
    decorate: o = igt,
    onDOMBeforeInput: i,
    placeholder: a,
    readOnly: s = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: p = sgt,
    style: d = {},
    as: g = "div",
    disableDefaultStyles: f = !1
  } = e, y = Rd(e, egt), b = Nk(), [E, w] = k(!1), M = ht(null), O = ht([]), [v, x] = k(), _ = ht(!1), {
    onUserInput: z,
    receivedUserInput: L
  } = $ht(), [, N] = tge((I) => I + 1, 0);
  Bfe.set(b, N), rT.set(b, s);
  var R = Ft(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  h(() => {
    M.current && r && M.current.focus();
  }, [r]);
  var V = ht(), Z = Ft(() => mft(() => {
    if (Ld.get(b)) {
      Z();
      return;
    }
    var I = Le.toDOMNode(b, b), U = I.getRootNode();
    if (!_.current && ip && U instanceof ShadowRoot) {
      _.current = !0;
      var T = oht();
      T ? document.execCommand("indent") : $e.deselect(b), _.current = !1;
      return;
    }
    var q = V.current;
    if ((ns || !Le.isComposing(b)) && (!R.isUpdatingSelection || q != null && q.isFlushing()) && !R.isDraggingInternally) {
      var j = Le.findDocumentOrShadowRoot(b), {
        activeElement: Y
      } = j, B = Le.toDOMNode(b, b), le = ag(j);
      if (Y === B ? (R.latestElement = Y, ec.set(b, !0)) : ec.delete(b), !le)
        return $e.deselect(b);
      var {
        anchorNode: he,
        focusNode: oe
      } = le, Pe = Le.hasEditableTarget(b, he) || Le.isTargetInsideNonReadonlyVoid(b, he), Ue = Le.hasTarget(b, oe);
      if (Pe && Ue) {
        var Ze = Le.toSlateRange(b, le, {
          exactMatch: !1,
          suppressThrow: !0
        });
        Ze && (!Le.isComposing(b) && !(q != null && q.hasPendingChanges()) && !(q != null && q.isFlushing()) ? $e.select(b, Ze) : q == null || q.handleUserSelect(Ze));
      }
      s && (!Pe || !Ue) && $e.deselect(b);
    }
  }, 100), [b, s, R]), H = Ft(() => cft(Z, 0), [Z]);
  V.current = Eht({
    node: M,
    onDOMSelectionChange: Z,
    scheduleOnDOMSelectionChange: H
  }), Cm(() => {
    var I, U, T;
    M.current && (T = LR(M.current)) ? (Ife.set(b, T), Iw.set(b, M.current), Sp.set(b, M.current), wm.set(M.current, b)) : Sp.delete(b);
    var {
      selection: q
    } = b, j = Le.findDocumentOrShadowRoot(b), Y = ag(j);
    if (!(!Y || !Le.isFocused(b) || (I = V.current) !== null && I !== void 0 && I.hasPendingAction())) {
      var B = (Pe) => {
        var Ue = Y.type !== "None";
        if (!(!q && !Ue)) {
          var Ze = Y.focusNode, _e;
          if (md && Y.rangeCount > 1) {
            var rt = Y.getRangeAt(0), Ve = Y.getRangeAt(Y.rangeCount - 1);
            rt.startContainer === Ze ? _e = Ve.endContainer : _e = rt.startContainer;
          } else
            _e = Y.anchorNode;
          var ye = Iw.get(b), Ge = !1;
          if (ye.contains(_e) && ye.contains(Ze) && (Ge = !0), Ue && Ge && q && !Pe) {
            var ct = Le.toSlateRange(b, Y, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (ct && Ce.equals(ct, q)) {
              var ve;
              if (!R.hasMarkPlaceholder || (ve = _e) !== null && ve !== void 0 && (ve = ve.parentElement) !== null && ve !== void 0 && ve.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (q && !Le.hasRange(b, q)) {
            b.selection = Le.toSlateRange(b, Y, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          R.isUpdatingSelection = !0;
          var Oe = q && Le.toDOMRange(b, q);
          return Oe ? (Le.isComposing(b) && !ns ? Y.collapseToEnd() : Ce.isBackward(q) ? Y.setBaseAndExtent(Oe.endContainer, Oe.endOffset, Oe.startContainer, Oe.startOffset) : Y.setBaseAndExtent(Oe.startContainer, Oe.startOffset, Oe.endContainer, Oe.endOffset), p(b, Oe)) : Y.removeAllRanges(), Oe;
        }
      };
      Y.rangeCount <= 1 && B();
      var le = ((U = V.current) === null || U === void 0 ? void 0 : U.isFlushing()) === "action";
      if (!ns || !le) {
        setTimeout(() => {
          R.isUpdatingSelection = !1;
        });
        return;
      }
      var he = null, oe = requestAnimationFrame(() => {
        if (le) {
          var Pe = (Ue) => {
            try {
              var Ze = Le.toDOMNode(b, b);
              Ze.focus(), B(Ue);
            } catch {
            }
          };
          Pe(), he = setTimeout(() => {
            Pe(!0), R.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(oe), he && clearTimeout(he);
      };
    }
  });
  var $ = ur((I) => {
    var U = Le.toDOMNode(b, b), T = U.getRootNode();
    if (_ != null && _.current && ip && T instanceof ShadowRoot) {
      var q = I.getTargetRanges(), j = q[0], Y = new window.Range();
      Y.setStart(j.startContainer, j.startOffset), Y.setEnd(j.endContainer, j.endOffset);
      var B = Le.toSlateRange(b, Y, {
        exactMatch: !1,
        suppressThrow: !1
      });
      $e.select(b, B), I.preventDefault(), I.stopImmediatePropagation();
      return;
    }
    if (z(), !s && Le.hasEditableTarget(b, I.target) && !agt(I, i)) {
      var le;
      if (V.current)
        return V.current.handleDOMBeforeInput(I);
      H.flush(), Z.flush();
      var {
        selection: he
      } = b, {
        inputType: oe
      } = I, Pe = I.dataTransfer || I.data || void 0, Ue = oe === "insertCompositionText" || oe === "deleteCompositionText";
      if (Ue && Le.isComposing(b))
        return;
      var Ze = !1;
      if (oe === "insertText" && he && Ce.isCollapsed(he) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      I.data && I.data.length === 1 && /[a-z ]/i.test(I.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      he.anchor.offset !== 0 && (Ze = !0, b.marks && (Ze = !1), !Ld.get(b))) {
        var _e, rt, {
          anchor: Ve
        } = he, [ye, Ge] = Le.toDOMPoint(b, Ve), ct = (_e = ye.parentElement) === null || _e === void 0 ? void 0 : _e.closest("a"), ve = Le.getWindow(b);
        if (Ze && ct && Le.hasDOMNode(b, ct)) {
          var Oe, qe = ve == null ? void 0 : ve.document.createTreeWalker(ct, NodeFilter.SHOW_TEXT).lastChild();
          qe === ye && ((Oe = qe.textContent) === null || Oe === void 0 ? void 0 : Oe.length) === Ge && (Ze = !1);
        }
        if (Ze && ye.parentElement && (ve == null || (rt = ve.getComputedStyle(ye.parentElement)) === null || rt === void 0 ? void 0 : rt.whiteSpace) === "pre") {
          var ze = re.above(b, {
            at: Ve.path,
            match: (lt) => wt.isElement(lt) && re.isBlock(b, lt)
          });
          ze && it.string(ze[0]).includes("	") && (Ze = !1);
        }
      }
      if ((!oe.startsWith("delete") || oe.startsWith("deleteBy")) && !Ld.get(b)) {
        var [Se] = I.getTargetRanges();
        if (Se) {
          var st = Le.toSlateRange(b, Se, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!he || !Ce.equals(he, st)) {
            Ze = !1;
            var xe = !Ue && b.selection && re.rangeRef(b, b.selection);
            $e.select(b, st), xe && sg.set(b, xe);
          }
        }
      }
      if (Ue)
        return;
      if (Ze || I.preventDefault(), he && Ce.isExpanded(he) && oe.startsWith("delete")) {
        var xt = oe.endsWith("Backward") ? "backward" : "forward";
        re.deleteFragment(b, {
          direction: xt
        });
        return;
      }
      switch (oe) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          re.deleteFragment(b);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          re.deleteForward(b);
          break;
        }
        case "deleteContentBackward": {
          re.deleteBackward(b);
          break;
        }
        case "deleteEntireSoftLine": {
          re.deleteBackward(b, {
            unit: "line"
          }), re.deleteForward(b, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          re.deleteBackward(b, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          re.deleteBackward(b, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          re.deleteForward(b, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          re.deleteForward(b, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          re.deleteBackward(b, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          re.deleteForward(b, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          re.insertSoftBreak(b);
          break;
        case "insertParagraph": {
          re.insertBreak(b);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          oe === "insertFromComposition" && Le.isComposing(b) && (w(!1), Ep.set(b, !1)), (Pe == null ? void 0 : Pe.constructor.name) === "DataTransfer" ? Le.insertData(b, Pe) : typeof Pe == "string" && (Ze ? O.current.push(() => re.insertText(b, Pe)) : re.insertText(b, Pe));
          break;
        }
      }
      var at = (le = sg.get(b)) === null || le === void 0 ? void 0 : le.unref();
      sg.delete(b), at && (!b.selection || !Ce.equals(b.selection, at)) && $e.select(b, at);
    }
  }, [b, Z, z, i, s, H]), K = ur((I) => {
    I == null ? (Z.cancel(), H.cancel(), Iw.delete(b), Sp.delete(b), M.current && Cu && M.current.removeEventListener("beforeinput", $)) : Cu && I.addEventListener("beforeinput", $), M.current = I, typeof t == "function" ? t(I) : t && (t.current = I);
  }, [Z, H, b, $, t]);
  Cm(() => {
    var I = Le.getWindow(b);
    I.document.addEventListener("selectionchange", H);
    var U = () => {
      R.isDraggingInternally = !1;
    };
    return I.document.addEventListener("dragend", U), I.document.addEventListener("drop", U), () => {
      I.document.removeEventListener("selectionchange", H), I.document.removeEventListener("dragend", U), I.document.removeEventListener("drop", U);
    };
  }, [H, R]);
  var X = o([b, []]), Q = a && b.children.length === 1 && Array.from(it.texts(b)).length === 1 && it.string(b) === "" && !E, J = ur((I) => {
    if (I && Q) {
      var U;
      x((U = I.getBoundingClientRect()) === null || U === void 0 ? void 0 : U.height);
    } else
      x(void 0);
  }, [Q]);
  if (Q) {
    var P = re.start(b, []);
    X.push({
      [Nd]: !0,
      placeholder: a,
      onPlaceholderResize: J,
      anchor: P,
      focus: P
    });
  }
  var {
    marks: D
  } = b;
  if (R.hasMarkPlaceholder = !1, b.selection && Ce.isCollapsed(b.selection) && D) {
    var {
      anchor: F
    } = b.selection, S = it.leaf(b, F.path), W = Rd(S, tgt);
    if (!Ct.equals(S, D, {
      loose: !0
    })) {
      R.hasMarkPlaceholder = !0;
      var C = Object.fromEntries(Object.keys(W).map((I) => [I, null]));
      X.push(Ba(Ba(Ba({
        [Rfe]: !0
      }, C), D), {}, {
        anchor: F,
        focus: F
      }));
    }
  }
  return h(() => {
    setTimeout(() => {
      var {
        selection: I
      } = b;
      if (I) {
        var {
          anchor: U
        } = I, T = it.leaf(b, U.path);
        if (D && !Ct.equals(T, D, {
          loose: !0
        })) {
          ka.set(b, D);
          return;
        }
      }
      ka.delete(b);
    });
  }), /* @__PURE__ */ we.createElement(Kfe.Provider, {
    value: s
  }, /* @__PURE__ */ we.createElement(Qht.Provider, {
    value: E
  }, /* @__PURE__ */ we.createElement(qfe.Provider, {
    value: o
  }, /* @__PURE__ */ we.createElement(Jht, {
    node: M,
    receivedUserInput: L
  }, /* @__PURE__ */ we.createElement(g, Ba(Ba({
    role: s ? void 0 : "textbox",
    "aria-multiline": s ? void 0 : !0
  }, y), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: Cu || !Aw ? y.spellCheck : !1,
    autoCorrect: Cu || !Aw ? y.autoCorrect : "false",
    autoCapitalize: Cu || !Aw ? y.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !s,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: K,
    style: Ba(Ba({}, f ? {} : Ba({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, v ? {
      minHeight: v
    } : {})), d),
    onBeforeInput: ur((I) => {
      if (!Cu && !s && !es(I, y.onBeforeInput) && Le.hasSelectableTarget(b, I.target) && (I.preventDefault(), !Le.isComposing(b))) {
        var U = I.data;
        re.insertText(b, U);
      }
    }, [y.onBeforeInput, b, s]),
    onInput: ur((I) => {
      if (!es(I, y.onInput)) {
        if (V.current) {
          V.current.handleInput();
          return;
        }
        for (var U of O.current)
          U();
        if (O.current = [], !Le.isFocused(b)) {
          var T = I.nativeEvent, q = b;
          if (T.inputType === "historyUndo" && typeof q.undo == "function") {
            q.undo();
            return;
          }
          if (T.inputType === "historyRedo" && typeof q.redo == "function") {
            q.redo();
            return;
          }
        }
      }
    }, [y.onInput, b]),
    onBlur: ur((I) => {
      if (!(s || R.isUpdatingSelection || !Le.hasSelectableTarget(b, I.target) || es(I, y.onBlur))) {
        var U = Le.findDocumentOrShadowRoot(b);
        if (R.latestElement !== U.activeElement) {
          var {
            relatedTarget: T
          } = I, q = Le.toDOMNode(b, b);
          if (T !== q && !(Oa(T) && T.hasAttribute("data-slate-spacer"))) {
            if (T != null && nc(T) && Le.hasDOMNode(b, T)) {
              var j = Le.toSlateNode(b, T);
              if (wt.isElement(j) && !b.isVoid(j))
                return;
            }
            if (ip) {
              var Y = ag(U);
              Y == null || Y.removeAllRanges();
            }
            ec.delete(b);
          }
        }
      }
    }, [s, R.isUpdatingSelection, R.latestElement, b, y.onBlur]),
    onClick: ur((I) => {
      if (Le.hasTarget(b, I.target) && !es(I, y.onClick) && nc(I.target)) {
        var U = Le.toSlateNode(b, I.target), T = Le.findPath(b, U);
        if (!re.hasPath(b, T) || it.get(b, T) !== U)
          return;
        if (I.detail === Zht && T.length >= 1) {
          var q = T;
          if (!(wt.isElement(U) && re.isBlock(b, U))) {
            var j, Y = re.above(b, {
              match: (Ze) => wt.isElement(Ze) && re.isBlock(b, Ze),
              at: T
            });
            q = (j = Y == null ? void 0 : Y[1]) !== null && j !== void 0 ? j : T.slice(0, 1);
          }
          var B = re.range(b, q);
          $e.select(b, B);
          return;
        }
        if (s)
          return;
        var le = re.start(b, T), he = re.end(b, T), oe = re.void(b, {
          at: le
        }), Pe = re.void(b, {
          at: he
        });
        if (oe && Pe && ce.equals(oe[1], Pe[1])) {
          var Ue = re.range(b, le);
          $e.select(b, Ue);
        }
      }
    }, [b, y.onClick, s]),
    onCompositionEnd: ur((I) => {
      if (Le.hasSelectableTarget(b, I.target)) {
        var U;
        if (Le.isComposing(b) && Promise.resolve().then(() => {
          w(!1), Ep.set(b, !1);
        }), (U = V.current) === null || U === void 0 || U.handleCompositionEnd(I), es(I, y.onCompositionEnd) || ns)
          return;
        if (!ip && !qft && !jfe && !Kft && !Gft && I.data) {
          var T = ka.get(b);
          ka.delete(b), T !== void 0 && (Nl.set(b, b.marks), b.marks = T), re.insertText(b, I.data);
          var q = Nl.get(b);
          Nl.delete(b), q !== void 0 && (b.marks = q);
        }
      }
    }, [y.onCompositionEnd, b]),
    onCompositionUpdate: ur((I) => {
      Le.hasSelectableTarget(b, I.target) && !es(I, y.onCompositionUpdate) && (Le.isComposing(b) || (w(!0), Ep.set(b, !0)));
    }, [y.onCompositionUpdate, b]),
    onCompositionStart: ur((I) => {
      if (Le.hasSelectableTarget(b, I.target)) {
        var U;
        if ((U = V.current) === null || U === void 0 || U.handleCompositionStart(I), es(I, y.onCompositionStart) || ns)
          return;
        w(!0);
        var {
          selection: T
        } = b;
        if (T && Ce.isExpanded(T)) {
          re.deleteFragment(b);
          return;
        }
      }
    }, [y.onCompositionStart, b]),
    onCopy: ur((I) => {
      Le.hasSelectableTarget(b, I.target) && !es(I, y.onCopy) && !JJ(I) && (I.preventDefault(), Le.setFragmentData(b, I.clipboardData, "copy"));
    }, [y.onCopy, b]),
    onCut: ur((I) => {
      if (!s && Le.hasSelectableTarget(b, I.target) && !es(I, y.onCut) && !JJ(I)) {
        I.preventDefault(), Le.setFragmentData(b, I.clipboardData, "cut");
        var {
          selection: U
        } = b;
        if (U)
          if (Ce.isExpanded(U))
            re.deleteFragment(b);
          else {
            var T = it.parent(b, U.anchor.path);
            re.isVoid(b, T) && $e.delete(b);
          }
      }
    }, [s, b, y.onCut]),
    onDragOver: ur((I) => {
      if (Le.hasTarget(b, I.target) && !es(I, y.onDragOver)) {
        var U = Le.toSlateNode(b, I.target);
        wt.isElement(U) && re.isVoid(b, U) && I.preventDefault();
      }
    }, [y.onDragOver, b]),
    onDragStart: ur((I) => {
      if (!s && Le.hasTarget(b, I.target) && !es(I, y.onDragStart)) {
        var U = Le.toSlateNode(b, I.target), T = Le.findPath(b, U), q = wt.isElement(U) && re.isVoid(b, U) || re.void(b, {
          at: T,
          voids: !0
        });
        if (q) {
          var j = re.range(b, T);
          $e.select(b, j);
        }
        R.isDraggingInternally = !0, Le.setFragmentData(b, I.dataTransfer, "drag");
      }
    }, [s, b, y.onDragStart, R]),
    onDrop: ur((I) => {
      if (!s && Le.hasTarget(b, I.target) && !es(I, y.onDrop)) {
        I.preventDefault();
        var U = b.selection, T = Le.findEventRange(b, I), q = I.dataTransfer;
        $e.select(b, T), R.isDraggingInternally && U && !Ce.equals(U, T) && !re.void(b, {
          at: T,
          voids: !0
        }) && $e.delete(b, {
          at: U
        }), Le.insertData(b, q), Le.isFocused(b) || Le.focus(b);
      }
    }, [s, b, y.onDrop, R]),
    onDragEnd: ur((I) => {
      !s && R.isDraggingInternally && y.onDragEnd && Le.hasTarget(b, I.target) && y.onDragEnd(I);
    }, [s, R, y, b]),
    onFocus: ur((I) => {
      if (!s && !R.isUpdatingSelection && Le.hasEditableTarget(b, I.target) && !es(I, y.onFocus)) {
        var U = Le.toDOMNode(b, b), T = Le.findDocumentOrShadowRoot(b);
        if (R.latestElement = T.activeElement, md && I.target !== U) {
          U.focus();
          return;
        }
        ec.set(b, !0);
      }
    }, [s, R, b, y.onFocus]),
    onKeyDown: ur((I) => {
      if (!s && Le.hasEditableTarget(b, I.target)) {
        var U;
        (U = V.current) === null || U === void 0 || U.handleKeyDown(I);
        var {
          nativeEvent: T
        } = I;
        if (Le.isComposing(b) && T.isComposing === !1 && (Ep.set(b, !1), w(!1)), es(I, y.onKeyDown) || Le.isComposing(b))
          return;
        var {
          selection: q
        } = b, j = b.children[q !== null ? q.focus.path[0] : 0], Y = Cfe(it.string(j)) === "rtl";
        if (_o.isRedo(T)) {
          I.preventDefault();
          var B = b;
          typeof B.redo == "function" && B.redo();
          return;
        }
        if (_o.isUndo(T)) {
          I.preventDefault();
          var le = b;
          typeof le.undo == "function" && le.undo();
          return;
        }
        if (_o.isMoveLineBackward(T)) {
          I.preventDefault(), $e.move(b, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (_o.isMoveLineForward(T)) {
          I.preventDefault(), $e.move(b, {
            unit: "line"
          });
          return;
        }
        if (_o.isExtendLineBackward(T)) {
          I.preventDefault(), $e.move(b, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (_o.isExtendLineForward(T)) {
          I.preventDefault(), $e.move(b, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (_o.isMoveBackward(T)) {
          I.preventDefault(), q && Ce.isCollapsed(q) ? $e.move(b, {
            reverse: !Y
          }) : $e.collapse(b, {
            edge: Y ? "end" : "start"
          });
          return;
        }
        if (_o.isMoveForward(T)) {
          I.preventDefault(), q && Ce.isCollapsed(q) ? $e.move(b, {
            reverse: Y
          }) : $e.collapse(b, {
            edge: Y ? "start" : "end"
          });
          return;
        }
        if (_o.isMoveWordBackward(T)) {
          I.preventDefault(), q && Ce.isExpanded(q) && $e.collapse(b, {
            edge: "focus"
          }), $e.move(b, {
            unit: "word",
            reverse: !Y
          });
          return;
        }
        if (_o.isMoveWordForward(T)) {
          I.preventDefault(), q && Ce.isExpanded(q) && $e.collapse(b, {
            edge: "focus"
          }), $e.move(b, {
            unit: "word",
            reverse: Y
          });
          return;
        }
        if (Cu) {
          if ((Afe || ip) && q && (_o.isDeleteBackward(T) || _o.isDeleteForward(T)) && Ce.isCollapsed(q)) {
            var he = it.parent(b, q.anchor.path);
            if (wt.isElement(he) && re.isVoid(b, he) && (re.isInline(b, he) || re.isBlock(b, he))) {
              I.preventDefault(), re.deleteBackward(b, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (_o.isBold(T) || _o.isItalic(T) || _o.isTransposeCharacter(T)) {
            I.preventDefault();
            return;
          }
          if (_o.isSoftBreak(T)) {
            I.preventDefault(), re.insertSoftBreak(b);
            return;
          }
          if (_o.isSplitBlock(T)) {
            I.preventDefault(), re.insertBreak(b);
            return;
          }
          if (_o.isDeleteBackward(T)) {
            I.preventDefault(), q && Ce.isExpanded(q) ? re.deleteFragment(b, {
              direction: "backward"
            }) : re.deleteBackward(b);
            return;
          }
          if (_o.isDeleteForward(T)) {
            I.preventDefault(), q && Ce.isExpanded(q) ? re.deleteFragment(b, {
              direction: "forward"
            }) : re.deleteForward(b);
            return;
          }
          if (_o.isDeleteLineBackward(T)) {
            I.preventDefault(), q && Ce.isExpanded(q) ? re.deleteFragment(b, {
              direction: "backward"
            }) : re.deleteBackward(b, {
              unit: "line"
            });
            return;
          }
          if (_o.isDeleteLineForward(T)) {
            I.preventDefault(), q && Ce.isExpanded(q) ? re.deleteFragment(b, {
              direction: "forward"
            }) : re.deleteForward(b, {
              unit: "line"
            });
            return;
          }
          if (_o.isDeleteWordBackward(T)) {
            I.preventDefault(), q && Ce.isExpanded(q) ? re.deleteFragment(b, {
              direction: "backward"
            }) : re.deleteBackward(b, {
              unit: "word"
            });
            return;
          }
          if (_o.isDeleteWordForward(T)) {
            I.preventDefault(), q && Ce.isExpanded(q) ? re.deleteFragment(b, {
              direction: "forward"
            }) : re.deleteForward(b, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [s, b, y.onKeyDown]),
    onPaste: ur((I) => {
      !s && Le.hasEditableTarget(b, I.target) && !es(I, y.onPaste) && (!Cu || Jft(I.nativeEvent) || ip) && (I.preventDefault(), Le.insertData(b, I.clipboardData));
    }, [s, b, y.onPaste])
  }), /* @__PURE__ */ we.createElement(ngt, {
    decorations: X,
    node: b,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: b.selection
  }))))));
}), ogt = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ we.createElement("span", Ba({}, t), n, ns && /* @__PURE__ */ we.createElement("br", null))
  );
}, igt = () => [], sgt = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && Ce.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), bft(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, es = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, JJ = (e) => nc(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), agt = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, lgt = /* @__PURE__ */ We(!1), ugt = /* @__PURE__ */ We({});
function cgt(e) {
  var t = ht([]).current, n = ht({
    editor: e
  }).current, r = ur((i) => {
    n.editor = i, t.forEach((a) => a(i));
  }, [t, n]), o = Ft(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var pgt = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], dgt = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: a
  } = e, s = Rd(e, pgt), [l, u] = we.useState(() => {
    if (!it.isNodeList(a))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(bi.stringify(a)));
    if (!re.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(bi.stringify(t)));
    return t.children = a, Object.assign(t, s), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: p
  } = cgt(t), d = ur((y) => {
    var b;
    switch (r && r(t.children), y == null || (b = y.operation) === null || b === void 0 ? void 0 : b.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((E) => ({
      v: E.v + 1,
      editor: t
    })), p(t);
  }, [t, p, r, o, i]);
  h(() => (oT.set(t, d), () => {
    oT.set(t, () => {
    });
  }), [t, d]);
  var [g, f] = k(Le.isFocused(t));
  return h(() => {
    f(Le.isFocused(t));
  }, [t]), Cm(() => {
    var y = () => f(Le.isFocused(t));
    return Tfe >= 17 ? (document.addEventListener("focusin", y), document.addEventListener("focusout", y), () => {
      document.removeEventListener("focusin", y), document.removeEventListener("focusout", y);
    }) : (document.addEventListener("focus", y, !0), document.addEventListener("blur", y, !0), () => {
      document.removeEventListener("focus", y, !0), document.removeEventListener("blur", y, !0);
    });
  }, []), /* @__PURE__ */ we.createElement(ugt.Provider, {
    value: c
  }, /* @__PURE__ */ we.createElement(Yfe.Provider, {
    value: l
  }, /* @__PURE__ */ we.createElement(xR.Provider, {
    value: l.editor
  }, /* @__PURE__ */ we.createElement(lgt.Provider, {
    value: g
  }, n))));
}, QJ = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, eQ = (e, t, n) => {
  var r = Le.toDOMRange(e, t).getBoundingClientRect(), o = Le.toDOMRange(e, n).getBoundingClientRect();
  return QJ(r, o) && QJ(o, r);
}, fgt = (e, t) => {
  var n = re.range(e, Ce.end(t)), r = Array.from(re.positions(e, {
    at: t
  })), o = 0, i = r.length, a = Math.floor(i / 2);
  if (eQ(e, re.range(e, r[o]), n))
    return re.range(e, r[o], n);
  if (r.length < 2)
    return re.range(e, r[r.length - 1], n);
  for (; a !== r.length && a !== o; )
    eQ(e, re.range(e, r[a]), n) ? i = a : o = a, a = Math.floor((o + i) / 2);
  return re.range(e, r[i], n);
};
function tQ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nQ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tQ(Object(n), !0).forEach(function(r) {
      Ea(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tQ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hgt = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: a,
    addMark: s,
    removeMark: l
  } = r;
  return Rk.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var p, d;
    (p = kR.get(r)) === null || p === void 0 || p(), !ka.get(r) && (d = hs.get(r)) !== null && d !== void 0 && d.length && ka.set(r, null), Nl.delete(r), s(u, c);
  }, r.removeMark = (u) => {
    var c;
    !ka.get(r) && (c = hs.get(r)) !== null && c !== void 0 && c.length && ka.set(r, null), Nl.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return a(u);
    if (r.selection && Ce.isCollapsed(r.selection)) {
      var c = re.above(r, {
        match: (f) => wt.isElement(f) && re.isBlock(r, f),
        at: r.selection
      });
      if (c) {
        var [, p] = c, d = re.range(r, p, r.selection.anchor), g = fgt(r, d);
        Ce.isCollapsed(g) || $e.delete(r, {
          at: g
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], p = [], d = hs.get(r);
    if (d != null && d.length) {
      var g = d.map((H) => fht(H, u)).filter(Boolean);
      hs.set(r, g);
    }
    var f = Hu.get(r);
    f && Hu.set(r, WJ(r, f, u));
    var y = Uu.get(r);
    if (y != null && y.at) {
      var b = Kt.isPoint(y == null ? void 0 : y.at) ? aT(r, y.at, u) : WJ(r, y.at, u);
      Uu.set(r, b ? nQ(nQ({}, y), {}, {
        at: b
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...fd(r, u.path));
        break;
      }
      case "set_selection": {
        var E;
        (E = sg.get(r)) === null || E === void 0 || E.unref(), sg.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...fd(r, ce.parent(u.path)));
        break;
      }
      case "merge_node": {
        var w = ce.previous(u.path);
        c.push(...fd(r, w));
        break;
      }
      case "move_node": {
        var M = ce.common(ce.parent(u.path), ce.parent(u.newPath));
        c.push(...fd(r, M));
        var O;
        ce.isBefore(u.path, u.newPath) ? (c.push(...fd(r, ce.parent(u.path))), O = u.newPath) : (c.push(...fd(r, ce.parent(u.newPath))), O = u.path);
        var v = it.get(t, ce.parent(O)), x = Le.findKey(r, v), _ = re.pathRef(r, ce.parent(O));
        p.push([_, x]);
        break;
      }
    }
    switch (o(u), u.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node":
        Ld.set(r, !0);
    }
    for (var [z, L] of c) {
      var [N] = re.node(r, z);
      dx.set(N, L);
    }
    for (var [R, V] of p) {
      if (R.current) {
        var [Z] = re.node(r, R.current);
        dx.set(Z, V);
      }
      R.unref();
    }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [p, d] = Ce.edges(c), g = re.void(r, {
        at: p.path
      }), f = re.void(r, {
        at: d.path
      });
      if (!(Ce.isCollapsed(c) && !g)) {
        var y = Le.toDOMRange(r, c), b = y.cloneContents(), E = b.childNodes[0];
        if (b.childNodes.forEach((N) => {
          N.textContent && N.textContent.trim() !== "" && (E = N);
        }), f) {
          var [w] = f, M = y.cloneRange(), O = Le.toDOMNode(r, w);
          M.setEndAfter(O), b = M.cloneContents();
        }
        if (g && (E = b.querySelector("[data-slate-spacer]")), Array.from(b.querySelectorAll("[data-slate-zero-width]")).forEach((N) => {
          var R = N.getAttribute("data-slate-zero-width") === "n";
          N.textContent = R ? `
` : "";
        }), Ffe(E)) {
          var v = E.ownerDocument.createElement("span");
          v.style.whiteSpace = "pre", v.appendChild(E), b.appendChild(v), E = v;
        }
        var x = r.getFragment(), _ = JSON.stringify(x), z = window.btoa(encodeURIComponent(_));
        E.setAttribute("data-slate-fragment", z), u.setData("application/".concat(n), z);
        var L = b.ownerDocument.createElement("div");
        return L.appendChild(b), L.setAttribute("hidden", "true"), b.ownerDocument.body.appendChild(L), u.setData("text/html", L.innerHTML), u.setData("text/plain", Ufe(L)), b.ownerDocument.body.removeChild(L), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || rht(u);
    if (c) {
      var p = decodeURIComponent(window.atob(c)), d = JSON.parse(p);
      return r.insertFragment(d), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var p = c.split(/\r\n|\r|\n/), d = !1;
      for (var g of p)
        d && $e.splitNodes(r, {
          always: !0
        }), r.insertText(g), d = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = Tfe < 18 ? nl.unstable_batchedUpdates : (p) => p();
    c(() => {
      var p = oT.get(r);
      p && p(u), i(u);
    });
  }, r;
}, fd = (e, t) => {
  var n = [];
  for (var [r, o] of re.levels(e, {
    at: t
  })) {
    var i = Le.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function Jfe(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    re.nodes(e, {
      at: re.unhangRange(e, r),
      match: (i) => !re.isEditor(i) && wt.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const rQ = ["listItem", "numberedList"], Bw = ["left", "center", "right", "justify"];
function ggt(e, t) {
  const n = Bw.includes(t) ? "align" : "type", r = Jfe(e, t, n), o = rQ.includes(t);
  $e.unwrapNodes(e, {
    match: (a) => !re.isEditor(a) && wt.isElement(a) && rQ.includes(a.type) && !Bw.includes(t),
    split: !0
  });
  let i;
  if (Bw.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, $e.setNodes(e, i), !r && o) {
    const a = { type: t, children: [] };
    $e.wrapNodes(e, a);
  }
}
function qc({ format: e, icon: t }) {
  const n = Nk(), r = Bw.includes(e) ? "align" : "type", i = Jfe(n, e, r) ? "activeTrue" : "activeFalse";
  function a(s) {
    s.preventDefault(), ggt(n, e);
  }
  return /* @__PURE__ */ ne.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: a,
      children: /* @__PURE__ */ ne.jsx(t, {})
    }
  );
}
function mgt({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ ne.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ ne.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ ne.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ ne.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ ne.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ ne.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    case "image":
      return /* @__PURE__ */ ne.jsxs("div", { style: r, ...e, children: [
        /* @__PURE__ */ ne.jsx(
          "img",
          {
            className: "arkynElementImage",
            alt: "arkynElementImage",
            src: (n == null ? void 0 : n.src) || ""
          }
        ),
        t
      ] });
    default:
      return /* @__PURE__ */ ne.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
const Qfe = We({});
function vgt(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, s = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ ne.jsx(Qfe.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ ne.jsx(ute, { children: t && /* @__PURE__ */ ne.jsxs("aside", { className: s.trim(), ...i, children: [
    /* @__PURE__ */ ne.jsx(
      cg.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ ne.jsx(
      cg.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function ygt(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ ne.jsx("footer", { className: o.trim(), ...r });
}
function bgt(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ge(Qfe), a = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ ne.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ ne.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ ne.jsx(wT, { size: 24 })
      }
    )
  ] });
}
const uT = We({});
function wgt() {
  if (!uT)
    throw new Error("useTabContext must be used within a TabProvider");
  return ge(uT);
}
function Cgt(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [a, s] = k(r || ""), [l, u] = k(!0), c = ht(null), p = `arkynTabContainer ${o || ""}`, [d, g] = k({
    width: "0px",
    left: "0px",
    transition: "none"
  }), f = (b, E) => {
    const w = b.getBoundingClientRect(), M = c.current.getBoundingClientRect(), O = E ? void 0 : "none";
    u(!1), g({
      transition: O,
      width: `${w.width}px`,
      left: `${w.left - M.left}px`
    });
  };
  h(() => {
    const b = c.current;
    if (!b) return;
    let E = null;
    E = b.querySelector("button.activeTrue"), E && f(E);
  }, []);
  const y = (b) => {
    const E = b.target;
    E && (s(E.value), E.classList.add("activeTrue"), f(E, !0), n && n(E.value));
  };
  return /* @__PURE__ */ ne.jsxs("nav", { ref: c, className: p.trim(), ...i, children: [
    /* @__PURE__ */ ne.jsx(uT.Provider, { value: { handleTabClick: y, showInitialTab: l, value: a }, children: t }),
    /* @__PURE__ */ ne.jsx("div", { className: "activeLine", style: d })
  ] });
}
function oQ(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: a, handleTabClick: s } = wgt(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && a ? "showBorderBottom" : ""} ${l} ${n}`;
  function p(d) {
    s(d), r && r(d);
  }
  return /* @__PURE__ */ ne.jsx(
    "button",
    {
      onClick: p,
      className: c.trim(),
      ...o,
      type: "button",
      children: t
    }
  );
}
function xgt(e) {
  const {
    action: t,
    tabLabels: n = ["Adicionar URL", "Upload de arquivo"],
    modalCancelButton: r = "Cancelar",
    modalConfirmButton: o = "Confirmar",
    modalInputImageLabel: i = "Imagem:",
    modalInputUrlLabel: a = "URL da imagem:",
    modalTitle: s = "Inserir imagem"
  } = e, l = Nk(), [u, c] = k(!1), [p, d] = k(""), [g, f] = k("url");
  function y(b) {
    b.preventDefault(), !(!p || p === "") && (l.insertNodes([
      { type: "paragraph", children: [{ text: "" }] },
      { type: "image", src: p, children: [{ text: "" }] },
      { type: "paragraph", children: [{ text: "" }] }
    ]), c(!1));
  }
  return /* @__PURE__ */ ne.jsxs(ne.Fragment, { children: [
    /* @__PURE__ */ ne.jsx(
      "button",
      {
        type: "button",
        className: "arkynRichTextInsertImage",
        onMouseDown: () => c(!0),
        children: /* @__PURE__ */ ne.jsx(cge, {})
      }
    ),
    /* @__PURE__ */ ne.jsxs(
      vgt,
      {
        isVisibled: u,
        makeInvisible: () => c(!1),
        children: [
          /* @__PURE__ */ ne.jsx(bgt, { children: s }),
          /* @__PURE__ */ ne.jsxs("div", { className: "arkynRichTextInsertImageModalContent", children: [
            /* @__PURE__ */ ne.jsxs(Cgt, { defaultActive: g, onClick: f, children: [
              /* @__PURE__ */ ne.jsx(oQ, { value: "url", children: n[0] }),
              /* @__PURE__ */ ne.jsx(oQ, { value: "file", children: n[1] })
            ] }),
            g === "url" && /* @__PURE__ */ ne.jsxs(ne.Fragment, { children: [
              /* @__PURE__ */ ne.jsxs(vJ, { children: [
                /* @__PURE__ */ ne.jsx(yJ, { children: a }),
                /* @__PURE__ */ ne.jsx(
                  Ik,
                  {
                    type: "text",
                    name: "richTextimageURL",
                    defaultValue: p,
                    onChange: (b) => d(b.target.value)
                  }
                )
              ] }),
              p && /* @__PURE__ */ ne.jsx(
                "img",
                {
                  className: "arkynRichTextInsertImageModalPreviewImage",
                  src: p,
                  alt: "preview"
                }
              )
            ] }),
            g === "file" && /* @__PURE__ */ ne.jsxs(vJ, { children: [
              /* @__PURE__ */ ne.jsx(yJ, { children: i }),
              /* @__PURE__ */ ne.jsx(
                Opt,
                {
                  name: "richTextimageURL",
                  action: t,
                  defaultValue: p,
                  onUpload: (b) => d(b || "")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ ne.jsxs(ygt, { children: [
            /* @__PURE__ */ ne.jsx(
              vm,
              {
                type: "button",
                scheme: "danger",
                variant: "outline",
                onClick: () => c(!1),
                children: r
              }
            ),
            /* @__PURE__ */ ne.jsx(vm, { type: "button", onClick: y, children: o })
          ] })
        ]
      }
    )
  ] });
}
function Ogt({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ ne.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ ne.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ ne.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ ne.jsx("u", { children: t })), /* @__PURE__ */ ne.jsx("span", { ...e, children: t });
}
function ehe(e, t) {
  const n = re.marks(e);
  return n ? n[t] === !0 : !1;
}
function the(e, t) {
  ehe(e, t) ? re.removeMark(e, t) : re.addMark(e, t, !0);
}
function fw({ format: e, icon: t }) {
  const n = Nk(), o = ehe(n, e) ? "activeTrue" : "activeFalse";
  function i(a) {
    a.preventDefault(), the(n, e);
  }
  return /* @__PURE__ */ ne.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ ne.jsx(t, {})
    }
  );
}
function Egt({ children: e }) {
  return /* @__PURE__ */ ne.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
function iQ(e) {
  return e.map((t) => it.string(t)).join("");
}
const sQ = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, hw = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
function Zwt(e) {
  const {
    name: t,
    hiddenButtons: n,
    imageConfig: r,
    defaultValue: o = "[]",
    enforceCharacterLimit: i = !1,
    onChangeCharactersCount: a,
    maxLimit: s = 2e3,
    onChange: l,
    isError: u
  } = e, c = Ft(() => idt(hgt(sye())), []), { id: p, inputRef: d, error: g } = fs(), f = ht(null);
  function y() {
    try {
      const X = JSON.parse(o);
      return !Array.isArray(X) || X.length <= 0 ? hw : X.every(
        (J) => typeof J == "object" && J !== null && "type" in J && "children" in J
      ) ? X : hw;
    } catch {
      return hw;
    }
  }
  const b = iQ(y()), [E, w] = k(b.length), [M, O] = k(
    JSON.stringify(y()) || "[]"
  ), [v, x] = k(!1), _ = d || f, z = u || !!g, L = ur(Ogt, []), N = ur(mgt, []);
  function R(X) {
    const Q = iQ(X);
    w(Q.length), a && a(Q.length), !(i && Q.length >= s) && (O(JSON.stringify(X)), l && l(X), c.children = X, $e.setNodes(c, { children: X }));
  }
  const V = v ? "focusTrue" : "focusFalse", H = `arkynRichText ${z || s < E ? "errorTrue" : "errorFalse"} ${V}`, $ = s - E;
  function K(X) {
    return !(n != null && n.includes(X));
  }
  return /* @__PURE__ */ ne.jsxs(
    dgt,
    {
      editor: c,
      initialValue: y(),
      onChange: R,
      onValueChange: R,
      children: [
        /* @__PURE__ */ ne.jsxs("div", { className: H, children: [
          /* @__PURE__ */ ne.jsxs(Egt, { children: [
            K("headingOne") && /* @__PURE__ */ ne.jsx(qc, { format: "headingOne", icon: pge }),
            K("headingTwo") && /* @__PURE__ */ ne.jsx(qc, { format: "headingTwo", icon: dge }),
            K("blockQuote") && /* @__PURE__ */ ne.jsx(qc, { format: "blockQuote", icon: fge }),
            K("bold") && /* @__PURE__ */ ne.jsx(fw, { format: "bold", icon: hge }),
            K("italic") && /* @__PURE__ */ ne.jsx(fw, { format: "italic", icon: gge }),
            K("underline") && /* @__PURE__ */ ne.jsx(fw, { format: "underline", icon: mge }),
            K("code") && /* @__PURE__ */ ne.jsx(fw, { format: "code", icon: vge }),
            K("left") && /* @__PURE__ */ ne.jsx(qc, { format: "left", icon: yge }),
            K("right") && /* @__PURE__ */ ne.jsx(qc, { format: "right", icon: bge }),
            K("center") && /* @__PURE__ */ ne.jsx(qc, { format: "center", icon: wge }),
            K("justify") && /* @__PURE__ */ ne.jsx(qc, { format: "justify", icon: Cge }),
            r && K("image") && /* @__PURE__ */ ne.jsx(xgt, { ...r })
          ] }),
          /* @__PURE__ */ ne.jsx(
            rgt,
            {
              className: "editorContainer",
              renderElement: N,
              renderLeaf: L,
              spellCheck: !0,
              id: p,
              onFocus: () => x(!0),
              onBlur: () => x(!1),
              onKeyDown: (X) => {
                for (const Q in sQ)
                  if (rdt(Q, X)) {
                    X.preventDefault();
                    const J = sQ[Q];
                    the(c, J);
                  }
              }
            }
          ),
          $ < 0 && /* @__PURE__ */ ne.jsx("div", { className: "restatesCharacters", children: $ })
        ] }),
        /* @__PURE__ */ ne.jsx("input", { type: "hidden", ref: _, name: t, value: M }),
        /* @__PURE__ */ ne.jsx("input", { type: "hidden", name: `${t}Count`, value: E })
      ]
    }
  );
}
function kgt(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: p,
    onBlur: d,
    title: g,
    style: f,
    closeOnSelect: y = !0,
    ...b
  } = e, v = `arkyn_select ${s ? "hasPrefix" : ""} ${a} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, _ = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: v,
    prefix: Wte(s, _, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: p,
    onBlur: d,
    title: g,
    closeOnSelect: y,
    style: f,
    iconSize: _,
    Spinner: /* @__PURE__ */ ne.jsx(el, { className: "spinner", size: _, strokeWidth: 2.5 }),
    ...b
  };
}
function qwt(e) {
  var U;
  const [t, n] = k(""), [r, o] = k(!1), { inputRef: i, id: a, error: s } = fs(), l = ht(null), u = i || l, c = e.isError || !!s, {
    disabled: p,
    title: d,
    style: g,
    className: f,
    prefix: y,
    iconSize: b,
    isLoading: E,
    LeftIcon: w,
    value: M = null,
    defaultValue: O = "",
    onFocus: v,
    onBlur: x,
    Spinner: _,
    name: z,
    placeholder: L,
    onSelect: N,
    options: R,
    optionMaxHeight: V,
    closeOnSelect: Z,
    isSearchable: H,
    onSearch: $,
    ...K
  } = kgt({ ...e, id: a, isError: c }, r), [X, Q] = k(O);
  function J() {
    p || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function P(T) {
    $ && (n(""), $(T.target.value)), $ || n(T.target.value);
  }
  function D(T) {
    r || (o(!0), v && v(T));
  }
  function F() {
    o(!1), x && u.current && u.current.blur();
  }
  function S(T) {
    const { label: q, value: j } = T;
    Q(X !== j ? j : ""), N && N({ label: q, value: j }), Z && F();
  }
  const W = typeof M == "string" ? M : X, C = ((U = R.find((T) => T.value === W)) == null ? void 0 : U.label) || "", I = () => {
    if (!r && C) return !0;
    if (!r && !C) return !1;
    if (r && C) return !0;
    if (r && !C) return !1;
  };
  return /* @__PURE__ */ ne.jsxs(ne.Fragment, { children: [
    /* @__PURE__ */ ne.jsxs(
      "section",
      {
        title: d,
        style: g,
        onClick: J,
        className: `${f} placeholder_dark_${I()}`,
        children: [
          y,
          w && /* @__PURE__ */ ne.jsx(w, { size: b, strokeWidth: 2.5 }),
          /* @__PURE__ */ ne.jsx(
            "input",
            {
              disabled: p,
              readOnly: !0,
              placeholder: C || L,
              onFocus: D,
              ...K
            }
          ),
          /* @__PURE__ */ ne.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: z,
              value: W || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ ne.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: V },
              children: [
                H && /* @__PURE__ */ ne.jsx(
                  Ik,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: ste,
                    onChange: P
                  }
                ),
                R.filter((T) => !!(e.onSearch || !e.isSearchable || T.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: T, value: q }) => /* @__PURE__ */ ne.jsxs(
                  "div",
                  {
                    onClick: () => S({ label: T, value: q }),
                    className: W === q ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      T,
                      " ",
                      /* @__PURE__ */ ne.jsx(Ex, {})
                    ]
                  },
                  q
                )),
                R.length <= 0 && /* @__PURE__ */ ne.jsx("p", { children: "Sem opções disponíveis" })
              ]
            }
          ),
          !E && /* @__PURE__ */ ne.jsx(
            bT,
            {
              className: "arkyn_select_arrow",
              size: b,
              strokeWidth: 2.5
            }
          ),
          E && _
        ]
      }
    ),
    r && /* @__PURE__ */ ne.jsx("aside", { className: "arkyn_select_overlay", onClick: F })
  ] });
}
function Gwt(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: a,
    className: s = "",
    onCheck: l,
    ...u
  } = e, [c, p] = k(n), { id: d, inputRef: g } = fs(), f = typeof r == "boolean" ? r : c;
  function y() {
    p(!c), l && l(f ? i : o || "checked");
  }
  const E = `arkynSwitch ${f ? "checkedTrue" : "checkedFalse"} ${t} ${s}`;
  return /* @__PURE__ */ ne.jsx("button", { type: "button", onClick: y, className: E, ...u, children: /* @__PURE__ */ ne.jsx(
    "input",
    {
      id: d,
      type: "hidden",
      name: a,
      ref: g,
      onClick: y,
      value: f ? o || "checked" : i
    }
  ) });
}
function Kwt(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: a,
    onBlur: s,
    title: l,
    style: u,
    ...c
  } = e, [p, d] = k(!1), { inputRef: g, id: f, error: y } = fs(), b = ht(null), E = g || b, M = e.isError || !!y ? "errorTrue" : "errorFalse", x = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${M} ${p ? "focusedTrue" : "focusedFalse"} ${r}`;
  function _() {
    o || !(E != null && E.current) || (d(!0), E.current.focus());
  }
  function z(N) {
    d(!0), a && a(N);
  }
  function L(N) {
    d(!1), s && s(N);
  }
  return /* @__PURE__ */ ne.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: _,
      className: x,
      children: /* @__PURE__ */ ne.jsx(
        "textarea",
        {
          id: f,
          disabled: o,
          readOnly: i,
          ref: E,
          onFocus: z,
          onBlur: L,
          ...c
        }
      )
    }
  );
}
function Ywt(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ ne.jsx("nav", { className: r, ...n });
}
function Xwt(e) {
  const { pathname: t } = OT(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...a
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ ne.jsxs("p", { className: l, children: [
    /* @__PURE__ */ ne.jsx(sS, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ ne.jsxs(Ege, { to: i, className: l, ...a, children: [
    /* @__PURE__ */ ne.jsx(sS, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function nhe(e = "") {
  const t = OT(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([a, s]) => {
      s === void 0 ? n.delete(`${r}${a}`) : n.set(`${r}${a}`, String(s));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let a = n.toString();
      return a && (a = "?" + a), a;
    }
  };
}
function aQ(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function Jwt(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    currentPage: a = 1,
    registerPerPage: s = 20,
    ...l
  } = e, u = lte(), { getParam: c, getScopedSearch: p } = nhe(t), d = Number(c("page")) || a, g = Number(c("per_page")) || s, f = Math.ceil(n / g), y = d > 1 ? aQ(d - 1 - i, d - 1) : [], b = d < f ? aQ(
    d,
    Math.min(d + i, f)
  ) : [];
  function E(w) {
    u(p({ page: w }));
  }
  return /* @__PURE__ */ ne.jsxs("div", { className: "arkynPagination", ...l, children: [
    /* @__PURE__ */ ne.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d <= 1,
        onClick: () => E(d - 1),
        children: /* @__PURE__ */ ne.jsx(xge, {})
      }
    ),
    d > 1 + i && /* @__PURE__ */ ne.jsxs(ne.Fragment, { children: [
      /* @__PURE__ */ ne.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => E(1),
          children: "1"
        }
      ),
      d > 2 + i && /* @__PURE__ */ ne.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ ne.jsx(UR, {}) })
    ] }),
    y.length > 0 && y.map((w, M) => /* @__PURE__ */ ne.jsx(
      "button",
      {
        onClick: () => E(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      M
    )),
    /* @__PURE__ */ ne.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: d }),
    b.length > 0 && b.map((w, M) => /* @__PURE__ */ ne.jsx(
      "button",
      {
        onClick: () => E(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      M
    )),
    d + i < f && /* @__PURE__ */ ne.jsxs(ne.Fragment, { children: [
      d + 1 + i < f && /* @__PURE__ */ ne.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ ne.jsx(UR, {}) }),
      /* @__PURE__ */ ne.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => E(f),
          children: f
        }
      )
    ] }),
    /* @__PURE__ */ ne.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d >= f,
        onClick: () => E(d + 1),
        children: /* @__PURE__ */ ne.jsx(sS, {})
      }
    )
  ] });
}
const rhe = We({});
function Qwt(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...a
  } = e, s = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ ne.jsx(rhe.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ ne.jsx(ute, { children: t && /* @__PURE__ */ ne.jsxs("aside", { className: u.trim(), ...a, children: [
    /* @__PURE__ */ ne.jsx(
      cg.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ ne.jsx(
      cg.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${s})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${s})` },
        children: o
      }
    )
  ] }) }) });
}
function e0t(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ge(rhe), a = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ ne.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ ne.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ ne.jsx(wT, { size: 24 })
      }
    )
  ] });
}
function t0t(e) {
  const {
    children: t,
    button: n,
    closeOnClick: r,
    className: o = "",
    orientation: i = "bottomLeft"
  } = e, [a, s] = k(!1), u = `arkynPopover ${i} ${a ? "visibleTrue" : "visibleFalse"} ${o}`;
  function c() {
    a || s(!0);
  }
  return /* @__PURE__ */ ne.jsxs("div", { className: u, onClick: c, children: [
    n,
    /* @__PURE__ */ ne.jsx(
      cg.div,
      {
        style: { visibility: a ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: a ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && s(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    a && /* @__PURE__ */ ne.jsx("div", { onClick: () => s(!1), className: "arkynPopoverOverlay" })
  ] });
}
function n0t(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ ne.jsx(ite, {});
      case "danger":
        return /* @__PURE__ */ ne.jsx(ote, {});
      default:
        return /* @__PURE__ */ ne.jsx(rte, {});
    }
  }
  return /* @__PURE__ */ ne.jsxs("div", { className: r, children: [
    /* @__PURE__ */ ne.jsxs("div", { children: [
      /* @__PURE__ */ ne.jsx("div", { className: "bg" }),
      /* @__PURE__ */ ne.jsx(o, {})
    ] }),
    /* @__PURE__ */ ne.jsx("p", { children: /* @__PURE__ */ ne.jsx("span", { children: t }) })
  ] });
}
var ui = {}, _R = {}, kv = {}, Lv = {}, ohe = "Expected a function", lQ = NaN, Lgt = "[object Symbol]", Pgt = /^\s+|\s+$/g, _gt = /^[-+]0x[0-9a-f]+$/i, Sgt = /^0b[01]+$/i, Mgt = /^0o[0-7]+$/i, Dgt = parseInt, Tgt = typeof Pr == "object" && Pr && Pr.Object === Object && Pr, jgt = typeof self == "object" && self && self.Object === Object && self, Agt = Tgt || jgt || Function("return this")(), Igt = Object.prototype, Bgt = Igt.toString, Rgt = Math.max, Ngt = Math.min, V_ = function() {
  return Agt.Date.now();
};
function Fgt(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(ohe);
  t = uQ(t) || 0, fx(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Rgt(uQ(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(x) {
    var _ = r, z = o;
    return r = o = void 0, u = x, a = e.apply(z, _), a;
  }
  function f(x) {
    return u = x, s = setTimeout(E, t), c ? g(x) : a;
  }
  function y(x) {
    var _ = x - l, z = x - u, L = t - _;
    return p ? Ngt(L, i - z) : L;
  }
  function b(x) {
    var _ = x - l, z = x - u;
    return l === void 0 || _ >= t || _ < 0 || p && z >= i;
  }
  function E() {
    var x = V_();
    if (b(x))
      return w(x);
    s = setTimeout(E, y(x));
  }
  function w(x) {
    return s = void 0, d && r ? g(x) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(V_());
  }
  function v() {
    var x = V_(), _ = b(x);
    if (r = arguments, o = this, l = x, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = O, v;
}
function zgt(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(ohe);
  return fx(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Fgt(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function fx(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Ugt(e) {
  return !!e && typeof e == "object";
}
function Hgt(e) {
  return typeof e == "symbol" || Ugt(e) && Bgt.call(e) == Lgt;
}
function uQ(e) {
  if (typeof e == "number")
    return e;
  if (Hgt(e))
    return lQ;
  if (fx(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = fx(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Pgt, "");
  var n = Sgt.test(e);
  return n || Mgt.test(e) ? Dgt(e.slice(2), n ? 2 : 8) : _gt.test(e) ? lQ : +e;
}
var Wgt = zgt, Pv = {};
Object.defineProperty(Pv, "__esModule", {
  value: !0
});
Pv.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), Rw.has(n) || Rw.set(n, /* @__PURE__ */ new Set());
  var i = Rw.get(n);
  if (!i.has(o)) {
    var a = function() {
      var s = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return s;
    }();
    t.addEventListener(n, r, a ? { passive: !0 } : !1), i.add(o);
  }
};
Pv.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), Rw.get(n).delete(r.name || n);
};
var Rw = /* @__PURE__ */ new Map();
Object.defineProperty(Lv, "__esModule", {
  value: !0
});
var Vgt = Wgt, $gt = Zgt(Vgt), cQ = Pv;
function Zgt(e) {
  return e && e.__esModule ? e : { default: e };
}
var qgt = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, $gt.default)(t, n);
}, Ro = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = qgt(function(o) {
        Ro.scrollHandler(t);
      }, n);
      return Ro.scrollSpyContainers.push(t), (0, cQ.addPassiveEventListener)(t, "scroll", r), function() {
        (0, cQ.removePassiveEventListener)(t, "scroll", r), Ro.scrollSpyContainers.splice(Ro.scrollSpyContainers.indexOf(t), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(t) {
    return Ro.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.scrollY !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.scrollX : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.scrollX !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.scrollY : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = Ro.scrollSpyContainers[Ro.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(Ro.currentPositionX(t), Ro.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    Ro.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = Ro.scrollSpyContainers[Ro.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t);
  },
  updateStates: function() {
    Ro.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    Ro.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), Ro.spySetState && Ro.spySetState.length && Ro.spySetState.indexOf(t) > -1 && Ro.spySetState.splice(Ro.spySetState.indexOf(t), 1), document.removeEventListener("scroll", Ro.scrollHandler);
  },
  update: function() {
    return Ro.scrollSpyContainers.forEach(function(t) {
      return Ro.scrollHandler(t);
    });
  }
};
Lv.default = Ro;
var pf = {}, _v = {};
Object.defineProperty(_v, "__esModule", {
  value: !0
});
var Ggt = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, a = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", a) : history.replaceState(history.state, "", a);
}, Kgt = function() {
  return window.location.hash.replace(/^#/, "");
}, Ygt = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, Xgt = function(t) {
  return getComputedStyle(t).position !== "static";
}, $_ = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, Jgt = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Xgt(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = $_(n, o), a = i.offsetTop, s = i.offsetParent;
      if (s !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return a;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return $_(n, l).offsetTop - $_(t, l).offsetTop;
};
_v.default = {
  updateHash: Ggt,
  getHash: Kgt,
  filterElementInContainer: Ygt,
  scrollOffset: Jgt
};
var Fk = {}, SR = {};
Object.defineProperty(SR, "__esModule", {
  value: !0
});
SR.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var MR = {};
Object.defineProperty(MR, "__esModule", {
  value: !0
});
var Qgt = Pv, emt = ["mousedown", "wheel", "touchmove", "keydown"];
MR.default = {
  subscribe: function(t) {
    return typeof document < "u" && emt.forEach(function(n) {
      return (0, Qgt.addPassiveEventListener)(document, n, t);
    });
  }
};
var Sv = {};
Object.defineProperty(Sv, "__esModule", {
  value: !0
});
var cT = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      cT.registered[t] = n;
    },
    remove: function(t) {
      cT.registered[t] = null;
    }
  }
};
Sv.default = cT;
Object.defineProperty(Fk, "__esModule", {
  value: !0
});
var tmt = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, nmt = _v;
zk(nmt);
var rmt = SR, pQ = zk(rmt), omt = MR, imt = zk(omt), smt = Sv, $a = zk(smt);
function zk(e) {
  return e && e.__esModule ? e : { default: e };
}
var ihe = function(t) {
  return pQ.default[t.smooth] || pQ.default.defaultEasing;
}, amt = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, lmt = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, pT = function() {
  return lmt() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), she = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, ahe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, lhe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, umt = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, cmt = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, pmt = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    $a.default.registered.end && $a.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    pT.call(window, i);
    return;
  }
  $a.default.registered.end && $a.default.registered.end(o.to, o.target, o.currentPosition);
}, DR = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, Mv = function(t, n, r, o) {
  n.data = n.data || she(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (imt.default.subscribe(i), DR(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? ahe(n) : lhe(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    $a.default.registered.end && $a.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = amt(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var a = ihe(n), s = pmt.bind(null, a, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      $a.default.registered.begin && $a.default.registered.begin(n.data.to, n.data.target), pT.call(window, s);
    }, n.delay);
    return;
  }
  $a.default.registered.begin && $a.default.registered.begin(n.data.to, n.data.target), pT.call(window, s);
}, Uk = function(t) {
  return t = tmt({}, t), t.data = t.data || she(), t.absolute = !0, t;
}, dmt = function(t) {
  Mv(0, Uk(t));
}, fmt = function(t, n) {
  Mv(t, Uk(n));
}, hmt = function(t) {
  t = Uk(t), DR(t), Mv(t.horizontal ? umt(t) : cmt(t), t);
}, gmt = function(t, n) {
  n = Uk(n), DR(n);
  var r = n.horizontal ? ahe(n) : lhe(n);
  Mv(t + r, n);
};
Fk.default = {
  animateTopScroll: Mv,
  getAnimationType: ihe,
  scrollToTop: dmt,
  scrollToBottom: hmt,
  scrollTo: fmt,
  scrollMore: gmt
};
Object.defineProperty(pf, "__esModule", {
  value: !0
});
var mmt = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, vmt = _v, ymt = TR(vmt), bmt = Fk, wmt = TR(bmt), Cmt = Sv, gw = TR(Cmt);
function TR(e) {
  return e && e.__esModule ? e : { default: e };
}
var mw = {}, dQ = void 0;
pf.default = {
  unmount: function() {
    mw = {};
  },
  register: function(t, n) {
    mw[t] = n;
  },
  unregister: function(t) {
    delete mw[t];
  },
  get: function(t) {
    return mw[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return dQ = t;
  },
  getActiveLink: function() {
    return dQ;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = mmt({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, a = void 0;
    o ? a = document.getElementById(o) : i && i.nodeType ? a = i : a = document, n.absolute = !0;
    var s = n.horizontal, l = ymt.default.scrollOffset(a, r, s) + (n.offset || 0);
    if (!n.smooth) {
      gw.default.registered.begin && gw.default.registered.begin(t, r), a === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : a.scrollTop = l, gw.default.registered.end && gw.default.registered.end(t, r);
      return;
    }
    wmt.default.animateTopScroll(l, n, t, r);
  }
};
var dT = { exports: {} }, vw = { exports: {} }, ar = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fQ;
function xmt() {
  if (fQ) return ar;
  fQ = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function O(v) {
    return M(v) === u;
  }
  return ar.AsyncMode = l, ar.ConcurrentMode = u, ar.ContextConsumer = s, ar.ContextProvider = a, ar.Element = t, ar.ForwardRef = c, ar.Fragment = r, ar.Lazy = f, ar.Memo = g, ar.Portal = n, ar.Profiler = i, ar.StrictMode = o, ar.Suspense = p, ar.isAsyncMode = function(v) {
    return O(v) || M(v) === l;
  }, ar.isConcurrentMode = O, ar.isContextConsumer = function(v) {
    return M(v) === s;
  }, ar.isContextProvider = function(v) {
    return M(v) === a;
  }, ar.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, ar.isForwardRef = function(v) {
    return M(v) === c;
  }, ar.isFragment = function(v) {
    return M(v) === r;
  }, ar.isLazy = function(v) {
    return M(v) === f;
  }, ar.isMemo = function(v) {
    return M(v) === g;
  }, ar.isPortal = function(v) {
    return M(v) === n;
  }, ar.isProfiler = function(v) {
    return M(v) === i;
  }, ar.isStrictMode = function(v) {
    return M(v) === o;
  }, ar.isSuspense = function(v) {
    return M(v) === p;
  }, ar.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === y);
  }, ar.typeOf = M, ar;
}
var lr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hQ;
function Omt() {
  return hQ || (hQ = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, y = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === b || B.$$typeof === E || B.$$typeof === w || B.$$typeof === y);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var le = B.$$typeof;
        switch (le) {
          case t:
            var he = B.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, x = u, _ = s, z = a, L = t, N = c, R = r, V = f, Z = g, H = n, $ = i, K = o, X = p, Q = !1;
    function J(B) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function F(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function W(B) {
      return O(B) === c;
    }
    function C(B) {
      return O(B) === r;
    }
    function I(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function j(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    lr.AsyncMode = v, lr.ConcurrentMode = x, lr.ContextConsumer = _, lr.ContextProvider = z, lr.Element = L, lr.ForwardRef = N, lr.Fragment = R, lr.Lazy = V, lr.Memo = Z, lr.Portal = H, lr.Profiler = $, lr.StrictMode = K, lr.Suspense = X, lr.isAsyncMode = J, lr.isConcurrentMode = P, lr.isContextConsumer = D, lr.isContextProvider = F, lr.isElement = S, lr.isForwardRef = W, lr.isFragment = C, lr.isLazy = I, lr.isMemo = U, lr.isPortal = T, lr.isProfiler = q, lr.isStrictMode = j, lr.isSuspense = Y, lr.isValidElementType = M, lr.typeOf = O;
  }()), lr;
}
var gQ;
function uhe() {
  return gQ || (gQ = 1, process.env.NODE_ENV === "production" ? vw.exports = xmt() : vw.exports = Omt()), vw.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Z_, mQ;
function Emt() {
  if (mQ) return Z_;
  mQ = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Z_ = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, Z_;
}
var q_, vQ;
function jR() {
  if (vQ) return q_;
  vQ = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return q_ = e, q_;
}
var G_, yQ;
function che() {
  return yQ || (yQ = 1, G_ = Function.call.bind(Object.prototype.hasOwnProperty)), G_;
}
var K_, bQ;
function kmt() {
  if (bQ) return K_;
  bQ = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = jR(), n = {}, r = che();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, K_ = o, K_;
}
var Y_, wQ;
function Lmt() {
  if (wQ) return Y_;
  wQ = 1;
  var e = uhe(), t = Emt(), n = jR(), r = che(), o = kmt(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Y_ = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: v(),
      instanceOf: x,
      node: N(),
      objectOf: z,
      oneOf: _,
      oneOfType: L,
      shape: V,
      exact: Z
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function y(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    y.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, F = 0;
      function S(C, I, U, T, q, j, Y) {
        if (T = T || d, j = j || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            F < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + j + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, F++);
          }
        }
        return I[U] == null ? C ? I[U] === null ? new y("The " + q + " `" + j + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new y("The " + q + " `" + j + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(I, U, T, q, j);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(P) {
      function D(F, S, W, C, I, U) {
        var T = F[S], q = K(T);
        if (q !== P) {
          var j = X(T);
          return new y(
            "Invalid " + C + " `" + I + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = F[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var j = P(U, q, W, C, I + "[" + q + "]", n);
          if (j instanceof Error)
            return j;
        }
        return null;
      }
      return b(D);
    }
    function O() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!s(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function v() {
      function P(D, F, S, W, C) {
        var I = D[F];
        if (!e.isValidElementType(I)) {
          var U = K(I);
          return new y("Invalid " + W + " `" + C + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function x(P) {
      function D(F, S, W, C, I) {
        if (!(F[S] instanceof P)) {
          var U = P.name || d, T = J(F[S]);
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(F, S, W, C, I) {
        for (var U = F[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(Y, B) {
          var le = X(B);
          return le === "symbol" ? String(B) : B;
        });
        return new y("Invalid " + C + " `" + I + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function z(P) {
      function D(F, S, W, C, I) {
        if (typeof P != "function")
          return new y("Property `" + I + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var j = P(U, q, W, C, I + "." + q, n);
            if (j instanceof Error)
              return j;
          }
        return null;
      }
      return b(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var F = P[D];
        if (typeof F != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(F) + " at index " + D + "."
          ), a;
      }
      function S(W, C, I, U, T) {
        for (var q = [], j = 0; j < P.length; j++) {
          var Y = P[j], B = Y(W, C, I, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new y("Invalid " + U + " `" + T + "` supplied to " + ("`" + I + "`" + le + "."));
      }
      return b(S);
    }
    function N() {
      function P(D, F, S, W, C) {
        return H(D[F]) ? null : new y("Invalid " + W + " `" + C + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, D, F, S, W) {
      return new y(
        (P || "React class") + ": " + D + " type `" + F + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function V(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in P) {
          var j = P[q];
          if (typeof j != "function")
            return R(W, C, I, q, X(j));
          var Y = j(U, q, W, C, I + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(D);
    }
    function Z(P) {
      function D(F, S, W, C, I) {
        var U = F[S], T = K(U);
        if (T !== "object")
          return new y("Invalid " + C + " `" + I + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, F[S], P);
        for (var j in q) {
          var Y = P[j];
          if (r(P, j) && typeof Y != "function")
            return R(W, C, I, j, X(Y));
          if (!Y)
            return new y(
              "Invalid " + C + " `" + I + "` key `" + j + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(F[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, j, W, C, I + "." + j, n);
          if (B)
            return B;
        }
        return null;
      }
      return b(D);
    }
    function H(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(H);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var F = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = F.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = F.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function $(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : $(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, Y_;
}
var X_, CQ;
function Pmt() {
  if (CQ) return X_;
  CQ = 1;
  var e = jR();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, X_ = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, X_;
}
if (process.env.NODE_ENV !== "production") {
  var _mt = uhe(), Smt = !0;
  dT.exports = Lmt()(_mt.isElement, Smt);
} else
  dT.exports = Pmt()();
var Hk = dT.exports, Wk = {};
Object.defineProperty(Wk, "__esModule", {
  value: !0
});
var Mmt = _v, J_ = Dmt(Mmt);
function Dmt(e) {
  return e && e.__esModule ? e : { default: e };
}
var Tmt = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return J_.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && J_.default.getHash() !== t && J_.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Wk.default = Tmt;
Object.defineProperty(kv, "__esModule", {
  value: !0
});
var yw = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, jmt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Amt = we, xQ = Dv(Amt), Imt = Lv, bw = Dv(Imt), Bmt = pf, Rmt = Dv(Bmt), Nmt = Hk, Po = Dv(Nmt), Fmt = Wk, xu = Dv(Fmt);
function Dv(e) {
  return e && e.__esModule ? e : { default: e };
}
function zmt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Umt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Hmt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var OQ = {
  to: Po.default.string.isRequired,
  containerId: Po.default.string,
  container: Po.default.object,
  activeClass: Po.default.string,
  activeStyle: Po.default.object,
  spy: Po.default.bool,
  horizontal: Po.default.bool,
  smooth: Po.default.oneOfType([Po.default.bool, Po.default.string]),
  offset: Po.default.number,
  delay: Po.default.number,
  isDynamic: Po.default.bool,
  onClick: Po.default.func,
  duration: Po.default.oneOfType([Po.default.number, Po.default.func]),
  absolute: Po.default.bool,
  onSetActive: Po.default.func,
  onSetInactive: Po.default.func,
  ignoreCancelEvents: Po.default.bool,
  hashSpy: Po.default.bool,
  saveHashHistory: Po.default.bool,
  spyThrottle: Po.default.number
};
kv.default = function(e, t) {
  var n = t || Rmt.default, r = function(i) {
    Hmt(a, i);
    function a(s) {
      zmt(this, a);
      var l = Umt(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return jmt(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          if (!bw.default.isMounted(l)) {
            var u = bw.default.mount(l, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(u);
          }
          this.props.hashSpy && (xu.default.isMounted() || xu.default.mount(n), xu.default.mapContainer(this.props.to, l)), bw.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        bw.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(l) {
          return l();
        });
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = yw({}, this.props.style, this.props.activeStyle) : u = yw({}, this.props.style);
        var c = yw({}, this.props);
        for (var p in OQ)
          c.hasOwnProperty(p) && delete c[p];
        return c.className = l, c.style = u, c.onClick = this.handleClick, xQ.default.createElement(e, c);
      }
    }]), a;
  }(xQ.default.PureComponent), o = function() {
    var a = this;
    this.scrollTo = function(s, l) {
      n.scrollTo(s, yw({}, a.state, l));
    }, this.handleClick = function(s) {
      a.props.onClick && a.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), a.scrollTo(a.props.to, a.props);
    }, this.spyHandler = function(s, l) {
      var u = a.getScrollSpyContainer();
      if (!(xu.default.isMounted() && !xu.default.isInitialized())) {
        var c = a.props.horizontal, p = a.props.to, d = null, g = void 0, f = void 0;
        if (c) {
          var y = 0, b = 0, E = 0;
          if (u.getBoundingClientRect) {
            var w = u.getBoundingClientRect();
            E = w.left;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var M = d.getBoundingClientRect();
            y = M.left - E + s, b = y + M.width;
          }
          var O = s - a.props.offset;
          g = O >= Math.floor(y) && O < Math.floor(b), f = O < Math.floor(y) || O >= Math.floor(b);
        } else {
          var v = 0, x = 0, _ = 0;
          if (u.getBoundingClientRect) {
            var z = u.getBoundingClientRect();
            _ = z.top;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var L = d.getBoundingClientRect();
            v = L.top - _ + l, x = v + L.height;
          }
          var N = l - a.props.offset;
          g = N >= Math.floor(v) && N < Math.floor(x), f = N < Math.floor(v) || N >= Math.floor(x);
        }
        var R = n.getActiveLink();
        if (f) {
          if (p === R && n.setActiveLink(void 0), a.props.hashSpy && xu.default.getHash() === p) {
            var V = a.props.saveHashHistory, Z = V === void 0 ? !1 : V;
            xu.default.changeHash("", Z);
          }
          a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive(p, d));
        }
        if (g && (R !== p || a.state.active === !1)) {
          n.setActiveLink(p);
          var H = a.props.saveHashHistory, $ = H === void 0 ? !1 : H;
          a.props.hashSpy && xu.default.changeHash(p, $), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(p, d));
        }
      }
    };
  };
  return r.propTypes = OQ, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(_R, "__esModule", {
  value: !0
});
var Wmt = we, EQ = phe(Wmt), Vmt = kv, $mt = phe(Vmt);
function phe(e) {
  return e && e.__esModule ? e : { default: e };
}
function Zmt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function kQ(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function qmt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Gmt = function(e) {
  qmt(t, e);
  function t() {
    var n, r, o, i;
    Zmt(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = kQ(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return EQ.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), kQ(o, i);
  }
  return t;
}(EQ.default.Component);
_R.default = (0, $mt.default)(Gmt);
var AR = {};
Object.defineProperty(AR, "__esModule", {
  value: !0
});
var Kmt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Ymt = we, LQ = dhe(Ymt), Xmt = kv, Jmt = dhe(Xmt);
function dhe(e) {
  return e && e.__esModule ? e : { default: e };
}
function Qmt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function evt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function tvt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var nvt = function(e) {
  tvt(t, e);
  function t() {
    return Qmt(this, t), evt(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Kmt(t, [{
    key: "render",
    value: function() {
      return LQ.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(LQ.default.Component);
AR.default = (0, Jmt.default)(nvt);
var IR = {}, Vk = {};
Object.defineProperty(Vk, "__esModule", {
  value: !0
});
var rvt = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ovt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ivt = we, PQ = $k(ivt), svt = nl;
$k(svt);
var avt = pf, _Q = $k(avt), lvt = Hk, SQ = $k(lvt);
function $k(e) {
  return e && e.__esModule ? e : { default: e };
}
function uvt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function cvt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function pvt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Vk.default = function(e) {
  var t = function(n) {
    pvt(r, n);
    function r(o) {
      uvt(this, r);
      var i = cvt(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return ovt(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        _Q.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        _Q.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return PQ.default.createElement(e, rvt({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(PQ.default.Component);
  return t.propTypes = {
    name: SQ.default.string,
    id: SQ.default.string
  }, t;
};
Object.defineProperty(IR, "__esModule", {
  value: !0
});
var MQ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, dvt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), fvt = we, DQ = BR(fvt), hvt = Vk, gvt = BR(hvt), mvt = Hk, TQ = BR(mvt);
function BR(e) {
  return e && e.__esModule ? e : { default: e };
}
function vvt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function yvt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function bvt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var fhe = function(e) {
  bvt(t, e);
  function t() {
    return vvt(this, t), yvt(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return dvt(t, [{
    key: "render",
    value: function() {
      var r = this, o = MQ({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, DQ.default.createElement(
        "div",
        MQ({}, o, { ref: function(a) {
          r.props.parentBindings.domNode = a;
        } }),
        this.props.children
      );
    }
  }]), t;
}(DQ.default.Component);
fhe.propTypes = {
  name: TQ.default.string,
  id: TQ.default.string
};
IR.default = (0, gvt.default)(fhe);
var Q_ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, jQ = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function AQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function IQ(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function BQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ww = we, Gc = Lv, eS = pf, Zo = Hk, Ou = Wk, RQ = {
  to: Zo.string.isRequired,
  containerId: Zo.string,
  container: Zo.object,
  activeClass: Zo.string,
  spy: Zo.bool,
  smooth: Zo.oneOfType([Zo.bool, Zo.string]),
  offset: Zo.number,
  delay: Zo.number,
  isDynamic: Zo.bool,
  onClick: Zo.func,
  duration: Zo.oneOfType([Zo.number, Zo.func]),
  absolute: Zo.bool,
  onSetActive: Zo.func,
  onSetInactive: Zo.func,
  ignoreCancelEvents: Zo.bool,
  hashSpy: Zo.bool,
  spyThrottle: Zo.number
}, wvt = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || eS, o = function(a) {
      BQ(s, a);
      function s(l) {
        AQ(this, s);
        var u = IQ(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return jQ(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            Gc.isMounted(u) || Gc.mount(u, this.props.spyThrottle), this.props.hashSpy && (Ou.isMounted() || Ou.mount(r), Ou.mapContainer(this.props.to, u)), this.props.spy && Gc.addStateHandler(this.stateHandler), Gc.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Gc.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = Q_({}, this.props);
          for (var p in RQ)
            c.hasOwnProperty(p) && delete c[p];
          return c.className = u, c.onClick = this.handleClick, ww.createElement(t, c);
        }
      }]), s;
    }(ww.Component), i = function() {
      var s = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, Q_({}, s.state, u));
      }, this.handleClick = function(l) {
        s.props.onClick && s.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), s.scrollTo(s.props.to, s.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== s.props.to && (s.state !== null && s.state.active && s.props.onSetInactive && s.props.onSetInactive(), s.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = s.getScrollSpyContainer();
        if (!(Ou.isMounted() && !Ou.isInitialized())) {
          var c = s.props.to, p = null, d = 0, g = 0, f = 0;
          if (u.getBoundingClientRect) {
            var y = u.getBoundingClientRect();
            f = y.top;
          }
          if (!p || s.props.isDynamic) {
            if (p = r.get(c), !p)
              return;
            var b = p.getBoundingClientRect();
            d = b.top - f + l, g = d + b.height;
          }
          var E = l - s.props.offset, w = E >= Math.floor(d) && E < Math.floor(g), M = E < Math.floor(d) || E >= Math.floor(g), O = r.getActiveLink();
          if (M)
            return c === O && r.setActiveLink(void 0), s.props.hashSpy && Ou.getHash() === c && Ou.changeHash(), s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive()), Gc.updateStates();
          if (w && O !== c)
            return r.setActiveLink(c), s.props.hashSpy && Ou.changeHash(c), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(c)), Gc.updateStates();
        }
      };
    };
    return o.propTypes = RQ, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      BQ(o, r);
      function o(i) {
        AQ(this, o);
        var a = IQ(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return a.childBindings = {
          domNode: null
        }, a;
      }
      return jQ(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(a) {
          this.props.name !== a.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          eS.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(a) {
          eS.register(a, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return ww.createElement(t, Q_({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(ww.Component);
    return n.propTypes = {
      name: Zo.string,
      id: Zo.string
    }, n;
  }
}, Cvt = wvt;
Object.defineProperty(ui, "__esModule", {
  value: !0
});
ui.Helpers = ui.ScrollElement = ui.ScrollLink = Ehe = ui.animateScroll = ui.scrollSpy = ui.Events = ui.scroller = ui.Element = ui.Button = ui.Link = void 0;
var xvt = _R, hhe = pl(xvt), Ovt = AR, ghe = pl(Ovt), Evt = IR, mhe = pl(Evt), kvt = pf, vhe = pl(kvt), Lvt = Sv, yhe = pl(Lvt), Pvt = Lv, bhe = pl(Pvt), _vt = Fk, whe = pl(_vt), Svt = kv, Che = pl(Svt), Mvt = Vk, xhe = pl(Mvt), Dvt = Cvt, Ohe = pl(Dvt);
function pl(e) {
  return e && e.__esModule ? e : { default: e };
}
ui.Link = hhe.default;
ui.Button = ghe.default;
ui.Element = mhe.default;
ui.scroller = vhe.default;
ui.Events = yhe.default;
ui.scrollSpy = bhe.default;
var Ehe = ui.animateScroll = whe.default;
ui.ScrollLink = Che.default;
ui.ScrollElement = xhe.default;
ui.Helpers = Ohe.default;
ui.default = { Link: hhe.default, Button: ghe.default, Element: mhe.default, scroller: vhe.default, Events: yhe.default, scrollSpy: bhe.default, animateScroll: whe.default, ScrollLink: Che.default, ScrollElement: xhe.default, Helpers: Ohe.default };
const RR = We({}), khe = We({});
function Tvt() {
  const e = ge(khe);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function NQ(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function r0t() {
  const e = CT(), { closeModal: t, closeAll: n, modalIsOpen: r } = ge(RR), { showToast: o } = Tvt(), { getParam: i } = nhe(), { pathname: a } = OT(), s = lte(), l = i("closeAllModals"), u = xT();
  h(() => {
    var d, g;
    const c = ((g = (d = u[0]) == null ? void 0 : d.data) == null ? void 0 : g.closeModalKey) || "", p = r(c);
    c && p && t(c);
  }, [u]), h(() => {
    l === "true" && (n(), s(a));
  }, [l]), h(() => {
    const c = e == null ? void 0 : e.closeModalKey;
    c && t(c);
  }, [e]), h(() => {
    const c = e == null ? void 0 : e.closeAllModals;
    typeof c == "boolean" && c && n();
  }, [e]), h(() => {
    const c = e == null ? void 0 : e.toast, p = e == null ? void 0 : e.message;
    NQ(c) && o(c), !NQ(c) && p && o({ message: p, type: "danger" });
  }, [e]), h(() => {
    var c, p;
    if (typeof ((c = e == null ? void 0 : e.data) == null ? void 0 : c.scrollTo) == "string") {
      const d = document.getElementById((p = e == null ? void 0 : e.data) == null ? void 0 : p.scrollTo);
      d && Ehe.scrollTo(d.offsetTop - 200);
    }
  }, [e]);
}
const Lhe = We({});
function o0t(e) {
  const t = ge(Lhe);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, a = r(e), s = n(e);
    return { drawerIsOpen: a, drawerData: s, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function jvt() {
  return () => {
  };
}
function Avt() {
  return nge(
    jvt,
    () => !0,
    () => !1
  );
}
function i0t(e) {
  const t = ge(RR);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, a = r(e), s = n(e);
    return { modalIsOpen: a, modalData: s, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function s0t(e) {
  const { children: t = !1 } = e, [n, r] = k([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function a(l, u) {
    const c = o(l);
    r(c ? (p) => [...p.filter((g) => g.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function s(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ ne.jsx(
    Lhe.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: a, closeDrawer: s },
      children: t
    }
  );
}
function xm(e) {
  "@babel/helpers - typeof";
  return xm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, xm(e);
}
function Ivt(e, t) {
  if (xm(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (xm(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Bvt(e) {
  var t = Ivt(e, "string");
  return xm(t) == "symbol" ? t : t + "";
}
function ke(e, t, n) {
  return (t = Bvt(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Phe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var tS, FQ;
function Rvt() {
  if (FQ) return tS;
  FQ = 1;
  var e = process.env.NODE_ENV, t = function(r, o, i, a, s, l, u, c) {
    if (e !== "production" && o === void 0)
      throw new Error("invariant requires an error message argument");
    if (!r) {
      var p;
      if (o === void 0)
        p = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [i, a, s, l, u, c], g = 0;
        p = new Error(o.replace(/%s/g, function() {
          return d[g++];
        })), p.name = "Invariant Violation";
      }
      throw p.framesToPop = 1, p;
    }
  };
  return tS = t, tS;
}
var Nvt = Rvt(), yi = /* @__PURE__ */ Phe(Nvt), zt = We(null);
function Fvt() {
  yi(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(zt);
  return yi(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function zvt(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function Uvt(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Hvt(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Uvt(e, i), o;
}
function Wvt(e, t, n) {
  var r = zvt(n, function(i, a, s) {
    return typeof e[s] == "function" && i.push(google.maps.event.addListener(t, a, e[s])), i;
  }, []);
  return r;
}
function Vvt(e) {
  google.maps.event.removeListener(e);
}
function gn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(Vvt);
}
function on(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = Wvt(o, i, n);
  return Hvt(t, r, o, i), a;
}
var zQ = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, UQ = {
  extraMapTypes(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center(e, t) {
    e.setCenter(t);
  },
  clickableIcons(e, t) {
    e.setClickableIcons(t);
  },
  heading(e, t) {
    e.setHeading(t);
  },
  mapTypeId(e, t) {
    e.setMapTypeId(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  streetView(e, t) {
    e.setStreetView(t);
  },
  tilt(e, t) {
    e.setTilt(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
function $vt(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: y,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [v, x] = k(null), _ = ht(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null), [j, Y] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && y && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", y)));
  }, [y]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (j !== null && google.maps.event.removeListener(j), Y(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return x(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), ne.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: ne.jsx(zt.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me($vt);
let Zvt = class extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      map: null
    }), ke(this, "registeredEvents", []), ke(this, "mapRef", null), ke(this, "getInstance", () => this.mapRef === null ? null : new google.maps.Map(this.mapRef, this.props.options)), ke(this, "panTo", (t) => {
      var n = this.getInstance();
      n && n.panTo(t);
    }), ke(this, "setMapCallback", () => {
      this.state.map !== null && this.props.onLoad && this.props.onLoad(this.state.map);
    }), ke(this, "getRef", (t) => {
      this.mapRef = t;
    });
  }
  componentDidMount() {
    var t = this.getInstance();
    this.registeredEvents = on({
      updaterMap: UQ,
      eventMap: zQ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        map: t
      };
    }, this.setMapCallback);
  }
  componentDidUpdate(t) {
    this.state.map !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: UQ,
      eventMap: zQ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.map
    }));
  }
  componentWillUnmount() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), gn(this.registeredEvents));
  }
  render() {
    return ne.jsx("div", {
      id: this.props.id,
      ref: this.getRef,
      style: this.props.mapContainerStyle,
      className: this.props.mapContainerClassName,
      children: ne.jsx(zt.Provider, {
        value: this.state.map,
        children: this.state.map !== null ? this.props.children : null
      })
    });
  }
};
function HQ(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function _he(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        HQ(i, r, o, a, s, "next", l);
      }
      function s(l) {
        HQ(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function She(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return yi(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var kp = typeof document < "u";
function Mhe(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return kp ? new Promise(function(i, a) {
    var s = document.getElementById(n), l = window;
    if (s) {
      var u = s.getAttribute("data-state");
      if (s.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, p = s.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, s.onerror = function(g) {
          p && p(g), a(g);
        };
        return;
      } else
        s.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(f) {
      d.setAttribute("data-state", "error"), a(f);
    }, l.initMap = function() {
      d.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function WQ(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Dhe() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return WQ(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return WQ(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
var oh = !1;
function The() {
  return ne.jsx("div", {
    children: "Loading..."
  });
}
var fT = {
  id: "script-loader",
  version: "weekly"
};
class jhe extends pe {
  constructor() {
    super(...arguments), ke(this, "check", null), ke(this, "state", {
      loaded: !1
    }), ke(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ke(this, "isCleaningUp", /* @__PURE__ */ _he(function* () {
      function t(n) {
        if (!oh)
          n();
        else if (kp)
          var r = window.setInterval(function() {
            oh || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ke(this, "cleanup", () => {
      oh = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(r) {
        return typeof r.src == "string" && r.src.includes("maps.googleapis");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(r) {
        return r.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(r) {
        return r.innerText !== void 0 && r.innerText.length > 0 && r.innerText.includes(".gm-");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    }), ke(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Dhe(), yi(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: She(this.props)
      };
      Mhe(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), ke(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (kp) {
      if (window.google && window.google.maps && !oh) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), kp && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (kp) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, oh = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ne.jsxs(ne.Fragment, {
      children: [ne.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ne.jsx(The, {})]
    });
  }
}
ke(jhe, "defaultProps", fT);
function qvt(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function NR(e, t) {
  if (e == null) return {};
  var n, r, o = qvt(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var VQ;
function Gvt(e) {
  var {
    id: t = fT.id,
    version: n = fT.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ht(!1), [f, y] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    kp && u && Dhe();
  }, [u]), h(function() {
    f && yi(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = She({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!kp)
      return;
    function v() {
      g.current && (y(!0), VQ = w);
    }
    if (window.google && window.google.maps && VQ === w) {
      v();
      return;
    }
    Mhe({
      id: t,
      url: w,
      nonce: r
    }).then(v).catch(function(_) {
      g.current && E(_), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(_);
    });
  }, [t, w, r]);
  var M = ht(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var Kvt = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], Yvt = ne.jsx(The, {});
function Xvt(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = NR(e, Kvt), {
    isLoaded: s,
    loadError: l
  } = Gvt(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || Yvt;
}
me(Xvt);
var $Q;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})($Q || ($Q = {}));
function ZQ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZQ(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZQ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qQ = {}, GQ = {
  options(e, t) {
    e.setOptions(t);
  }
};
function Jvt(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(zt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(hx(hx({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(Jvt);
class Qvt extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      trafficLayer: null
    }), ke(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(hx(hx({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = on({
      updaterMap: GQ,
      eventMap: qQ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: GQ,
      eventMap: qQ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), gn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Qvt, "contextType", zt);
function eyt(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(zt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(eyt);
class tyt extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      bicyclingLayer: null
    }), ke(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(tyt, "contextType", zt);
function nyt(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(zt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(nyt);
class ryt extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      transitLayer: null
    }), ke(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(ryt, "contextType", zt);
function KQ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KQ(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KQ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YQ = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, XQ = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function oyt(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(zt), [d, g] = k(null), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), y(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    yi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(gx(gx({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && y(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && v(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(oyt);
class iyt extends pe {
  constructor(t) {
    super(t), ke(this, "registeredEvents", []), ke(this, "state", {
      drawingManager: null
    }), ke(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), yi(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(gx(gx({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = on({
      updaterMap: XQ,
      eventMap: YQ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: XQ,
      eventMap: YQ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), gn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ke(iyt, "contextType", zt);
function JQ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JQ(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JQ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var QQ = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, eee = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, mx = {};
function syt(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: y,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: v,
    onMouseOut: x,
    onMouseOver: _,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: Z,
    onDraggableChanged: H,
    onFlatChanged: $,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: F,
    onUnmount: S
  } = e, W = ge(zt), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null), [oe, Pe] = k(null), [Ue, Ze] = k(null), [_e, rt] = k(null), [Ve, ye] = k(null), [Ge, ct] = k(null), [ve, Oe] = k(null), [qe, ze] = k(null), [Se, st] = k(null), [xe, xt] = k(null), [at, lt] = k(null), [pt, Ot] = k(null), [dt, ft] = k(null), [ot, He] = k(null), [Et, kt] = k(null), [gt, St] = k(null), [mt, Mt] = k(null), [vt, Pt] = k(null);
  h(() => {
    C !== null && C.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && C !== null && C.setOptions(n);
  }, [C, n]), h(() => {
    typeof a < "u" && C !== null && C.setDraggable(a);
  }, [C, a]), h(() => {
    t && C !== null && C.setPosition(t);
  }, [C, t]), h(() => {
    typeof s < "u" && C !== null && C.setVisible(s);
  }, [C, s]), h(() => {
    C == null || C.setAnimation(l);
  }, [C, l]), h(() => {
    C && u !== void 0 && C.setClickable(u);
  }, [C, u]), h(() => {
    C && c !== void 0 && C.setCursor(c);
  }, [C, c]), h(() => {
    C && p !== void 0 && C.setIcon(p);
  }, [C, p]), h(() => {
    C && d !== void 0 && C.setLabel(d);
  }, [C, d]), h(() => {
    C && g !== void 0 && C.setOpacity(g);
  }, [C, g]), h(() => {
    C && f !== void 0 && C.setShape(f);
  }, [C, f]), h(() => {
    C && y !== void 0 && C.setTitle(y);
  }, [C, y]), h(() => {
    C && b !== void 0 && C.setZIndex(b);
  }, [C, b]), h(() => {
    C && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(C, "dblclick", w)));
  }, [w]), h(() => {
    C && O && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(C, "dragend", O)));
  }, [O]), h(() => {
    C && v && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(C, "dragstart", v)));
  }, [v]), h(() => {
    C && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(C, "mousedown", L)));
  }, [L]), h(() => {
    C && x && (oe !== null && google.maps.event.removeListener(oe), Pe(google.maps.event.addListener(C, "mouseout", x)));
  }, [x]), h(() => {
    C && _ && (Ue !== null && google.maps.event.removeListener(Ue), Ze(google.maps.event.addListener(C, "mouseover", _)));
  }, [_]), h(() => {
    C && z && (_e !== null && google.maps.event.removeListener(_e), rt(google.maps.event.addListener(C, "mouseup", z)));
  }, [z]), h(() => {
    C && N && (Ve !== null && google.maps.event.removeListener(Ve), ye(google.maps.event.addListener(C, "rightclick", N)));
  }, [N]), h(() => {
    C && E && (Ge !== null && google.maps.event.removeListener(Ge), ct(google.maps.event.addListener(C, "click", E)));
  }, [E]), h(() => {
    C && M && (ve !== null && google.maps.event.removeListener(ve), Oe(google.maps.event.addListener(C, "drag", M)));
  }, [M]), h(() => {
    C && R && (qe !== null && google.maps.event.removeListener(qe), ze(google.maps.event.addListener(C, "clickable_changed", R)));
  }, [R]), h(() => {
    C && V && (Se !== null && google.maps.event.removeListener(Se), st(google.maps.event.addListener(C, "cursor_changed", V)));
  }, [V]), h(() => {
    C && Z && (xe !== null && google.maps.event.removeListener(xe), xt(google.maps.event.addListener(C, "animation_changed", Z)));
  }, [Z]), h(() => {
    C && H && (at !== null && google.maps.event.removeListener(at), lt(google.maps.event.addListener(C, "draggable_changed", H)));
  }, [H]), h(() => {
    C && $ && (pt !== null && google.maps.event.removeListener(pt), Ot(google.maps.event.addListener(C, "flat_changed", $)));
  }, [$]), h(() => {
    C && K && (dt !== null && google.maps.event.removeListener(dt), ft(google.maps.event.addListener(C, "icon_changed", K)));
  }, [K]), h(() => {
    C && X && (ot !== null && google.maps.event.removeListener(ot), He(google.maps.event.addListener(C, "position_changed", X)));
  }, [X]), h(() => {
    C && Q && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(C, "shape_changed", Q)));
  }, [Q]), h(() => {
    C && J && (gt !== null && google.maps.event.removeListener(gt), St(google.maps.event.addListener(C, "title_changed", J)));
  }, [J]), h(() => {
    C && P && (mt !== null && google.maps.event.removeListener(mt), Mt(google.maps.event.addListener(C, "visible_changed", P)));
  }, [P]), h(() => {
    C && D && (vt !== null && google.maps.event.removeListener(vt), Pt(google.maps.event.addListener(C, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = Pd(Pd(Pd({}, n || mx), r ? mx : {
      map: W
    }), {}, {
      position: t
    }), te = new google.maps.Marker(yt);
    return r ? r.addMarker(te, !!o) : te.setMap(W), t && te.setPosition(t), typeof s < "u" && te.setVisible(s), typeof a < "u" && te.setDraggable(a), typeof u < "u" && te.setClickable(u), typeof c == "string" && te.setCursor(c), p && te.setIcon(p), typeof d < "u" && te.setLabel(d), typeof g < "u" && te.setOpacity(g), f && te.setShape(f), typeof y == "string" && te.setTitle(y), typeof b == "number" && te.setZIndex(b), w && T(google.maps.event.addListener(te, "dblclick", w)), O && j(google.maps.event.addListener(te, "dragend", O)), v && B(google.maps.event.addListener(te, "dragstart", v)), L && he(google.maps.event.addListener(te, "mousedown", L)), x && Pe(google.maps.event.addListener(te, "mouseout", x)), _ && Ze(google.maps.event.addListener(te, "mouseover", _)), z && rt(google.maps.event.addListener(te, "mouseup", z)), N && ye(google.maps.event.addListener(te, "rightclick", N)), E && ct(google.maps.event.addListener(te, "click", E)), M && Oe(google.maps.event.addListener(te, "drag", M)), R && ze(google.maps.event.addListener(te, "clickable_changed", R)), V && st(google.maps.event.addListener(te, "cursor_changed", V)), Z && xt(google.maps.event.addListener(te, "animation_changed", Z)), H && lt(google.maps.event.addListener(te, "draggable_changed", H)), $ && Ot(google.maps.event.addListener(te, "flat_changed", $)), K && ft(google.maps.event.addListener(te, "icon_changed", K)), X && He(google.maps.event.addListener(te, "position_changed", X)), Q && kt(google.maps.event.addListener(te, "shape_changed", Q)), J && St(google.maps.event.addListener(te, "title_changed", J)), P && Mt(google.maps.event.addListener(te, "visible_changed", P)), D && Pt(google.maps.event.addListener(te, "zindex_changed", D)), I(te), F && F(te), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), _e !== null && google.maps.event.removeListener(_e), Ve !== null && google.maps.event.removeListener(Ve), Ge !== null && google.maps.event.removeListener(Ge), qe !== null && google.maps.event.removeListener(qe), Se !== null && google.maps.event.removeListener(Se), xe !== null && google.maps.event.removeListener(xe), at !== null && google.maps.event.removeListener(at), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ot !== null && google.maps.event.removeListener(ot), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(te), r ? r.removeMarker(te, !!o) : te && te.setMap(null);
    };
  }, []);
  var jn = Ft(() => i ? ut.map(i, (yt) => {
    if (!wi(yt))
      return yt;
    var te = yt;
    return Ci(te, {
      anchor: C
    });
  }) : null, [i, C]);
  return ne.jsx(ne.Fragment, {
    children: jn
  }) || null;
}
me(syt);
class Ahe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return _he(function* () {
      var n = Pd(Pd(Pd({}, t.props.options || mx), t.props.clusterer ? mx : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = on({
        updaterMap: eee,
        eventMap: QQ,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: eee,
      eventMap: QQ,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), gn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? ut.map(this.props.children, (n) => {
      if (!wi(n))
        return n;
      var r = n;
      return Ci(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ke(Ahe, "contextType", zt);
var ayt = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), lyt = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new ayt(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function uyt(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var cyt = 2e3, pyt = 500, dyt = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", fyt = "png", hyt = [53, 56, 66, 78, 90], gyt = "cluster", Ihe = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || dyt, this.imageExtension = r.imageExtension || fyt, this.imageSizes = r.imageSizes || hyt, this.calculator = r.calculator || uyt, this.batchSize = r.batchSize || cyt, this.batchSizeIE = r.batchSizeIE || pyt, this.clusterClass = r.clusterClass || gyt, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new lyt(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var a = i;
          this.prototype[a] = o.prototype[a];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function tee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function myt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xa = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Xn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, vyt = {};
function yyt(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: y,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: v,
    onMouseOut: x,
    onLoad: _,
    onUnmount: z
  } = e, [L, N] = k(null), R = ge(zt), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && x && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, xa.onMouseOut, x)));
  }, [x]), h(() => {
    L && v && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, xa.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(L, xa.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(L, xa.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), $(google.maps.event.addListener(L, xa.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && Xn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Xn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Xn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Xn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Xn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Xn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Xn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Xn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Xn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Xn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Xn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Xn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof y < "u" && L !== null && Xn.styles(L, y);
  }, [L, y]), h(() => {
    typeof b < "u" && L !== null && Xn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && Xn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var F = myt({}, n || vyt), S = new Ihe(R, [], F);
      return r && Xn.averageCenter(S, r), o && Xn.batchSizeIE(S, o), i && Xn.calculator(S, i), a && Xn.clusterClass(S, a), s && Xn.enableRetinaIcons(S, s), l && Xn.gridSize(S, l), u && Xn.ignoreHidden(S, u), c && Xn.imageExtension(S, c), p && Xn.imagePath(S, p), d && Xn.imageSizes(S, d), g && Xn.maxZoom(S, g), f && Xn.minimumClusterSize(S, f), y && Xn.styles(S, y), b && Xn.title(S, b), E && Xn.zoomOnClick(S, E), x && J(google.maps.event.addListener(S, xa.onMouseOut, x)), v && D(google.maps.event.addListener(S, xa.onMouseOver, v)), w && Z(google.maps.event.addListener(S, xa.onClick, w)), M && $(google.maps.event.addListener(S, xa.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, xa.onClusteringEnd, O)), N(S), _ && _(S), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), z && z(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(yyt);
class byt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      markerClusterer: null
    }), ke(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Ihe(this.context, [], this.props.options);
      this.registeredEvents = on({
        updaterMap: Xn,
        eventMap: xa,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: Xn,
      eventMap: xa,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), gn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ke(byt, "contextType", zt);
function nee(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Bhe = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(c) {
        c.returnValue = !1, c.preventDefault && c.preventDefault(), t.enableEventPropagation || nee(c);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, nee));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, y = this.getProjection(), b = y.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), wyt = ["position"], Cyt = ["position"];
function ree(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ree(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ree(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oee = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, iee = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, xyt = {};
function Oyt(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(zt), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || xyt, {
        position: V
      } = R, Z = NR(R, wyt), H;
      V && !(V instanceof google.maps.LatLng) && (H = new google.maps.LatLng(V.lat, V.lng));
      var $ = new Bhe(vx(vx({}, Z), H ? {
        position: H
      } : {}));
      N.current = document.createElement("div"), y($), a && E(google.maps.event.addListener($, "closeclick", a)), s && M(google.maps.event.addListener($, "domready", s)), l && v(google.maps.event.addListener($, "content_changed", l)), u && _(google.maps.event.addListener($, "position_changed", u)), c && L(google.maps.event.addListener($, "zindex_changed", c)), $.setContent(N.current), n ? $.open(g, n) : $.getPosition() ? $.open(g) : yi(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p($);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(Oyt);
class Eyt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", null), ke(this, "state", {
      infoBox: null
    }), ke(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : yi(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ke(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = NR(t, Cyt), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Bhe(vx(vx({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = on({
      updaterMap: iee,
      eventMap: oee,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: iee,
      eventMap: oee,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), gn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
ke(Eyt, "contextType", zt);
var nS, see;
function kyt() {
  return see || (see = 1, nS = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), nS;
}
var Lyt = kyt(), aee = /* @__PURE__ */ Phe(Lyt), lee = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], rS = 1, ih = 8;
class FR {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== rS)
      throw new Error("Got v".concat(o, " data when expected v").concat(rS, "."));
    var i = lee[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new FR(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = lee.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, ih, t), this.coords = new this.ArrayType(this.data, ih + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(ih + a + s + l), this.ids = new this.IndexArrayType(this.data, ih, t), this.coords = new this.ArrayType(this.data, ih + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (rS << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return hT(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], y = a[2 * g + 1];
          f >= t && f <= r && y >= n && y <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          uee(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, y = i[2 * f], b = i[2 * f + 1];
      uee(y, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= y : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= y : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function hT(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Rhe(e, t, a, r, o, i), hT(e, t, n, r, a - 1, 1 - i), hT(e, t, n, a + 1, o, 1 - i);
  }
}
function Rhe(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Rhe(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, y = o;
    for (sh(e, t, r, n), t[2 * o + i] > g && sh(e, t, r, o); f < y; ) {
      for (sh(e, t, f, y), f++, y--; t[2 * f + i] < g; ) f++;
      for (; t[2 * y + i] > g; ) y--;
    }
    t[2 * r + i] === g ? sh(e, t, r, y) : (y++, sh(e, t, y, o)), y <= n && (r = y + 1), n <= y && (o = y - 1);
  }
}
function sh(e, t, n, r) {
  oS(e, n, r), oS(t, 2 * n, 2 * r), oS(t, 2 * n + 1, 2 * r + 1);
}
function oS(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function uee(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Pyt = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, cee = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Kc = 2, Wu = 3, iS = 4, Tu = 5, Nhe = 6;
class _yt {
  constructor(t) {
    this.options = Object.assign(Object.create(Pyt), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = cee(Cw(u)), d = cee(xw(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var y = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - y);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Cw(r), xw(a), Cw(i), xw(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Tu] > 1 ? pee(p, f, this.clusterProps) : this.points[p[f + Wu]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + iS] === t && p.push(a[g + Tu] > 1 ? pee(a, g, this.clusterProps) : this.points[a[g + Wu]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new FR(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Tu] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Fhe(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Wu]];
        c = g.properties;
        var [f, y] = g.geometry.coordinates;
        p = Cw(f), d = xw(y);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Wu] : E = this.points[n[l + Wu]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Kc] <= n)) {
        l[p + Kc] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), y = l[p + Tu], b = y;
        for (var E of f) {
          var w = E * c;
          l[w + Kc] > n && (b += l[w + Tu]);
        }
        if (b > y && b >= a) {
          var M = d * y, O = g * y, v = void 0, x = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Kc] <= n)) {
              l[L + Kc] = n;
              var N = l[L + Tu];
              M += l[L] * N, O += l[L + 1] * N, l[L + iS] = _, i && (v || (v = this._map(l, p, !0), x = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + iS] = _, u.push(M / b, O / b, 1 / 0, _, -1, b), i && u.push(x);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var Z = V * c;
              if (!(l[Z + Kc] <= n)) {
                l[Z + Kc] = n;
                for (var H = 0; H < c; H++) u.push(l[Z + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Tu] > 1) {
      var o = this.clusterProps[t[n + Nhe]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Wu]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function pee(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Wu],
    properties: Fhe(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [Syt(e[t]), Myt(e[t + 1])]
    }
  };
}
function Fhe(e, t, n) {
  var r = e[t + Tu], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Nhe], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Wu],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Cw(e) {
  return e / 360 + 0.5;
}
function xw(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Syt(e) {
  return (e - 0.5) * 360;
}
function Myt(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Dyt(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ks {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class gT {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ks.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ks.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ks.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Tyt {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return jyt(n);
  }
}
var jyt = (e) => {
  var t = e.map((n) => new gT({
    position: Ks.getPosition(n),
    markers: [n]
  }));
  return t;
};
class Ayt extends Tyt {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Dyt(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new _yt(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!aee(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Ks.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !aee(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new gT({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new gT({
      markers: [i],
      position: Ks.getPosition(i)
    });
  }
}
class Iyt {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Byt {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ks.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function Ryt(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class zR {
  constructor() {
    Ryt(zR, google.maps.OverlayView);
  }
}
var lg;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(lg || (lg = {}));
var Nyt = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Fyt extends zR {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new Ayt(o),
      renderer: a = new Byt(),
      onClusterClick: s = Nyt
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ks.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, lg.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Ks.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Ks.setMap(l, null)));
      }
      google.maps.event.trigger(this, lg.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ks.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Iyt(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ks.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, lg.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ks.setMap(r.marker, n);
    });
  }
}
function dee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fee(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function zyt(e) {
  var t = Fvt(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new Fyt(fee(fee({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Uyt(e) {
  var {
    children: t,
    options: n
  } = e, r = zyt(n);
  return r !== null ? t(r) : null;
}
me(Uyt);
var hee = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, gee = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Hyt(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(zt), [f, y] = k(null), [b, E] = k(null), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return y(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && v(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : yi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), z && google.maps.event.removeListener(z), d && d(R), R.close();
    };
  }, []), N.current ? Tn(ut.only(t), N.current) : null;
}
me(Hyt);
class Wyt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", null), ke(this, "state", {
      infoWindow: null
    }), ke(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : yi(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ke(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = on({
      updaterMap: gee,
      eventMap: hee,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: gee,
      eventMap: hee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (gn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Tn(ut.only(this.props.children), this.containerElement) : null;
  }
}
ke(Wyt, "contextType", zt);
function mee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vee = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, yee = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Vyt = {};
function $yt(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(zt), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && y && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(O, "click", y)));
  }, [y]), h(() => {
    O && b && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(O, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(yx(yx({}, t || Vyt), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && Z(google.maps.event.addListener(T, "mousedown", u)), c && $(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), y && C(google.maps.event.addListener(T, "click", y)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me($yt);
class Zyt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      polyline: null
    }), ke(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(yx(yx({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = on({
      updaterMap: yee,
      eventMap: vee,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: yee,
      eventMap: vee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), gn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Zyt, "contextType", zt);
function bee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wee(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Cee = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, xee = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function qyt(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, v = ge(zt), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    x !== null && x.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    typeof a < "u" && x !== null && x.setPaths(a);
  }, [x, a]), h(() => {
    x && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dblclick", s)));
  }, [s]), h(() => {
    x && (google.maps.event.addListener(x.getPath(), "insert_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "set_at", () => {
      O == null || O(x);
    }), google.maps.event.addListener(x.getPath(), "remove_at", () => {
      O == null || O(x);
    }));
  }, [x, O]), h(() => {
    x && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragend", l)));
  }, [l]), h(() => {
    x && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(x, "dragstart", u)));
  }, [u]), h(() => {
    x && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(x, "mousedown", c)));
  }, [c]), h(() => {
    x && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(x, "mousemove", p)));
  }, [p]), h(() => {
    x && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseout", d)));
  }, [d]), h(() => {
    x && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(x, "mouseover", g)));
  }, [g]), h(() => {
    x && typeof f == "function" && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(x, "mouseup", f)));
  }, [f]), h(() => {
    x && typeof y == "function" && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(x, "rightclick", y)));
  }, [y]), h(() => {
    x && typeof b == "function" && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(x, "click", b)));
  }, [b]), h(() => {
    x && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(x, "drag", E)));
  }, [E]), h(() => {
    var j = new google.maps.Polygon(wee(wee({}, t), {}, {
      map: v
    }));
    return i && j.setPath(i), a && j.setPaths(a), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), s && L(google.maps.event.addListener(j, "dblclick", s)), l && R(google.maps.event.addListener(j, "dragend", l)), u && Z(google.maps.event.addListener(j, "dragstart", u)), c && $(google.maps.event.addListener(j, "mousedown", c)), p && X(google.maps.event.addListener(j, "mousemove", p)), d && J(google.maps.event.addListener(j, "mouseout", d)), g && D(google.maps.event.addListener(j, "mouseover", g)), f && S(google.maps.event.addListener(j, "mouseup", f)), y && C(google.maps.event.addListener(j, "rightclick", y)), b && U(google.maps.event.addListener(j, "click", b)), E && q(google.maps.event.addListener(j, "drag", E)), _(j), w && w(j), () => {
      z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), M && M(j), j.setMap(null);
    };
  }, []), null;
}
me(qyt);
class Gyt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = on({
      updaterMap: xee,
      eventMap: Cee,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: xee,
      eventMap: Cee,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), gn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Gyt, "contextType", zt);
function Oee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Oee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Oee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Eee = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, kee = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Kyt(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: y,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(zt), [v, x] = k(null), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null);
  return h(() => {
    v !== null && v.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(v, "click", y)));
  }, [y]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(bx(bx({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && z(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && H(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && F(google.maps.event.addListener(Y, "mouseup", g)), f && W(google.maps.event.addListener(Y, "rightclick", f)), y && I(google.maps.event.addListener(Y, "click", y)), b && T(google.maps.event.addListener(Y, "drag", b)), E && j(google.maps.event.addListener(Y, "bounds_changed", E)), x(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
me(Kyt);
class Yyt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      rectangle: null
    }), ke(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(bx(bx({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = on({
      updaterMap: kee,
      eventMap: Eee,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: kee,
      eventMap: Eee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), gn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Yyt, "contextType", zt);
function Lee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Lee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Lee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Pee = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, _ee = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Xyt = {};
function Jyt(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: y,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: v
  } = e, x = ge(zt), [_, z] = k(null), [L, N] = k(null), [R, V] = k(null), [Z, H] = k(null), [$, K] = k(null), [X, Q] = k(null), [J, P] = k(null), [D, F] = k(null), [S, W] = k(null), [C, I] = k(null), [U, T] = k(null), [q, j] = k(null), [Y, B] = k(null), [le, he] = k(null);
  return h(() => {
    _ !== null && _.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (Z !== null && google.maps.event.removeListener(Z), H(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && ($ !== null && google.maps.event.removeListener($), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), Q(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), F(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && y && (C !== null && google.maps.event.removeListener(C), I(google.maps.event.addListener(_, "rightclick", y)));
  }, [y]), h(() => {
    _ && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", b)));
  }, [b]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [b]), h(() => {
    _ && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(wx(wx({}, t || Xyt), {}, {
      map: x
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && F(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), y && I(google.maps.event.addListener(oe, "rightclick", y)), b && T(google.maps.event.addListener(oe, "click", b)), E && j(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), z(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), Z !== null && google.maps.event.removeListener(Z), $ !== null && google.maps.event.removeListener($), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(Jyt);
class Qyt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      circle: null
    }), ke(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(wx(wx({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = on({
      updaterMap: _ee,
      eventMap: Pee,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: _ee,
      eventMap: Pee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), gn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ke(Qyt, "contextType", zt);
function See(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? See(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : See(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Mee = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, Dee = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function ebt(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: y,
    onUnmount: b
  } = e, E = ge(zt), [w, M] = k(null), [O, v] = k(null), [x, _] = k(null), [z, L] = k(null), [N, R] = k(null), [V, Z] = k(null), [H, $] = k(null), [K, X] = k(null), [Q, J] = k(null), [P, D] = k(null), [F, S] = k(null), [W, C] = k(null), [I, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (x !== null && google.maps.event.removeListener(x), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), Z(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), $(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (F !== null && google.maps.event.removeListener(F), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), C(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (I !== null && google.maps.event.removeListener(I), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var j = new google.maps.Data(Cx(Cx({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(j, "dblclick", r)), o && _(google.maps.event.addListener(j, "mousedown", o)), i && L(google.maps.event.addListener(j, "mousemove", i)), a && R(google.maps.event.addListener(j, "mouseout", a)), s && Z(google.maps.event.addListener(j, "mouseover", s)), l && $(google.maps.event.addListener(j, "mouseup", l)), u && X(google.maps.event.addListener(j, "rightclick", u)), n && J(google.maps.event.addListener(j, "click", n)), c && D(google.maps.event.addListener(j, "addfeature", c)), p && S(google.maps.event.addListener(j, "removefeature", p)), d && C(google.maps.event.addListener(j, "removeproperty", d)), g && U(google.maps.event.addListener(j, "setgeometry", g)), f && q(google.maps.event.addListener(j, "setproperty", f)), M(j), y && y(j);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), x !== null && google.maps.event.removeListener(x), z !== null && google.maps.event.removeListener(z), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), F !== null && google.maps.event.removeListener(F), W !== null && google.maps.event.removeListener(W), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(ebt);
class tbt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      data: null
    }), ke(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Cx(Cx({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = on({
        updaterMap: Dee,
        eventMap: Mee,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: Dee,
      eventMap: Mee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), gn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ke(tbt, "contextType", zt);
function Tee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jee(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Tee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Aee = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Iee = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class nbt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      kmlLayer: null
    }), ke(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(jee(jee({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = on({
      updaterMap: Iee,
      eventMap: Aee,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: Iee,
      eventMap: Aee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), gn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(nbt, "contextType", zt);
function zhe(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function rbt(e, t) {
  return new t(e.lat, e.lng);
}
function obt(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function ibt(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function sbt(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function abt(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function lbt(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Uhe(e, t, n, r) {
  return n !== void 0 ? abt(e, t, sbt(n, google.maps.LatLngBounds, obt)) : lbt(e, t, ibt(r, google.maps.LatLng, rbt));
}
function ubt(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function Bee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cbt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Bee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Bee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function pbt(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = cbt({}, this.container ? zhe(this.container, o) : {
        x: 0,
        y: 0
      }), u = Uhe(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function Ree(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dbt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ree(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ree(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Nee(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function Fee(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function fbt(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(zt), c = Ft(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Ft(() => pbt(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), xi.createPortal(l, c);
}
me(fbt);
class df extends pe {
  constructor(t) {
    super(t), ke(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ke(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      yi(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ke(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ke(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = dbt({
        x: 0,
        y: 0
      }, this.containerRef.current ? zhe(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Uhe(r, o, this.props.bounds, this.props.position);
      if (!ubt(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ke(this, "draw", () => {
      this.onPositionElement();
    }), ke(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Br();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = Nee(t.position), r = Nee(this.props.position), o = Fee(t.bounds), i = Fee(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? xi.createPortal(ne.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: ut.only(this.props.children)
    }), t) : null;
  }
}
ke(df, "FLOAT_PANE", "floatPane");
ke(df, "MAP_PANE", "mapPane");
ke(df, "MARKER_LAYER", "markerLayer");
ke(df, "OVERLAY_LAYER", "overlayLayer");
ke(df, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ke(df, "contextType", zt);
function hbt() {
}
function zee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uee(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Hee = {
  onDblClick: "dblclick",
  onClick: "click"
}, Wee = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function gbt(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(zt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Ft(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(gbt);
class Hhe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      groundOverlay: null
    }), ke(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    yi(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Uee(Uee({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = on({
      updaterMap: Wee,
      eventMap: Hee,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: Wee,
      eventMap: Hee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Hhe, "defaultProps", {
  onLoad: hbt
});
ke(Hhe, "contextType", zt);
function Vee(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Vee(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Vee(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $ee = {}, Zee = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function mbt(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(zt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || yi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    yi(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(xx(xx({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(mbt);
class vbt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      heatmapLayer: null
    }), ke(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    yi(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), yi(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(xx(xx({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = on({
      updaterMap: Zee,
      eventMap: $ee,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: Zee,
      eventMap: $ee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), gn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(vbt, "contextType", zt);
var qee = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, Gee = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class ybt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      streetViewPanorama: null
    }), ke(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = on({
      updaterMap: Gee,
      eventMap: qee,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: Gee,
      eventMap: qee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), gn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ke(ybt, "contextType", zt);
class bbt extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      streetViewService: null
    }), ke(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ke(bbt, "contextType", zt);
var Kee = {
  onDirectionsChanged: "directions_changed"
}, Yee = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class wbt extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      directionsRenderer: null
    }), ke(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = on({
      updaterMap: Yee,
      eventMap: Kee,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: Yee,
      eventMap: Kee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), gn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(wbt, "contextType", zt);
var Xee = {
  onPlacesChanged: "places_changed"
}, Jee = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Whe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", Br()), ke(this, "state", {
      searchBox: null
    }), ke(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (yi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = on({
          updaterMap: Jee,
          eventMap: Xee,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: Jee,
      eventMap: Xee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), gn(this.registeredEvents));
  }
  render() {
    return ne.jsx("div", {
      ref: this.containerElement,
      children: ut.only(this.props.children)
    });
  }
}
ke(Whe, "contextType", zt);
var Qee = {
  onPlaceChanged: "place_changed"
}, ete = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Vhe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", Br()), ke(this, "state", {
      autocomplete: null
    }), ke(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    yi(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = on({
        updaterMap: ete,
        eventMap: Qee,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    gn(this.registeredEvents), this.registeredEvents = on({
      updaterMap: ete,
      eventMap: Qee,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && gn(this.registeredEvents);
  }
  render() {
    return ne.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: ut.only(this.props.children)
    });
  }
}
ke(Vhe, "defaultProps", {
  className: ""
});
ke(Vhe, "contextType", zt);
function l0t({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ ne.jsx(
    jhe,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function u0t(e) {
  const { children: t = !1 } = e, [n, r] = k([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((p) => p.key === u)) == null ? void 0 : c.data;
  }
  function a(u, c) {
    const p = o(u);
    r(p ? (d) => [...d.filter((f) => f.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function s(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ ne.jsx(
    RR.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: a, closeModal: s, closeAll: l },
      children: t
    }
  );
}
let Cbt = { data: "" }, xbt = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Cbt, Obt = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Ebt = /\/\*[^]*?\*\/|  +/g, tte = /\n+/g, Ju = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Ju(a, i) : i + "{" + Ju(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Ju(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Ju.p ? Ju.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Sl = {}, $he = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + $he(e[n]);
    return t;
  }
  return e;
}, kbt = (e, t, n, r, o) => {
  let i = $he(e), a = Sl[i] || (Sl[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Sl[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Obt.exec(u.replace(Ebt, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(tte, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(tte, " ").trim();
      return d[0];
    })(e);
    Sl[a] = Ju(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Sl.g ? Sl.g : null;
  return n && (Sl.g = Sl[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Sl[a], t, r, s), a;
}, Lbt = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Ju(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Zk(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return kbt(n.unshift ? n.raw ? Lbt(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, xbt(t.target), t.g, t.o, t.k);
}
let Zhe, mT, vT;
Zk.bind({ g: 1 });
let Gl = Zk.bind({ k: 1 });
function Pbt(e, t, n, r) {
  Ju.p = t, Zhe = e, mT = n, vT = r;
}
function Mc(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: mT && mT() }, s), n.o = / *go\d+/.test(l), s.className = Zk.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), vT && u[0] && vT(s), Zhe(u, s);
    }
    return o;
  };
}
var _bt = (e) => typeof e == "function", Ox = (e, t) => _bt(e) ? e(t) : e, Sbt = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), qhe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Mbt = 20, Ghe = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, Mbt) };
    case 1:
      return { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return Ghe(e, { type: e.toasts.find((i) => i.id === n.id) ? 1 : 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, dismissed: !0, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, Nw = [], Lp = { toasts: [], pausedAt: void 0 }, dd = (e) => {
  Lp = Ghe(Lp, e), Nw.forEach((t) => {
    t(Lp);
  });
}, Dbt = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, Tbt = (e = {}) => {
  let [t, n] = k(Lp), r = ht(Lp);
  h(() => (r.current !== Lp && n(Lp), Nw.push(n), () => {
    let i = Nw.indexOf(n);
    i > -1 && Nw.splice(i, 1);
  }), []);
  let o = t.toasts.map((i) => {
    var a, s, l;
    return { ...e, ...e[i.type], ...i, removeDelay: i.removeDelay || ((a = e[i.type]) == null ? void 0 : a.removeDelay) || (e == null ? void 0 : e.removeDelay), duration: i.duration || ((s = e[i.type]) == null ? void 0 : s.duration) || (e == null ? void 0 : e.duration) || Dbt[i.type], style: { ...e.style, ...(l = e[i.type]) == null ? void 0 : l.style, ...i.style } };
  });
  return { ...t, toasts: o };
}, jbt = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, dismissed: !1, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || Sbt() }), Tv = (e) => (t, n) => {
  let r = jbt(t, e, n);
  return dd({ type: 2, toast: r }), r.id;
}, ts = (e, t) => Tv("blank")(e, t);
ts.error = Tv("error");
ts.success = Tv("success");
ts.loading = Tv("loading");
ts.custom = Tv("custom");
ts.dismiss = (e) => {
  dd({ type: 3, toastId: e });
};
ts.remove = (e) => dd({ type: 4, toastId: e });
ts.promise = (e, t, n) => {
  let r = ts.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return typeof e == "function" && (e = e()), e.then((o) => {
    let i = t.success ? Ox(t.success, o) : void 0;
    return i ? ts.success(i, { id: r, ...n, ...n == null ? void 0 : n.success }) : ts.dismiss(r), o;
  }).catch((o) => {
    let i = t.error ? Ox(t.error, o) : void 0;
    i ? ts.error(i, { id: r, ...n, ...n == null ? void 0 : n.error }) : ts.dismiss(r);
  }), e;
};
var Abt = (e, t) => {
  dd({ type: 1, toast: { id: e, height: t } });
}, Ibt = () => {
  dd({ type: 5, time: Date.now() });
}, ug = /* @__PURE__ */ new Map(), Bbt = 1e3, Rbt = (e, t = Bbt) => {
  if (ug.has(e)) return;
  let n = setTimeout(() => {
    ug.delete(e), dd({ type: 4, toastId: e });
  }, t);
  ug.set(e, n);
}, Nbt = (e) => {
  let { toasts: t, pausedAt: n } = Tbt(e);
  h(() => {
    if (n) return;
    let i = Date.now(), a = t.map((s) => {
      if (s.duration === 1 / 0) return;
      let l = (s.duration || 0) + s.pauseDuration - (i - s.createdAt);
      if (l < 0) {
        s.visible && ts.dismiss(s.id);
        return;
      }
      return setTimeout(() => ts.dismiss(s.id), l);
    });
    return () => {
      a.forEach((s) => s && clearTimeout(s));
    };
  }, [t, n]);
  let r = ur(() => {
    n && dd({ type: 6, time: Date.now() });
  }, [n]), o = ur((i, a) => {
    let { reverseOrder: s = !1, gutter: l = 8, defaultPosition: u } = a || {}, c = t.filter((g) => (g.position || u) === (i.position || u) && g.height), p = c.findIndex((g) => g.id === i.id), d = c.filter((g, f) => f < p && g.visible).length;
    return c.filter((g) => g.visible).slice(...s ? [d + 1] : [0, d]).reduce((g, f) => g + (f.height || 0) + l, 0);
  }, [t]);
  return h(() => {
    t.forEach((i) => {
      if (i.dismissed) Rbt(i.id, i.removeDelay);
      else {
        let a = ug.get(i.id);
        a && (clearTimeout(a), ug.delete(i.id));
      }
    });
  }, [t]), { toasts: t, handlers: { updateHeight: Abt, startPause: Ibt, endPause: r, calculateOffset: o } };
}, Fbt = Gl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, zbt = Gl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Ubt = Gl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Hbt = Mc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Fbt} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${zbt} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Ubt} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Wbt = Gl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Vbt = Mc("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Wbt} 1s linear infinite;
`, $bt = Gl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Zbt = Gl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, qbt = Mc("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${$bt} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Zbt} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Gbt = Mc("div")`
  position: absolute;
`, Kbt = Mc("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Ybt = Gl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Xbt = Mc("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Ybt} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, Jbt = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Me.createElement(Xbt, null, t) : t : n === "blank" ? null : Me.createElement(Kbt, null, Me.createElement(Vbt, { ...r }), n !== "loading" && Me.createElement(Gbt, null, n === "error" ? Me.createElement(Hbt, { ...r }) : Me.createElement(qbt, { ...r })));
}, Qbt = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ewt = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, twt = "0%{opacity:0;} 100%{opacity:1;}", nwt = "0%{opacity:1;} 100%{opacity:0;}", rwt = Mc("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, owt = Mc("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, iwt = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = qhe() ? [twt, nwt] : [Qbt(n), ewt(n)];
  return { animation: t ? `${Gl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Gl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, swt = Me.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? iwt(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Me.createElement(Jbt, { toast: e }), a = Me.createElement(owt, { ...e.ariaProps }, Ox(e.message, e));
  return Me.createElement(rwt, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Me.createElement(Me.Fragment, null, i, a));
});
Pbt(Me.createElement);
var awt = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = Me.useCallback((a) => {
    if (a) {
      let s = () => {
        let l = a.getBoundingClientRect().height;
        r(e, l);
      };
      s(), new MutationObserver(s).observe(a, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return Me.createElement("div", { ref: i, className: t, style: n }, o);
}, lwt = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: qhe() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, uwt = Zk`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, Ow = 16, cwt = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: a }) => {
  let { toasts: s, handlers: l } = Nbt(n);
  return Me.createElement("div", { id: "_rht_toaster", style: { position: "fixed", zIndex: 9999, top: Ow, left: Ow, right: Ow, bottom: Ow, pointerEvents: "none", ...i }, className: a, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, s.map((u) => {
    let c = u.position || t, p = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), d = lwt(c, p);
    return Me.createElement(awt, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? uwt : "", style: d }, u.type === "custom" ? Ox(u.message, u) : o ? o(u) : Me.createElement(swt, { toast: u, position: c }));
  }));
}, nte = ts;
function c0t({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return nte.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return nte.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ ne.jsxs(khe.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ ne.jsx(
      cwt,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
function Khe({ children: e, fallback: t = null }) {
  return Avt() ? /* @__PURE__ */ ne.jsx(ne.Fragment, { children: e() }) : /* @__PURE__ */ ne.jsx(ne.Fragment, { children: t });
}
let pwt = class {
  constructor(t, n) {
    jv(this, "pixelId");
    jv(this, "autoConfig");
    jv(this, "initialized");
    this.pixelId = t, this.autoConfig = (n == null ? void 0 : n.autoConfig) || !0, this.initialized = !1;
  }
  loadFacebookPixel() {
    if (window.fbq) return;
    const t = function(...o) {
      t.callMethod ? t.callMethod.apply(t, o) : t.queue.push(o);
    };
    window._fbq || (window._fbq = t), t.push = t, t.loaded = !0, t.version = "2.0", t.queue = [];
    const n = document.createElement("script");
    n.async = !0, n.src = "https://connect.facebook.net/en_US/fbevents.js";
    const r = document.getElementsByTagName("script")[0];
    if (!r.parentNode)
      throw new Error("No script tag found in the document");
    r.parentNode.insertBefore(n, r), window.fbq = t;
  }
  init(t = {}) {
    if (this.initialized = typeof window < "u" && !!window.fbq, this.loadFacebookPixel(), !window.fbq)
      throw new Error("window.fbq is not defined");
    this.autoConfig === !1 ? window.fbq("set", "autoConfig", !1, this.pixelId) : window.fbq("init", this.pixelId, t), this.initialized = !0;
  }
  pageView() {
    this.initialized && window.fbq && window.fbq("track", "PageView");
  }
  track(t, n) {
    this.initialized && window.fbq && window.fbq("track", t, n);
  }
  trackSingle(t, n, r) {
    this.initialized && window.fbq && window.fbq("trackSingle", t, n, r);
  }
  trackCustom(t, n) {
    this.initialized && window.fbq && window.fbq("trackCustom", t, n);
  }
  trackSingleCustom(t, n, r) {
    this.initialized && window.fbq && window.fbq("trackSingle", t, n, r);
  }
  grantConsent() {
    this.initialized && window.fbq && window.fbq("consent", "grant");
  }
  revokeConsent() {
    this.initialized && window.fbq && window.fbq("consent", "revoke");
  }
};
function dwt(e) {
  const {
    pixelId: t,
    options: n,
    pageView: r,
    track: o,
    trackCustom: i,
    trackSingle: a,
    trackSingleCustom: s,
    grantConsent: l,
    revokeConsent: u
  } = e, c = new pwt(t, n);
  return c.init(), r && c.pageView(), l && c.grantConsent(), u && c.revokeConsent(), o && c.track(...o), i && c.trackCustom(...i), a && c.trackSingle(t, ...a), s && c.trackSingleCustom(t, ...s), /* @__PURE__ */ ne.jsx(ne.Fragment, {});
}
function d0t(e) {
  return process.env.NODE_ENV !== "production" && !e.showInDevMode ? /* @__PURE__ */ ne.jsx(ne.Fragment, {}) : /* @__PURE__ */ ne.jsx(Khe, { children: () => /* @__PURE__ */ ne.jsx(dwt, { ...e }) });
}
function f0t({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ ne.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ ne.jsx(
    Zvt,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ ne.jsx(Ahe, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ ne.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ ne.jsx(Oge, {}) });
}
function h0t({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = k(null), a = (l) => i(l), s = () => {
    var g, f, y, b;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function p(E) {
      const w = c.find((M) => M.types[0] === E);
      return w ? w.long_name : "";
    }
    function d(E) {
      const w = c.find((M) => M.types[0] === E);
      return w ? w.short_name : "";
    }
    if (u) {
      const E = p("route"), w = p("street_number"), M = p("sublocality_level_1"), O = p("administrative_area_level_2"), v = p("administrative_area_level_1"), x = d("administrative_area_level_1"), _ = p("postal_code"), z = (f = (g = u.geometry) == null ? void 0 : g.location) == null ? void 0 : f.lat(), L = (b = (y = u.geometry) == null ? void 0 : y.location) == null ? void 0 : b.lng();
      t && t({
        street: E,
        city: O,
        state: v,
        district: M,
        cep: _,
        streetNumber: w,
        stateShortName: x,
        coordinates: { lat: z, lng: L }
      });
    }
  };
  return /* @__PURE__ */ ne.jsx(
    Whe,
    {
      onLoad: a,
      onPlacesChanged: s,
      options: n,
      children: /* @__PURE__ */ ne.jsx(Ik, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function Yhe(e) {
  const { dataLayer: t, dataLayerName: n } = e;
  return `
  window.${n} = window.${n} || [];
  window.${n}.push(${JSON.stringify(t)})`;
}
function fwt(e) {
  const { id: t, events: n, dataLayer: r, dataLayerName: o, preview: i, auth: a } = e, s = `&gtm_auth=${a}`, l = `&gtm_preview=${i}`;
  t || console.warn("GTM Id is required");
  const u = `
    <iframe src="https://www.googletagmanager.com/ns.html?id=${t}${s}${l}&gtm_cookies_win=x"
      height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>`, c = `
    (function(w,d,s,l,i){w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', ${JSON.stringify(
    n
  ).slice(1, -1)}});
      var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'${s}${l}&gtm_cookies_win=x';
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','${o}','${t}');`, p = Yhe({ dataLayer: r, dataLayerName: o });
  return {
    iframe: u,
    script: c,
    dataLayerVar: p
  };
}
let hwt = class {
  initializeDataScript(t) {
    const n = document.createElement("script");
    return n.innerHTML = t, n;
  }
  initializeGTMElements(t) {
    const n = fwt(t), r = () => {
      const a = document.createElement("noscript");
      return a.innerHTML = n.iframe, a;
    }, o = () => {
      const a = document.createElement("script");
      return a.innerHTML = n.script, a;
    }, i = this.initializeDataScript(n.dataLayerVar);
    return {
      noScript: r,
      script: o,
      dataScript: i
    };
  }
  initializeDataLayer(t) {
    const { dataLayer: n, dataLayerName: r } = t;
    if (window[r]) return window[r].push(n);
    const o = Yhe({ dataLayer: n, dataLayerName: r }), i = this.initializeDataScript(o);
    document.head.insertBefore(i, document.head.childNodes[0]);
  }
  initialize(t) {
    const {
      events: n,
      gtmId: r,
      dataLayer: o,
      auth: i = "",
      preview: a = "",
      dataLayerName: s = "dataLayer"
    } = t, l = this.initializeGTMElements({
      id: r,
      events: n,
      dataLayer: o || void 0,
      dataLayerName: s,
      auth: i,
      preview: a
    });
    o && document.head.appendChild(l.dataScript), document.head.insertBefore(l.script(), document.head.childNodes[0]), document.body.insertBefore(l.noScript(), document.body.childNodes[0]);
  }
};
function gwt(e) {
  return new hwt().initialize(e), /* @__PURE__ */ ne.jsx(ne.Fragment, {});
}
function m0t(e) {
  const {
    gtmId: t,
    auth: n = "",
    preview: r = "",
    dataLayerName: o = "dataLayer",
    events: i = {},
    dataLayer: a = {},
    showInDevMode: s = !1
  } = e;
  return process.env.NODE_ENV !== "production" && !s ? /* @__PURE__ */ ne.jsx(ne.Fragment, {}) : /* @__PURE__ */ ne.jsx(Khe, { children: () => /* @__PURE__ */ ne.jsx(
    gwt,
    {
      auth: n,
      dataLayer: a,
      dataLayerName: o,
      events: i,
      gtmId: t,
      preview: r
    }
  ) });
}
export {
  Owt as AlertContainer,
  Ewt as AlertContent,
  kwt as AlertDescription,
  Lwt as AlertIcon,
  Pge as AlertTitle,
  Nwt as AudioUpload,
  Mwt as Badge,
  Ywt as BreadcrumbContainer,
  Xwt as BreadcrumbLink,
  vm as Button,
  Dwt as Card,
  Fwt as Checkbox,
  Khe as ClientOnly,
  Vte as Divider,
  Qwt as DrawerContainer,
  e0t as DrawerHeader,
  s0t as DrawerProvider,
  d0t as FacebookPixel,
  zwt as FileUpload,
  vJ as FormController,
  Uwt as FormError,
  yJ as FormLabel,
  f0t as GoogleMap,
  l0t as GoogleProvider,
  h0t as GoogleSearchPlaces,
  m0t as GoogleTagManager,
  sfe as IconButton,
  Opt as ImageUpload,
  Ik as Input,
  vgt as ModalContainer,
  ygt as ModalFooter,
  bgt as ModalHeader,
  u0t as ModalProvider,
  Hwt as MultiSelect,
  Jwt as Pagination,
  Wwt as PhoneInput,
  t0t as Popover,
  $wt as RadioBox,
  Vwt as RadioGroup,
  Zwt as RichText,
  qwt as Select,
  Twt as Skeleton,
  dpt as Slider,
  Gwt as Switch,
  oQ as TabButton,
  Cgt as TabContainer,
  jwt as TableBody,
  Awt as TableCaption,
  Iwt as TableContainer,
  Bwt as TableFooter,
  Rwt as TableHeader,
  Kwt as Textarea,
  n0t as Toast,
  c0t as ToastProvider,
  afe as Tooltip,
  Pwt as getHtmlFromRichTextValue,
  _wt as getRichTextValueFromHtml,
  Swt as isHtml,
  Wte as morpheme,
  r0t as useAutomation,
  o0t as useDrawer,
  fR as useFieldErrors,
  fs as useFormController,
  Avt as useHydrated,
  i0t as useModal,
  nhe as useScopedParams,
  Tvt as useToast
};
